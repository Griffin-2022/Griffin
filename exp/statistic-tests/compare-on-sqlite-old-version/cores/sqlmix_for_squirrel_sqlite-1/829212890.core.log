GNU gdb (Ubuntu 9.2-0ubuntu1~20.04.1) 9.2
Copyright (C) 2020 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Type "show copying" and "show warranty" for details.
This GDB was configured as "x86_64-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
<http://www.gnu.org/software/gdb/bugs/>.
Find the GDB manual and other documentation resources online at:
    <http://www.gnu.org/software/gdb/documentation/>.

For help, type "help".
Type "apropos word" to search for commands related to "word"...
Reading symbols from /root/sqlite_driver_fast...
(gdb) Starting program: /root/sqlite_driver_fast < "/root/out/default/crashes/id:000571,sig:06,src:021922+023127,time:40738060,execs:7301443,op:merge.so,pos:0"
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".
parser: [[[PRAGMA foreign_keys = on;SELECT typeof( 
    CAST (X'31002E0032003300' AS REAL) ),  
    CAST (X'31002E0032003300' AS REAL) 
;CREATE TABLE a (b INTEGER, PRIMARY KEY(b)) WITHOUT ROWID;;-- Parsing of negative values
  
;ATTACH 'test2.db' AS aux;SELECT*FROM"aux".sqlite_master ORDER BY rowid
;PRAGMA journal_mode = off;SELECT 99 WHERE 0.0
  
;;SELECT * FROM a;;INSERT INTO a VALUES(1), (2), (3), (4), (5), (6), (7), (8), (9);;CREATE TABLE ex(i1);;CREATE INDEX i2 ON a(b COLLATE binary);;PRAGMA vdbe_trace=on;;
;CREATE VIEW t2 AS 
  SELECT sum(b) FILTER( WHERE b>9 ),
         sum(b) FILTER( WHERE b>8 ),
         sum(b) FILTER( WHERE b>7 ),
         sum(b) FILTER( WHERE b>6 ),
         sum(b) FILTER( WHERE b>5 ),
         sum(b) FILTER( WHERE b>4 ),
         sum(b) FILTER( WHERE b>3 ),
         sum(b) FILTER( WHERE b>2 ),
         sum(b) FILTER( WHERE b>1 ),
         sum(b) FILTER( WHERE b>0 )
  FROM a;;
;VACUUM;;
;SELECT * FROM a ORDER BY b, b;;
;SELECT * FROM a ORDER BY b DESC, b DESC;CREATE INDEX t3 ON a(b)
;SELECT*FROM"temp".sqlite_temp_master ORDER BY rowid
;SELECT x.b || '/' || y.b FROM a x, a y ORDER BY x.b, x.b DESC
  
;SELECT x.b || '/' || y.b FROM a x, a y ORDER BY x.b, x.b||x.b
  
;SELECT x.b || '/' || y.b FROM a x, a y ORDER BY x.b, x.b, y.b||y.b
  
;SELECT x.b || '/' || y.b FROM a x, a y ORDER BY x.b, y.b||y.b DESC
  
;SELECT x.b || '/' || y.b FROM a x, a y ORDER BY x.b, x.b||y.b
  
;SELECT*FROM"temp".sqlite_temp_master ORDER BY rowid
;;
;CREATE TABLE x(y INTEGER PRIMARY KEY, t2i1);ALTER TABLE x ADD t1i1
    
;;
;SELECT x.RowID id FROM a, x WHERE a.b = x.RowID AND id = 2;SELECT*FROM"temp".sqlite_temp_master ORDER BY rowid
;ALTER TABLE x ADD abc
    
;CREATE INDEX c ON a(b)
;CREATE INDEX v1 ON a(b)
;ALTER TABLE ex ADD v2
    
;CREATE TABLE tr1(t1a, t1b);;SELECT y, v2 FROM x, ex WHERE y>v2;;
;SELECT DISTINCT b FROM a LEFT JOIN ex ON b=v2 ORDER BY +v2;CREATE INDEX x1 ON a(b)
;CREATE INDEX z ON a(b)
;CREATE INDEX example ON ex(v2)
;;SELECT count(*) FROM sqlite_master WHERE tbl_name = 'e' AND type = 'index';;
;CREATE TABLE example_idx_00000042(id PRIMARY KEY, UNIQUE(id) );;BEGIN;;CREATE UNIQUE INDEX IF NOT EXISTS a_id ON a(b==0);;SELECT * FROM ex;]]]
parser: Input 'PRAGMA' in state 0
parser: Shift 'PRAGMA', go to state 215
parser: Return. Stack=[PRAGMA]
parser: Input 'ID' in state 215
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[PRAGMA ID]
parser: Input 'EQ' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 215.
parser: ... then shift 'nm', go to state 295
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 394
parser: Shift 'EQ', go to state 31
parser: Return. Stack=[PRAGMA nm dbnm EQ]
parser: Input 'ON' in state 31
parser: Shift 'ON', pending reduce 362
parser: Return. Stack=[PRAGMA nm dbnm EQ ON]
parser: Input 'SEMI' with pending reduce 362
parser: Reduce 362 [nmnum ::= ON], go to state 31.
parser: ... then shift 'nmnum', pending reduce 238
parser: Reduce 238 [cmd ::= PRAGMA nm dbnm EQ nmnum], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT typeof( 
    CAST (X'31002E0032003300' AS REAL) ),  
    CAST (X'31002E0032003300' AS REAL) 
;CREATE TABLE a (b INTEGER, PRIMARY KEY(b)) WITHOUT ROWID;;-- Parsing of negative values
  
;ATTACH 'test2.db' AS aux;SELECT*FROM"aux".sqlite_master ORDER BY rowid
;PRAGMA journal_mode = off;SELECT 99 WHERE 0.0
  
;;SELECT * FROM a;;INSERT INTO a VALUES(1), (2), (3), (4), (5), (6), (7), (8), (9);;CREATE TABLE ex(i1);;CREATE INDEX i2 ON a(b COLLATE binary);;PRAGMA vdbe_trace=on;;
;CREATE VIEW t2 AS 
  SELECT sum(b) FILTER( WHERE b>9 ),
         sum(b) FILTER( WHERE b>8 ),
         sum(b) FILTER( WHERE b>7 ),
         sum(b) FILTER( WHERE b>6 ),
         sum(b) FILTER( WHERE b>5 ),
         sum(b) FILTER( WHERE b>4 ),
         sum(b) FILTER( WHERE b>3 ),
         sum(b) FILTER( WHERE b>2 ),
         sum(b) FILTER( WHERE b>1 ),
         sum(b) FILTER( WHERE b>0 )
  FROM a;;
;VACUUM;;
;SELECT * FROM a ORDER BY b, b;;
;SELECT * FROM a ORDER BY b DESC, b DESC;CREATE INDEX t3 ON a(b)
;SELECT*FROM"temp".sqlite_temp_master ORDER BY rowid
;SELECT x.b || '/' || y.b FROM a x, a y ORDER BY x.b, x.b DESC
  
;SELECT x.b || '/' || y.b FROM a x, a y ORDER BY x.b, x.b||x.b
  
;SELECT x.b || '/' || y.b FROM a x, a y ORDER BY x.b, x.b, y.b||y.b
  
;SELECT x.b || '/' || y.b FROM a x, a y ORDER BY x.b, y.b||y.b DESC
  
;SELECT x.b || '/' || y.b FROM a x, a y ORDER BY x.b, x.b||y.b
  
;SELECT*FROM"temp".sqlite_temp_master ORDER BY rowid
;;
;CREATE TABLE x(y INTEGER PRIMARY KEY, t2i1);ALTER TABLE x ADD t1i1
    
;;
;SELECT x.RowID id FROM a, x WHERE a.b = x.RowID AND id = 2;SELECT*FROM"temp".sqlite_temp_master ORDER BY rowid
;ALTER TABLE x ADD abc
    
;CREATE INDEX c ON a(b)
;CREATE INDEX v1 ON a(b)
;ALTER TABLE ex ADD v2
    
;CREATE TABLE tr1(t1a, t1b);;SELECT y, v2 FROM x, ex WHERE y>v2;;
;SELECT DISTINCT b FROM a LEFT JOIN ex ON b=v2 ORDER BY +v2;CREATE INDEX x1 ON a(b)
;CREATE INDEX z ON a(b)
;CREATE INDEX example ON ex(v2)
;;SELECT count(*) FROM sqlite_master WHERE tbl_name = 'e' AND type = 'index';;
;CREATE TABLE example_idx_00000042(id PRIMARY KEY, UNIQUE(id) );;BEGIN;;CREATE UNIQUE INDEX IF NOT EXISTS a_id ON a(b==0);;SELECT * FROM ex;]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 95 [sclp ::=].
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 419
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 419
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP]
parser: Input 'CAST' in state 266
parser: FALLBACK CAST => ID
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'CAST', go to state 532
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct CAST]
parser: Input 'LP' in state 532
parser: Shift 'LP', go to state 106
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct CAST LP]
parser: Input 'BLOB' in state 106
parser: Shift 'BLOB', pending reduce 171
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct CAST LP BLOB]
parser: Input 'AS' with pending reduce 171
parser: Reduce 171 [term ::= NULL|FLOAT|BLOB], go to state 106.
parser: ... then shift 'term', go to state 53
parser: Shift 'AS', go to state 193
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct CAST LP term AS]
parser: Input 'ID' in state 193
parser: Shift 'ID', pending reduce 341
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct CAST LP term AS ID]
parser: Input 'RP' with pending reduce 341
parser: Reduce 341 [typename ::= ID|STRING], go to state 193.
parser: ... then shift 'typename', go to state 392
parser: Reduce 340 [typetoken ::= typename], go to state 193.
parser: ... then shift 'typetoken', go to state 530
parser: Shift 'RP', pending reduce 176
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct CAST LP term AS typetoken RP]
parser: Input 'RP' with pending reduce 176
parser: Reduce 176 [expr ::= CAST LP expr AS typetoken RP], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 220 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 519
parser: Reduce 359 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 484
parser: Shift 'RP', go to state 146
parser: Return. Stack=[SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'COMMA' in state 146
parser: Reduce 177 [expr ::= ID|INDEXED LP distinct exprlist RP], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 355
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'CAST' with pending reduce 355
parser: Reduce 355 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 384
parser: FALLBACK CAST => ID
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'CAST', go to state 532
parser: Return. Stack=[SELECT distinct sclp scanpt CAST]
parser: Input 'LP' in state 532
parser: Shift 'LP', go to state 106
parser: Return. Stack=[SELECT distinct sclp scanpt CAST LP]
parser: Input 'BLOB' in state 106
parser: Shift 'BLOB', pending reduce 171
parser: Return. Stack=[SELECT distinct sclp scanpt CAST LP BLOB]
parser: Input 'AS' with pending reduce 171
parser: Reduce 171 [term ::= NULL|FLOAT|BLOB], go to state 106.
parser: ... then shift 'term', go to state 53
parser: Shift 'AS', go to state 193
parser: Return. Stack=[SELECT distinct sclp scanpt CAST LP term AS]
parser: Input 'ID' in state 193
parser: Shift 'ID', pending reduce 341
parser: Return. Stack=[SELECT distinct sclp scanpt CAST LP term AS ID]
parser: Input 'RP' with pending reduce 341
parser: Reduce 341 [typename ::= ID|STRING], go to state 193.
parser: ... then shift 'typename', go to state 392
parser: Reduce 340 [typetoken ::= typename], go to state 193.
parser: ... then shift 'typetoken', go to state 530
parser: Shift 'RP', pending reduce 176
parser: Return. Stack=[SELECT distinct sclp scanpt CAST LP term AS typetoken RP]
parser: Input 'SEMI' with pending reduce 176
parser: Reduce 176 [expr ::= CAST LP expr AS typetoken RP], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Reduce 101 [from ::=].
parser: ... then shift 'from', go to state 363
parser: Reduce 147 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 362
parser: Reduce 138 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 361
parser: Reduce 140 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 128 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 360
parser: Reduce 142 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 88
parser: Reduce 88 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 83 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 80
parser: Reduce 80 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[CREATE TABLE a (b INTEGER, PRIMARY KEY(b)) WITHOUT ROWID;;-- Parsing of negative values
  
;ATTACH 'test2.db' AS aux;SELECT*FROM"aux".sqlite_master ORDER BY rowid
;PRAGMA journal_mode = off;SELECT 99 WHERE 0.0
  
;;SELECT * FROM a;;INSERT INTO a VALUES(1), (2), (3), (4), (5), (6), (7), (8), (9);;CREATE TABLE ex(i1);;CREATE INDEX i2 ON a(b COLLATE binary);;PRAGMA vdbe_trace=on;;
;CREATE VIEW t2 AS 
  SELECT sum(b) FILTER( WHERE b>9 ),
         sum(b) FILTER( WHERE b>8 ),
         sum(b) FILTER( WHERE b>7 ),
         sum(b) FILTER( WHERE b>6 ),
         sum(b) FILTER( WHERE b>5 ),
         sum(b) FILTER( WHERE b>4 ),
         sum(b) FILTER( WHERE b>3 ),
         sum(b) FILTER( WHERE b>2 ),
         sum(b) FILTER( WHERE b>1 ),
         sum(b) FILTER( WHERE b>0 )
  FROM a;;
;VACUUM;;
;SELECT * FROM a ORDER BY b, b;;
;SELECT * FROM a ORDER BY b DESC, b DESC;CREATE INDEX t3 ON a(b)
;SELECT*FROM"temp".sqlite_temp_master ORDER BY rowid
;SELECT x.b || '/' || y.b FROM a x, a y ORDER BY x.b, x.b DESC
  
;SELECT x.b || '/' || y.b FROM a x, a y ORDER BY x.b, x.b||x.b
  
;SELECT x.b || '/' || y.b FROM a x, a y ORDER BY x.b, x.b, y.b||y.b
  
;SELECT x.b || '/' || y.b FROM a x, a y ORDER BY x.b, y.b||y.b DESC
  
;SELECT x.b || '/' || y.b FROM a x, a y ORDER BY x.b, x.b||y.b
  
;SELECT*FROM"temp".sqlite_temp_master ORDER BY rowid
;;
;CREATE TABLE x(y INTEGER PRIMARY KEY, t2i1);ALTER TABLE x ADD t1i1
    
;;
;SELECT x.RowID id FROM a, x WHERE a.b = x.RowID AND id = 2;SELECT*FROM"temp".sqlite_temp_master ORDER BY rowid
;ALTER TABLE x ADD abc
    
;CREATE INDEX c ON a(b)
;CREATE INDEX v1 ON a(b)
;ALTER TABLE ex ADD v2
    
;CREATE TABLE tr1(t1a, t1b);;SELECT y, v2 FROM x, ex WHERE y>v2;;
;SELECT DISTINCT b FROM a LEFT JOIN ex ON b=v2 ORDER BY +v2;CREATE INDEX x1 ON a(b)
;CREATE INDEX z ON a(b)
;CREATE INDEX example ON ex(v2)
;;SELECT count(*) FROM sqlite_master WHERE tbl_name = 'e' AND type = 'index';;
;CREATE TABLE example_idx_00000042(id PRIMARY KEY, UNIQUE(id) );;BEGIN;;CREATE UNIQUE INDEX IF NOT EXISTS a_id ON a(b==0);;SELECT * FROM ex;]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 390
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 0.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP ID]
parser: Input 'ID' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 192
parser: Shift 'ID', pending reduce 341
parser: Return. Stack=[create_table LP nm ID]
parser: Input 'COMMA' with pending reduce 341
parser: Reduce 341 [typename ::= ID|STRING], go to state 192.
parser: ... then shift 'typename', go to state 392
parser: Reduce 340 [typetoken ::= typename], go to state 192.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 379
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 152
parser: Reduce 336 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'PRIMARY' in state 34
parser: Shift 'PRIMARY', go to state 475
parser: Return. Stack=[create_table LP columnlist COMMA PRIMARY]
parser: Input 'KEY' in state 475
parser: Shift 'KEY', go to state 474
parser: Return. Stack=[create_table LP columnlist COMMA PRIMARY KEY]
parser: Input 'LP' in state 474
parser: Shift 'LP', go to state 20
parser: Return. Stack=[create_table LP columnlist COMMA PRIMARY KEY LP]
parser: Input 'ID' in state 20
parser: Shift 'ID', go to state 419
parser: Return. Stack=[create_table LP columnlist COMMA PRIMARY KEY LP ID]
parser: Input 'RP' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 20.
parser: ... then shift 'expr', go to state 13
parser: Reduce 134 [sortorder ::=].
parser: ... then shift 'sortorder', go to state 353
parser: Reduce 137 [nulls ::=].
parser: ... then shift 'nulls', pending reduce 131
parser: Reduce 131 [sortlist ::= expr sortorder nulls], go to state 20.
parser: ... then shift 'sortlist', go to state 277
parser: Reduce 43 [autoinc ::=].
parser: ... then shift 'autoinc', go to state 473
parser: Shift 'RP', go to state 328
parser: Return. Stack=[create_table LP columnlist COMMA PRIMARY KEY LP sortlist autoinc RP]
parser: Input 'RP' in state 328
parser: Reduce 69 [onconf ::=].
parser: ... then shift 'onconf', pending reduce 64
parser: Reduce 64 [tcons ::= PRIMARY KEY LP sortlist autoinc RP onconf], go to state 34.
parser: ... then shift 'tcons', go to state 278
parser: Reduce 347 [conslist_opt ::= COMMA conslist], go to state 365.
parser: ... then shift 'conslist_opt', go to state 540
parser: Shift 'RP', go to state 364
parser: Return. Stack=[create_table LP columnlist conslist_opt RP]
parser: Input 'WITHOUT' in state 364
parser: Shift 'WITHOUT', go to state 251
parser: Return. Stack=[create_table LP columnlist conslist_opt RP WITHOUT]
parser: Input 'ID' in state 251
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist conslist_opt RP WITHOUT ID]
parser: Input 'SEMI' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 251.
parser: ... then shift 'nm', pending reduce 22
parser: Reduce 22 [table_options ::= WITHOUT nm], go to state 364.
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: [[[UPDATE 'main'.sqlite_master SET type='table', name='a', tbl_name='a', rootpage=#2, sql='CREATE TABLE a (b INTEGER, PRIMARY KEY(b)) WITHOUT ROWID' WHERE rowid=#1]]]
parser: Input 'UPDATE' in state 0
parser: Reduce 380 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'UPDATE', go to state 299
parser: Return. Stack=[with UPDATE]
parser: Input 'STRING' in state 299
parser: Reduce 71 [orconf ::=].
parser: ... then shift 'orconf', go to state 167
parser: Shift 'STRING', pending reduce 338
parser: Return. Stack=[with UPDATE orconf STRING]
parser: Input 'DOT' with pending reduce 338
parser: Reduce 338 [nm ::= STRING], go to state 167.
parser: ... then shift 'nm', go to state 395
parser: Shift 'DOT', go to state 218
parser: Return. Stack=[with UPDATE orconf nm DOT]
parser: Input 'ID' in state 218
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[with UPDATE orconf nm DOT ID]
parser: Input 'SET' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 218.
parser: ... then shift 'nm', go to state 432
parser: Reduce 114 [xfullname ::= nm DOT nm], go to state 167.
parser: ... then shift 'xfullname', go to state 271
parser: Reduce 123 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 431
parser: Shift 'SET', go to state 155
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET]
parser: Input 'ID' in state 155
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET ID]
parser: Input 'EQ' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 155.
parser: ... then shift 'nm', go to state 445
parser: Shift 'EQ', go to state 84
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ]
parser: Input 'STRING' in state 84
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ STRING]
parser: Input 'COMMA' in state 539
parser: Reduce 172 [term ::= STRING], go to state 84.
parser: ... then shift 'term', go to state 58
parser: Reduce 152 [setlist ::= nm EQ expr], go to state 155.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 447
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING' in state 86
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'COMMA' in state 539
parser: Reduce 172 [term ::= STRING], go to state 86.
parser: ... then shift 'term', go to state 60
parser: Reduce 150 [setlist ::= setlist COMMA nm EQ expr], go to state 155.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 447
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING' in state 86
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'COMMA' in state 539
parser: Reduce 172 [term ::= STRING], go to state 86.
parser: ... then shift 'term', go to state 60
parser: Reduce 150 [setlist ::= setlist COMMA nm EQ expr], go to state 155.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 447
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'VARIABLE' in state 86
parser: Shift 'VARIABLE', pending reduce 174
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ VARIABLE]
parser: Input 'COMMA' with pending reduce 174
parser: Reduce 174 [expr ::= VARIABLE], go to state 86.
parser: ... then shift 'expr', go to state 60
parser: Reduce 150 [setlist ::= setlist COMMA nm EQ expr], go to state 155.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 447
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING' in state 86
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'WHERE' in state 539
parser: Reduce 172 [term ::= STRING], go to state 86.
parser: ... then shift 'term', go to state 60
parser: Reduce 150 [setlist ::= setlist COMMA nm EQ expr], go to state 155.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 419
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE ID]
parser: Input 'EQ' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr EQ]
parser: Input 'VARIABLE' in state 117
parser: Shift 'VARIABLE', pending reduce 174
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr EQ VARIABLE]
parser: Input 'SEMI' with pending reduce 174
parser: Reduce 174 [expr ::= VARIABLE], go to state 117.
parser: ... then shift 'expr', go to state 129
parser: Reduce 186 [expr ::= expr EQ|NE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 148 [where_opt ::= WHERE expr], go to state 270.
parser: ... then shift 'where_opt', pending reduce 149
parser: Reduce 149 [cmd ::= with UPDATE orconf xfullname indexed_opt SET setlist where_opt], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Input '$' with pending reduce 327
parser: Reduce 327 [ecmd ::= cmdx SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 323 [input ::= cmdlist], go to state 0.
parser: ... then shift 'input', pending reduce -2
parser: Accept!
parser: ... then shift 'create_table_args', pending reduce 334
parser: Reduce 334 [cmd ::= create_table create_table_args], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT*FROM"main".sqlite_master WHERE tbl_name='a' AND type!='trigger' ORDER BY rowid]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'STAR' in state 288
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 95 [sclp ::=].
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STAR', pending reduce 97
parser: Return. Stack=[SELECT distinct sclp scanpt STAR]
parser: Input 'FROM' with pending reduce 97
parser: Reduce 97 [selcollist ::= sclp scanpt STAR], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 104 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'DOT' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 350
parser: Shift 'DOT', go to state 245
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID' in state 245
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'WHERE' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 245.
parser: ... then shift 'nm', pending reduce 110
parser: Reduce 110 [dbnm ::= DOT nm], go to state 350.
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 123 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 349
parser: Reduce 122 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 348
parser: Reduce 127 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 105
parser: Reduce 105 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 102 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 363
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[SELECT distinct selcollist from WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 419
parser: Return. Stack=[SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr EQ STRING]
parser: Input 'AND' in state 539
parser: Reduce 172 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 186 [expr ::= expr EQ|NE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'AND', go to state 120
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID' in state 120
parser: Shift 'ID', go to state 419
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'NE' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Shift 'NE', go to state 117
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr NE]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr NE STRING]
parser: Input 'ORDER' in state 539
parser: Reduce 172 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 186 [expr ::= expr EQ|NE expr], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Reduce 183 [expr ::= expr AND expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 148 [where_opt ::= WHERE expr], go to state 363.
parser: ... then shift 'where_opt', go to state 362
parser: Reduce 138 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 361
parser: Reduce 140 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 517
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 517
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 419
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 134 [sortorder ::=].
parser: ... then shift 'sortorder', go to state 353
parser: Reduce 137 [nulls ::=].
parser: ... then shift 'nulls', pending reduce 131
parser: Reduce 131 [sortlist ::= expr sortorder nulls], go to state 26.
parser: ... then shift 'sortlist', go to state 516
parser: Reduce 129 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 360
parser: Reduce 142 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 88
parser: Reduce 88 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 83 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 80
parser: Reduce 80 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[CREATE TABLE a (b INTEGER, PRIMARY KEY(b)) WITHOUT ROWID]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 390
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 0.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP ID]
parser: Input 'ID' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 192
parser: Shift 'ID', pending reduce 341
parser: Return. Stack=[create_table LP nm ID]
parser: Input 'COMMA' with pending reduce 341
parser: Reduce 341 [typename ::= ID|STRING], go to state 192.
parser: ... then shift 'typename', go to state 392
parser: Reduce 340 [typetoken ::= typename], go to state 192.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 379
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 152
parser: Reduce 336 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'PRIMARY' in state 34
parser: Shift 'PRIMARY', go to state 475
parser: Return. Stack=[create_table LP columnlist COMMA PRIMARY]
parser: Input 'KEY' in state 475
parser: Shift 'KEY', go to state 474
parser: Return. Stack=[create_table LP columnlist COMMA PRIMARY KEY]
parser: Input 'LP' in state 474
parser: Shift 'LP', go to state 20
parser: Return. Stack=[create_table LP columnlist COMMA PRIMARY KEY LP]
parser: Input 'ID' in state 20
parser: Shift 'ID', go to state 419
parser: Return. Stack=[create_table LP columnlist COMMA PRIMARY KEY LP ID]
parser: Input 'RP' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 20.
parser: ... then shift 'expr', go to state 13
parser: Reduce 134 [sortorder ::=].
parser: ... then shift 'sortorder', go to state 353
parser: Reduce 137 [nulls ::=].
parser: ... then shift 'nulls', pending reduce 131
parser: Reduce 131 [sortlist ::= expr sortorder nulls], go to state 20.
parser: ... then shift 'sortlist', go to state 277
parser: Reduce 43 [autoinc ::=].
parser: ... then shift 'autoinc', go to state 473
parser: Shift 'RP', go to state 328
parser: Return. Stack=[create_table LP columnlist COMMA PRIMARY KEY LP sortlist autoinc RP]
parser: Input 'RP' in state 328
parser: Reduce 69 [onconf ::=].
parser: ... then shift 'onconf', pending reduce 64
parser: Reduce 64 [tcons ::= PRIMARY KEY LP sortlist autoinc RP onconf], go to state 34.
parser: ... then shift 'tcons', go to state 278
parser: Reduce 347 [conslist_opt ::= COMMA conslist], go to state 365.
parser: ... then shift 'conslist_opt', go to state 540
parser: Shift 'RP', go to state 364
parser: Return. Stack=[create_table LP columnlist conslist_opt RP]
parser: Input 'WITHOUT' in state 364
parser: Shift 'WITHOUT', go to state 251
parser: Return. Stack=[create_table LP columnlist conslist_opt RP WITHOUT]
parser: Input 'ID' in state 251
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist conslist_opt RP WITHOUT ID]
parser: Input 'SEMI' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 251.
parser: ... then shift 'nm', pending reduce 22
parser: Reduce 22 [table_options ::= WITHOUT nm], go to state 364.
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: ... then shift 'create_table_args', pending reduce 334
parser: Reduce 334 [cmd ::= create_table create_table_args], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[;-- Parsing of negative values
  
;ATTACH 'test2.db' AS aux;SELECT*FROM"aux".sqlite_master ORDER BY rowid
;PRAGMA journal_mode = off;SELECT 99 WHERE 0.0
  
;;SELECT * FROM a;;INSERT INTO a VALUES(1), (2), (3), (4), (5), (6), (7), (8), (9);;CREATE TABLE ex(i1);;CREATE INDEX i2 ON a(b COLLATE binary);;PRAGMA vdbe_trace=on;;
;CREATE VIEW t2 AS 
  SELECT sum(b) FILTER( WHERE b>9 ),
         sum(b) FILTER( WHERE b>8 ),
         sum(b) FILTER( WHERE b>7 ),
         sum(b) FILTER( WHERE b>6 ),
         sum(b) FILTER( WHERE b>5 ),
         sum(b) FILTER( WHERE b>4 ),
         sum(b) FILTER( WHERE b>3 ),
         sum(b) FILTER( WHERE b>2 ),
         sum(b) FILTER( WHERE b>1 ),
         sum(b) FILTER( WHERE b>0 )
  FROM a;;
;VACUUM;;
;SELECT * FROM a ORDER BY b, b;;
;SELECT * FROM a ORDER BY b DESC, b DESC;CREATE INDEX t3 ON a(b)
;SELECT*FROM"temp".sqlite_temp_master ORDER BY rowid
;SELECT x.b || '/' || y.b FROM a x, a y ORDER BY x.b, x.b DESC
  
;SELECT x.b || '/' || y.b FROM a x, a y ORDER BY x.b, x.b||x.b
  
;SELECT x.b || '/' || y.b FROM a x, a y ORDER BY x.b, x.b, y.b||y.b
  
;SELECT x.b || '/' || y.b FROM a x, a y ORDER BY x.b, y.b||y.b DESC
  
;SELECT x.b || '/' || y.b FROM a x, a y ORDER BY x.b, x.b||y.b
  
;SELECT*FROM"temp".sqlite_temp_master ORDER BY rowid
;;
;CREATE TABLE x(y INTEGER PRIMARY KEY, t2i1);ALTER TABLE x ADD t1i1
    
;;
;SELECT x.RowID id FROM a, x WHERE a.b = x.RowID AND id = 2;SELECT*FROM"temp".sqlite_temp_master ORDER BY rowid
;ALTER TABLE x ADD abc
    
;CREATE INDEX c ON a(b)
;CREATE INDEX v1 ON a(b)
;ALTER TABLE ex ADD v2
    
;CREATE TABLE tr1(t1a, t1b);;SELECT y, v2 FROM x, ex WHERE y>v2;;
;SELECT DISTINCT b FROM a LEFT JOIN ex ON b=v2 ORDER BY +v2;CREATE INDEX x1 ON a(b)
;CREATE INDEX z ON a(b)
;CREATE INDEX example ON ex(v2)
;;SELECT count(*) FROM sqlite_master WHERE tbl_name = 'e' AND type = 'index';;
;CREATE TABLE example_idx_00000042(id PRIMARY KEY, UNIQUE(id) );;BEGIN;;CREATE UNIQUE INDEX IF NOT EXISTS a_id ON a(b==0);;SELECT * FROM ex;]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 326
parser: Return. Stack=[SEMI]
parser: Input 'SEMI' with pending reduce 326
parser: Reduce 326 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Shift 'SEMI', pending reduce 326
parser: Return. Stack=[ecmd SEMI]
parser: Input 'ATTACH' with pending reduce 326
parser: Reduce 326 [ecmd ::= SEMI], go to state 1.
parser: ... then shift 'ecmd', pending reduce 324
parser: Reduce 324 [cmdlist ::= cmdlist ecmd], go to state 0.
parser: ... then shift 'cmdlist', go to state 1
parser: Shift 'ATTACH', go to state 294
parser: Return. Stack=[cmdlist ATTACH]
parser: Input 'STRING' in state 294
parser: Reduce 371 [database_kw_opt ::=].
parser: ... then shift 'database_kw_opt', go to state 81
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[cmdlist ATTACH database_kw_opt STRING]
parser: Input 'AS' in state 539
parser: Reduce 172 [term ::= STRING], go to state 81.
parser: ... then shift 'term', go to state 44
parser: Shift 'AS', go to state 80
parser: Return. Stack=[cmdlist ATTACH database_kw_opt term AS]
parser: Input 'ID' in state 80
parser: Shift 'ID', go to state 419
parser: Return. Stack=[cmdlist ATTACH database_kw_opt term AS ID]
parser: Input 'SEMI' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 80.
parser: ... then shift 'expr', go to state 15
parser: Reduce 271 [key_opt ::=].
parser: ... then shift 'key_opt', pending reduce 269
parser: Reduce 269 [cmd ::= ATTACH database_kw_opt expr AS expr key_opt], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdlist cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping cmdlist
parser: [[[CREATE TABLE x(type text,name text,tbl_name text,rootpage int,sql text)]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 390
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 0.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP ID]
parser: Input 'ID' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 192
parser: Shift 'ID', pending reduce 341
parser: Return. Stack=[create_table LP nm ID]
parser: Input 'COMMA' with pending reduce 341
parser: Reduce 341 [typename ::= ID|STRING], go to state 192.
parser: ... then shift 'typename', go to state 392
parser: Reduce 340 [typetoken ::= typename], go to state 192.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 379
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 152
parser: Reduce 336 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'ID' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Shift 'ID', pending reduce 341
parser: Return. Stack=[create_table LP columnlist COMMA nm ID]
parser: Input 'COMMA' with pending reduce 341
parser: Reduce 341 [typename ::= ID|STRING], go to state 192.
parser: ... then shift 'typename', go to state 392
parser: Reduce 340 [typetoken ::= typename], go to state 192.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'ID' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Shift 'ID', pending reduce 341
parser: Return. Stack=[create_table LP columnlist COMMA nm ID]
parser: Input 'COMMA' with pending reduce 341
parser: Reduce 341 [typename ::= ID|STRING], go to state 192.
parser: ... then shift 'typename', go to state 392
parser: Reduce 340 [typetoken ::= typename], go to state 192.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'ID' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Shift 'ID', pending reduce 341
parser: Return. Stack=[create_table LP columnlist COMMA nm ID]
parser: Input 'COMMA' with pending reduce 341
parser: Reduce 341 [typename ::= ID|STRING], go to state 192.
parser: ... then shift 'typename', go to state 392
parser: Reduce 340 [typetoken ::= typename], go to state 192.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'ID' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Shift 'ID', pending reduce 341
parser: Return. Stack=[create_table LP columnlist COMMA nm ID]
parser: Input 'RP' with pending reduce 341
parser: Reduce 341 [typename ::= ID|STRING], go to state 192.
parser: ... then shift 'typename', go to state 392
parser: Reduce 340 [typetoken ::= typename], go to state 192.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Reduce 61 [conslist_opt ::=].
parser: ... then shift 'conslist_opt', go to state 540
parser: Shift 'RP', go to state 364
parser: Return. Stack=[create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 364
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: ... then shift 'create_table_args', pending reduce 334
parser: Reduce 334 [cmd ::= create_table create_table_args], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT*FROM"aux".sqlite_master ORDER BY rowid]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'STAR' in state 288
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 95 [sclp ::=].
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STAR', pending reduce 97
parser: Return. Stack=[SELECT distinct sclp scanpt STAR]
parser: Input 'FROM' with pending reduce 97
parser: Reduce 97 [selcollist ::= sclp scanpt STAR], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 104 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'DOT' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 350
parser: Shift 'DOT', go to state 245
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID' in state 245
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'ORDER' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 245.
parser: ... then shift 'nm', pending reduce 110
parser: Reduce 110 [dbnm ::= DOT nm], go to state 350.
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 123 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 349
parser: Reduce 122 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 348
parser: Reduce 127 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 105
parser: Reduce 105 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 102 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 363
parser: Reduce 147 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 362
parser: Reduce 138 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 361
parser: Reduce 140 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 517
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 517
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 419
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 134 [sortorder ::=].
parser: ... then shift 'sortorder', go to state 353
parser: Reduce 137 [nulls ::=].
parser: ... then shift 'nulls', pending reduce 131
parser: Reduce 131 [sortlist ::= expr sortorder nulls], go to state 26.
parser: ... then shift 'sortlist', go to state 516
parser: Reduce 129 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 360
parser: Reduce 142 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 88
parser: Reduce 88 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 83 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 80
parser: Reduce 80 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[CREATE TABLE stuff(description, shape, color)]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 390
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 0.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP ID]
parser: Input 'COMMA' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 192
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 379
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 152
parser: Reduce 336 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'COMMA' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'RP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Reduce 61 [conslist_opt ::=].
parser: ... then shift 'conslist_opt', go to state 540
parser: Shift 'RP', go to state 364
parser: Return. Stack=[create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 364
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: ... then shift 'create_table_args', pending reduce 334
parser: Reduce 334 [cmd ::= create_table create_table_args], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[CREATE TABLE insert_log(db, d, e, f)]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 390
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 0.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP ID]
parser: Input 'COMMA' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 192
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 379
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 152
parser: Reduce 336 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'COMMA' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'COMMA' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'RP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Reduce 61 [conslist_opt ::=].
parser: ... then shift 'conslist_opt', go to state 540
parser: Shift 'RP', go to state 364
parser: Return. Stack=[create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 364
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: ... then shift 'create_table_args', pending reduce 334
parser: Reduce 334 [cmd ::= create_table create_table_args], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[CREATE TABLE ghi(g, h, i)]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 390
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 0.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP ID]
parser: Input 'COMMA' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 192
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 379
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 152
parser: Reduce 336 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'COMMA' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'RP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Reduce 61 [conslist_opt ::=].
parser: ... then shift 'conslist_opt', go to state 540
parser: Shift 'RP', go to state 364
parser: Return. Stack=[create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 364
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: ... then shift 'create_table_args', pending reduce 334
parser: Reduce 334 [cmd ::= create_table create_table_args], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[CREATE TABLE files(name, text)]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 390
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 0.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP ID]
parser: Input 'COMMA' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 192
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 379
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 152
parser: Reduce 336 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'RP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Reduce 61 [conslist_opt ::=].
parser: ... then shift 'conslist_opt', go to state 540
parser: Shift 'RP', go to state 364
parser: Return. Stack=[create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 364
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: ... then shift 'create_table_args', pending reduce 334
parser: Reduce 334 [cmd ::= create_table create_table_args], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[CREATE TABLE ab(a, b)]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 390
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 0.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP ID]
parser: Input 'COMMA' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 192
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 379
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 152
parser: Reduce 336 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'RP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Reduce 61 [conslist_opt ::=].
parser: ... then shift 'conslist_opt', go to state 540
parser: Shift 'RP', go to state 364
parser: Return. Stack=[create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 364
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: ... then shift 'create_table_args', pending reduce 334
parser: Reduce 334 [cmd ::= create_table create_table_args], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[CREATE TABLE def(d, e, f)]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 390
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 0.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP ID]
parser: Input 'COMMA' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 192
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 379
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 152
parser: Reduce 336 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'COMMA' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'RP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Reduce 61 [conslist_opt ::=].
parser: ... then shift 'conslist_opt', go to state 540
parser: Shift 'RP', go to state 364
parser: Return. Stack=[create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 364
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: ... then shift 'create_table_args', pending reduce 334
parser: Reduce 334 [cmd ::= create_table create_table_args], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[CREATE TABLE sqlite_stat1(tbl,idx,stat)]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 390
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 0.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP ID]
parser: Input 'COMMA' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 192
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 379
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 152
parser: Reduce 336 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'COMMA' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'RP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Reduce 61 [conslist_opt ::=].
parser: ... then shift 'conslist_opt', go to state 540
parser: Shift 'RP', go to state 364
parser: Return. Stack=[create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 364
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: ... then shift 'create_table_args', pending reduce 334
parser: Reduce 334 [cmd ::= create_table create_table_args], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[CREATE TABLE f3_rules(ruleset, cfrom, cto, cost)]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 390
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 0.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP ID]
parser: Input 'COMMA' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 192
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 379
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 152
parser: Reduce 336 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'COMMA' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'COMMA' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'RP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Reduce 61 [conslist_opt ::=].
parser: ... then shift 'conslist_opt', go to state 540
parser: Shift 'RP', go to state 364
parser: Return. Stack=[create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 364
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: ... then shift 'create_table_args', pending reduce 334
parser: Reduce 334 [cmd ::= create_table create_table_args], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[CREATE TABLE t28 (a INTEGER PRIMARY KEY, b TEXT)]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 390
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 0.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP ID]
parser: Input 'ID' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 192
parser: Shift 'ID', pending reduce 341
parser: Return. Stack=[create_table LP nm ID]
parser: Input 'PRIMARY' with pending reduce 341
parser: Reduce 341 [typename ::= ID|STRING], go to state 192.
parser: ... then shift 'typename', go to state 392
parser: Reduce 340 [typetoken ::= typename], go to state 192.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 379
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 152
parser: Shift 'PRIMARY', go to state 478
parser: Return. Stack=[create_table LP columnname carglist PRIMARY]
parser: Input 'KEY' in state 478
parser: Shift 'KEY', go to state 280
parser: Return. Stack=[create_table LP columnname carglist PRIMARY KEY]
parser: Input 'COMMA' in state 280
parser: Reduce 134 [sortorder ::=].
parser: ... then shift 'sortorder', go to state 333
parser: Reduce 69 [onconf ::=].
parser: ... then shift 'onconf', go to state 332
parser: Reduce 43 [autoinc ::=].
parser: ... then shift 'autoinc', pending reduce 37
parser: Reduce 37 [ccons ::= PRIMARY KEY sortorder onconf autoinc], go to state 152.
parser: ... then shift 'ccons', pending reduce 344
parser: Reduce 344 [carglist ::= carglist ccons], go to state 379.
parser: ... then shift 'carglist', go to state 152
parser: Reduce 336 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'ID' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Shift 'ID', pending reduce 341
parser: Return. Stack=[create_table LP columnlist COMMA nm ID]
parser: Input 'RP' with pending reduce 341
parser: Reduce 341 [typename ::= ID|STRING], go to state 192.
parser: ... then shift 'typename', go to state 392
parser: Reduce 340 [typetoken ::= typename], go to state 192.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Reduce 61 [conslist_opt ::=].
parser: ... then shift 'conslist_opt', go to state 540
parser: Shift 'RP', go to state 364
parser: Return. Stack=[create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 364
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: ... then shift 'create_table_args', pending reduce 334
parser: Reduce 334 [cmd ::= create_table create_table_args], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[CREATE TABLE "t1new"(a, b, c)]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 390
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 0.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP ID]
parser: Input 'COMMA' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 192
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 379
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 152
parser: Reduce 336 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'COMMA' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'RP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Reduce 61 [conslist_opt ::=].
parser: ... then shift 'conslist_opt', go to state 540
parser: Shift 'RP', go to state 364
parser: Return. Stack=[create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 364
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: ... then shift 'create_table_args', pending reduce 334
parser: Reduce 334 [cmd ::= create_table create_table_args], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[CREATE TABLE t16 (a INTEGER PRIMARY KEY, b TEXT)]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 390
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 0.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP ID]
parser: Input 'ID' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 192
parser: Shift 'ID', pending reduce 341
parser: Return. Stack=[create_table LP nm ID]
parser: Input 'PRIMARY' with pending reduce 341
parser: Reduce 341 [typename ::= ID|STRING], go to state 192.
parser: ... then shift 'typename', go to state 392
parser: Reduce 340 [typetoken ::= typename], go to state 192.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 379
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 152
parser: Shift 'PRIMARY', go to state 478
parser: Return. Stack=[create_table LP columnname carglist PRIMARY]
parser: Input 'KEY' in state 478
parser: Shift 'KEY', go to state 280
parser: Return. Stack=[create_table LP columnname carglist PRIMARY KEY]
parser: Input 'COMMA' in state 280
parser: Reduce 134 [sortorder ::=].
parser: ... then shift 'sortorder', go to state 333
parser: Reduce 69 [onconf ::=].
parser: ... then shift 'onconf', go to state 332
parser: Reduce 43 [autoinc ::=].
parser: ... then shift 'autoinc', pending reduce 37
parser: Reduce 37 [ccons ::= PRIMARY KEY sortorder onconf autoinc], go to state 152.
parser: ... then shift 'ccons', pending reduce 344
parser: Reduce 344 [carglist ::= carglist ccons], go to state 379.
parser: ... then shift 'carglist', go to state 152
parser: Reduce 336 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'ID' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Shift 'ID', pending reduce 341
parser: Return. Stack=[create_table LP columnlist COMMA nm ID]
parser: Input 'RP' with pending reduce 341
parser: Reduce 341 [typename ::= ID|STRING], go to state 192.
parser: ... then shift 'typename', go to state 392
parser: Reduce 340 [typetoken ::= typename], go to state 192.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Reduce 61 [conslist_opt ::=].
parser: ... then shift 'conslist_opt', go to state 540
parser: Shift 'RP', go to state 364
parser: Return. Stack=[create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 364
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: ... then shift 'create_table_args', pending reduce 334
parser: Reduce 334 [cmd ::= create_table create_table_args], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[CREATE TABLE t20_3(z)]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 390
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 0.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP ID]
parser: Input 'RP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 192
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 379
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 152
parser: Reduce 336 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Reduce 61 [conslist_opt ::=].
parser: ... then shift 'conslist_opt', go to state 540
parser: Shift 'RP', go to state 364
parser: Return. Stack=[create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 364
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: ... then shift 'create_table_args', pending reduce 334
parser: Reduce 334 [cmd ::= create_table create_table_args], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[CREATE TABLE "t xx"(a, b, c)]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 390
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 0.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP ID]
parser: Input 'COMMA' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 192
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 379
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 152
parser: Reduce 336 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'COMMA' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'RP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Reduce 61 [conslist_opt ::=].
parser: ... then shift 'conslist_opt', go to state 540
parser: Shift 'RP', go to state 364
parser: Return. Stack=[create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 364
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: ... then shift 'create_table_args', pending reduce 334
parser: Reduce 334 [cmd ::= create_table create_table_args], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[CREATE TABLE t20_2(y)]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 390
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 0.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP ID]
parser: Input 'RP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 192
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 379
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 152
parser: Reduce 336 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Reduce 61 [conslist_opt ::=].
parser: ... then shift 'conslist_opt', go to state 540
parser: Shift 'RP', go to state 364
parser: Return. Stack=[create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 364
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: ... then shift 'create_table_args', pending reduce 334
parser: Reduce 334 [cmd ::= create_table create_table_args], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[CREATE TABLE "bool" ( a integer , abc, v1, i2, t2, t3, x, y, t2i1, ex, i1)]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 390
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 0.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP ID]
parser: Input 'ID' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 192
parser: Shift 'ID', pending reduce 341
parser: Return. Stack=[create_table LP nm ID]
parser: Input 'COMMA' with pending reduce 341
parser: Reduce 341 [typename ::= ID|STRING], go to state 192.
parser: ... then shift 'typename', go to state 392
parser: Reduce 340 [typetoken ::= typename], go to state 192.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 379
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 152
parser: Reduce 336 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'COMMA' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'COMMA' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'COMMA' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'COMMA' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'COMMA' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'COMMA' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'COMMA' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'COMMA' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'COMMA' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'RP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Reduce 61 [conslist_opt ::=].
parser: ... then shift 'conslist_opt', go to state 540
parser: Shift 'RP', go to state 364
parser: Return. Stack=[create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 364
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: ... then shift 'create_table_args', pending reduce 334
parser: Reduce 334 [cmd ::= create_table create_table_args], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[CREATE TABLE t19 (a INTEGER PRIMARY KEY, b TEXT)]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 390
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 0.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP ID]
parser: Input 'ID' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 192
parser: Shift 'ID', pending reduce 341
parser: Return. Stack=[create_table LP nm ID]
parser: Input 'PRIMARY' with pending reduce 341
parser: Reduce 341 [typename ::= ID|STRING], go to state 192.
parser: ... then shift 'typename', go to state 392
parser: Reduce 340 [typetoken ::= typename], go to state 192.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 379
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 152
parser: Shift 'PRIMARY', go to state 478
parser: Return. Stack=[create_table LP columnname carglist PRIMARY]
parser: Input 'KEY' in state 478
parser: Shift 'KEY', go to state 280
parser: Return. Stack=[create_table LP columnname carglist PRIMARY KEY]
parser: Input 'COMMA' in state 280
parser: Reduce 134 [sortorder ::=].
parser: ... then shift 'sortorder', go to state 333
parser: Reduce 69 [onconf ::=].
parser: ... then shift 'onconf', go to state 332
parser: Reduce 43 [autoinc ::=].
parser: ... then shift 'autoinc', pending reduce 37
parser: Reduce 37 [ccons ::= PRIMARY KEY sortorder onconf autoinc], go to state 152.
parser: ... then shift 'ccons', pending reduce 344
parser: Reduce 344 [carglist ::= carglist ccons], go to state 379.
parser: ... then shift 'carglist', go to state 152
parser: Reduce 336 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'ID' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Shift 'ID', pending reduce 341
parser: Return. Stack=[create_table LP columnlist COMMA nm ID]
parser: Input 'RP' with pending reduce 341
parser: Reduce 341 [typename ::= ID|STRING], go to state 192.
parser: ... then shift 'typename', go to state 392
parser: Reduce 340 [typetoken ::= typename], go to state 192.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Reduce 61 [conslist_opt ::=].
parser: ... then shift 'conslist_opt', go to state 540
parser: Shift 'RP', go to state 364
parser: Return. Stack=[create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 364
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: ... then shift 'create_table_args', pending reduce 334
parser: Reduce 334 [cmd ::= create_table create_table_args], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[CREATE TABLE x3(a INTEGER PRIMARY KEY, b TEXT, c BLOB)]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 390
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 0.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP ID]
parser: Input 'ID' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 192
parser: Shift 'ID', pending reduce 341
parser: Return. Stack=[create_table LP nm ID]
parser: Input 'PRIMARY' with pending reduce 341
parser: Reduce 341 [typename ::= ID|STRING], go to state 192.
parser: ... then shift 'typename', go to state 392
parser: Reduce 340 [typetoken ::= typename], go to state 192.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 379
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 152
parser: Shift 'PRIMARY', go to state 478
parser: Return. Stack=[create_table LP columnname carglist PRIMARY]
parser: Input 'KEY' in state 478
parser: Shift 'KEY', go to state 280
parser: Return. Stack=[create_table LP columnname carglist PRIMARY KEY]
parser: Input 'COMMA' in state 280
parser: Reduce 134 [sortorder ::=].
parser: ... then shift 'sortorder', go to state 333
parser: Reduce 69 [onconf ::=].
parser: ... then shift 'onconf', go to state 332
parser: Reduce 43 [autoinc ::=].
parser: ... then shift 'autoinc', pending reduce 37
parser: Reduce 37 [ccons ::= PRIMARY KEY sortorder onconf autoinc], go to state 152.
parser: ... then shift 'ccons', pending reduce 344
parser: Reduce 344 [carglist ::= carglist ccons], go to state 379.
parser: ... then shift 'carglist', go to state 152
parser: Reduce 336 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'ID' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Shift 'ID', pending reduce 341
parser: Return. Stack=[create_table LP columnlist COMMA nm ID]
parser: Input 'COMMA' with pending reduce 341
parser: Reduce 341 [typename ::= ID|STRING], go to state 192.
parser: ... then shift 'typename', go to state 392
parser: Reduce 340 [typetoken ::= typename], go to state 192.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'ID' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Shift 'ID', pending reduce 341
parser: Return. Stack=[create_table LP columnlist COMMA nm ID]
parser: Input 'RP' with pending reduce 341
parser: Reduce 341 [typename ::= ID|STRING], go to state 192.
parser: ... then shift 'typename', go to state 392
parser: Reduce 340 [typetoken ::= typename], go to state 192.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Reduce 61 [conslist_opt ::=].
parser: ... then shift 'conslist_opt', go to state 540
parser: Shift 'RP', go to state 364
parser: Return. Stack=[create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 364
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: ... then shift 'create_table_args', pending reduce 334
parser: Reduce 334 [cmd ::= create_table create_table_args], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[CREATE TABLE t2i1(t1i1 INT,abc, c VARCHAR(128))]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 390
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 0.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP ID]
parser: Input 'ID' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 192
parser: Shift 'ID', pending reduce 341
parser: Return. Stack=[create_table LP nm ID]
parser: Input 'COMMA' with pending reduce 341
parser: Reduce 341 [typename ::= ID|STRING], go to state 192.
parser: ... then shift 'typename', go to state 392
parser: Reduce 340 [typetoken ::= typename], go to state 192.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 379
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 152
parser: Reduce 336 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'COMMA' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'ID' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Shift 'ID', pending reduce 341
parser: Return. Stack=[create_table LP columnlist COMMA nm ID]
parser: Input 'LP' with pending reduce 341
parser: Reduce 341 [typename ::= ID|STRING], go to state 192.
parser: ... then shift 'typename', go to state 392
parser: Shift 'LP', go to state 138
parser: Return. Stack=[create_table LP columnlist COMMA nm typename LP]
parser: Input 'INTEGER' in state 138
parser: Shift 'INTEGER', pending reduce 365
parser: Return. Stack=[create_table LP columnlist COMMA nm typename LP INTEGER]
parser: Input 'RP' with pending reduce 365
parser: Reduce 365 [plus_num ::= INTEGER|FLOAT], go to state 138.
parser: ... then shift 'plus_num', go to state 416
parser: Shift 'RP', pending reduce 25
parser: Return. Stack=[create_table LP columnlist COMMA nm typename LP plus_num RP]
parser: Input 'RP' with pending reduce 25
parser: Reduce 25 [typetoken ::= typename LP signed RP], go to state 192.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Reduce 61 [conslist_opt ::=].
parser: ... then shift 'conslist_opt', go to state 540
parser: Shift 'RP', go to state 364
parser: Return. Stack=[create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 364
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: ... then shift 'create_table_args', pending reduce 334
parser: Reduce 334 [cmd ::= create_table create_table_args], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[CREATE TABLE t3(e, f)]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 390
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 0.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP ID]
parser: Input 'COMMA' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 192
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 379
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 152
parser: Reduce 336 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'RP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Reduce 61 [conslist_opt ::=].
parser: ... then shift 'conslist_opt', go to state 540
parser: Shift 'RP', go to state 364
parser: Return. Stack=[create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 364
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: ... then shift 'create_table_args', pending reduce 334
parser: Reduce 334 [cmd ::= create_table create_table_args], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[CREATE VIEW y AS SELECT * FROM i1]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'VIEW' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: FALLBACK VIEW => ID
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 390
parser: Shift 'VIEW', go to state 322
parser: Return. Stack=[createkw temp VIEW]
parser: Input 'ID' in state 322
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 228
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw temp VIEW ifnotexists ID]
parser: Input 'AS' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 228.
parser: ... then shift 'nm', go to state 321
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 320
parser: Reduce 226 [eidlist_opt ::=].
parser: ... then shift 'eidlist_opt', go to state 464
parser: Shift 'AS', go to state 37
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS]
parser: Input 'SELECT' in state 37
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT]
parser: Input 'STAR' in state 288
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 95 [sclp ::=].
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STAR', pending reduce 97
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt STAR]
parser: Input 'FROM' with pending reduce 97
parser: Reduce 97 [selcollist ::= sclp scanpt STAR], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 104 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'SEMI' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 350
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 123 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 349
parser: Reduce 122 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 348
parser: Reduce 127 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 105
parser: Reduce 105 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 102 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 363
parser: Reduce 147 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 362
parser: Reduce 138 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 361
parser: Reduce 140 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 128 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 360
parser: Reduce 142 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 88
parser: Reduce 88 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 37.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 83 [select ::= selectnowith], go to state 37.
parser: ... then shift 'select', pending reduce 78
parser: Reduce 78 [cmd ::= createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[CREATE VIEW v3 AS VALUES(1)]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'VIEW' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: FALLBACK VIEW => ID
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 390
parser: Shift 'VIEW', go to state 322
parser: Return. Stack=[createkw temp VIEW]
parser: Input 'ID' in state 322
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 228
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw temp VIEW ifnotexists ID]
parser: Input 'AS' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 228.
parser: ... then shift 'nm', go to state 321
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 320
parser: Reduce 226 [eidlist_opt ::=].
parser: ... then shift 'eidlist_opt', go to state 464
parser: Shift 'AS', go to state 37
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS]
parser: Input 'VALUES' in state 37
parser: Shift 'VALUES', go to state 528
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS VALUES]
parser: Input 'LP' in state 528
parser: Shift 'LP', go to state 28
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS VALUES LP]
parser: Input 'INTEGER' in state 28
parser: Shift 'INTEGER', pending reduce 173
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS VALUES LP INTEGER]
parser: Input 'RP' with pending reduce 173
parser: Reduce 173 [term ::= INTEGER], go to state 28.
parser: ... then shift 'term', go to state 70
parser: Reduce 220 [nexprlist ::= expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 413
parser: Shift 'RP', pending reduce 90
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS VALUES LP nexprlist RP]
parser: Input 'SEMI' with pending reduce 90
parser: Reduce 90 [values ::= VALUES LP nexprlist RP], go to state 37.
parser: ... then shift 'values', go to state 534
parser: Reduce 354 [oneselect ::= values], go to state 37.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 83 [select ::= selectnowith], go to state 37.
parser: ... then shift 'select', pending reduce 78
parser: Reduce 78 [cmd ::= createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[CREATE VIEW ex AS SELECT * FROM "bool"]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'VIEW' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: FALLBACK VIEW => ID
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 390
parser: Shift 'VIEW', go to state 322
parser: Return. Stack=[createkw temp VIEW]
parser: Input 'ID' in state 322
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 228
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw temp VIEW ifnotexists ID]
parser: Input 'AS' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 228.
parser: ... then shift 'nm', go to state 321
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 320
parser: Reduce 226 [eidlist_opt ::=].
parser: ... then shift 'eidlist_opt', go to state 464
parser: Shift 'AS', go to state 37
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS]
parser: Input 'SELECT' in state 37
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT]
parser: Input 'STAR' in state 288
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 95 [sclp ::=].
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STAR', pending reduce 97
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt STAR]
parser: Input 'FROM' with pending reduce 97
parser: Reduce 97 [selcollist ::= sclp scanpt STAR], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 104 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'SEMI' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 350
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 123 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 349
parser: Reduce 122 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 348
parser: Reduce 127 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 105
parser: Reduce 105 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 102 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 363
parser: Reduce 147 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 362
parser: Reduce 138 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 361
parser: Reduce 140 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 128 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 360
parser: Reduce 142 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 88
parser: Reduce 88 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 37.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 83 [select ::= selectnowith], go to state 37.
parser: ... then shift 'select', pending reduce 78
parser: Reduce 78 [cmd ::= createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[CREATE VIRTUAL TABLE e2 USING echo(i1)]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'VIRTUAL' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Shift 'VIRTUAL', go to state 436
parser: Return. Stack=[createkw VIRTUAL]
parser: Input 'TABLE' in state 436
parser: Shift 'TABLE', go to state 306
parser: Return. Stack=[createkw VIRTUAL TABLE]
parser: Input 'ID' in state 306
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 221
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw VIRTUAL TABLE ifnotexists ID]
parser: Input 'USING' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 221.
parser: ... then shift 'nm', go to state 305
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 435
parser: Shift 'USING', go to state 220
parser: Return. Stack=[createkw VIRTUAL TABLE ifnotexists nm dbnm USING]
parser: Input 'ID' in state 220
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw VIRTUAL TABLE ifnotexists nm dbnm USING ID]
parser: Input 'LP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 220.
parser: ... then shift 'nm', pending reduce 283
parser: Reduce 283 [create_vtab ::= createkw VIRTUAL TABLE ifnotexists nm dbnm USING nm], go to state 0.
parser: ... then shift 'create_vtab', go to state 422
parser: Shift 'LP', go to state 196
parser: Return. Stack=[create_vtab LP]
parser: Input 'ID' in state 196
parser: Reduce 284 [vtabarg ::=].
parser: ... then shift 'vtabarg', go to state 163
parser: WILDCARD ID => ANY
parser: Shift 'ID', pending reduce 285
parser: Return. Stack=[create_vtab LP vtabarg ID]
parser: Input 'RP' with pending reduce 285
parser: Reduce 285 [vtabargtoken ::= ANY], go to state 163.
parser: ... then shift 'vtabargtoken', pending reduce 376
parser: Reduce 376 [vtabarg ::= vtabarg vtabargtoken], go to state 196.
parser: ... then shift 'vtabarg', go to state 163
parser: Reduce 374 [vtabarglist ::= vtabarg], go to state 196.
parser: ... then shift 'vtabarglist', go to state 393
parser: Shift 'RP', pending reduce 282
parser: Return. Stack=[create_vtab LP vtabarglist RP]
parser: Input 'SEMI' with pending reduce 282
parser: Reduce 282 [cmd ::= create_vtab LP vtabarglist RP], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[CREATE VIEW v2 AS SELECT * FROM t1]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'VIEW' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: FALLBACK VIEW => ID
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 390
parser: Shift 'VIEW', go to state 322
parser: Return. Stack=[createkw temp VIEW]
parser: Input 'ID' in state 322
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 228
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw temp VIEW ifnotexists ID]
parser: Input 'AS' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 228.
parser: ... then shift 'nm', go to state 321
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 320
parser: Reduce 226 [eidlist_opt ::=].
parser: ... then shift 'eidlist_opt', go to state 464
parser: Shift 'AS', go to state 37
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS]
parser: Input 'SELECT' in state 37
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT]
parser: Input 'STAR' in state 288
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 95 [sclp ::=].
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STAR', pending reduce 97
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt STAR]
parser: Input 'FROM' with pending reduce 97
parser: Reduce 97 [selcollist ::= sclp scanpt STAR], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 104 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'SEMI' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 350
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 123 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 349
parser: Reduce 122 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 348
parser: Reduce 127 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 105
parser: Reduce 105 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 102 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 363
parser: Reduce 147 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 362
parser: Reduce 138 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 361
parser: Reduce 140 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 128 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 360
parser: Reduce 142 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 88
parser: Reduce 88 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 37.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 83 [select ::= selectnowith], go to state 37.
parser: ... then shift 'select', pending reduce 78
parser: Reduce 78 [cmd ::= createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[CREATE TRIGGER tr1 AFTER INSERT ON t3 BEGIN
      INSERT INTO t3 VALUES(new.e*2, new.f*2);
    END]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TRIGGER' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: FALLBACK TRIGGER => ID
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 390
parser: Shift 'TRIGGER', go to state 319
parser: Return. Stack=[createkw temp TRIGGER]
parser: Input 'ID' in state 319
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 227
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw temp TRIGGER ifnotexists ID]
parser: Input 'AFTER' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 227.
parser: ... then shift 'nm', go to state 318
parser: FALLBACK AFTER => ID
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 257
parser: Shift 'AFTER', pending reduce 246
parser: Return. Stack=[createkw temp TRIGGER ifnotexists nm dbnm AFTER]
parser: Input 'INSERT' with pending reduce 246
parser: Reduce 246 [trigger_time ::= BEFORE|AFTER], go to state 257.
parser: ... then shift 'trigger_time', go to state 256
parser: Shift 'INSERT', pending reduce 249
parser: Return. Stack=[createkw temp TRIGGER ifnotexists nm dbnm trigger_time INSERT]
parser: Input 'ON' with pending reduce 249
parser: Reduce 249 [trigger_event ::= DELETE|INSERT], go to state 256.
parser: ... then shift 'trigger_event', go to state 463
parser: Shift 'ON', go to state 181
parser: Return. Stack=[createkw temp TRIGGER ifnotexists nm dbnm trigger_time trigger_event ON]
parser: Input 'ID' in state 181
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw temp TRIGGER ifnotexists nm dbnm trigger_time trigger_event ON ID]
parser: Input 'BEGIN' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 181.
parser: ... then shift 'nm', go to state 462
parser: FALLBACK BEGIN => ID
parser: Reduce 111 [fullname ::= nm], go to state 181.
parser: ... then shift 'fullname', go to state 317
parser: FALLBACK BEGIN => ID
parser: Reduce 366 [foreach_clause ::=].
parser: ... then shift 'foreach_clause', go to state 316
parser: FALLBACK BEGIN => ID
parser: Reduce 252 [when_clause ::=].
parser: ... then shift 'when_clause', pending reduce 245
parser: Reduce 245 [trigger_decl ::= temp TRIGGER ifnotexists nm dbnm trigger_time trigger_event ON fullname foreach_clause when_clause], go to state 134.
parser: ... then shift 'trigger_decl', go to state 453
parser: Shift 'BEGIN', go to state 144
parser: Return. Stack=[createkw trigger_decl BEGIN]
parser: Input 'INSERT' in state 144
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 12
parser: Shift 'INSERT', go to state 311
parser: Return. Stack=[createkw trigger_decl BEGIN scanpt INSERT]
parser: Input 'INTO' in state 311
parser: Reduce 71 [orconf ::=].
parser: ... then shift 'orconf', pending reduce 160
parser: Reduce 160 [insert_cmd ::= INSERT orconf], go to state 12.
parser: ... then shift 'insert_cmd', go to state 443
parser: Shift 'INTO', go to state 176
parser: Return. Stack=[createkw trigger_decl BEGIN scanpt insert_cmd INTO]
parser: Input 'ID' in state 176
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw trigger_decl BEGIN scanpt insert_cmd INTO ID]
parser: Input 'VALUES' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 176.
parser: ... then shift 'nm', go to state 451
parser: Reduce 368 [trnm ::= nm], go to state 176.
parser: ... then shift 'trnm', go to state 310
parser: Reduce 162 [idlist_opt ::=].
parser: ... then shift 'idlist_opt', go to state 36
parser: Shift 'VALUES', go to state 528
parser: Return. Stack=[createkw trigger_decl BEGIN scanpt insert_cmd INTO trnm idlist_opt VALUES]
parser: Input 'LP' in state 528
parser: Shift 'LP', go to state 28
parser: Return. Stack=[createkw trigger_decl BEGIN scanpt insert_cmd INTO trnm idlist_opt VALUES LP]
parser: Input 'ID' in state 28
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw trigger_decl BEGIN scanpt insert_cmd INTO trnm idlist_opt VALUES LP ID]
parser: Input 'DOT' in state 419
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 28.
parser: ... then shift 'nm', go to state 537
parser: Shift 'DOT', go to state 249
parser: Return. Stack=[createkw trigger_decl BEGIN scanpt insert_cmd INTO trnm idlist_opt VALUES LP nm DOT]
parser: Input 'ID' in state 249
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw trigger_decl BEGIN scanpt insert_cmd INTO trnm idlist_opt VALUES LP nm DOT ID]
parser: Input 'STAR' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 249.
parser: ... then shift 'nm', go to state 536
parser: Reduce 169 [expr ::= nm DOT nm], go to state 28.
parser: ... then shift 'expr', go to state 70
parser: Shift 'STAR', go to state 114
parser: Return. Stack=[createkw trigger_decl BEGIN scanpt insert_cmd INTO trnm idlist_opt VALUES LP expr STAR]
parser: Input 'INTEGER' in state 114
parser: Shift 'INTEGER', pending reduce 173
parser: Return. Stack=[createkw trigger_decl BEGIN scanpt insert_cmd INTO trnm idlist_opt VALUES LP expr STAR INTEGER]
parser: Input 'COMMA' with pending reduce 173
parser: Reduce 173 [term ::= INTEGER], go to state 114.
parser: ... then shift 'term', go to state 147
parser: Reduce 189 [expr ::= expr STAR|SLASH|REM expr], go to state 28.
parser: ... then shift 'expr', go to state 70
parser: Reduce 220 [nexprlist ::= expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 413
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[createkw trigger_decl BEGIN scanpt insert_cmd INTO trnm idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'ID' in state 107
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw trigger_decl BEGIN scanpt insert_cmd INTO trnm idlist_opt VALUES LP nexprlist COMMA ID]
parser: Input 'DOT' in state 419
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 107.
parser: ... then shift 'nm', go to state 537
parser: Shift 'DOT', go to state 249
parser: Return. Stack=[createkw trigger_decl BEGIN scanpt insert_cmd INTO trnm idlist_opt VALUES LP nexprlist COMMA nm DOT]
parser: Input 'ID' in state 249
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw trigger_decl BEGIN scanpt insert_cmd INTO trnm idlist_opt VALUES LP nexprlist COMMA nm DOT ID]
parser: Input 'STAR' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 249.
parser: ... then shift 'nm', go to state 536
parser: Reduce 169 [expr ::= nm DOT nm], go to state 107.
parser: ... then shift 'expr', go to state 71
parser: Shift 'STAR', go to state 114
parser: Return. Stack=[createkw trigger_decl BEGIN scanpt insert_cmd INTO trnm idlist_opt VALUES LP nexprlist COMMA expr STAR]
parser: Input 'INTEGER' in state 114
parser: Shift 'INTEGER', pending reduce 173
parser: Return. Stack=[createkw trigger_decl BEGIN scanpt insert_cmd INTO trnm idlist_opt VALUES LP nexprlist COMMA expr STAR INTEGER]
parser: Input 'RP' with pending reduce 173
parser: Reduce 173 [term ::= INTEGER], go to state 114.
parser: ... then shift 'term', go to state 147
parser: Reduce 189 [expr ::= expr STAR|SLASH|REM expr], go to state 107.
parser: ... then shift 'expr', go to state 71
parser: Reduce 219 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 413
parser: Shift 'RP', pending reduce 90
parser: Return. Stack=[createkw trigger_decl BEGIN scanpt insert_cmd INTO trnm idlist_opt VALUES LP nexprlist RP]
parser: Input 'SEMI' with pending reduce 90
parser: Reduce 90 [values ::= VALUES LP nexprlist RP], go to state 36.
parser: ... then shift 'values', go to state 534
parser: Reduce 354 [oneselect ::= values], go to state 36.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 83 [select ::= selectnowith], go to state 36.
parser: ... then shift 'select', go to state 309
parser: Reduce 156 [upsert ::=].
parser: ... then shift 'upsert', go to state 377
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', pending reduce 260
parser: Reduce 260 [trigger_cmd ::= scanpt insert_cmd INTO trnm idlist_opt select upsert scanpt], go to state 144.
parser: ... then shift 'trigger_cmd', go to state 437
parser: Shift 'SEMI', pending reduce 255
parser: Return. Stack=[createkw trigger_decl BEGIN trigger_cmd SEMI]
parser: Input 'END' with pending reduce 255
parser: Reduce 255 [trigger_cmd_list ::= trigger_cmd SEMI], go to state 144.
parser: ... then shift 'trigger_cmd_list', go to state 189
parser: Shift 'END', pending reduce 244
parser: Return. Stack=[createkw trigger_decl BEGIN trigger_cmd_list END]
parser: Input 'SEMI' with pending reduce 244
parser: Reduce 244 [cmd ::= createkw trigger_decl BEGIN trigger_cmd_list END], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[CREATE INDEX i1 on t3(e)]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'INDEX' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 225 [uniqueflag ::=].
parser: ... then shift 'uniqueflag', go to state 456
parser: Shift 'INDEX', go to state 315
parser: Return. Stack=[createkw uniqueflag INDEX]
parser: Input 'ID' in state 315
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 225
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists ID]
parser: Input 'ON' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 225.
parser: ... then shift 'nm', go to state 314
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 455
parser: Shift 'ON', go to state 224
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON]
parser: Input 'ID' in state 224
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON ID]
parser: Input 'LP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 224.
parser: ... then shift 'nm', go to state 454
parser: Shift 'LP', go to state 18
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP]
parser: Input 'ID' in state 18
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP ID]
parser: Input 'RP' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 18.
parser: ... then shift 'expr', go to state 13
parser: Reduce 134 [sortorder ::=].
parser: ... then shift 'sortorder', go to state 353
parser: Reduce 137 [nulls ::=].
parser: ... then shift 'nulls', pending reduce 131
parser: Reduce 131 [sortlist ::= expr sortorder nulls], go to state 18.
parser: ... then shift 'sortlist', go to state 402
parser: Shift 'RP', go to state 313
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP]
parser: Input 'SEMI' in state 313
parser: Reduce 147 [where_opt ::=].
parser: ... then shift 'where_opt', pending reduce 223
parser: Reduce 223 [cmd ::= createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP where_opt], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT tbl,idx,stat FROM 'aux'.sqlite_stat1]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 95 [sclp ::=].
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 419
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 355
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 355
parser: Reduce 355 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 419
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 355
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 355
parser: Reduce 355 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 419
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'FROM' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'STRING' in state 197
parser: Reduce 104 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'STRING', pending reduce 338
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix STRING]
parser: Input 'DOT' with pending reduce 338
parser: Reduce 338 [nm ::= STRING], go to state 206.
parser: ... then shift 'nm', go to state 350
parser: Shift 'DOT', go to state 245
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID' in state 245
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'SEMI' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 245.
parser: ... then shift 'nm', pending reduce 110
parser: Reduce 110 [dbnm ::= DOT nm], go to state 350.
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 123 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 349
parser: Reduce 122 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 348
parser: Reduce 127 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 105
parser: Reduce 105 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 102 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 363
parser: Reduce 147 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 362
parser: Reduce 138 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 361
parser: Reduce 140 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 128 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 360
parser: Reduce 142 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 88
parser: Reduce 88 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 83 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 80
parser: Reduce 80 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT*FROM"aux".sqlite_master ORDER BY rowid
;PRAGMA journal_mode = off;SELECT 99 WHERE 0.0
  
;;SELECT * FROM a;;INSERT INTO a VALUES(1), (2), (3), (4), (5), (6), (7), (8), (9);;CREATE TABLE ex(i1);;CREATE INDEX i2 ON a(b COLLATE binary);;PRAGMA vdbe_trace=on;;
;CREATE VIEW t2 AS 
  SELECT sum(b) FILTER( WHERE b>9 ),
         sum(b) FILTER( WHERE b>8 ),
         sum(b) FILTER( WHERE b>7 ),
         sum(b) FILTER( WHERE b>6 ),
         sum(b) FILTER( WHERE b>5 ),
         sum(b) FILTER( WHERE b>4 ),
         sum(b) FILTER( WHERE b>3 ),
         sum(b) FILTER( WHERE b>2 ),
         sum(b) FILTER( WHERE b>1 ),
         sum(b) FILTER( WHERE b>0 )
  FROM a;;
;VACUUM;;
;SELECT * FROM a ORDER BY b, b;;
;SELECT * FROM a ORDER BY b DESC, b DESC;CREATE INDEX t3 ON a(b)
;SELECT*FROM"temp".sqlite_temp_master ORDER BY rowid
;SELECT x.b || '/' || y.b FROM a x, a y ORDER BY x.b, x.b DESC
  
;SELECT x.b || '/' || y.b FROM a x, a y ORDER BY x.b, x.b||x.b
  
;SELECT x.b || '/' || y.b FROM a x, a y ORDER BY x.b, x.b, y.b||y.b
  
;SELECT x.b || '/' || y.b FROM a x, a y ORDER BY x.b, y.b||y.b DESC
  
;SELECT x.b || '/' || y.b FROM a x, a y ORDER BY x.b, x.b||y.b
  
;SELECT*FROM"temp".sqlite_temp_master ORDER BY rowid
;;
;CREATE TABLE x(y INTEGER PRIMARY KEY, t2i1);ALTER TABLE x ADD t1i1
    
;;
;SELECT x.RowID id FROM a, x WHERE a.b = x.RowID AND id = 2;SELECT*FROM"temp".sqlite_temp_master ORDER BY rowid
;ALTER TABLE x ADD abc
    
;CREATE INDEX c ON a(b)
;CREATE INDEX v1 ON a(b)
;ALTER TABLE ex ADD v2
    
;CREATE TABLE tr1(t1a, t1b);;SELECT y, v2 FROM x, ex WHERE y>v2;;
;SELECT DISTINCT b FROM a LEFT JOIN ex ON b=v2 ORDER BY +v2;CREATE INDEX x1 ON a(b)
;CREATE INDEX z ON a(b)
;CREATE INDEX example ON ex(v2)
;;SELECT count(*) FROM sqlite_master WHERE tbl_name = 'e' AND type = 'index';;
;CREATE TABLE example_idx_00000042(id PRIMARY KEY, UNIQUE(id) );;BEGIN;;CREATE UNIQUE INDEX IF NOT EXISTS a_id ON a(b==0);;SELECT * FROM ex;]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'STAR' in state 288
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 95 [sclp ::=].
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STAR', pending reduce 97
parser: Return. Stack=[SELECT distinct sclp scanpt STAR]
parser: Input 'FROM' with pending reduce 97
parser: Reduce 97 [selcollist ::= sclp scanpt STAR], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 104 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'DOT' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 350
parser: Shift 'DOT', go to state 245
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID' in state 245
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'ORDER' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 245.
parser: ... then shift 'nm', pending reduce 110
parser: Reduce 110 [dbnm ::= DOT nm], go to state 350.
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 123 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 349
parser: Reduce 122 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 348
parser: Reduce 127 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 105
parser: Reduce 105 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 102 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 363
parser: Reduce 147 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 362
parser: Reduce 138 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 361
parser: Reduce 140 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 517
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 517
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 419
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 134 [sortorder ::=].
parser: ... then shift 'sortorder', go to state 353
parser: Reduce 137 [nulls ::=].
parser: ... then shift 'nulls', pending reduce 131
parser: Reduce 131 [sortlist ::= expr sortorder nulls], go to state 26.
parser: ... then shift 'sortlist', go to state 516
parser: Reduce 129 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 360
parser: Reduce 142 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 88
parser: Reduce 88 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 83 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 80
parser: Reduce 80 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[PRAGMA journal_mode = off;SELECT 99 WHERE 0.0
  
;;SELECT * FROM a;;INSERT INTO a VALUES(1), (2), (3), (4), (5), (6), (7), (8), (9);;CREATE TABLE ex(i1);;CREATE INDEX i2 ON a(b COLLATE binary);;PRAGMA vdbe_trace=on;;
;CREATE VIEW t2 AS 
  SELECT sum(b) FILTER( WHERE b>9 ),
         sum(b) FILTER( WHERE b>8 ),
         sum(b) FILTER( WHERE b>7 ),
         sum(b) FILTER( WHERE b>6 ),
         sum(b) FILTER( WHERE b>5 ),
         sum(b) FILTER( WHERE b>4 ),
         sum(b) FILTER( WHERE b>3 ),
         sum(b) FILTER( WHERE b>2 ),
         sum(b) FILTER( WHERE b>1 ),
         sum(b) FILTER( WHERE b>0 )
  FROM a;;
;VACUUM;;
;SELECT * FROM a ORDER BY b, b;;
;SELECT * FROM a ORDER BY b DESC, b DESC;CREATE INDEX t3 ON a(b)
;SELECT*FROM"temp".sqlite_temp_master ORDER BY rowid
;SELECT x.b || '/' || y.b FROM a x, a y ORDER BY x.b, x.b DESC
  
;SELECT x.b || '/' || y.b FROM a x, a y ORDER BY x.b, x.b||x.b
  
;SELECT x.b || '/' || y.b FROM a x, a y ORDER BY x.b, x.b, y.b||y.b
  
;SELECT x.b || '/' || y.b FROM a x, a y ORDER BY x.b, y.b||y.b DESC
  
;SELECT x.b || '/' || y.b FROM a x, a y ORDER BY x.b, x.b||y.b
  
;SELECT*FROM"temp".sqlite_temp_master ORDER BY rowid
;;
;CREATE TABLE x(y INTEGER PRIMARY KEY, t2i1);ALTER TABLE x ADD t1i1
    
;;
;SELECT x.RowID id FROM a, x WHERE a.b = x.RowID AND id = 2;SELECT*FROM"temp".sqlite_temp_master ORDER BY rowid
;ALTER TABLE x ADD abc
    
;CREATE INDEX c ON a(b)
;CREATE INDEX v1 ON a(b)
;ALTER TABLE ex ADD v2
    
;CREATE TABLE tr1(t1a, t1b);;SELECT y, v2 FROM x, ex WHERE y>v2;;
;SELECT DISTINCT b FROM a LEFT JOIN ex ON b=v2 ORDER BY +v2;CREATE INDEX x1 ON a(b)
;CREATE INDEX z ON a(b)
;CREATE INDEX example ON ex(v2)
;;SELECT count(*) FROM sqlite_master WHERE tbl_name = 'e' AND type = 'index';;
;CREATE TABLE example_idx_00000042(id PRIMARY KEY, UNIQUE(id) );;BEGIN;;CREATE UNIQUE INDEX IF NOT EXISTS a_id ON a(b==0);;SELECT * FROM ex;]]]
parser: Input 'PRAGMA' in state 0
parser: Shift 'PRAGMA', go to state 215
parser: Return. Stack=[PRAGMA]
parser: Input 'ID' in state 215
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[PRAGMA ID]
parser: Input 'EQ' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 215.
parser: ... then shift 'nm', go to state 295
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 394
parser: Shift 'EQ', go to state 31
parser: Return. Stack=[PRAGMA nm dbnm EQ]
parser: Input 'ID' in state 31
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[PRAGMA nm dbnm EQ ID]
parser: Input 'SEMI' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 31.
parser: ... then shift 'nm', pending reduce 238
parser: Reduce 238 [cmd ::= PRAGMA nm dbnm EQ nmnum], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT 99 WHERE 0.0
  
;;SELECT * FROM a;;INSERT INTO a VALUES(1), (2), (3), (4), (5), (6), (7), (8), (9);;CREATE TABLE ex(i1);;CREATE INDEX i2 ON a(b COLLATE binary);;PRAGMA vdbe_trace=on;;
;CREATE VIEW t2 AS 
  SELECT sum(b) FILTER( WHERE b>9 ),
         sum(b) FILTER( WHERE b>8 ),
         sum(b) FILTER( WHERE b>7 ),
         sum(b) FILTER( WHERE b>6 ),
         sum(b) FILTER( WHERE b>5 ),
         sum(b) FILTER( WHERE b>4 ),
         sum(b) FILTER( WHERE b>3 ),
         sum(b) FILTER( WHERE b>2 ),
         sum(b) FILTER( WHERE b>1 ),
         sum(b) FILTER( WHERE b>0 )
  FROM a;;
;VACUUM;;
;SELECT * FROM a ORDER BY b, b;;
;SELECT * FROM a ORDER BY b DESC, b DESC;CREATE INDEX t3 ON a(b)
;SELECT*FROM"temp".sqlite_temp_master ORDER BY rowid
;SELECT x.b || '/' || y.b FROM a x, a y ORDER BY x.b, x.b DESC
  
;SELECT x.b || '/' || y.b FROM a x, a y ORDER BY x.b, x.b||x.b
  
;SELECT x.b || '/' || y.b FROM a x, a y ORDER BY x.b, x.b, y.b||y.b
  
;SELECT x.b || '/' || y.b FROM a x, a y ORDER BY x.b, y.b||y.b DESC
  
;SELECT x.b || '/' || y.b FROM a x, a y ORDER BY x.b, x.b||y.b
  
;SELECT*FROM"temp".sqlite_temp_master ORDER BY rowid
;;
;CREATE TABLE x(y INTEGER PRIMARY KEY, t2i1);ALTER TABLE x ADD t1i1
    
;;
;SELECT x.RowID id FROM a, x WHERE a.b = x.RowID AND id = 2;SELECT*FROM"temp".sqlite_temp_master ORDER BY rowid
;ALTER TABLE x ADD abc
    
;CREATE INDEX c ON a(b)
;CREATE INDEX v1 ON a(b)
;ALTER TABLE ex ADD v2
    
;CREATE TABLE tr1(t1a, t1b);;SELECT y, v2 FROM x, ex WHERE y>v2;;
;SELECT DISTINCT b FROM a LEFT JOIN ex ON b=v2 ORDER BY +v2;CREATE INDEX x1 ON a(b)
;CREATE INDEX z ON a(b)
;CREATE INDEX example ON ex(v2)
;;SELECT count(*) FROM sqlite_master WHERE tbl_name = 'e' AND type = 'index';;
;CREATE TABLE example_idx_00000042(id PRIMARY KEY, UNIQUE(id) );;BEGIN;;CREATE UNIQUE INDEX IF NOT EXISTS a_id ON a(b==0);;SELECT * FROM ex;]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'INTEGER' in state 288
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 95 [sclp ::=].
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'INTEGER', pending reduce 173
parser: Return. Stack=[SELECT distinct sclp scanpt INTEGER]
parser: Input 'WHERE' with pending reduce 173
parser: Reduce 173 [term ::= INTEGER], go to state 77.
parser: ... then shift 'term', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Reduce 101 [from ::=].
parser: ... then shift 'from', go to state 363
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[SELECT distinct selcollist from WHERE]
parser: Input 'FLOAT' in state 93
parser: Shift 'FLOAT', pending reduce 171
parser: Return. Stack=[SELECT distinct selcollist from WHERE FLOAT]
parser: Input 'SEMI' with pending reduce 171
parser: Reduce 171 [term ::= NULL|FLOAT|BLOB], go to state 93.
parser: ... then shift 'term', go to state 63
parser: Reduce 148 [where_opt ::= WHERE expr], go to state 363.
parser: ... then shift 'where_opt', go to state 362
parser: Reduce 138 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 361
parser: Reduce 140 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 128 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 360
parser: Reduce 142 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 88
parser: Reduce 88 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 83 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 80
parser: Reduce 80 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[;SELECT * FROM a;;INSERT INTO a VALUES(1), (2), (3), (4), (5), (6), (7), (8), (9);;CREATE TABLE ex(i1);;CREATE INDEX i2 ON a(b COLLATE binary);;PRAGMA vdbe_trace=on;;
;CREATE VIEW t2 AS 
  SELECT sum(b) FILTER( WHERE b>9 ),
         sum(b) FILTER( WHERE b>8 ),
         sum(b) FILTER( WHERE b>7 ),
         sum(b) FILTER( WHERE b>6 ),
         sum(b) FILTER( WHERE b>5 ),
         sum(b) FILTER( WHERE b>4 ),
         sum(b) FILTER( WHERE b>3 ),
         sum(b) FILTER( WHERE b>2 ),
         sum(b) FILTER( WHERE b>1 ),
         sum(b) FILTER( WHERE b>0 )
  FROM a;;
;VACUUM;;
;SELECT * FROM a ORDER BY b, b;;
;SELECT * FROM a ORDER BY b DESC, b DESC;CREATE INDEX t3 ON a(b)
;SELECT*FROM"temp".sqlite_temp_master ORDER BY rowid
;SELECT x.b || '/' || y.b FROM a x, a y ORDER BY x.b, x.b DESC
  
;SELECT x.b || '/' || y.b FROM a x, a y ORDER BY x.b, x.b||x.b
  
;SELECT x.b || '/' || y.b FROM a x, a y ORDER BY x.b, x.b, y.b||y.b
  
;SELECT x.b || '/' || y.b FROM a x, a y ORDER BY x.b, y.b||y.b DESC
  
;SELECT x.b || '/' || y.b FROM a x, a y ORDER BY x.b, x.b||y.b
  
;SELECT*FROM"temp".sqlite_temp_master ORDER BY rowid
;;
;CREATE TABLE x(y INTEGER PRIMARY KEY, t2i1);ALTER TABLE x ADD t1i1
    
;;
;SELECT x.RowID id FROM a, x WHERE a.b = x.RowID AND id = 2;SELECT*FROM"temp".sqlite_temp_master ORDER BY rowid
;ALTER TABLE x ADD abc
    
;CREATE INDEX c ON a(b)
;CREATE INDEX v1 ON a(b)
;ALTER TABLE ex ADD v2
    
;CREATE TABLE tr1(t1a, t1b);;SELECT y, v2 FROM x, ex WHERE y>v2;;
;SELECT DISTINCT b FROM a LEFT JOIN ex ON b=v2 ORDER BY +v2;CREATE INDEX x1 ON a(b)
;CREATE INDEX z ON a(b)
;CREATE INDEX example ON ex(v2)
;;SELECT count(*) FROM sqlite_master WHERE tbl_name = 'e' AND type = 'index';;
;CREATE TABLE example_idx_00000042(id PRIMARY KEY, UNIQUE(id) );;BEGIN;;CREATE UNIQUE INDEX IF NOT EXISTS a_id ON a(b==0);;SELECT * FROM ex;]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 326
parser: Return. Stack=[SEMI]
parser: Input 'SELECT' with pending reduce 326
parser: Reduce 326 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[ecmd SELECT]
parser: Input 'STAR' in state 288
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 95 [sclp ::=].
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STAR', pending reduce 97
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt STAR]
parser: Input 'FROM' with pending reduce 97
parser: Reduce 97 [selcollist ::= sclp scanpt STAR], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[ecmd SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 104 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[ecmd SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'SEMI' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 350
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 123 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 349
parser: Reduce 122 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 348
parser: Reduce 127 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 105
parser: Reduce 105 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 102 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 363
parser: Reduce 147 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 362
parser: Reduce 138 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 361
parser: Reduce 140 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 128 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 360
parser: Reduce 142 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 88
parser: Reduce 88 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 1.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 83 [select ::= selectnowith], go to state 1.
parser: ... then shift 'select', pending reduce 80
parser: Reduce 80 [cmd ::= select], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[ecmd cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping ecmd
parser: [[[;INSERT INTO a VALUES(1), (2), (3), (4), (5), (6), (7), (8), (9);;CREATE TABLE ex(i1);;CREATE INDEX i2 ON a(b COLLATE binary);;PRAGMA vdbe_trace=on;;
;CREATE VIEW t2 AS 
  SELECT sum(b) FILTER( WHERE b>9 ),
         sum(b) FILTER( WHERE b>8 ),
         sum(b) FILTER( WHERE b>7 ),
         sum(b) FILTER( WHERE b>6 ),
         sum(b) FILTER( WHERE b>5 ),
         sum(b) FILTER( WHERE b>4 ),
         sum(b) FILTER( WHERE b>3 ),
         sum(b) FILTER( WHERE b>2 ),
         sum(b) FILTER( WHERE b>1 ),
         sum(b) FILTER( WHERE b>0 )
  FROM a;;
;VACUUM;;
;SELECT * FROM a ORDER BY b, b;;
;SELECT * FROM a ORDER BY b DESC, b DESC;CREATE INDEX t3 ON a(b)
;SELECT*FROM"temp".sqlite_temp_master ORDER BY rowid
;SELECT x.b || '/' || y.b FROM a x, a y ORDER BY x.b, x.b DESC
  
;SELECT x.b || '/' || y.b FROM a x, a y ORDER BY x.b, x.b||x.b
  
;SELECT x.b || '/' || y.b FROM a x, a y ORDER BY x.b, x.b, y.b||y.b
  
;SELECT x.b || '/' || y.b FROM a x, a y ORDER BY x.b, y.b||y.b DESC
  
;SELECT x.b || '/' || y.b FROM a x, a y ORDER BY x.b, x.b||y.b
  
;SELECT*FROM"temp".sqlite_temp_master ORDER BY rowid
;;
;CREATE TABLE x(y INTEGER PRIMARY KEY, t2i1);ALTER TABLE x ADD t1i1
    
;;
;SELECT x.RowID id FROM a, x WHERE a.b = x.RowID AND id = 2;SELECT*FROM"temp".sqlite_temp_master ORDER BY rowid
;ALTER TABLE x ADD abc
    
;CREATE INDEX c ON a(b)
;CREATE INDEX v1 ON a(b)
;ALTER TABLE ex ADD v2
    
;CREATE TABLE tr1(t1a, t1b);;SELECT y, v2 FROM x, ex WHERE y>v2;;
;SELECT DISTINCT b FROM a LEFT JOIN ex ON b=v2 ORDER BY +v2;CREATE INDEX x1 ON a(b)
;CREATE INDEX z ON a(b)
;CREATE INDEX example ON ex(v2)
;;SELECT count(*) FROM sqlite_master WHERE tbl_name = 'e' AND type = 'index';;
;CREATE TABLE example_idx_00000042(id PRIMARY KEY, UNIQUE(id) );;BEGIN;;CREATE UNIQUE INDEX IF NOT EXISTS a_id ON a(b==0);;SELECT * FROM ex;]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 326
parser: Return. Stack=[SEMI]
parser: Input 'INSERT' with pending reduce 326
parser: Reduce 326 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 380 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'INSERT', go to state 311
parser: Return. Stack=[ecmd with INSERT]
parser: Input 'INTO' in state 311
parser: Reduce 71 [orconf ::=].
parser: ... then shift 'orconf', pending reduce 160
parser: Reduce 160 [insert_cmd ::= INSERT orconf], go to state 219.
parser: ... then shift 'insert_cmd', go to state 430
parser: Shift 'INTO', go to state 166
parser: Return. Stack=[ecmd with insert_cmd INTO]
parser: Input 'ID' in state 166
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[ecmd with insert_cmd INTO ID]
parser: Input 'VALUES' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 166.
parser: ... then shift 'nm', go to state 395
parser: Reduce 113 [xfullname ::= nm], go to state 166.
parser: ... then shift 'xfullname', go to state 298
parser: Reduce 162 [idlist_opt ::=].
parser: ... then shift 'idlist_opt', go to state 35
parser: Shift 'VALUES', go to state 528
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES]
parser: Input 'LP' in state 528
parser: Shift 'LP', go to state 28
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP]
parser: Input 'INTEGER' in state 28
parser: Shift 'INTEGER', pending reduce 173
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP INTEGER]
parser: Input 'RP' with pending reduce 173
parser: Reduce 173 [term ::= INTEGER], go to state 28.
parser: ... then shift 'term', go to state 70
parser: Reduce 220 [nexprlist ::= expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 413
parser: Shift 'RP', pending reduce 90
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist RP]
parser: Input 'COMMA' with pending reduce 90
parser: Reduce 90 [values ::= VALUES LP nexprlist RP], go to state 35.
parser: ... then shift 'values', go to state 534
parser: Shift 'COMMA', go to state 533
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt values COMMA]
parser: Input 'LP' in state 533
parser: Shift 'LP', go to state 29
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt values COMMA LP]
parser: Input 'INTEGER' in state 29
parser: Shift 'INTEGER', pending reduce 173
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt values COMMA LP INTEGER]
parser: Input 'RP' with pending reduce 173
parser: Reduce 173 [term ::= INTEGER], go to state 29.
parser: ... then shift 'term', go to state 70
parser: Reduce 220 [nexprlist ::= expr], go to state 29.
parser: ... then shift 'nexprlist', go to state 417
parser: Shift 'RP', pending reduce 91
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt values COMMA LP nexprlist RP]
parser: Input 'COMMA' with pending reduce 91
parser: Reduce 91 [values ::= values COMMA LP nexprlist RP], go to state 35.
parser: ... then shift 'values', go to state 534
parser: Shift 'COMMA', go to state 533
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt values COMMA]
parser: Input 'LP' in state 533
parser: Shift 'LP', go to state 29
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt values COMMA LP]
parser: Input 'INTEGER' in state 29
parser: Shift 'INTEGER', pending reduce 173
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt values COMMA LP INTEGER]
parser: Input 'RP' with pending reduce 173
parser: Reduce 173 [term ::= INTEGER], go to state 29.
parser: ... then shift 'term', go to state 70
parser: Reduce 220 [nexprlist ::= expr], go to state 29.
parser: ... then shift 'nexprlist', go to state 417
parser: Shift 'RP', pending reduce 91
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt values COMMA LP nexprlist RP]
parser: Input 'COMMA' with pending reduce 91
parser: Reduce 91 [values ::= values COMMA LP nexprlist RP], go to state 35.
parser: ... then shift 'values', go to state 534
parser: Shift 'COMMA', go to state 533
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt values COMMA]
parser: Input 'LP' in state 533
parser: Shift 'LP', go to state 29
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt values COMMA LP]
parser: Input 'INTEGER' in state 29
parser: Shift 'INTEGER', pending reduce 173
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt values COMMA LP INTEGER]
parser: Input 'RP' with pending reduce 173
parser: Reduce 173 [term ::= INTEGER], go to state 29.
parser: ... then shift 'term', go to state 70
parser: Reduce 220 [nexprlist ::= expr], go to state 29.
parser: ... then shift 'nexprlist', go to state 417
parser: Shift 'RP', pending reduce 91
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt values COMMA LP nexprlist RP]
parser: Input 'COMMA' with pending reduce 91
parser: Reduce 91 [values ::= values COMMA LP nexprlist RP], go to state 35.
parser: ... then shift 'values', go to state 534
parser: Shift 'COMMA', go to state 533
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt values COMMA]
parser: Input 'LP' in state 533
parser: Shift 'LP', go to state 29
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt values COMMA LP]
parser: Input 'INTEGER' in state 29
parser: Shift 'INTEGER', pending reduce 173
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt values COMMA LP INTEGER]
parser: Input 'RP' with pending reduce 173
parser: Reduce 173 [term ::= INTEGER], go to state 29.
parser: ... then shift 'term', go to state 70
parser: Reduce 220 [nexprlist ::= expr], go to state 29.
parser: ... then shift 'nexprlist', go to state 417
parser: Shift 'RP', pending reduce 91
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt values COMMA LP nexprlist RP]
parser: Input 'COMMA' with pending reduce 91
parser: Reduce 91 [values ::= values COMMA LP nexprlist RP], go to state 35.
parser: ... then shift 'values', go to state 534
parser: Shift 'COMMA', go to state 533
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt values COMMA]
parser: Input 'LP' in state 533
parser: Shift 'LP', go to state 29
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt values COMMA LP]
parser: Input 'INTEGER' in state 29
parser: Shift 'INTEGER', pending reduce 173
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt values COMMA LP INTEGER]
parser: Input 'RP' with pending reduce 173
parser: Reduce 173 [term ::= INTEGER], go to state 29.
parser: ... then shift 'term', go to state 70
parser: Reduce 220 [nexprlist ::= expr], go to state 29.
parser: ... then shift 'nexprlist', go to state 417
parser: Shift 'RP', pending reduce 91
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt values COMMA LP nexprlist RP]
parser: Input 'COMMA' with pending reduce 91
parser: Reduce 91 [values ::= values COMMA LP nexprlist RP], go to state 35.
parser: ... then shift 'values', go to state 534
parser: Shift 'COMMA', go to state 533
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt values COMMA]
parser: Input 'LP' in state 533
parser: Shift 'LP', go to state 29
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt values COMMA LP]
parser: Input 'INTEGER' in state 29
parser: Shift 'INTEGER', pending reduce 173
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt values COMMA LP INTEGER]
parser: Input 'RP' with pending reduce 173
parser: Reduce 173 [term ::= INTEGER], go to state 29.
parser: ... then shift 'term', go to state 70
parser: Reduce 220 [nexprlist ::= expr], go to state 29.
parser: ... then shift 'nexprlist', go to state 417
parser: Shift 'RP', pending reduce 91
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt values COMMA LP nexprlist RP]
parser: Input 'COMMA' with pending reduce 91
parser: Reduce 91 [values ::= values COMMA LP nexprlist RP], go to state 35.
parser: ... then shift 'values', go to state 534
parser: Shift 'COMMA', go to state 533
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt values COMMA]
parser: Input 'LP' in state 533
parser: Shift 'LP', go to state 29
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt values COMMA LP]
parser: Input 'INTEGER' in state 29
parser: Shift 'INTEGER', pending reduce 173
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt values COMMA LP INTEGER]
parser: Input 'RP' with pending reduce 173
parser: Reduce 173 [term ::= INTEGER], go to state 29.
parser: ... then shift 'term', go to state 70
parser: Reduce 220 [nexprlist ::= expr], go to state 29.
parser: ... then shift 'nexprlist', go to state 417
parser: Shift 'RP', pending reduce 91
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt values COMMA LP nexprlist RP]
parser: Input 'COMMA' with pending reduce 91
parser: Reduce 91 [values ::= values COMMA LP nexprlist RP], go to state 35.
parser: ... then shift 'values', go to state 534
parser: Shift 'COMMA', go to state 533
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt values COMMA]
parser: Input 'LP' in state 533
parser: Shift 'LP', go to state 29
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt values COMMA LP]
parser: Input 'INTEGER' in state 29
parser: Shift 'INTEGER', pending reduce 173
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt values COMMA LP INTEGER]
parser: Input 'RP' with pending reduce 173
parser: Reduce 173 [term ::= INTEGER], go to state 29.
parser: ... then shift 'term', go to state 70
parser: Reduce 220 [nexprlist ::= expr], go to state 29.
parser: ... then shift 'nexprlist', go to state 417
parser: Shift 'RP', pending reduce 91
parser: Return. Stack=[ecmd with insert_cmd INTO xfullname idlist_opt values COMMA LP nexprlist RP]
parser: Input 'SEMI' with pending reduce 91
parser: Reduce 91 [values ::= values COMMA LP nexprlist RP], go to state 35.
parser: ... then shift 'values', go to state 534
parser: Reduce 354 [oneselect ::= values], go to state 35.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 83 [select ::= selectnowith], go to state 35.
parser: ... then shift 'select', go to state 297
parser: Reduce 156 [upsert ::=].
parser: ... then shift 'upsert', pending reduce 154
parser: Reduce 154 [cmd ::= with insert_cmd INTO xfullname idlist_opt select upsert], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[ecmd cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping ecmd
parser: [[[;CREATE TABLE ex(i1);;CREATE INDEX i2 ON a(b COLLATE binary);;PRAGMA vdbe_trace=on;;
;CREATE VIEW t2 AS 
  SELECT sum(b) FILTER( WHERE b>9 ),
         sum(b) FILTER( WHERE b>8 ),
         sum(b) FILTER( WHERE b>7 ),
         sum(b) FILTER( WHERE b>6 ),
         sum(b) FILTER( WHERE b>5 ),
         sum(b) FILTER( WHERE b>4 ),
         sum(b) FILTER( WHERE b>3 ),
         sum(b) FILTER( WHERE b>2 ),
         sum(b) FILTER( WHERE b>1 ),
         sum(b) FILTER( WHERE b>0 )
  FROM a;;
;VACUUM;;
;SELECT * FROM a ORDER BY b, b;;
;SELECT * FROM a ORDER BY b DESC, b DESC;CREATE INDEX t3 ON a(b)
;SELECT*FROM"temp".sqlite_temp_master ORDER BY rowid
;SELECT x.b || '/' || y.b FROM a x, a y ORDER BY x.b, x.b DESC
  
;SELECT x.b || '/' || y.b FROM a x, a y ORDER BY x.b, x.b||x.b
  
;SELECT x.b || '/' || y.b FROM a x, a y ORDER BY x.b, x.b, y.b||y.b
  
;SELECT x.b || '/' || y.b FROM a x, a y ORDER BY x.b, y.b||y.b DESC
  
;SELECT x.b || '/' || y.b FROM a x, a y ORDER BY x.b, x.b||y.b
  
;SELECT*FROM"temp".sqlite_temp_master ORDER BY rowid
;;
;CREATE TABLE x(y INTEGER PRIMARY KEY, t2i1);ALTER TABLE x ADD t1i1
    
;;
;SELECT x.RowID id FROM a, x WHERE a.b = x.RowID AND id = 2;SELECT*FROM"temp".sqlite_temp_master ORDER BY rowid
;ALTER TABLE x ADD abc
    
;CREATE INDEX c ON a(b)
;CREATE INDEX v1 ON a(b)
;ALTER TABLE ex ADD v2
    
;CREATE TABLE tr1(t1a, t1b);;SELECT y, v2 FROM x, ex WHERE y>v2;;
;SELECT DISTINCT b FROM a LEFT JOIN ex ON b=v2 ORDER BY +v2;CREATE INDEX x1 ON a(b)
;CREATE INDEX z ON a(b)
;CREATE INDEX example ON ex(v2)
;;SELECT count(*) FROM sqlite_master WHERE tbl_name = 'e' AND type = 'index';;
;CREATE TABLE example_idx_00000042(id PRIMARY KEY, UNIQUE(id) );;BEGIN;;CREATE UNIQUE INDEX IF NOT EXISTS a_id ON a(b==0);;SELECT * FROM ex;]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 326
parser: Return. Stack=[SEMI]
parser: Input 'CREATE' with pending reduce 326
parser: Reduce 326 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[ecmd CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 1.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 390
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[ecmd createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[ecmd createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 1.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[ecmd create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[ecmd create_table LP ID]
parser: Input 'RP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 192
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 379
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 152
parser: Reduce 336 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Reduce 61 [conslist_opt ::=].
parser: ... then shift 'conslist_opt', go to state 540
parser: Shift 'RP', go to state 364
parser: Return. Stack=[ecmd create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 364
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: [[[UPDATE 'main'.sqlite_master SET type='table', name='ex', tbl_name='ex', rootpage=#2, sql='CREATE TABLE ex(i1)' WHERE rowid=#1]]]
parser: Input 'UPDATE' in state 0
parser: Reduce 380 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'UPDATE', go to state 299
parser: Return. Stack=[with UPDATE]
parser: Input 'STRING' in state 299
parser: Reduce 71 [orconf ::=].
parser: ... then shift 'orconf', go to state 167
parser: Shift 'STRING', pending reduce 338
parser: Return. Stack=[with UPDATE orconf STRING]
parser: Input 'DOT' with pending reduce 338
parser: Reduce 338 [nm ::= STRING], go to state 167.
parser: ... then shift 'nm', go to state 395
parser: Shift 'DOT', go to state 218
parser: Return. Stack=[with UPDATE orconf nm DOT]
parser: Input 'ID' in state 218
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[with UPDATE orconf nm DOT ID]
parser: Input 'SET' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 218.
parser: ... then shift 'nm', go to state 432
parser: Reduce 114 [xfullname ::= nm DOT nm], go to state 167.
parser: ... then shift 'xfullname', go to state 271
parser: Reduce 123 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 431
parser: Shift 'SET', go to state 155
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET]
parser: Input 'ID' in state 155
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET ID]
parser: Input 'EQ' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 155.
parser: ... then shift 'nm', go to state 445
parser: Shift 'EQ', go to state 84
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ]
parser: Input 'STRING' in state 84
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ STRING]
parser: Input 'COMMA' in state 539
parser: Reduce 172 [term ::= STRING], go to state 84.
parser: ... then shift 'term', go to state 58
parser: Reduce 152 [setlist ::= nm EQ expr], go to state 155.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 447
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING' in state 86
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'COMMA' in state 539
parser: Reduce 172 [term ::= STRING], go to state 86.
parser: ... then shift 'term', go to state 60
parser: Reduce 150 [setlist ::= setlist COMMA nm EQ expr], go to state 155.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 447
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING' in state 86
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'COMMA' in state 539
parser: Reduce 172 [term ::= STRING], go to state 86.
parser: ... then shift 'term', go to state 60
parser: Reduce 150 [setlist ::= setlist COMMA nm EQ expr], go to state 155.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 447
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'VARIABLE' in state 86
parser: Shift 'VARIABLE', pending reduce 174
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ VARIABLE]
parser: Input 'COMMA' with pending reduce 174
parser: Reduce 174 [expr ::= VARIABLE], go to state 86.
parser: ... then shift 'expr', go to state 60
parser: Reduce 150 [setlist ::= setlist COMMA nm EQ expr], go to state 155.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 447
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING' in state 86
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'WHERE' in state 539
parser: Reduce 172 [term ::= STRING], go to state 86.
parser: ... then shift 'term', go to state 60
parser: Reduce 150 [setlist ::= setlist COMMA nm EQ expr], go to state 155.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 419
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE ID]
parser: Input 'EQ' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr EQ]
parser: Input 'VARIABLE' in state 117
parser: Shift 'VARIABLE', pending reduce 174
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr EQ VARIABLE]
parser: Input 'SEMI' with pending reduce 174
parser: Reduce 174 [expr ::= VARIABLE], go to state 117.
parser: ... then shift 'expr', go to state 129
parser: Reduce 186 [expr ::= expr EQ|NE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 148 [where_opt ::= WHERE expr], go to state 270.
parser: ... then shift 'where_opt', pending reduce 149
parser: Reduce 149 [cmd ::= with UPDATE orconf xfullname indexed_opt SET setlist where_opt], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Input '$' with pending reduce 327
parser: Reduce 327 [ecmd ::= cmdx SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 323 [input ::= cmdlist], go to state 0.
parser: ... then shift 'input', pending reduce -2
parser: Accept!
parser: ... then shift 'create_table_args', pending reduce 334
parser: Reduce 334 [cmd ::= create_table create_table_args], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[ecmd cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping ecmd
parser: [[[SELECT*FROM"main".sqlite_master WHERE tbl_name='ex' AND type!='trigger' ORDER BY rowid]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'STAR' in state 288
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 95 [sclp ::=].
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STAR', pending reduce 97
parser: Return. Stack=[SELECT distinct sclp scanpt STAR]
parser: Input 'FROM' with pending reduce 97
parser: Reduce 97 [selcollist ::= sclp scanpt STAR], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 104 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'DOT' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 350
parser: Shift 'DOT', go to state 245
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID' in state 245
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'WHERE' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 245.
parser: ... then shift 'nm', pending reduce 110
parser: Reduce 110 [dbnm ::= DOT nm], go to state 350.
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 123 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 349
parser: Reduce 122 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 348
parser: Reduce 127 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 105
parser: Reduce 105 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 102 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 363
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[SELECT distinct selcollist from WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 419
parser: Return. Stack=[SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr EQ STRING]
parser: Input 'AND' in state 539
parser: Reduce 172 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 186 [expr ::= expr EQ|NE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'AND', go to state 120
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID' in state 120
parser: Shift 'ID', go to state 419
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'NE' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Shift 'NE', go to state 117
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr NE]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr NE STRING]
parser: Input 'ORDER' in state 539
parser: Reduce 172 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 186 [expr ::= expr EQ|NE expr], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Reduce 183 [expr ::= expr AND expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 148 [where_opt ::= WHERE expr], go to state 363.
parser: ... then shift 'where_opt', go to state 362
parser: Reduce 138 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 361
parser: Reduce 140 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 517
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 517
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 419
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 134 [sortorder ::=].
parser: ... then shift 'sortorder', go to state 353
parser: Reduce 137 [nulls ::=].
parser: ... then shift 'nulls', pending reduce 131
parser: Reduce 131 [sortlist ::= expr sortorder nulls], go to state 26.
parser: ... then shift 'sortlist', go to state 516
parser: Reduce 129 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 360
parser: Reduce 142 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 88
parser: Reduce 88 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 83 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 80
parser: Reduce 80 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[CREATE TABLE ex(i1)]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 390
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 0.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP ID]
parser: Input 'RP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 192
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 379
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 152
parser: Reduce 336 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Reduce 61 [conslist_opt ::=].
parser: ... then shift 'conslist_opt', go to state 540
parser: Shift 'RP', go to state 364
parser: Return. Stack=[create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 364
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: ... then shift 'create_table_args', pending reduce 334
parser: Reduce 334 [cmd ::= create_table create_table_args], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[;CREATE INDEX i2 ON a(b COLLATE binary);;PRAGMA vdbe_trace=on;;
;CREATE VIEW t2 AS 
  SELECT sum(b) FILTER( WHERE b>9 ),
         sum(b) FILTER( WHERE b>8 ),
         sum(b) FILTER( WHERE b>7 ),
         sum(b) FILTER( WHERE b>6 ),
         sum(b) FILTER( WHERE b>5 ),
         sum(b) FILTER( WHERE b>4 ),
         sum(b) FILTER( WHERE b>3 ),
         sum(b) FILTER( WHERE b>2 ),
         sum(b) FILTER( WHERE b>1 ),
         sum(b) FILTER( WHERE b>0 )
  FROM a;;
;VACUUM;;
;SELECT * FROM a ORDER BY b, b;;
;SELECT * FROM a ORDER BY b DESC, b DESC;CREATE INDEX t3 ON a(b)
;SELECT*FROM"temp".sqlite_temp_master ORDER BY rowid
;SELECT x.b || '/' || y.b FROM a x, a y ORDER BY x.b, x.b DESC
  
;SELECT x.b || '/' || y.b FROM a x, a y ORDER BY x.b, x.b||x.b
  
;SELECT x.b || '/' || y.b FROM a x, a y ORDER BY x.b, x.b, y.b||y.b
  
;SELECT x.b || '/' || y.b FROM a x, a y ORDER BY x.b, y.b||y.b DESC
  
;SELECT x.b || '/' || y.b FROM a x, a y ORDER BY x.b, x.b||y.b
  
;SELECT*FROM"temp".sqlite_temp_master ORDER BY rowid
;;
;CREATE TABLE x(y INTEGER PRIMARY KEY, t2i1);ALTER TABLE x ADD t1i1
    
;;
;SELECT x.RowID id FROM a, x WHERE a.b = x.RowID AND id = 2;SELECT*FROM"temp".sqlite_temp_master ORDER BY rowid
;ALTER TABLE x ADD abc
    
;CREATE INDEX c ON a(b)
;CREATE INDEX v1 ON a(b)
;ALTER TABLE ex ADD v2
    
;CREATE TABLE tr1(t1a, t1b);;SELECT y, v2 FROM x, ex WHERE y>v2;;
;SELECT DISTINCT b FROM a LEFT JOIN ex ON b=v2 ORDER BY +v2;CREATE INDEX x1 ON a(b)
;CREATE INDEX z ON a(b)
;CREATE INDEX example ON ex(v2)
;;SELECT count(*) FROM sqlite_master WHERE tbl_name = 'e' AND type = 'index';;
;CREATE TABLE example_idx_00000042(id PRIMARY KEY, UNIQUE(id) );;BEGIN;;CREATE UNIQUE INDEX IF NOT EXISTS a_id ON a(b==0);;SELECT * FROM ex;]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 326
parser: Return. Stack=[SEMI]
parser: Input 'CREATE' with pending reduce 326
parser: Reduce 326 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[ecmd CREATE]
parser: Input 'INDEX' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 1.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 225 [uniqueflag ::=].
parser: ... then shift 'uniqueflag', go to state 456
parser: Shift 'INDEX', go to state 315
parser: Return. Stack=[ecmd createkw uniqueflag INDEX]
parser: Input 'ID' in state 315
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 225
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[ecmd createkw uniqueflag INDEX ifnotexists ID]
parser: Input 'ON' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 225.
parser: ... then shift 'nm', go to state 314
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 455
parser: Shift 'ON', go to state 224
parser: Return. Stack=[ecmd createkw uniqueflag INDEX ifnotexists nm dbnm ON]
parser: Input 'ID' in state 224
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[ecmd createkw uniqueflag INDEX ifnotexists nm dbnm ON ID]
parser: Input 'LP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 224.
parser: ... then shift 'nm', go to state 454
parser: Shift 'LP', go to state 18
parser: Return. Stack=[ecmd createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP]
parser: Input 'ID' in state 18
parser: Shift 'ID', go to state 419
parser: Return. Stack=[ecmd createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP ID]
parser: Input 'COLLATE' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 18.
parser: ... then shift 'expr', go to state 13
parser: Shift 'COLLATE', go to state 418
parser: Return. Stack=[ecmd createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP expr COLLATE]
parser: Input 'ID' in state 418
parser: Shift 'ID', pending reduce 175
parser: Return. Stack=[ecmd createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP expr COLLATE ID]
parser: Input 'RP' with pending reduce 175
parser: Reduce 175 [expr ::= expr COLLATE ID|STRING], go to state 18.
parser: ... then shift 'expr', go to state 13
parser: Reduce 134 [sortorder ::=].
parser: ... then shift 'sortorder', go to state 353
parser: Reduce 137 [nulls ::=].
parser: ... then shift 'nulls', pending reduce 131
parser: Reduce 131 [sortlist ::= expr sortorder nulls], go to state 18.
parser: ... then shift 'sortlist', go to state 402
parser: Shift 'RP', go to state 313
parser: Return. Stack=[ecmd createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP]
parser: Input 'SEMI' in state 313
parser: Reduce 147 [where_opt ::=].
parser: ... then shift 'where_opt', pending reduce 223
parser: Reduce 223 [cmd ::= createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP where_opt], go to state 1.
parser: [[[INSERT INTO 'main'.sqlite_master VALUES('index','i2','a',#1,'CREATE INDEX i2 ON a(b COLLATE binary)');]]]
parser: Input 'INSERT' in state 0
parser: Reduce 380 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'INSERT', go to state 311
parser: Return. Stack=[with INSERT]
parser: Input 'INTO' in state 311
parser: Reduce 71 [orconf ::=].
parser: ... then shift 'orconf', pending reduce 160
parser: Reduce 160 [insert_cmd ::= INSERT orconf], go to state 219.
parser: ... then shift 'insert_cmd', go to state 430
parser: Shift 'INTO', go to state 166
parser: Return. Stack=[with insert_cmd INTO]
parser: Input 'STRING' in state 166
parser: Shift 'STRING', pending reduce 338
parser: Return. Stack=[with insert_cmd INTO STRING]
parser: Input 'DOT' with pending reduce 338
parser: Reduce 338 [nm ::= STRING], go to state 166.
parser: ... then shift 'nm', go to state 395
parser: Shift 'DOT', go to state 218
parser: Return. Stack=[with insert_cmd INTO nm DOT]
parser: Input 'ID' in state 218
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[with insert_cmd INTO nm DOT ID]
parser: Input 'VALUES' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 218.
parser: ... then shift 'nm', go to state 432
parser: Reduce 114 [xfullname ::= nm DOT nm], go to state 166.
parser: ... then shift 'xfullname', go to state 298
parser: Reduce 162 [idlist_opt ::=].
parser: ... then shift 'idlist_opt', go to state 35
parser: Shift 'VALUES', go to state 528
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES]
parser: Input 'LP' in state 528
parser: Shift 'LP', go to state 28
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP]
parser: Input 'STRING' in state 28
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP STRING]
parser: Input 'COMMA' in state 539
parser: Reduce 172 [term ::= STRING], go to state 28.
parser: ... then shift 'term', go to state 70
parser: Reduce 220 [nexprlist ::= expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 413
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'STRING' in state 107
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA STRING]
parser: Input 'COMMA' in state 539
parser: Reduce 172 [term ::= STRING], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 219 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 413
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'STRING' in state 107
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA STRING]
parser: Input 'COMMA' in state 539
parser: Reduce 172 [term ::= STRING], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 219 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 413
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'VARIABLE' in state 107
parser: Shift 'VARIABLE', pending reduce 174
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA VARIABLE]
parser: Input 'COMMA' with pending reduce 174
parser: Reduce 174 [expr ::= VARIABLE], go to state 107.
parser: ... then shift 'expr', go to state 71
parser: Reduce 219 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 413
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'STRING' in state 107
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA STRING]
parser: Input 'RP' in state 539
parser: Reduce 172 [term ::= STRING], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 219 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 413
parser: Shift 'RP', pending reduce 90
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist RP]
parser: Input 'SEMI' with pending reduce 90
parser: Reduce 90 [values ::= VALUES LP nexprlist RP], go to state 35.
parser: ... then shift 'values', go to state 534
parser: Reduce 354 [oneselect ::= values], go to state 35.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 83 [select ::= selectnowith], go to state 35.
parser: ... then shift 'select', go to state 297
parser: Reduce 156 [upsert ::=].
parser: ... then shift 'upsert', pending reduce 154
parser: Reduce 154 [cmd ::= with insert_cmd INTO xfullname idlist_opt select upsert], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Input '$' with pending reduce 327
parser: Reduce 327 [ecmd ::= cmdx SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 323 [input ::= cmdlist], go to state 0.
parser: ... then shift 'input', pending reduce -2
parser: Accept!
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[ecmd cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping ecmd
parser: [[[SELECT*FROM"main".sqlite_master WHERE name='i2' AND type='index' ORDER BY rowid]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'STAR' in state 288
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 95 [sclp ::=].
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STAR', pending reduce 97
parser: Return. Stack=[SELECT distinct sclp scanpt STAR]
parser: Input 'FROM' with pending reduce 97
parser: Reduce 97 [selcollist ::= sclp scanpt STAR], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 104 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'DOT' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 350
parser: Shift 'DOT', go to state 245
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID' in state 245
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'WHERE' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 245.
parser: ... then shift 'nm', pending reduce 110
parser: Reduce 110 [dbnm ::= DOT nm], go to state 350.
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 123 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 349
parser: Reduce 122 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 348
parser: Reduce 127 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 105
parser: Reduce 105 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 102 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 363
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[SELECT distinct selcollist from WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 419
parser: Return. Stack=[SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr EQ STRING]
parser: Input 'AND' in state 539
parser: Reduce 172 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 186 [expr ::= expr EQ|NE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'AND', go to state 120
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID' in state 120
parser: Shift 'ID', go to state 419
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'EQ' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr EQ]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr EQ STRING]
parser: Input 'ORDER' in state 539
parser: Reduce 172 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 186 [expr ::= expr EQ|NE expr], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Reduce 183 [expr ::= expr AND expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 148 [where_opt ::= WHERE expr], go to state 363.
parser: ... then shift 'where_opt', go to state 362
parser: Reduce 138 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 361
parser: Reduce 140 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 517
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 517
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 419
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 134 [sortorder ::=].
parser: ... then shift 'sortorder', go to state 353
parser: Reduce 137 [nulls ::=].
parser: ... then shift 'nulls', pending reduce 131
parser: Reduce 131 [sortlist ::= expr sortorder nulls], go to state 26.
parser: ... then shift 'sortlist', go to state 516
parser: Reduce 129 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 360
parser: Reduce 142 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 88
parser: Reduce 88 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 83 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 80
parser: Reduce 80 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[CREATE INDEX i2 ON a(b COLLATE binary)]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'INDEX' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 225 [uniqueflag ::=].
parser: ... then shift 'uniqueflag', go to state 456
parser: Shift 'INDEX', go to state 315
parser: Return. Stack=[createkw uniqueflag INDEX]
parser: Input 'ID' in state 315
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 225
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists ID]
parser: Input 'ON' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 225.
parser: ... then shift 'nm', go to state 314
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 455
parser: Shift 'ON', go to state 224
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON]
parser: Input 'ID' in state 224
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON ID]
parser: Input 'LP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 224.
parser: ... then shift 'nm', go to state 454
parser: Shift 'LP', go to state 18
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP]
parser: Input 'ID' in state 18
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP ID]
parser: Input 'COLLATE' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 18.
parser: ... then shift 'expr', go to state 13
parser: Shift 'COLLATE', go to state 418
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP expr COLLATE]
parser: Input 'ID' in state 418
parser: Shift 'ID', pending reduce 175
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP expr COLLATE ID]
parser: Input 'RP' with pending reduce 175
parser: Reduce 175 [expr ::= expr COLLATE ID|STRING], go to state 18.
parser: ... then shift 'expr', go to state 13
parser: Reduce 134 [sortorder ::=].
parser: ... then shift 'sortorder', go to state 353
parser: Reduce 137 [nulls ::=].
parser: ... then shift 'nulls', pending reduce 131
parser: Reduce 131 [sortlist ::= expr sortorder nulls], go to state 18.
parser: ... then shift 'sortlist', go to state 402
parser: Shift 'RP', go to state 313
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP]
parser: Input 'SEMI' in state 313
parser: Reduce 147 [where_opt ::=].
parser: ... then shift 'where_opt', pending reduce 223
parser: Reduce 223 [cmd ::= createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP where_opt], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[;PRAGMA vdbe_trace=on;;
;CREATE VIEW t2 AS 
  SELECT sum(b) FILTER( WHERE b>9 ),
         sum(b) FILTER( WHERE b>8 ),
         sum(b) FILTER( WHERE b>7 ),
         sum(b) FILTER( WHERE b>6 ),
         sum(b) FILTER( WHERE b>5 ),
         sum(b) FILTER( WHERE b>4 ),
         sum(b) FILTER( WHERE b>3 ),
         sum(b) FILTER( WHERE b>2 ),
         sum(b) FILTER( WHERE b>1 ),
         sum(b) FILTER( WHERE b>0 )
  FROM a;;
;VACUUM;;
;SELECT * FROM a ORDER BY b, b;;
;SELECT * FROM a ORDER BY b DESC, b DESC;CREATE INDEX t3 ON a(b)
;SELECT*FROM"temp".sqlite_temp_master ORDER BY rowid
;SELECT x.b || '/' || y.b FROM a x, a y ORDER BY x.b, x.b DESC
  
;SELECT x.b || '/' || y.b FROM a x, a y ORDER BY x.b, x.b||x.b
  
;SELECT x.b || '/' || y.b FROM a x, a y ORDER BY x.b, x.b, y.b||y.b
  
;SELECT x.b || '/' || y.b FROM a x, a y ORDER BY x.b, y.b||y.b DESC
  
;SELECT x.b || '/' || y.b FROM a x, a y ORDER BY x.b, x.b||y.b
  
;SELECT*FROM"temp".sqlite_temp_master ORDER BY rowid
;;
;CREATE TABLE x(y INTEGER PRIMARY KEY, t2i1);ALTER TABLE x ADD t1i1
    
;;
;SELECT x.RowID id FROM a, x WHERE a.b = x.RowID AND id = 2;SELECT*FROM"temp".sqlite_temp_master ORDER BY rowid
;ALTER TABLE x ADD abc
    
;CREATE INDEX c ON a(b)
;CREATE INDEX v1 ON a(b)
;ALTER TABLE ex ADD v2
    
;CREATE TABLE tr1(t1a, t1b);;SELECT y, v2 FROM x, ex WHERE y>v2;;
;SELECT DISTINCT b FROM a LEFT JOIN ex ON b=v2 ORDER BY +v2;CREATE INDEX x1 ON a(b)
;CREATE INDEX z ON a(b)
;CREATE INDEX example ON ex(v2)
;;SELECT count(*) FROM sqlite_master WHERE tbl_name = 'e' AND type = 'index';;
;CREATE TABLE example_idx_00000042(id PRIMARY KEY, UNIQUE(id) );;BEGIN;;CREATE UNIQUE INDEX IF NOT EXISTS a_id ON a(b==0);;SELECT * FROM ex;]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 326
parser: Return. Stack=[SEMI]
parser: Input 'PRAGMA' with pending reduce 326
parser: Reduce 326 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Shift 'PRAGMA', go to state 215
parser: Return. Stack=[ecmd PRAGMA]
parser: Input 'ID' in state 215
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[ecmd PRAGMA ID]
parser: Input 'EQ' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 215.
parser: ... then shift 'nm', go to state 295
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 394
parser: Shift 'EQ', go to state 31
parser: Return. Stack=[ecmd PRAGMA nm dbnm EQ]
parser: Input 'ON' in state 31
parser: Shift 'ON', pending reduce 362
parser: Return. Stack=[ecmd PRAGMA nm dbnm EQ ON]
parser: Input 'SEMI' with pending reduce 362
parser: Reduce 362 [nmnum ::= ON], go to state 31.
parser: ... then shift 'nmnum', pending reduce 238
parser: Reduce 238 [cmd ::= PRAGMA nm dbnm EQ nmnum], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[ecmd cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping ecmd
SQL: [;PRAGMA vdbe_trace=on;]
VDBE Trace:
   0 Init             0    1    0               00 Start at 1
   1 Expire           0    0    0               00 
   2 Halt             0    0    0               00 
parser: [[[;
;CREATE VIEW t2 AS 
  SELECT sum(b) FILTER( WHERE b>9 ),
         sum(b) FILTER( WHERE b>8 ),
         sum(b) FILTER( WHERE b>7 ),
         sum(b) FILTER( WHERE b>6 ),
         sum(b) FILTER( WHERE b>5 ),
         sum(b) FILTER( WHERE b>4 ),
         sum(b) FILTER( WHERE b>3 ),
         sum(b) FILTER( WHERE b>2 ),
         sum(b) FILTER( WHERE b>1 ),
         sum(b) FILTER( WHERE b>0 )
  FROM a;;
;VACUUM;;
;SELECT * FROM a ORDER BY b, b;;
;SELECT * FROM a ORDER BY b DESC, b DESC;CREATE INDEX t3 ON a(b)
;SELECT*FROM"temp".sqlite_temp_master ORDER BY rowid
;SELECT x.b || '/' || y.b FROM a x, a y ORDER BY x.b, x.b DESC
  
;SELECT x.b || '/' || y.b FROM a x, a y ORDER BY x.b, x.b||x.b
  
;SELECT x.b || '/' || y.b FROM a x, a y ORDER BY x.b, x.b, y.b||y.b
  
;SELECT x.b || '/' || y.b FROM a x, a y ORDER BY x.b, y.b||y.b DESC
  
;SELECT x.b || '/' || y.b FROM a x, a y ORDER BY x.b, x.b||y.b
  
;SELECT*FROM"temp".sqlite_temp_master ORDER BY rowid
;;
;CREATE TABLE x(y INTEGER PRIMARY KEY, t2i1);ALTER TABLE x ADD t1i1
    
;;
;SELECT x.RowID id FROM a, x WHERE a.b = x.RowID AND id = 2;SELECT*FROM"temp".sqlite_temp_master ORDER BY rowid
;ALTER TABLE x ADD abc
    
;CREATE INDEX c ON a(b)
;CREATE INDEX v1 ON a(b)
;ALTER TABLE ex ADD v2
    
;CREATE TABLE tr1(t1a, t1b);;SELECT y, v2 FROM x, ex WHERE y>v2;;
;SELECT DISTINCT b FROM a LEFT JOIN ex ON b=v2 ORDER BY +v2;CREATE INDEX x1 ON a(b)
;CREATE INDEX z ON a(b)
;CREATE INDEX example ON ex(v2)
;;SELECT count(*) FROM sqlite_master WHERE tbl_name = 'e' AND type = 'index';;
;CREATE TABLE example_idx_00000042(id PRIMARY KEY, UNIQUE(id) );;BEGIN;;CREATE UNIQUE INDEX IF NOT EXISTS a_id ON a(b==0);;SELECT * FROM ex;]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 326
parser: Return. Stack=[SEMI]
parser: Input 'SEMI' with pending reduce 326
parser: Reduce 326 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Shift 'SEMI', pending reduce 326
parser: Return. Stack=[ecmd SEMI]
parser: Input 'CREATE' with pending reduce 326
parser: Reduce 326 [ecmd ::= SEMI], go to state 1.
parser: ... then shift 'ecmd', pending reduce 324
parser: Reduce 324 [cmdlist ::= cmdlist ecmd], go to state 0.
parser: ... then shift 'cmdlist', go to state 1
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[cmdlist CREATE]
parser: Input 'VIEW' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 1.
parser: ... then shift 'createkw', go to state 134
parser: FALLBACK VIEW => ID
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 390
parser: Shift 'VIEW', go to state 322
parser: Return. Stack=[cmdlist createkw temp VIEW]
parser: Input 'ID' in state 322
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 228
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists ID]
parser: Input 'AS' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 228.
parser: ... then shift 'nm', go to state 321
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 320
parser: Reduce 226 [eidlist_opt ::=].
parser: ... then shift 'eidlist_opt', go to state 464
parser: Shift 'AS', go to state 37
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS]
parser: Input 'SELECT' in state 37
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT]
parser: Input 'ID' in state 288
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 95 [sclp ::=].
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 419
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 419
parser: Shift 'LP', go to state 266
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 419
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 220 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 519
parser: Reduce 359 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 484
parser: Shift 'RP', go to state 146
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'FILTER' in state 146
parser: Shift 'FILTER', go to state 482
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER]
parser: Input 'LP' in state 482
parser: Shift 'LP', go to state 481
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP]
parser: Input 'WHERE' in state 481
parser: Shift 'WHERE', go to state 90
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE]
parser: Input 'ID' in state 90
parser: Shift 'ID', go to state 419
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE ID]
parser: Input 'GT' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'GT', go to state 118
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT]
parser: Input 'INTEGER' in state 118
parser: Shift 'INTEGER', pending reduce 173
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT INTEGER]
parser: Input 'RP' with pending reduce 173
parser: Reduce 173 [term ::= INTEGER], go to state 118.
parser: ... then shift 'term', go to state 130
parser: Reduce 185 [expr ::= expr LT|GT|GE|LE expr], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'RP', pending reduce 322
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr RP]
parser: Input 'COMMA' with pending reduce 322
parser: Reduce 322 [filter_clause ::= FILTER LP WHERE expr RP], go to state 146.
parser: ... then shift 'filter_clause', go to state 337
parser: Reduce 319 [filter_over ::= filter_clause], go to state 146.
parser: ... then shift 'filter_over', pending reduce 179
parser: Reduce 179 [expr ::= ID|INDEXED LP distinct exprlist RP filter_over], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 355
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 355
parser: Reduce 355 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 419
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 419
parser: Shift 'LP', go to state 266
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 419
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 220 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 519
parser: Reduce 359 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 484
parser: Shift 'RP', go to state 146
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'FILTER' in state 146
parser: Shift 'FILTER', go to state 482
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER]
parser: Input 'LP' in state 482
parser: Shift 'LP', go to state 481
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP]
parser: Input 'WHERE' in state 481
parser: Shift 'WHERE', go to state 90
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE]
parser: Input 'ID' in state 90
parser: Shift 'ID', go to state 419
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE ID]
parser: Input 'GT' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'GT', go to state 118
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT]
parser: Input 'INTEGER' in state 118
parser: Shift 'INTEGER', pending reduce 173
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT INTEGER]
parser: Input 'RP' with pending reduce 173
parser: Reduce 173 [term ::= INTEGER], go to state 118.
parser: ... then shift 'term', go to state 130
parser: Reduce 185 [expr ::= expr LT|GT|GE|LE expr], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'RP', pending reduce 322
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr RP]
parser: Input 'COMMA' with pending reduce 322
parser: Reduce 322 [filter_clause ::= FILTER LP WHERE expr RP], go to state 146.
parser: ... then shift 'filter_clause', go to state 337
parser: Reduce 319 [filter_over ::= filter_clause], go to state 146.
parser: ... then shift 'filter_over', pending reduce 179
parser: Reduce 179 [expr ::= ID|INDEXED LP distinct exprlist RP filter_over], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 355
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 355
parser: Reduce 355 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 419
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 419
parser: Shift 'LP', go to state 266
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 419
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 220 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 519
parser: Reduce 359 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 484
parser: Shift 'RP', go to state 146
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'FILTER' in state 146
parser: Shift 'FILTER', go to state 482
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER]
parser: Input 'LP' in state 482
parser: Shift 'LP', go to state 481
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP]
parser: Input 'WHERE' in state 481
parser: Shift 'WHERE', go to state 90
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE]
parser: Input 'ID' in state 90
parser: Shift 'ID', go to state 419
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE ID]
parser: Input 'GT' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'GT', go to state 118
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT]
parser: Input 'INTEGER' in state 118
parser: Shift 'INTEGER', pending reduce 173
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT INTEGER]
parser: Input 'RP' with pending reduce 173
parser: Reduce 173 [term ::= INTEGER], go to state 118.
parser: ... then shift 'term', go to state 130
parser: Reduce 185 [expr ::= expr LT|GT|GE|LE expr], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'RP', pending reduce 322
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr RP]
parser: Input 'COMMA' with pending reduce 322
parser: Reduce 322 [filter_clause ::= FILTER LP WHERE expr RP], go to state 146.
parser: ... then shift 'filter_clause', go to state 337
parser: Reduce 319 [filter_over ::= filter_clause], go to state 146.
parser: ... then shift 'filter_over', pending reduce 179
parser: Reduce 179 [expr ::= ID|INDEXED LP distinct exprlist RP filter_over], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 355
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 355
parser: Reduce 355 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 419
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 419
parser: Shift 'LP', go to state 266
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 419
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 220 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 519
parser: Reduce 359 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 484
parser: Shift 'RP', go to state 146
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'FILTER' in state 146
parser: Shift 'FILTER', go to state 482
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER]
parser: Input 'LP' in state 482
parser: Shift 'LP', go to state 481
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP]
parser: Input 'WHERE' in state 481
parser: Shift 'WHERE', go to state 90
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE]
parser: Input 'ID' in state 90
parser: Shift 'ID', go to state 419
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE ID]
parser: Input 'GT' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'GT', go to state 118
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT]
parser: Input 'INTEGER' in state 118
parser: Shift 'INTEGER', pending reduce 173
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT INTEGER]
parser: Input 'RP' with pending reduce 173
parser: Reduce 173 [term ::= INTEGER], go to state 118.
parser: ... then shift 'term', go to state 130
parser: Reduce 185 [expr ::= expr LT|GT|GE|LE expr], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'RP', pending reduce 322
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr RP]
parser: Input 'COMMA' with pending reduce 322
parser: Reduce 322 [filter_clause ::= FILTER LP WHERE expr RP], go to state 146.
parser: ... then shift 'filter_clause', go to state 337
parser: Reduce 319 [filter_over ::= filter_clause], go to state 146.
parser: ... then shift 'filter_over', pending reduce 179
parser: Reduce 179 [expr ::= ID|INDEXED LP distinct exprlist RP filter_over], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 355
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 355
parser: Reduce 355 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 419
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 419
parser: Shift 'LP', go to state 266
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 419
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 220 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 519
parser: Reduce 359 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 484
parser: Shift 'RP', go to state 146
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'FILTER' in state 146
parser: Shift 'FILTER', go to state 482
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER]
parser: Input 'LP' in state 482
parser: Shift 'LP', go to state 481
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP]
parser: Input 'WHERE' in state 481
parser: Shift 'WHERE', go to state 90
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE]
parser: Input 'ID' in state 90
parser: Shift 'ID', go to state 419
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE ID]
parser: Input 'GT' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'GT', go to state 118
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT]
parser: Input 'INTEGER' in state 118
parser: Shift 'INTEGER', pending reduce 173
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT INTEGER]
parser: Input 'RP' with pending reduce 173
parser: Reduce 173 [term ::= INTEGER], go to state 118.
parser: ... then shift 'term', go to state 130
parser: Reduce 185 [expr ::= expr LT|GT|GE|LE expr], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'RP', pending reduce 322
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr RP]
parser: Input 'COMMA' with pending reduce 322
parser: Reduce 322 [filter_clause ::= FILTER LP WHERE expr RP], go to state 146.
parser: ... then shift 'filter_clause', go to state 337
parser: Reduce 319 [filter_over ::= filter_clause], go to state 146.
parser: ... then shift 'filter_over', pending reduce 179
parser: Reduce 179 [expr ::= ID|INDEXED LP distinct exprlist RP filter_over], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 355
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 355
parser: Reduce 355 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 419
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 419
parser: Shift 'LP', go to state 266
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 419
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 220 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 519
parser: Reduce 359 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 484
parser: Shift 'RP', go to state 146
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'FILTER' in state 146
parser: Shift 'FILTER', go to state 482
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER]
parser: Input 'LP' in state 482
parser: Shift 'LP', go to state 481
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP]
parser: Input 'WHERE' in state 481
parser: Shift 'WHERE', go to state 90
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE]
parser: Input 'ID' in state 90
parser: Shift 'ID', go to state 419
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE ID]
parser: Input 'GT' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'GT', go to state 118
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT]
parser: Input 'INTEGER' in state 118
parser: Shift 'INTEGER', pending reduce 173
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT INTEGER]
parser: Input 'RP' with pending reduce 173
parser: Reduce 173 [term ::= INTEGER], go to state 118.
parser: ... then shift 'term', go to state 130
parser: Reduce 185 [expr ::= expr LT|GT|GE|LE expr], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'RP', pending reduce 322
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr RP]
parser: Input 'COMMA' with pending reduce 322
parser: Reduce 322 [filter_clause ::= FILTER LP WHERE expr RP], go to state 146.
parser: ... then shift 'filter_clause', go to state 337
parser: Reduce 319 [filter_over ::= filter_clause], go to state 146.
parser: ... then shift 'filter_over', pending reduce 179
parser: Reduce 179 [expr ::= ID|INDEXED LP distinct exprlist RP filter_over], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 355
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 355
parser: Reduce 355 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 419
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 419
parser: Shift 'LP', go to state 266
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 419
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 220 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 519
parser: Reduce 359 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 484
parser: Shift 'RP', go to state 146
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'FILTER' in state 146
parser: Shift 'FILTER', go to state 482
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER]
parser: Input 'LP' in state 482
parser: Shift 'LP', go to state 481
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP]
parser: Input 'WHERE' in state 481
parser: Shift 'WHERE', go to state 90
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE]
parser: Input 'ID' in state 90
parser: Shift 'ID', go to state 419
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE ID]
parser: Input 'GT' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'GT', go to state 118
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT]
parser: Input 'INTEGER' in state 118
parser: Shift 'INTEGER', pending reduce 173
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT INTEGER]
parser: Input 'RP' with pending reduce 173
parser: Reduce 173 [term ::= INTEGER], go to state 118.
parser: ... then shift 'term', go to state 130
parser: Reduce 185 [expr ::= expr LT|GT|GE|LE expr], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'RP', pending reduce 322
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr RP]
parser: Input 'COMMA' with pending reduce 322
parser: Reduce 322 [filter_clause ::= FILTER LP WHERE expr RP], go to state 146.
parser: ... then shift 'filter_clause', go to state 337
parser: Reduce 319 [filter_over ::= filter_clause], go to state 146.
parser: ... then shift 'filter_over', pending reduce 179
parser: Reduce 179 [expr ::= ID|INDEXED LP distinct exprlist RP filter_over], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 355
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 355
parser: Reduce 355 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 419
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 419
parser: Shift 'LP', go to state 266
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 419
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 220 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 519
parser: Reduce 359 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 484
parser: Shift 'RP', go to state 146
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'FILTER' in state 146
parser: Shift 'FILTER', go to state 482
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER]
parser: Input 'LP' in state 482
parser: Shift 'LP', go to state 481
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP]
parser: Input 'WHERE' in state 481
parser: Shift 'WHERE', go to state 90
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE]
parser: Input 'ID' in state 90
parser: Shift 'ID', go to state 419
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE ID]
parser: Input 'GT' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'GT', go to state 118
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT]
parser: Input 'INTEGER' in state 118
parser: Shift 'INTEGER', pending reduce 173
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT INTEGER]
parser: Input 'RP' with pending reduce 173
parser: Reduce 173 [term ::= INTEGER], go to state 118.
parser: ... then shift 'term', go to state 130
parser: Reduce 185 [expr ::= expr LT|GT|GE|LE expr], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'RP', pending reduce 322
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr RP]
parser: Input 'COMMA' with pending reduce 322
parser: Reduce 322 [filter_clause ::= FILTER LP WHERE expr RP], go to state 146.
parser: ... then shift 'filter_clause', go to state 337
parser: Reduce 319 [filter_over ::= filter_clause], go to state 146.
parser: ... then shift 'filter_over', pending reduce 179
parser: Reduce 179 [expr ::= ID|INDEXED LP distinct exprlist RP filter_over], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 355
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 355
parser: Reduce 355 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 419
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 419
parser: Shift 'LP', go to state 266
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 419
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 220 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 519
parser: Reduce 359 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 484
parser: Shift 'RP', go to state 146
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'FILTER' in state 146
parser: Shift 'FILTER', go to state 482
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER]
parser: Input 'LP' in state 482
parser: Shift 'LP', go to state 481
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP]
parser: Input 'WHERE' in state 481
parser: Shift 'WHERE', go to state 90
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE]
parser: Input 'ID' in state 90
parser: Shift 'ID', go to state 419
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE ID]
parser: Input 'GT' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'GT', go to state 118
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT]
parser: Input 'INTEGER' in state 118
parser: Shift 'INTEGER', pending reduce 173
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT INTEGER]
parser: Input 'RP' with pending reduce 173
parser: Reduce 173 [term ::= INTEGER], go to state 118.
parser: ... then shift 'term', go to state 130
parser: Reduce 185 [expr ::= expr LT|GT|GE|LE expr], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'RP', pending reduce 322
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr RP]
parser: Input 'COMMA' with pending reduce 322
parser: Reduce 322 [filter_clause ::= FILTER LP WHERE expr RP], go to state 146.
parser: ... then shift 'filter_clause', go to state 337
parser: Reduce 319 [filter_over ::= filter_clause], go to state 146.
parser: ... then shift 'filter_over', pending reduce 179
parser: Reduce 179 [expr ::= ID|INDEXED LP distinct exprlist RP filter_over], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 355
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 355
parser: Reduce 355 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 419
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 419
parser: Shift 'LP', go to state 266
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 419
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 220 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 519
parser: Reduce 359 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 484
parser: Shift 'RP', go to state 146
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'FILTER' in state 146
parser: Shift 'FILTER', go to state 482
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER]
parser: Input 'LP' in state 482
parser: Shift 'LP', go to state 481
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP]
parser: Input 'WHERE' in state 481
parser: Shift 'WHERE', go to state 90
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE]
parser: Input 'ID' in state 90
parser: Shift 'ID', go to state 419
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE ID]
parser: Input 'GT' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'GT', go to state 118
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT]
parser: Input 'INTEGER' in state 118
parser: Shift 'INTEGER', pending reduce 173
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT INTEGER]
parser: Input 'RP' with pending reduce 173
parser: Reduce 173 [term ::= INTEGER], go to state 118.
parser: ... then shift 'term', go to state 130
parser: Reduce 185 [expr ::= expr LT|GT|GE|LE expr], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'RP', pending reduce 322
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr RP]
parser: Input 'FROM' with pending reduce 322
parser: Reduce 322 [filter_clause ::= FILTER LP WHERE expr RP], go to state 146.
parser: ... then shift 'filter_clause', go to state 337
parser: Reduce 319 [filter_over ::= filter_clause], go to state 146.
parser: ... then shift 'filter_over', pending reduce 179
parser: Reduce 179 [expr ::= ID|INDEXED LP distinct exprlist RP filter_over], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 104 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[cmdlist createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'SEMI' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 350
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 123 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 349
parser: Reduce 122 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 348
parser: Reduce 127 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 105
parser: Reduce 105 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 102 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 363
parser: Reduce 147 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 362
parser: Reduce 138 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 361
parser: Reduce 140 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 128 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 360
parser: Reduce 142 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 88
parser: Reduce 88 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 37.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 83 [select ::= selectnowith], go to state 37.
parser: ... then shift 'select', pending reduce 78
parser: Reduce 78 [cmd ::= createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS select], go to state 1.
parser: [[[UPDATE 'main'.sqlite_master SET type='view', name='t2', tbl_name='t2', rootpage=#2, sql='CREATE VIEW t2 AS 
  SELECT sum(b) FILTER( WHERE b>9 ),
         sum(b) FILTER( WHERE b>8 ),
         sum(b) FILTER( WHERE b>7 ),
         sum(b) FILTER( WHERE b>6 ),
         sum(b) FILTER( WHERE b>5 ),
         sum(b) FILTER( WHERE b>4 ),
         sum(b) FILTER( WHERE b>3 ),
         sum(b) FILTER( WHERE b>2 ),
         sum(b) FILTER( WHERE b>1 ),
         sum(b) FILTER( WHERE b>0 )
  FROM a' WHERE rowid=#1]]]
parser: Input 'UPDATE' in state 0
parser: Reduce 380 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'UPDATE', go to state 299
parser: Return. Stack=[with UPDATE]
parser: Input 'STRING' in state 299
parser: Reduce 71 [orconf ::=].
parser: ... then shift 'orconf', go to state 167
parser: Shift 'STRING', pending reduce 338
parser: Return. Stack=[with UPDATE orconf STRING]
parser: Input 'DOT' with pending reduce 338
parser: Reduce 338 [nm ::= STRING], go to state 167.
parser: ... then shift 'nm', go to state 395
parser: Shift 'DOT', go to state 218
parser: Return. Stack=[with UPDATE orconf nm DOT]
parser: Input 'ID' in state 218
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[with UPDATE orconf nm DOT ID]
parser: Input 'SET' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 218.
parser: ... then shift 'nm', go to state 432
parser: Reduce 114 [xfullname ::= nm DOT nm], go to state 167.
parser: ... then shift 'xfullname', go to state 271
parser: Reduce 123 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 431
parser: Shift 'SET', go to state 155
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET]
parser: Input 'ID' in state 155
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET ID]
parser: Input 'EQ' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 155.
parser: ... then shift 'nm', go to state 445
parser: Shift 'EQ', go to state 84
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ]
parser: Input 'STRING' in state 84
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ STRING]
parser: Input 'COMMA' in state 539
parser: Reduce 172 [term ::= STRING], go to state 84.
parser: ... then shift 'term', go to state 58
parser: Reduce 152 [setlist ::= nm EQ expr], go to state 155.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 447
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING' in state 86
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'COMMA' in state 539
parser: Reduce 172 [term ::= STRING], go to state 86.
parser: ... then shift 'term', go to state 60
parser: Reduce 150 [setlist ::= setlist COMMA nm EQ expr], go to state 155.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 447
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING' in state 86
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'COMMA' in state 539
parser: Reduce 172 [term ::= STRING], go to state 86.
parser: ... then shift 'term', go to state 60
parser: Reduce 150 [setlist ::= setlist COMMA nm EQ expr], go to state 155.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 447
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'VARIABLE' in state 86
parser: Shift 'VARIABLE', pending reduce 174
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ VARIABLE]
parser: Input 'COMMA' with pending reduce 174
parser: Reduce 174 [expr ::= VARIABLE], go to state 86.
parser: ... then shift 'expr', go to state 60
parser: Reduce 150 [setlist ::= setlist COMMA nm EQ expr], go to state 155.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 447
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING' in state 86
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'WHERE' in state 539
parser: Reduce 172 [term ::= STRING], go to state 86.
parser: ... then shift 'term', go to state 60
parser: Reduce 150 [setlist ::= setlist COMMA nm EQ expr], go to state 155.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 419
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE ID]
parser: Input 'EQ' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr EQ]
parser: Input 'VARIABLE' in state 117
parser: Shift 'VARIABLE', pending reduce 174
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr EQ VARIABLE]
parser: Input 'SEMI' with pending reduce 174
parser: Reduce 174 [expr ::= VARIABLE], go to state 117.
parser: ... then shift 'expr', go to state 129
parser: Reduce 186 [expr ::= expr EQ|NE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 148 [where_opt ::= WHERE expr], go to state 270.
parser: ... then shift 'where_opt', pending reduce 149
parser: Reduce 149 [cmd ::= with UPDATE orconf xfullname indexed_opt SET setlist where_opt], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Input '$' with pending reduce 327
parser: Reduce 327 [ecmd ::= cmdx SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 323 [input ::= cmdlist], go to state 0.
parser: ... then shift 'input', pending reduce -2
parser: Accept!
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdlist cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping cmdlist
SQL: [;
;CREATE VIEW t2 AS 
  SELECT sum(b) FILTER( WHERE b>9 ),
         sum(b) FILTER( WHERE b>8 ),
         sum(b) FILTER( WHERE b>7 ),
         sum(b) FILTER( WHERE b>6 ),
         sum(b) FILTER( WHERE b>5 ),
         sum(b) FILTER( WHERE b>4 ),
         sum(b) FILTER( WHERE b>3 ),
         sum(b) FILTER( WHERE b>2 ),
         sum(b) FILTER( WHERE b>1 ),
         sum(b) FILTER( WHERE b>0 )
  FROM a;]
VDBE Trace:
   0 Init             0   28    0               00 Start at 28
  28 Transaction      0    1    4 0             01 usesStmtJournal=0
  29 Goto             0    1    0               00 
   1 ReadCookie       0    3    2               00 
REG[3] =  i:4
   2 If               3    5    0               00 
REG[3] =  i:4
   5 Integer          0    2    0               00 r[2]=0
REG[2] =  i:0
   6 OpenWrite        0    1    0 5             00 root=1 iDb=0
   7 NewRowid         0    1    0               00 r[1]=rowid
REG[1] =  i:5
   8 Blob             6    3    0              00 r[3]= (len=6)
REG[3] =  tx6[060000000000|......]
   9 Insert           0    3    1               08 intkey=r[1] data=r[3]
REG[3] =  tx6[060000000000|......]
REG[1] =  i:5
  10 Close            0    0    0               00 
  11 Close            0    0    0               00 
  12 Null             0    4    5               00 r[4..5]=NULL
REG[4] =  NULL
  13 OpenWrite        1    1    0 5             00 root=1 iDb=0; sqlite_master
  14 Explain         14    0    0 SEARCH TABLE sqlite_master USING INTEGER PRIMARY KEY (rowid=?) 00 
  15 SeekRowid        1   17    1               00 intkey=r[1]
REG[1] =  i:5
  16 Rowid            1    5    0               00 r[5]=rowid
REG[5] =  i:5
  17 IsNull           5   25    0               00 if r[5]==NULL goto 25
REG[5] =  i:5
  18 String8          0    6    0 view          00 r[6]='view'
REG[6] =   t4[view](8)
  19 String8          0    7    0 t2            00 r[7]='t2'
REG[7] =   t2[t2](8)
  20 String8          0    8    0 t2            00 r[8]='t2'
REG[8] =   t2[t2](8)
  21 Copy             2    9    0               00 r[9]=r[2]
REG[9] =  i:0
  22 String8          0   10    0 CREATE VIEW t2 AS 
  SELECT sum(b) FILTER( WHERE b>9 ),
         sum(b) FILTER( WHERE b>8 ),
         sum(b) FILTER( WHERE b>7 ),
         sum(b) FILTER( WHERE b>6 ),
         sum(b) FILTER( WHERE b>5 ),
         sum(b) FILTER( WHERE b>4 ),
         sum(b) FILTER( WHERE b>3 ),
         sum(b) FILTER( WHERE b>2 ),
         sum(b) FILTER( WHERE b>1 ),
         sum(b) FILTER( WHERE b>0 )
  FROM a 00 r[10]='CREATE VIEW t2 AS 
  SELECT sum(b) FILTER( WHERE b>9 ),
         sum(b) FILTER( WHERE b>8 ),
REG[10] =   t396[CREATE VIEW t2 AS .  SELE](8)
  23 MakeRecord       6    5    4 BBBDB         00 r[4]=mkrec(r[6..10])
REG[6] =   t4[view](8)
REG[7] =   t2[t2](8)
REG[8] =   t2[t2](8)
REG[9] =  i:0
REG[10] =   t396[CREATE VIEW t2 AS .  SELE](8)
REG[4] =  sx411[07151111088625766965777432743243524541544520564945|......%viewt2t2CREATE VIE]
  24 Insert           1    4    5               00 intkey=r[5] data=r[4]
REG[4] =  sx411[07151111088625766965777432743243524541544520564945|......%viewt2t2CREATE VIE]
REG[5] =  i:5
  25 SetCookie        0    1    5               00 
  26 ParseSchema      0    0    0 tbl_name='t2' AND type!='trigger' 00 
parser: [[[SELECT*FROM"main".sqlite_master WHERE tbl_name='t2' AND type!='trigger' ORDER BY rowid]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'STAR' in state 288
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 95 [sclp ::=].
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STAR', pending reduce 97
parser: Return. Stack=[SELECT distinct sclp scanpt STAR]
parser: Input 'FROM' with pending reduce 97
parser: Reduce 97 [selcollist ::= sclp scanpt STAR], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 104 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'DOT' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 350
parser: Shift 'DOT', go to state 245
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID' in state 245
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'WHERE' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 245.
parser: ... then shift 'nm', pending reduce 110
parser: Reduce 110 [dbnm ::= DOT nm], go to state 350.
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 123 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 349
parser: Reduce 122 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 348
parser: Reduce 127 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 105
parser: Reduce 105 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 102 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 363
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[SELECT distinct selcollist from WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 419
parser: Return. Stack=[SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr EQ STRING]
parser: Input 'AND' in state 539
parser: Reduce 172 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 186 [expr ::= expr EQ|NE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'AND', go to state 120
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID' in state 120
parser: Shift 'ID', go to state 419
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'NE' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Shift 'NE', go to state 117
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr NE]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr NE STRING]
parser: Input 'ORDER' in state 539
parser: Reduce 172 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 186 [expr ::= expr EQ|NE expr], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Reduce 183 [expr ::= expr AND expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 148 [where_opt ::= WHERE expr], go to state 363.
parser: ... then shift 'where_opt', go to state 362
parser: Reduce 138 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 361
parser: Reduce 140 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 517
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 517
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 419
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 134 [sortorder ::=].
parser: ... then shift 'sortorder', go to state 353
parser: Reduce 137 [nulls ::=].
parser: ... then shift 'nulls', pending reduce 131
parser: Reduce 131 [sortlist ::= expr sortorder nulls], go to state 26.
parser: ... then shift 'sortlist', go to state 516
parser: Reduce 129 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 360
parser: Reduce 142 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 88
parser: Reduce 88 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 83 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 80
parser: Reduce 80 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
VDBE Trace:
   0 Init             0   17    0               00 Start at 17
  17 Transaction      0    0    5 0             00 usesStmtJournal=0
  18 String8          0    2    0 t2            00 r[2]='t2'
REG[2] =   t2[t2](8)
  19 String8          0    3    0 trigger       00 r[3]='trigger'
REG[3] =   t7[trigger](8)
  20 Goto             0    1    0               00 
   1 Noop             1    7    0               00 
   2 OpenRead         0    1    0 5             00 root=1 iDb=0; sqlite_master
   3 Explain          3    0    0 SCAN TABLE sqlite_master 00 
   4 Rewind           0   16    0               00 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s2[t1](8)
   6 Ne               2   15    1 (BINARY)      52 if r[1]!=r[2] goto 15
REG[2] =   t2[t2](8)
REG[1] =   s2[t1](8)
  15 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s1[a](8)
   6 Ne               2   15    1 (BINARY)      52 if r[1]!=r[2] goto 15
REG[2] =   t2[t2](8)
REG[1] =   s1[a](8)
  15 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s2[ex](8)
   6 Ne               2   15    1 (BINARY)      52 if r[1]!=r[2] goto 15
REG[2] =   t2[t2](8)
REG[1] =   s2[ex](8)
  15 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s1[a](8)
   6 Ne               2   15    1 (BINARY)      52 if r[1]!=r[2] goto 15
REG[2] =   t2[t2](8)
REG[1] =   s1[a](8)
  15 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s2[t2](8)
   6 Ne               2   15    1 (BINARY)      52 if r[1]!=r[2] goto 15
REG[2] =   t2[t2](8)
REG[1] =   s2[t2](8)
   7 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s4[view](8)
   8 Eq               3   15    1 (BINARY)      52 if r[1]==r[3] goto 15
REG[3] =   t7[trigger](8)
REG[1] =   s4[view](8)
   9 Column           0    0    4               00 r[4]=sqlite_master.type
REG[4] =   s4[view](8)
  10 Column           0    1    5               00 r[5]=sqlite_master.name
REG[5] =   s2[t2](8)
  11 Column           0    2    6               00 r[6]=sqlite_master.tbl_name
REG[6] =   s2[t2](8)
  12 Column           0    3    7               00 r[7]=sqlite_master.rootpage
REG[7] =  i:0
  13 Column           0    4    8               00 r[8]=sqlite_master.sql
REG[8] =   s396[CREATE VIEW t2 AS .  SELE](8)
  14 ResultRow        4    5    0               00 output=r[4..8]
REG[4] =   s4[view](8)
REG[5] =   s2[t2](8)
REG[6] =   s2[t2](8)
REG[7] =  i:0
REG[8] =   s396[CREATE VIEW t2 AS .  SELE](8)
parser: [[[CREATE VIEW t2 AS 
  SELECT sum(b) FILTER( WHERE b>9 ),
         sum(b) FILTER( WHERE b>8 ),
         sum(b) FILTER( WHERE b>7 ),
         sum(b) FILTER( WHERE b>6 ),
         sum(b) FILTER( WHERE b>5 ),
         sum(b) FILTER( WHERE b>4 ),
         sum(b) FILTER( WHERE b>3 ),
         sum(b) FILTER( WHERE b>2 ),
         sum(b) FILTER( WHERE b>1 ),
         sum(b) FILTER( WHERE b>0 )
  FROM a]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'VIEW' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: FALLBACK VIEW => ID
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 390
parser: Shift 'VIEW', go to state 322
parser: Return. Stack=[createkw temp VIEW]
parser: Input 'ID' in state 322
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 228
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw temp VIEW ifnotexists ID]
parser: Input 'AS' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 228.
parser: ... then shift 'nm', go to state 321
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 320
parser: Reduce 226 [eidlist_opt ::=].
parser: ... then shift 'eidlist_opt', go to state 464
parser: Shift 'AS', go to state 37
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS]
parser: Input 'SELECT' in state 37
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT]
parser: Input 'ID' in state 288
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 95 [sclp ::=].
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 419
parser: Shift 'LP', go to state 266
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 220 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 519
parser: Reduce 359 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 484
parser: Shift 'RP', go to state 146
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'FILTER' in state 146
parser: Shift 'FILTER', go to state 482
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER]
parser: Input 'LP' in state 482
parser: Shift 'LP', go to state 481
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP]
parser: Input 'WHERE' in state 481
parser: Shift 'WHERE', go to state 90
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE]
parser: Input 'ID' in state 90
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE ID]
parser: Input 'GT' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'GT', go to state 118
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT]
parser: Input 'INTEGER' in state 118
parser: Shift 'INTEGER', pending reduce 173
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT INTEGER]
parser: Input 'RP' with pending reduce 173
parser: Reduce 173 [term ::= INTEGER], go to state 118.
parser: ... then shift 'term', go to state 130
parser: Reduce 185 [expr ::= expr LT|GT|GE|LE expr], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'RP', pending reduce 322
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr RP]
parser: Input 'COMMA' with pending reduce 322
parser: Reduce 322 [filter_clause ::= FILTER LP WHERE expr RP], go to state 146.
parser: ... then shift 'filter_clause', go to state 337
parser: Reduce 319 [filter_over ::= filter_clause], go to state 146.
parser: ... then shift 'filter_over', pending reduce 179
parser: Reduce 179 [expr ::= ID|INDEXED LP distinct exprlist RP filter_over], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 355
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 355
parser: Reduce 355 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 419
parser: Shift 'LP', go to state 266
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 220 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 519
parser: Reduce 359 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 484
parser: Shift 'RP', go to state 146
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'FILTER' in state 146
parser: Shift 'FILTER', go to state 482
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER]
parser: Input 'LP' in state 482
parser: Shift 'LP', go to state 481
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP]
parser: Input 'WHERE' in state 481
parser: Shift 'WHERE', go to state 90
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE]
parser: Input 'ID' in state 90
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE ID]
parser: Input 'GT' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'GT', go to state 118
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT]
parser: Input 'INTEGER' in state 118
parser: Shift 'INTEGER', pending reduce 173
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT INTEGER]
parser: Input 'RP' with pending reduce 173
parser: Reduce 173 [term ::= INTEGER], go to state 118.
parser: ... then shift 'term', go to state 130
parser: Reduce 185 [expr ::= expr LT|GT|GE|LE expr], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'RP', pending reduce 322
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr RP]
parser: Input 'COMMA' with pending reduce 322
parser: Reduce 322 [filter_clause ::= FILTER LP WHERE expr RP], go to state 146.
parser: ... then shift 'filter_clause', go to state 337
parser: Reduce 319 [filter_over ::= filter_clause], go to state 146.
parser: ... then shift 'filter_over', pending reduce 179
parser: Reduce 179 [expr ::= ID|INDEXED LP distinct exprlist RP filter_over], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 355
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 355
parser: Reduce 355 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 419
parser: Shift 'LP', go to state 266
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 220 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 519
parser: Reduce 359 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 484
parser: Shift 'RP', go to state 146
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'FILTER' in state 146
parser: Shift 'FILTER', go to state 482
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER]
parser: Input 'LP' in state 482
parser: Shift 'LP', go to state 481
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP]
parser: Input 'WHERE' in state 481
parser: Shift 'WHERE', go to state 90
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE]
parser: Input 'ID' in state 90
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE ID]
parser: Input 'GT' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'GT', go to state 118
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT]
parser: Input 'INTEGER' in state 118
parser: Shift 'INTEGER', pending reduce 173
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT INTEGER]
parser: Input 'RP' with pending reduce 173
parser: Reduce 173 [term ::= INTEGER], go to state 118.
parser: ... then shift 'term', go to state 130
parser: Reduce 185 [expr ::= expr LT|GT|GE|LE expr], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'RP', pending reduce 322
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr RP]
parser: Input 'COMMA' with pending reduce 322
parser: Reduce 322 [filter_clause ::= FILTER LP WHERE expr RP], go to state 146.
parser: ... then shift 'filter_clause', go to state 337
parser: Reduce 319 [filter_over ::= filter_clause], go to state 146.
parser: ... then shift 'filter_over', pending reduce 179
parser: Reduce 179 [expr ::= ID|INDEXED LP distinct exprlist RP filter_over], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 355
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 355
parser: Reduce 355 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 419
parser: Shift 'LP', go to state 266
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 220 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 519
parser: Reduce 359 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 484
parser: Shift 'RP', go to state 146
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'FILTER' in state 146
parser: Shift 'FILTER', go to state 482
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER]
parser: Input 'LP' in state 482
parser: Shift 'LP', go to state 481
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP]
parser: Input 'WHERE' in state 481
parser: Shift 'WHERE', go to state 90
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE]
parser: Input 'ID' in state 90
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE ID]
parser: Input 'GT' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'GT', go to state 118
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT]
parser: Input 'INTEGER' in state 118
parser: Shift 'INTEGER', pending reduce 173
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT INTEGER]
parser: Input 'RP' with pending reduce 173
parser: Reduce 173 [term ::= INTEGER], go to state 118.
parser: ... then shift 'term', go to state 130
parser: Reduce 185 [expr ::= expr LT|GT|GE|LE expr], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'RP', pending reduce 322
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr RP]
parser: Input 'COMMA' with pending reduce 322
parser: Reduce 322 [filter_clause ::= FILTER LP WHERE expr RP], go to state 146.
parser: ... then shift 'filter_clause', go to state 337
parser: Reduce 319 [filter_over ::= filter_clause], go to state 146.
parser: ... then shift 'filter_over', pending reduce 179
parser: Reduce 179 [expr ::= ID|INDEXED LP distinct exprlist RP filter_over], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 355
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 355
parser: Reduce 355 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 419
parser: Shift 'LP', go to state 266
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 220 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 519
parser: Reduce 359 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 484
parser: Shift 'RP', go to state 146
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'FILTER' in state 146
parser: Shift 'FILTER', go to state 482
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER]
parser: Input 'LP' in state 482
parser: Shift 'LP', go to state 481
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP]
parser: Input 'WHERE' in state 481
parser: Shift 'WHERE', go to state 90
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE]
parser: Input 'ID' in state 90
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE ID]
parser: Input 'GT' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'GT', go to state 118
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT]
parser: Input 'INTEGER' in state 118
parser: Shift 'INTEGER', pending reduce 173
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT INTEGER]
parser: Input 'RP' with pending reduce 173
parser: Reduce 173 [term ::= INTEGER], go to state 118.
parser: ... then shift 'term', go to state 130
parser: Reduce 185 [expr ::= expr LT|GT|GE|LE expr], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'RP', pending reduce 322
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr RP]
parser: Input 'COMMA' with pending reduce 322
parser: Reduce 322 [filter_clause ::= FILTER LP WHERE expr RP], go to state 146.
parser: ... then shift 'filter_clause', go to state 337
parser: Reduce 319 [filter_over ::= filter_clause], go to state 146.
parser: ... then shift 'filter_over', pending reduce 179
parser: Reduce 179 [expr ::= ID|INDEXED LP distinct exprlist RP filter_over], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 355
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 355
parser: Reduce 355 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 419
parser: Shift 'LP', go to state 266
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 220 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 519
parser: Reduce 359 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 484
parser: Shift 'RP', go to state 146
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'FILTER' in state 146
parser: Shift 'FILTER', go to state 482
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER]
parser: Input 'LP' in state 482
parser: Shift 'LP', go to state 481
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP]
parser: Input 'WHERE' in state 481
parser: Shift 'WHERE', go to state 90
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE]
parser: Input 'ID' in state 90
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE ID]
parser: Input 'GT' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'GT', go to state 118
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT]
parser: Input 'INTEGER' in state 118
parser: Shift 'INTEGER', pending reduce 173
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT INTEGER]
parser: Input 'RP' with pending reduce 173
parser: Reduce 173 [term ::= INTEGER], go to state 118.
parser: ... then shift 'term', go to state 130
parser: Reduce 185 [expr ::= expr LT|GT|GE|LE expr], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'RP', pending reduce 322
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr RP]
parser: Input 'COMMA' with pending reduce 322
parser: Reduce 322 [filter_clause ::= FILTER LP WHERE expr RP], go to state 146.
parser: ... then shift 'filter_clause', go to state 337
parser: Reduce 319 [filter_over ::= filter_clause], go to state 146.
parser: ... then shift 'filter_over', pending reduce 179
parser: Reduce 179 [expr ::= ID|INDEXED LP distinct exprlist RP filter_over], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 355
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 355
parser: Reduce 355 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 419
parser: Shift 'LP', go to state 266
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 220 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 519
parser: Reduce 359 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 484
parser: Shift 'RP', go to state 146
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'FILTER' in state 146
parser: Shift 'FILTER', go to state 482
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER]
parser: Input 'LP' in state 482
parser: Shift 'LP', go to state 481
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP]
parser: Input 'WHERE' in state 481
parser: Shift 'WHERE', go to state 90
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE]
parser: Input 'ID' in state 90
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE ID]
parser: Input 'GT' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'GT', go to state 118
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT]
parser: Input 'INTEGER' in state 118
parser: Shift 'INTEGER', pending reduce 173
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT INTEGER]
parser: Input 'RP' with pending reduce 173
parser: Reduce 173 [term ::= INTEGER], go to state 118.
parser: ... then shift 'term', go to state 130
parser: Reduce 185 [expr ::= expr LT|GT|GE|LE expr], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'RP', pending reduce 322
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr RP]
parser: Input 'COMMA' with pending reduce 322
parser: Reduce 322 [filter_clause ::= FILTER LP WHERE expr RP], go to state 146.
parser: ... then shift 'filter_clause', go to state 337
parser: Reduce 319 [filter_over ::= filter_clause], go to state 146.
parser: ... then shift 'filter_over', pending reduce 179
parser: Reduce 179 [expr ::= ID|INDEXED LP distinct exprlist RP filter_over], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 355
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 355
parser: Reduce 355 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 419
parser: Shift 'LP', go to state 266
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 220 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 519
parser: Reduce 359 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 484
parser: Shift 'RP', go to state 146
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'FILTER' in state 146
parser: Shift 'FILTER', go to state 482
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER]
parser: Input 'LP' in state 482
parser: Shift 'LP', go to state 481
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP]
parser: Input 'WHERE' in state 481
parser: Shift 'WHERE', go to state 90
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE]
parser: Input 'ID' in state 90
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE ID]
parser: Input 'GT' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'GT', go to state 118
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT]
parser: Input 'INTEGER' in state 118
parser: Shift 'INTEGER', pending reduce 173
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT INTEGER]
parser: Input 'RP' with pending reduce 173
parser: Reduce 173 [term ::= INTEGER], go to state 118.
parser: ... then shift 'term', go to state 130
parser: Reduce 185 [expr ::= expr LT|GT|GE|LE expr], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'RP', pending reduce 322
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr RP]
parser: Input 'COMMA' with pending reduce 322
parser: Reduce 322 [filter_clause ::= FILTER LP WHERE expr RP], go to state 146.
parser: ... then shift 'filter_clause', go to state 337
parser: Reduce 319 [filter_over ::= filter_clause], go to state 146.
parser: ... then shift 'filter_over', pending reduce 179
parser: Reduce 179 [expr ::= ID|INDEXED LP distinct exprlist RP filter_over], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 355
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 355
parser: Reduce 355 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 419
parser: Shift 'LP', go to state 266
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 220 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 519
parser: Reduce 359 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 484
parser: Shift 'RP', go to state 146
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'FILTER' in state 146
parser: Shift 'FILTER', go to state 482
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER]
parser: Input 'LP' in state 482
parser: Shift 'LP', go to state 481
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP]
parser: Input 'WHERE' in state 481
parser: Shift 'WHERE', go to state 90
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE]
parser: Input 'ID' in state 90
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE ID]
parser: Input 'GT' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'GT', go to state 118
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT]
parser: Input 'INTEGER' in state 118
parser: Shift 'INTEGER', pending reduce 173
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT INTEGER]
parser: Input 'RP' with pending reduce 173
parser: Reduce 173 [term ::= INTEGER], go to state 118.
parser: ... then shift 'term', go to state 130
parser: Reduce 185 [expr ::= expr LT|GT|GE|LE expr], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'RP', pending reduce 322
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr RP]
parser: Input 'COMMA' with pending reduce 322
parser: Reduce 322 [filter_clause ::= FILTER LP WHERE expr RP], go to state 146.
parser: ... then shift 'filter_clause', go to state 337
parser: Reduce 319 [filter_over ::= filter_clause], go to state 146.
parser: ... then shift 'filter_over', pending reduce 179
parser: Reduce 179 [expr ::= ID|INDEXED LP distinct exprlist RP filter_over], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 355
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 355
parser: Reduce 355 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 419
parser: Shift 'LP', go to state 266
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 220 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 519
parser: Reduce 359 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 484
parser: Shift 'RP', go to state 146
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'FILTER' in state 146
parser: Shift 'FILTER', go to state 482
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER]
parser: Input 'LP' in state 482
parser: Shift 'LP', go to state 481
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP]
parser: Input 'WHERE' in state 481
parser: Shift 'WHERE', go to state 90
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE]
parser: Input 'ID' in state 90
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE ID]
parser: Input 'GT' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'GT', go to state 118
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT]
parser: Input 'INTEGER' in state 118
parser: Shift 'INTEGER', pending reduce 173
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT INTEGER]
parser: Input 'RP' with pending reduce 173
parser: Reduce 173 [term ::= INTEGER], go to state 118.
parser: ... then shift 'term', go to state 130
parser: Reduce 185 [expr ::= expr LT|GT|GE|LE expr], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'RP', pending reduce 322
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr RP]
parser: Input 'FROM' with pending reduce 322
parser: Reduce 322 [filter_clause ::= FILTER LP WHERE expr RP], go to state 146.
parser: ... then shift 'filter_clause', go to state 337
parser: Reduce 319 [filter_over ::= filter_clause], go to state 146.
parser: ... then shift 'filter_over', pending reduce 179
parser: Reduce 179 [expr ::= ID|INDEXED LP distinct exprlist RP filter_over], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 104 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'SEMI' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 350
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 123 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 349
parser: Reduce 122 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 348
parser: Reduce 127 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 105
parser: Reduce 105 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 102 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 363
parser: Reduce 147 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 362
parser: Reduce 138 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 361
parser: Reduce 140 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 128 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 360
parser: Reduce 142 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 88
parser: Reduce 88 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 37.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 83 [select ::= selectnowith], go to state 37.
parser: ... then shift 'select', pending reduce 78
parser: Reduce 78 [cmd ::= createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
  15 Next             0    5    0               01 
  16 Halt             0    0    0               00 
  27 Halt             0    0    0               00 
parser: [[[;
;VACUUM;;
;SELECT * FROM a ORDER BY b, b;;
;SELECT * FROM a ORDER BY b DESC, b DESC;CREATE INDEX t3 ON a(b)
;SELECT*FROM"temp".sqlite_temp_master ORDER BY rowid
;SELECT x.b || '/' || y.b FROM a x, a y ORDER BY x.b, x.b DESC
  
;SELECT x.b || '/' || y.b FROM a x, a y ORDER BY x.b, x.b||x.b
  
;SELECT x.b || '/' || y.b FROM a x, a y ORDER BY x.b, x.b, y.b||y.b
  
;SELECT x.b || '/' || y.b FROM a x, a y ORDER BY x.b, y.b||y.b DESC
  
;SELECT x.b || '/' || y.b FROM a x, a y ORDER BY x.b, x.b||y.b
  
;SELECT*FROM"temp".sqlite_temp_master ORDER BY rowid
;;
;CREATE TABLE x(y INTEGER PRIMARY KEY, t2i1);ALTER TABLE x ADD t1i1
    
;;
;SELECT x.RowID id FROM a, x WHERE a.b = x.RowID AND id = 2;SELECT*FROM"temp".sqlite_temp_master ORDER BY rowid
;ALTER TABLE x ADD abc
    
;CREATE INDEX c ON a(b)
;CREATE INDEX v1 ON a(b)
;ALTER TABLE ex ADD v2
    
;CREATE TABLE tr1(t1a, t1b);;SELECT y, v2 FROM x, ex WHERE y>v2;;
;SELECT DISTINCT b FROM a LEFT JOIN ex ON b=v2 ORDER BY +v2;CREATE INDEX x1 ON a(b)
;CREATE INDEX z ON a(b)
;CREATE INDEX example ON ex(v2)
;;SELECT count(*) FROM sqlite_master WHERE tbl_name = 'e' AND type = 'index';;
;CREATE TABLE example_idx_00000042(id PRIMARY KEY, UNIQUE(id) );;BEGIN;;CREATE UNIQUE INDEX IF NOT EXISTS a_id ON a(b==0);;SELECT * FROM ex;]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 326
parser: Return. Stack=[SEMI]
parser: Input 'SEMI' with pending reduce 326
parser: Reduce 326 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Shift 'SEMI', pending reduce 326
parser: Return. Stack=[ecmd SEMI]
parser: Input 'VACUUM' with pending reduce 326
parser: Reduce 326 [ecmd ::= SEMI], go to state 1.
parser: ... then shift 'ecmd', pending reduce 324
parser: Reduce 324 [cmdlist ::= cmdlist ecmd], go to state 0.
parser: ... then shift 'cmdlist', go to state 1
parser: Shift 'VACUUM', go to state 154
parser: Return. Stack=[cmdlist VACUUM]
parser: Input 'SEMI' in state 154
parser: Reduce 236 [vinto ::=].
parser: ... then shift 'vinto', pending reduce 233
parser: Reduce 233 [cmd ::= VACUUM vinto], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdlist cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping cmdlist
SQL: [;
;VACUUM;]
VDBE Trace:
   0 Init             0    1    0               00 Start at 1
   1 Vacuum           0    0    0               00 
parser: [[[ATTACH '' AS vacuum_db]]]
parser: Input 'ATTACH' in state 0
parser: Shift 'ATTACH', go to state 294
parser: Return. Stack=[ATTACH]
parser: Input 'STRING' in state 294
parser: Reduce 371 [database_kw_opt ::=].
parser: ... then shift 'database_kw_opt', go to state 81
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[ATTACH database_kw_opt STRING]
parser: Input 'AS' in state 539
parser: Reduce 172 [term ::= STRING], go to state 81.
parser: ... then shift 'term', go to state 44
parser: Shift 'AS', go to state 80
parser: Return. Stack=[ATTACH database_kw_opt term AS]
parser: Input 'ID' in state 80
parser: Shift 'ID', go to state 419
parser: Return. Stack=[ATTACH database_kw_opt term AS ID]
parser: Input 'SEMI' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 80.
parser: ... then shift 'expr', go to state 15
parser: Reduce 271 [key_opt ::=].
parser: ... then shift 'key_opt', pending reduce 269
parser: Reduce 269 [cmd ::= ATTACH database_kw_opt expr AS expr key_opt], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
SQL: [ATTACH '' AS vacuum_db]
VDBE Trace:
   0 Init             0    1    0               00 Start at 1
   1 String8          0    1    0               00 r[1]=''
REG[1] =   t0[](8)
   2 String8          0    2    0 vacuum_db     00 r[2]='vacuum_db'
REG[2] =   t9[vacuum_db](8)
   3 Null             0    3    0               00 r[3]=NULL
REG[3] =  NULL
   4 Function0        0    1    4 sqlite_attach(3) 03 r[4]=func(r[1..3])
REG[1] =   t0[](8)
REG[2] =   t9[vacuum_db](8)
REG[3] =  NULL
parser: [[[CREATE TABLE x(type text,name text,tbl_name text,rootpage int,sql text)]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 390
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 0.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP ID]
parser: Input 'ID' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 192
parser: Shift 'ID', pending reduce 341
parser: Return. Stack=[create_table LP nm ID]
parser: Input 'COMMA' with pending reduce 341
parser: Reduce 341 [typename ::= ID|STRING], go to state 192.
parser: ... then shift 'typename', go to state 392
parser: Reduce 340 [typetoken ::= typename], go to state 192.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 379
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 152
parser: Reduce 336 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'ID' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Shift 'ID', pending reduce 341
parser: Return. Stack=[create_table LP columnlist COMMA nm ID]
parser: Input 'COMMA' with pending reduce 341
parser: Reduce 341 [typename ::= ID|STRING], go to state 192.
parser: ... then shift 'typename', go to state 392
parser: Reduce 340 [typetoken ::= typename], go to state 192.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'ID' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Shift 'ID', pending reduce 341
parser: Return. Stack=[create_table LP columnlist COMMA nm ID]
parser: Input 'COMMA' with pending reduce 341
parser: Reduce 341 [typename ::= ID|STRING], go to state 192.
parser: ... then shift 'typename', go to state 392
parser: Reduce 340 [typetoken ::= typename], go to state 192.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'ID' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Shift 'ID', pending reduce 341
parser: Return. Stack=[create_table LP columnlist COMMA nm ID]
parser: Input 'COMMA' with pending reduce 341
parser: Reduce 341 [typename ::= ID|STRING], go to state 192.
parser: ... then shift 'typename', go to state 392
parser: Reduce 340 [typetoken ::= typename], go to state 192.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'ID' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Shift 'ID', pending reduce 341
parser: Return. Stack=[create_table LP columnlist COMMA nm ID]
parser: Input 'RP' with pending reduce 341
parser: Reduce 341 [typename ::= ID|STRING], go to state 192.
parser: ... then shift 'typename', go to state 392
parser: Reduce 340 [typetoken ::= typename], go to state 192.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Reduce 61 [conslist_opt ::=].
parser: ... then shift 'conslist_opt', go to state 540
parser: Shift 'RP', go to state 364
parser: Return. Stack=[create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 364
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: ... then shift 'create_table_args', pending reduce 334
parser: Reduce 334 [cmd ::= create_table create_table_args], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT*FROM"vacuum_db".sqlite_master ORDER BY rowid]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'STAR' in state 288
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 95 [sclp ::=].
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STAR', pending reduce 97
parser: Return. Stack=[SELECT distinct sclp scanpt STAR]
parser: Input 'FROM' with pending reduce 97
parser: Reduce 97 [selcollist ::= sclp scanpt STAR], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 104 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'DOT' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 350
parser: Shift 'DOT', go to state 245
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID' in state 245
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'ORDER' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 245.
parser: ... then shift 'nm', pending reduce 110
parser: Reduce 110 [dbnm ::= DOT nm], go to state 350.
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 123 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 349
parser: Reduce 122 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 348
parser: Reduce 127 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 105
parser: Reduce 105 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 102 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 363
parser: Reduce 147 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 362
parser: Reduce 138 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 361
parser: Reduce 140 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 517
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 517
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 419
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 134 [sortorder ::=].
parser: ... then shift 'sortorder', go to state 353
parser: Reduce 137 [nulls ::=].
parser: ... then shift 'nulls', pending reduce 131
parser: Reduce 131 [sortlist ::= expr sortorder nulls], go to state 26.
parser: ... then shift 'sortlist', go to state 516
parser: Reduce 129 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 360
parser: Reduce 142 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 88
parser: Reduce 88 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 83 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 80
parser: Reduce 80 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
VDBE Trace:
   0 Init             0   13    0               00 Start at 13
  13 Transaction      3    0    0 0             00 usesStmtJournal=0
  14 Goto             0    1    0               00 
   1 Noop             1    7    0               00 
   2 OpenRead         0    1    3 5             00 root=1 iDb=3; sqlite_master
   3 Explain          3    0    0 SCAN TABLE sqlite_master 00 
   4 Rewind           0   12    0               00 
  12 Halt             0    0    0               00 
REG[4] =  NULL
   5 Expire           1    0    0               00 
   6 Halt             0    0    0               00 
parser: [[[BEGIN]]]
parser: Input 'BEGIN' in state 0
parser: Shift 'BEGIN', go to state 268
parser: Return. Stack=[BEGIN]
parser: Input 'SEMI' in state 268
parser: Reduce 4 [transtype ::=].
parser: ... then shift 'transtype', go to state 370
parser: Reduce 329 [trans_opt ::=].
parser: ... then shift 'trans_opt', pending reduce 3
parser: Reduce 3 [cmd ::= BEGIN transtype trans_opt], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
SQL: [BEGIN]
VDBE Trace:
   0 Init             0    1    0               00 Start at 1
   1 AutoCommit       0    0    0               00 
parser: [[[SELECT sql FROM "main".sqlite_master WHERE type='table'AND name<>'sqlite_sequence' AND coalesce(rootpage,1)>0]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 95 [sclp ::=].
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 419
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'FROM' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 104 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'DOT' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 350
parser: Shift 'DOT', go to state 245
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID' in state 245
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'WHERE' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 245.
parser: ... then shift 'nm', pending reduce 110
parser: Reduce 110 [dbnm ::= DOT nm], go to state 350.
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 123 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 349
parser: Reduce 122 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 348
parser: Reduce 127 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 105
parser: Reduce 105 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 102 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 363
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[SELECT distinct selcollist from WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 419
parser: Return. Stack=[SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr EQ STRING]
parser: Input 'AND' in state 539
parser: Reduce 172 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 186 [expr ::= expr EQ|NE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'AND', go to state 120
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID' in state 120
parser: Shift 'ID', go to state 419
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'NE' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Shift 'NE', go to state 117
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr NE]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr NE STRING]
parser: Input 'AND' in state 539
parser: Reduce 172 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 186 [expr ::= expr EQ|NE expr], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Reduce 183 [expr ::= expr AND expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'AND', go to state 120
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID' in state 120
parser: Shift 'ID', go to state 419
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'LP' in state 419
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND ID LP]
parser: Input 'ID' in state 266
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 419
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND ID LP distinct ID]
parser: Input 'COMMA' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 220 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 519
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND ID LP distinct nexprlist COMMA]
parser: Input 'INTEGER' in state 107
parser: Shift 'INTEGER', pending reduce 173
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND ID LP distinct nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 173
parser: Reduce 173 [term ::= INTEGER], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 219 [nexprlist ::= nexprlist COMMA expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 519
parser: Reduce 359 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 484
parser: Shift 'RP', go to state 146
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND ID LP distinct exprlist RP]
parser: Input 'GT' in state 146
parser: Reduce 177 [expr ::= ID|INDEXED LP distinct exprlist RP], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Shift 'GT', go to state 118
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr GT]
parser: Input 'INTEGER' in state 118
parser: Shift 'INTEGER', pending reduce 173
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr GT INTEGER]
parser: Input 'SEMI' with pending reduce 173
parser: Reduce 173 [term ::= INTEGER], go to state 118.
parser: ... then shift 'term', go to state 130
parser: Reduce 185 [expr ::= expr LT|GT|GE|LE expr], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Reduce 183 [expr ::= expr AND expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 148 [where_opt ::= WHERE expr], go to state 363.
parser: ... then shift 'where_opt', go to state 362
parser: Reduce 138 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 361
parser: Reduce 140 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 128 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 360
parser: Reduce 142 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 88
parser: Reduce 88 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 83 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 80
parser: Reduce 80 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
SQL: [SELECT sql FROM "main".sqlite_master WHERE type='table'AND name<>'sqlite_sequence' AND coalesce(rootpage,1)>0]
VDBE Trace:
   0 Init             0   16    0               00 Start at 16
  16 Transaction      0    0    5 0             01 usesStmtJournal=0
  17 String8          0    2    0 table         00 r[2]='table'
REG[2] =   t5[table](8)
  18 String8          0    3    0 sqlite_sequence 00 r[3]='sqlite_sequence'
REG[3] =   t15[sqlite_sequence](8)
  19 Integer          0    4    0               00 r[4]=0
REG[4] =  i:0
  20 Goto             0    1    0               00 
   1 OpenRead         0    1    0 5             00 root=1 iDb=0; sqlite_master
   2 Explain          2    0    0 SCAN TABLE sqlite_master 00 
   3 Rewind           0   15    0               00 
   4 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s4[view](8)
   5 Ne               2   14    1 (BINARY)      52 if r[1]!=r[2] goto 14
REG[2] =   t5[table](8)
REG[1] =   s4[view](8)
  14 Next             0    4    0               01 
   4 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s5[table](8)
   5 Ne               2   14    1 (BINARY)      52 if r[1]!=r[2] goto 14
REG[2] =   t5[table](8)
REG[1] =   s5[table](8)
   6 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s1[a](8)
   7 Eq               3   14    1 (BINARY)      52 if r[1]==r[3] goto 14
REG[3] =   t15[sqlite_sequence](8)
REG[1] =   s1[a](8)
   8 Column           0    3    1               00 r[1]=sqlite_master.rootpage
REG[1] =  i:2
   9 NotNull          1   11    0               00 if r[1]!=NULL goto 11
REG[1] =  i:2
  11 Le               4   14    1               50 if r[1]<=r[4] goto 14
REG[4] =  i:0
REG[1] =  i:2
  12 Column           0    4    5               00 r[5]=sqlite_master.sql
REG[5] =   s56[CREATE TABLE a (b INTEGER](8)
  13 ResultRow        5    1    0               00 output=r[5]
REG[5] =   s56[CREATE TABLE a (b INTEGER](8)
parser: [[[CREATE TABLE a (b INTEGER, PRIMARY KEY(b)) WITHOUT ROWID]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 390
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 0.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP ID]
parser: Input 'ID' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 192
parser: Shift 'ID', pending reduce 341
parser: Return. Stack=[create_table LP nm ID]
parser: Input 'COMMA' with pending reduce 341
parser: Reduce 341 [typename ::= ID|STRING], go to state 192.
parser: ... then shift 'typename', go to state 392
parser: Reduce 340 [typetoken ::= typename], go to state 192.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 379
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 152
parser: Reduce 336 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'PRIMARY' in state 34
parser: Shift 'PRIMARY', go to state 475
parser: Return. Stack=[create_table LP columnlist COMMA PRIMARY]
parser: Input 'KEY' in state 475
parser: Shift 'KEY', go to state 474
parser: Return. Stack=[create_table LP columnlist COMMA PRIMARY KEY]
parser: Input 'LP' in state 474
parser: Shift 'LP', go to state 20
parser: Return. Stack=[create_table LP columnlist COMMA PRIMARY KEY LP]
parser: Input 'ID' in state 20
parser: Shift 'ID', go to state 419
parser: Return. Stack=[create_table LP columnlist COMMA PRIMARY KEY LP ID]
parser: Input 'RP' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 20.
parser: ... then shift 'expr', go to state 13
parser: Reduce 134 [sortorder ::=].
parser: ... then shift 'sortorder', go to state 353
parser: Reduce 137 [nulls ::=].
parser: ... then shift 'nulls', pending reduce 131
parser: Reduce 131 [sortlist ::= expr sortorder nulls], go to state 20.
parser: ... then shift 'sortlist', go to state 277
parser: Reduce 43 [autoinc ::=].
parser: ... then shift 'autoinc', go to state 473
parser: Shift 'RP', go to state 328
parser: Return. Stack=[create_table LP columnlist COMMA PRIMARY KEY LP sortlist autoinc RP]
parser: Input 'RP' in state 328
parser: Reduce 69 [onconf ::=].
parser: ... then shift 'onconf', pending reduce 64
parser: Reduce 64 [tcons ::= PRIMARY KEY LP sortlist autoinc RP onconf], go to state 34.
parser: ... then shift 'tcons', go to state 278
parser: Reduce 347 [conslist_opt ::= COMMA conslist], go to state 365.
parser: ... then shift 'conslist_opt', go to state 540
parser: Shift 'RP', go to state 364
parser: Return. Stack=[create_table LP columnlist conslist_opt RP]
parser: Input 'WITHOUT' in state 364
parser: Shift 'WITHOUT', go to state 251
parser: Return. Stack=[create_table LP columnlist conslist_opt RP WITHOUT]
parser: Input 'ID' in state 251
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist conslist_opt RP WITHOUT ID]
parser: Input 'SEMI' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 251.
parser: ... then shift 'nm', pending reduce 22
parser: Reduce 22 [table_options ::= WITHOUT nm], go to state 364.
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: [[[UPDATE 'vacuum_db'.sqlite_master SET type='table', name='a', tbl_name='a', rootpage=#2, sql='CREATE TABLE a (b INTEGER, PRIMARY KEY(b)) WITHOUT ROWID' WHERE rowid=#1]]]
parser: Input 'UPDATE' in state 0
parser: Reduce 380 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'UPDATE', go to state 299
parser: Return. Stack=[with UPDATE]
parser: Input 'STRING' in state 299
parser: Reduce 71 [orconf ::=].
parser: ... then shift 'orconf', go to state 167
parser: Shift 'STRING', pending reduce 338
parser: Return. Stack=[with UPDATE orconf STRING]
parser: Input 'DOT' with pending reduce 338
parser: Reduce 338 [nm ::= STRING], go to state 167.
parser: ... then shift 'nm', go to state 395
parser: Shift 'DOT', go to state 218
parser: Return. Stack=[with UPDATE orconf nm DOT]
parser: Input 'ID' in state 218
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[with UPDATE orconf nm DOT ID]
parser: Input 'SET' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 218.
parser: ... then shift 'nm', go to state 432
parser: Reduce 114 [xfullname ::= nm DOT nm], go to state 167.
parser: ... then shift 'xfullname', go to state 271
parser: Reduce 123 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 431
parser: Shift 'SET', go to state 155
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET]
parser: Input 'ID' in state 155
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET ID]
parser: Input 'EQ' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 155.
parser: ... then shift 'nm', go to state 445
parser: Shift 'EQ', go to state 84
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ]
parser: Input 'STRING' in state 84
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ STRING]
parser: Input 'COMMA' in state 539
parser: Reduce 172 [term ::= STRING], go to state 84.
parser: ... then shift 'term', go to state 58
parser: Reduce 152 [setlist ::= nm EQ expr], go to state 155.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 447
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING' in state 86
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'COMMA' in state 539
parser: Reduce 172 [term ::= STRING], go to state 86.
parser: ... then shift 'term', go to state 60
parser: Reduce 150 [setlist ::= setlist COMMA nm EQ expr], go to state 155.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 447
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING' in state 86
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'COMMA' in state 539
parser: Reduce 172 [term ::= STRING], go to state 86.
parser: ... then shift 'term', go to state 60
parser: Reduce 150 [setlist ::= setlist COMMA nm EQ expr], go to state 155.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 447
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'VARIABLE' in state 86
parser: Shift 'VARIABLE', pending reduce 174
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ VARIABLE]
parser: Input 'COMMA' with pending reduce 174
parser: Reduce 174 [expr ::= VARIABLE], go to state 86.
parser: ... then shift 'expr', go to state 60
parser: Reduce 150 [setlist ::= setlist COMMA nm EQ expr], go to state 155.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 447
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING' in state 86
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'WHERE' in state 539
parser: Reduce 172 [term ::= STRING], go to state 86.
parser: ... then shift 'term', go to state 60
parser: Reduce 150 [setlist ::= setlist COMMA nm EQ expr], go to state 155.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 419
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE ID]
parser: Input 'EQ' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr EQ]
parser: Input 'VARIABLE' in state 117
parser: Shift 'VARIABLE', pending reduce 174
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr EQ VARIABLE]
parser: Input 'SEMI' with pending reduce 174
parser: Reduce 174 [expr ::= VARIABLE], go to state 117.
parser: ... then shift 'expr', go to state 129
parser: Reduce 186 [expr ::= expr EQ|NE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 148 [where_opt ::= WHERE expr], go to state 270.
parser: ... then shift 'where_opt', pending reduce 149
parser: Reduce 149 [cmd ::= with UPDATE orconf xfullname indexed_opt SET setlist where_opt], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Input '$' with pending reduce 327
parser: Reduce 327 [ecmd ::= cmdx SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 323 [input ::= cmdlist], go to state 0.
parser: ... then shift 'input', pending reduce -2
parser: Accept!
parser: ... then shift 'create_table_args', pending reduce 334
parser: Reduce 334 [cmd ::= create_table create_table_args], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
SQL: [CREATE TABLE a (b INTEGER, PRIMARY KEY(b)) WITHOUT ROWID]
VDBE Trace:
   0 Init             0   28    0               00 Start at 28
  28 Transaction      3    1    0 0             01 usesStmtJournal=0
  29 Goto             0    1    0               00 
   1 ReadCookie       3    3    2               00 
REG[3] =  i:0
   2 If               3    5    0               00 
REG[3] =  i:0
   3 SetCookie        3    2    4               00 
   4 SetCookie        3    5    1               00 
   5 CreateBtree      3    2    2               00 r[2]=root iDb=3 flags=2
REG[2] =  i:2
   6 OpenWrite        0    1    3 5             00 root=1 iDb=3
   7 NewRowid         0    1    0               00 r[1]=rowid
REG[1] =  i:1
   8 Blob             6    3    0              00 r[3]= (len=6)
REG[3] =  tx6[060000000000|......]
   9 Insert           0    3    1               08 intkey=r[1] data=r[3]
REG[3] =  tx6[060000000000|......]
REG[1] =  i:1
  10 Close            0    0    0               00 
  11 Close            0    0    0               00 
  12 Null             0    4    5               00 r[4..5]=NULL
REG[4] =  NULL
  13 OpenWrite        1    1    3 5             00 root=1 iDb=3; sqlite_master
  14 Explain         14    0    0 SEARCH TABLE sqlite_master USING INTEGER PRIMARY KEY (rowid=?) 00 
  15 SeekRowid        1   17    1               00 intkey=r[1]
REG[1] =  i:1
  16 Rowid            1    5    0               00 r[5]=rowid
REG[5] =  i:1
  17 IsNull           5   25    0               00 if r[5]==NULL goto 25
REG[5] =  i:1
  18 String8          0    6    0 table         00 r[6]='table'
REG[6] =   t5[table](8)
  19 String8          0    7    0 a             00 r[7]='a'
REG[7] =   t1[a](8)
  20 String8          0    8    0 a             00 r[8]='a'
REG[8] =   t1[a](8)
  21 Copy             2    9    0               00 r[9]=r[2]
REG[9] =  i:2
  22 String8          0   10    0 CREATE TABLE a (b INTEGER, PRIMARY KEY(b)) WITHOUT ROWID 00 r[10]='CREATE TABLE a (b INTEGER, PRIMARY KEY(b)) WITHOUT ROWID'
REG[10] =   t56[CREATE TABLE a (b INTEGER](8)
  23 MakeRecord       6    5    4 BBBDB         00 r[4]=mkrec(r[6..10])
REG[6] =   t5[table](8)
REG[7] =   t1[a](8)
REG[8] =   t1[a](8)
REG[9] =  i:2
REG[10] =   t56[CREATE TABLE a (b INTEGER](8)
REG[4] =  sx70[06170F0F017D7461626C65616102435245415445205441424C|.....}tableaa.CREATE TABL]
  24 Insert           1    4    5               00 intkey=r[5] data=r[4]
REG[4] =  sx70[06170F0F017D7461626C65616102435245415445205441424C|.....}tableaa.CREATE TABL]
REG[5] =  i:1
  25 SetCookie        3    1    1               00 
  26 ParseSchema      3    0    0 tbl_name='a' AND type!='trigger' 00 
parser: [[[SELECT*FROM"vacuum_db".sqlite_master WHERE tbl_name='a' AND type!='trigger' ORDER BY rowid]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'STAR' in state 288
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 95 [sclp ::=].
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STAR', pending reduce 97
parser: Return. Stack=[SELECT distinct sclp scanpt STAR]
parser: Input 'FROM' with pending reduce 97
parser: Reduce 97 [selcollist ::= sclp scanpt STAR], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 104 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'DOT' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 350
parser: Shift 'DOT', go to state 245
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID' in state 245
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'WHERE' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 245.
parser: ... then shift 'nm', pending reduce 110
parser: Reduce 110 [dbnm ::= DOT nm], go to state 350.
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 123 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 349
parser: Reduce 122 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 348
parser: Reduce 127 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 105
parser: Reduce 105 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 102 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 363
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[SELECT distinct selcollist from WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 419
parser: Return. Stack=[SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr EQ STRING]
parser: Input 'AND' in state 539
parser: Reduce 172 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 186 [expr ::= expr EQ|NE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'AND', go to state 120
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID' in state 120
parser: Shift 'ID', go to state 419
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'NE' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Shift 'NE', go to state 117
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr NE]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr NE STRING]
parser: Input 'ORDER' in state 539
parser: Reduce 172 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 186 [expr ::= expr EQ|NE expr], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Reduce 183 [expr ::= expr AND expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 148 [where_opt ::= WHERE expr], go to state 363.
parser: ... then shift 'where_opt', go to state 362
parser: Reduce 138 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 361
parser: Reduce 140 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 517
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 517
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 419
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 134 [sortorder ::=].
parser: ... then shift 'sortorder', go to state 353
parser: Reduce 137 [nulls ::=].
parser: ... then shift 'nulls', pending reduce 131
parser: Reduce 131 [sortlist ::= expr sortorder nulls], go to state 26.
parser: ... then shift 'sortlist', go to state 516
parser: Reduce 129 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 360
parser: Reduce 142 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 88
parser: Reduce 88 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 83 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 80
parser: Reduce 80 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
VDBE Trace:
   0 Init             0   17    0               00 Start at 17
  17 Transaction      3    0    1 0             00 usesStmtJournal=0
  18 String8          0    2    0 a             00 r[2]='a'
REG[2] =   t1[a](8)
  19 String8          0    3    0 trigger       00 r[3]='trigger'
REG[3] =   t7[trigger](8)
  20 Goto             0    1    0               00 
   1 Noop             1    7    0               00 
   2 OpenRead         0    1    3 5             00 root=1 iDb=3; sqlite_master
   3 Explain          3    0    0 SCAN TABLE sqlite_master 00 
   4 Rewind           0   16    0               00 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s1[a](8)
   6 Ne               2   15    1 (BINARY)      52 if r[1]!=r[2] goto 15
REG[2] =   t1[a](8)
REG[1] =   s1[a](8)
   7 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s5[table](8)
   8 Eq               3   15    1 (BINARY)      52 if r[1]==r[3] goto 15
REG[3] =   t7[trigger](8)
REG[1] =   s5[table](8)
   9 Column           0    0    4               00 r[4]=sqlite_master.type
REG[4] =   s5[table](8)
  10 Column           0    1    5               00 r[5]=sqlite_master.name
REG[5] =   s1[a](8)
  11 Column           0    2    6               00 r[6]=sqlite_master.tbl_name
REG[6] =   s1[a](8)
  12 Column           0    3    7               00 r[7]=sqlite_master.rootpage
REG[7] =  i:2
  13 Column           0    4    8               00 r[8]=sqlite_master.sql
REG[8] =   s56[CREATE TABLE a (b INTEGER](8)
  14 ResultRow        4    5    0               00 output=r[4..8]
REG[4] =   s5[table](8)
REG[5] =   s1[a](8)
REG[6] =   s1[a](8)
REG[7] =  i:2
REG[8] =   s56[CREATE TABLE a (b INTEGER](8)
parser: [[[CREATE TABLE a (b INTEGER, PRIMARY KEY(b)) WITHOUT ROWID]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 390
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 0.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP ID]
parser: Input 'ID' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 192
parser: Shift 'ID', pending reduce 341
parser: Return. Stack=[create_table LP nm ID]
parser: Input 'COMMA' with pending reduce 341
parser: Reduce 341 [typename ::= ID|STRING], go to state 192.
parser: ... then shift 'typename', go to state 392
parser: Reduce 340 [typetoken ::= typename], go to state 192.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 379
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 152
parser: Reduce 336 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'PRIMARY' in state 34
parser: Shift 'PRIMARY', go to state 475
parser: Return. Stack=[create_table LP columnlist COMMA PRIMARY]
parser: Input 'KEY' in state 475
parser: Shift 'KEY', go to state 474
parser: Return. Stack=[create_table LP columnlist COMMA PRIMARY KEY]
parser: Input 'LP' in state 474
parser: Shift 'LP', go to state 20
parser: Return. Stack=[create_table LP columnlist COMMA PRIMARY KEY LP]
parser: Input 'ID' in state 20
parser: Shift 'ID', go to state 419
parser: Return. Stack=[create_table LP columnlist COMMA PRIMARY KEY LP ID]
parser: Input 'RP' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 20.
parser: ... then shift 'expr', go to state 13
parser: Reduce 134 [sortorder ::=].
parser: ... then shift 'sortorder', go to state 353
parser: Reduce 137 [nulls ::=].
parser: ... then shift 'nulls', pending reduce 131
parser: Reduce 131 [sortlist ::= expr sortorder nulls], go to state 20.
parser: ... then shift 'sortlist', go to state 277
parser: Reduce 43 [autoinc ::=].
parser: ... then shift 'autoinc', go to state 473
parser: Shift 'RP', go to state 328
parser: Return. Stack=[create_table LP columnlist COMMA PRIMARY KEY LP sortlist autoinc RP]
parser: Input 'RP' in state 328
parser: Reduce 69 [onconf ::=].
parser: ... then shift 'onconf', pending reduce 64
parser: Reduce 64 [tcons ::= PRIMARY KEY LP sortlist autoinc RP onconf], go to state 34.
parser: ... then shift 'tcons', go to state 278
parser: Reduce 347 [conslist_opt ::= COMMA conslist], go to state 365.
parser: ... then shift 'conslist_opt', go to state 540
parser: Shift 'RP', go to state 364
parser: Return. Stack=[create_table LP columnlist conslist_opt RP]
parser: Input 'WITHOUT' in state 364
parser: Shift 'WITHOUT', go to state 251
parser: Return. Stack=[create_table LP columnlist conslist_opt RP WITHOUT]
parser: Input 'ID' in state 251
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist conslist_opt RP WITHOUT ID]
parser: Input 'SEMI' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 251.
parser: ... then shift 'nm', pending reduce 22
parser: Reduce 22 [table_options ::= WITHOUT nm], go to state 364.
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: ... then shift 'create_table_args', pending reduce 334
parser: Reduce 334 [cmd ::= create_table create_table_args], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
  15 Next             0    5    0               01 
  16 Halt             0    0    0               00 
  27 Halt             0    0    0               00 
  14 Next             0    4    0               01 
   4 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s5[table](8)
   5 Ne               2   14    1 (BINARY)      52 if r[1]!=r[2] goto 14
REG[2] =   t5[table](8)
REG[1] =   s5[table](8)
   6 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s2[ex](8)
   7 Eq               3   14    1 (BINARY)      52 if r[1]==r[3] goto 14
REG[3] =   t15[sqlite_sequence](8)
REG[1] =   s2[ex](8)
   8 Column           0    3    1               00 r[1]=sqlite_master.rootpage
REG[1] =  i:3
   9 NotNull          1   11    0               00 if r[1]!=NULL goto 11
REG[1] =  i:3
  11 Le               4   14    1               50 if r[1]<=r[4] goto 14
REG[4] =  i:0
REG[1] =  i:3
  12 Column           0    4    5               00 r[5]=sqlite_master.sql
REG[5] =   s19[CREATE TABLE ex(i1)](8)
  13 ResultRow        5    1    0               00 output=r[5]
REG[5] =   s19[CREATE TABLE ex(i1)](8)
parser: [[[CREATE TABLE ex(i1)]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 390
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 0.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP ID]
parser: Input 'RP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 192
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 379
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 152
parser: Reduce 336 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Reduce 61 [conslist_opt ::=].
parser: ... then shift 'conslist_opt', go to state 540
parser: Shift 'RP', go to state 364
parser: Return. Stack=[create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 364
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: [[[UPDATE 'vacuum_db'.sqlite_master SET type='table', name='ex', tbl_name='ex', rootpage=#2, sql='CREATE TABLE ex(i1)' WHERE rowid=#1]]]
parser: Input 'UPDATE' in state 0
parser: Reduce 380 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'UPDATE', go to state 299
parser: Return. Stack=[with UPDATE]
parser: Input 'STRING' in state 299
parser: Reduce 71 [orconf ::=].
parser: ... then shift 'orconf', go to state 167
parser: Shift 'STRING', pending reduce 338
parser: Return. Stack=[with UPDATE orconf STRING]
parser: Input 'DOT' with pending reduce 338
parser: Reduce 338 [nm ::= STRING], go to state 167.
parser: ... then shift 'nm', go to state 395
parser: Shift 'DOT', go to state 218
parser: Return. Stack=[with UPDATE orconf nm DOT]
parser: Input 'ID' in state 218
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[with UPDATE orconf nm DOT ID]
parser: Input 'SET' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 218.
parser: ... then shift 'nm', go to state 432
parser: Reduce 114 [xfullname ::= nm DOT nm], go to state 167.
parser: ... then shift 'xfullname', go to state 271
parser: Reduce 123 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 431
parser: Shift 'SET', go to state 155
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET]
parser: Input 'ID' in state 155
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET ID]
parser: Input 'EQ' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 155.
parser: ... then shift 'nm', go to state 445
parser: Shift 'EQ', go to state 84
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ]
parser: Input 'STRING' in state 84
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ STRING]
parser: Input 'COMMA' in state 539
parser: Reduce 172 [term ::= STRING], go to state 84.
parser: ... then shift 'term', go to state 58
parser: Reduce 152 [setlist ::= nm EQ expr], go to state 155.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 447
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING' in state 86
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'COMMA' in state 539
parser: Reduce 172 [term ::= STRING], go to state 86.
parser: ... then shift 'term', go to state 60
parser: Reduce 150 [setlist ::= setlist COMMA nm EQ expr], go to state 155.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 447
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING' in state 86
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'COMMA' in state 539
parser: Reduce 172 [term ::= STRING], go to state 86.
parser: ... then shift 'term', go to state 60
parser: Reduce 150 [setlist ::= setlist COMMA nm EQ expr], go to state 155.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 447
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'VARIABLE' in state 86
parser: Shift 'VARIABLE', pending reduce 174
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ VARIABLE]
parser: Input 'COMMA' with pending reduce 174
parser: Reduce 174 [expr ::= VARIABLE], go to state 86.
parser: ... then shift 'expr', go to state 60
parser: Reduce 150 [setlist ::= setlist COMMA nm EQ expr], go to state 155.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 447
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING' in state 86
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'WHERE' in state 539
parser: Reduce 172 [term ::= STRING], go to state 86.
parser: ... then shift 'term', go to state 60
parser: Reduce 150 [setlist ::= setlist COMMA nm EQ expr], go to state 155.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 419
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE ID]
parser: Input 'EQ' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr EQ]
parser: Input 'VARIABLE' in state 117
parser: Shift 'VARIABLE', pending reduce 174
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr EQ VARIABLE]
parser: Input 'SEMI' with pending reduce 174
parser: Reduce 174 [expr ::= VARIABLE], go to state 117.
parser: ... then shift 'expr', go to state 129
parser: Reduce 186 [expr ::= expr EQ|NE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 148 [where_opt ::= WHERE expr], go to state 270.
parser: ... then shift 'where_opt', pending reduce 149
parser: Reduce 149 [cmd ::= with UPDATE orconf xfullname indexed_opt SET setlist where_opt], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Input '$' with pending reduce 327
parser: Reduce 327 [ecmd ::= cmdx SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 323 [input ::= cmdlist], go to state 0.
parser: ... then shift 'input', pending reduce -2
parser: Accept!
parser: ... then shift 'create_table_args', pending reduce 334
parser: Reduce 334 [cmd ::= create_table create_table_args], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
SQL: [CREATE TABLE ex(i1)]
VDBE Trace:
   0 Init             0   28    0               00 Start at 28
  28 Transaction      3    1    1 0             01 usesStmtJournal=0
  29 Goto             0    1    0               00 
   1 ReadCookie       3    3    2               00 
REG[3] =  i:4
   2 If               3    5    0               00 
REG[3] =  i:4
   5 CreateBtree      3    2    1               00 r[2]=root iDb=3 flags=1
REG[2] =  i:3
   6 OpenWrite        0    1    3 5             00 root=1 iDb=3
   7 NewRowid         0    1    0               00 r[1]=rowid
REG[1] =  i:2
   8 Blob             6    3    0              00 r[3]= (len=6)
REG[3] =  tx6[060000000000|......]
   9 Insert           0    3    1               08 intkey=r[1] data=r[3]
REG[3] =  tx6[060000000000|......]
REG[1] =  i:2
  10 Close            0    0    0               00 
  11 Close            0    0    0               00 
  12 Null             0    4    5               00 r[4..5]=NULL
REG[4] =  NULL
  13 OpenWrite        1    1    3 5             00 root=1 iDb=3; sqlite_master
  14 Explain         14    0    0 SEARCH TABLE sqlite_master USING INTEGER PRIMARY KEY (rowid=?) 00 
  15 SeekRowid        1   17    1               00 intkey=r[1]
REG[1] =  i:2
  16 Rowid            1    5    0               00 r[5]=rowid
REG[5] =  i:2
  17 IsNull           5   25    0               00 if r[5]==NULL goto 25
REG[5] =  i:2
  18 String8          0    6    0 table         00 r[6]='table'
REG[6] =   t5[table](8)
  19 String8          0    7    0 ex            00 r[7]='ex'
REG[7] =   t2[ex](8)
  20 String8          0    8    0 ex            00 r[8]='ex'
REG[8] =   t2[ex](8)
  21 Copy             2    9    0               00 r[9]=r[2]
REG[9] =  i:3
  22 String8          0   10    0 CREATE TABLE ex(i1) 00 r[10]='CREATE TABLE ex(i1)'
REG[10] =   t19[CREATE TABLE ex(i1)](8)
  23 MakeRecord       6    5    4 BBBDB         00 r[4]=mkrec(r[6..10])
REG[6] =   t5[table](8)
REG[7] =   t2[ex](8)
REG[8] =   t2[ex](8)
REG[9] =  i:3
REG[10] =   t19[CREATE TABLE ex(i1)](8)
REG[4] =  sx35[0617111101337461626C656578657803435245415445205441|.....3tableexex.CREATE TA]
  24 Insert           1    4    5               00 intkey=r[5] data=r[4]
REG[4] =  sx35[0617111101337461626C656578657803435245415445205441|.....3tableexex.CREATE TA]
REG[5] =  i:2
  25 SetCookie        3    1    2               00 
  26 ParseSchema      3    0    0 tbl_name='ex' AND type!='trigger' 00 
parser: [[[SELECT*FROM"vacuum_db".sqlite_master WHERE tbl_name='ex' AND type!='trigger' ORDER BY rowid]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'STAR' in state 288
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 95 [sclp ::=].
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STAR', pending reduce 97
parser: Return. Stack=[SELECT distinct sclp scanpt STAR]
parser: Input 'FROM' with pending reduce 97
parser: Reduce 97 [selcollist ::= sclp scanpt STAR], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 104 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'DOT' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 350
parser: Shift 'DOT', go to state 245
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID' in state 245
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'WHERE' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 245.
parser: ... then shift 'nm', pending reduce 110
parser: Reduce 110 [dbnm ::= DOT nm], go to state 350.
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 123 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 349
parser: Reduce 122 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 348
parser: Reduce 127 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 105
parser: Reduce 105 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 102 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 363
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[SELECT distinct selcollist from WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 419
parser: Return. Stack=[SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr EQ STRING]
parser: Input 'AND' in state 539
parser: Reduce 172 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 186 [expr ::= expr EQ|NE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'AND', go to state 120
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID' in state 120
parser: Shift 'ID', go to state 419
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'NE' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Shift 'NE', go to state 117
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr NE]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr NE STRING]
parser: Input 'ORDER' in state 539
parser: Reduce 172 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 186 [expr ::= expr EQ|NE expr], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Reduce 183 [expr ::= expr AND expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 148 [where_opt ::= WHERE expr], go to state 363.
parser: ... then shift 'where_opt', go to state 362
parser: Reduce 138 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 361
parser: Reduce 140 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 517
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 517
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 419
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 134 [sortorder ::=].
parser: ... then shift 'sortorder', go to state 353
parser: Reduce 137 [nulls ::=].
parser: ... then shift 'nulls', pending reduce 131
parser: Reduce 131 [sortlist ::= expr sortorder nulls], go to state 26.
parser: ... then shift 'sortlist', go to state 516
parser: Reduce 129 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 360
parser: Reduce 142 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 88
parser: Reduce 88 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 83 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 80
parser: Reduce 80 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
VDBE Trace:
   0 Init             0   17    0               00 Start at 17
  17 Transaction      3    0    2 0             00 usesStmtJournal=0
  18 String8          0    2    0 ex            00 r[2]='ex'
REG[2] =   t2[ex](8)
  19 String8          0    3    0 trigger       00 r[3]='trigger'
REG[3] =   t7[trigger](8)
  20 Goto             0    1    0               00 
   1 Noop             1    7    0               00 
   2 OpenRead         0    1    3 5             00 root=1 iDb=3; sqlite_master
   3 Explain          3    0    0 SCAN TABLE sqlite_master 00 
   4 Rewind           0   16    0               00 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s1[a](8)
   6 Ne               2   15    1 (BINARY)      52 if r[1]!=r[2] goto 15
REG[2] =   t2[ex](8)
REG[1] =   s1[a](8)
  15 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s2[ex](8)
   6 Ne               2   15    1 (BINARY)      52 if r[1]!=r[2] goto 15
REG[2] =   t2[ex](8)
REG[1] =   s2[ex](8)
   7 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s5[table](8)
   8 Eq               3   15    1 (BINARY)      52 if r[1]==r[3] goto 15
REG[3] =   t7[trigger](8)
REG[1] =   s5[table](8)
   9 Column           0    0    4               00 r[4]=sqlite_master.type
REG[4] =   s5[table](8)
  10 Column           0    1    5               00 r[5]=sqlite_master.name
REG[5] =   s2[ex](8)
  11 Column           0    2    6               00 r[6]=sqlite_master.tbl_name
REG[6] =   s2[ex](8)
  12 Column           0    3    7               00 r[7]=sqlite_master.rootpage
REG[7] =  i:3
  13 Column           0    4    8               00 r[8]=sqlite_master.sql
REG[8] =   s19[CREATE TABLE ex(i1)](8)
  14 ResultRow        4    5    0               00 output=r[4..8]
REG[4] =   s5[table](8)
REG[5] =   s2[ex](8)
REG[6] =   s2[ex](8)
REG[7] =  i:3
REG[8] =   s19[CREATE TABLE ex(i1)](8)
parser: [[[CREATE TABLE ex(i1)]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 390
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 0.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP ID]
parser: Input 'RP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 192
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 379
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 152
parser: Reduce 336 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Reduce 61 [conslist_opt ::=].
parser: ... then shift 'conslist_opt', go to state 540
parser: Shift 'RP', go to state 364
parser: Return. Stack=[create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 364
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: ... then shift 'create_table_args', pending reduce 334
parser: Reduce 334 [cmd ::= create_table create_table_args], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
  15 Next             0    5    0               01 
  16 Halt             0    0    0               00 
  27 Halt             0    0    0               00 
  14 Next             0    4    0               01 
   4 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s5[index](8)
   5 Ne               2   14    1 (BINARY)      52 if r[1]!=r[2] goto 14
REG[2] =   t5[table](8)
REG[1] =   s5[index](8)
  14 Next             0    4    0               01 
   4 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s4[view](8)
   5 Ne               2   14    1 (BINARY)      52 if r[1]!=r[2] goto 14
REG[2] =   t5[table](8)
REG[1] =   s4[view](8)
  14 Next             0    4    0               01 
  15 Halt             0    0    0               00 
parser: [[[SELECT sql FROM "main".sqlite_master WHERE type='index']]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 95 [sclp ::=].
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 419
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'FROM' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 104 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'DOT' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 350
parser: Shift 'DOT', go to state 245
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID' in state 245
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'WHERE' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 245.
parser: ... then shift 'nm', pending reduce 110
parser: Reduce 110 [dbnm ::= DOT nm], go to state 350.
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 123 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 349
parser: Reduce 122 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 348
parser: Reduce 127 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 105
parser: Reduce 105 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 102 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 363
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[SELECT distinct selcollist from WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 419
parser: Return. Stack=[SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr EQ STRING]
parser: Input 'SEMI' in state 539
parser: Reduce 172 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 186 [expr ::= expr EQ|NE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 148 [where_opt ::= WHERE expr], go to state 363.
parser: ... then shift 'where_opt', go to state 362
parser: Reduce 138 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 361
parser: Reduce 140 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 128 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 360
parser: Reduce 142 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 88
parser: Reduce 88 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 83 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 80
parser: Reduce 80 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
SQL: [SELECT sql FROM "main".sqlite_master WHERE type='index']
VDBE Trace:
   0 Init             0   10    0               00 Start at 10
  10 Transaction      0    0    5 0             01 usesStmtJournal=0
  11 String8          0    2    0 index         00 r[2]='index'
REG[2] =   t5[index](8)
  12 Goto             0    1    0               00 
   1 OpenRead         0    1    0 5             00 root=1 iDb=0; sqlite_master
   2 Explain          2    0    0 SCAN TABLE sqlite_master 00 
   3 Rewind           0    9    0               00 
   4 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s4[view](8)
   5 Ne               2    8    1 (BINARY)      52 if r[1]!=r[2] goto 8
REG[2] =   t5[index](8)
REG[1] =   s4[view](8)
   8 Next             0    4    0               01 
   4 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s5[table](8)
   5 Ne               2    8    1 (BINARY)      52 if r[1]!=r[2] goto 8
REG[2] =   t5[index](8)
REG[1] =   s5[table](8)
   8 Next             0    4    0               01 
   4 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s5[table](8)
   5 Ne               2    8    1 (BINARY)      52 if r[1]!=r[2] goto 8
REG[2] =   t5[index](8)
REG[1] =   s5[table](8)
   8 Next             0    4    0               01 
   4 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s5[index](8)
   5 Ne               2    8    1 (BINARY)      52 if r[1]!=r[2] goto 8
REG[2] =   t5[index](8)
REG[1] =   s5[index](8)
   6 Column           0    4    3               00 r[3]=sqlite_master.sql
REG[3] =   s38[CREATE INDEX i2 ON a(b CO](8)
   7 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s38[CREATE INDEX i2 ON a(b CO](8)
parser: [[[CREATE INDEX i2 ON a(b COLLATE binary)]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'INDEX' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 225 [uniqueflag ::=].
parser: ... then shift 'uniqueflag', go to state 456
parser: Shift 'INDEX', go to state 315
parser: Return. Stack=[createkw uniqueflag INDEX]
parser: Input 'ID' in state 315
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 225
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists ID]
parser: Input 'ON' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 225.
parser: ... then shift 'nm', go to state 314
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 455
parser: Shift 'ON', go to state 224
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON]
parser: Input 'ID' in state 224
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON ID]
parser: Input 'LP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 224.
parser: ... then shift 'nm', go to state 454
parser: Shift 'LP', go to state 18
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP]
parser: Input 'ID' in state 18
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP ID]
parser: Input 'COLLATE' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 18.
parser: ... then shift 'expr', go to state 13
parser: Shift 'COLLATE', go to state 418
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP expr COLLATE]
parser: Input 'ID' in state 418
parser: Shift 'ID', pending reduce 175
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP expr COLLATE ID]
parser: Input 'RP' with pending reduce 175
parser: Reduce 175 [expr ::= expr COLLATE ID|STRING], go to state 18.
parser: ... then shift 'expr', go to state 13
parser: Reduce 134 [sortorder ::=].
parser: ... then shift 'sortorder', go to state 353
parser: Reduce 137 [nulls ::=].
parser: ... then shift 'nulls', pending reduce 131
parser: Reduce 131 [sortlist ::= expr sortorder nulls], go to state 18.
parser: ... then shift 'sortlist', go to state 402
parser: Shift 'RP', go to state 313
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP]
parser: Input 'SEMI' in state 313
parser: Reduce 147 [where_opt ::=].
parser: ... then shift 'where_opt', pending reduce 223
parser: Reduce 223 [cmd ::= createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP where_opt], go to state 0.
parser: [[[INSERT INTO 'vacuum_db'.sqlite_master VALUES('index','i2','a',#1,'CREATE INDEX i2 ON a(b COLLATE binary)');]]]
parser: Input 'INSERT' in state 0
parser: Reduce 380 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'INSERT', go to state 311
parser: Return. Stack=[with INSERT]
parser: Input 'INTO' in state 311
parser: Reduce 71 [orconf ::=].
parser: ... then shift 'orconf', pending reduce 160
parser: Reduce 160 [insert_cmd ::= INSERT orconf], go to state 219.
parser: ... then shift 'insert_cmd', go to state 430
parser: Shift 'INTO', go to state 166
parser: Return. Stack=[with insert_cmd INTO]
parser: Input 'STRING' in state 166
parser: Shift 'STRING', pending reduce 338
parser: Return. Stack=[with insert_cmd INTO STRING]
parser: Input 'DOT' with pending reduce 338
parser: Reduce 338 [nm ::= STRING], go to state 166.
parser: ... then shift 'nm', go to state 395
parser: Shift 'DOT', go to state 218
parser: Return. Stack=[with insert_cmd INTO nm DOT]
parser: Input 'ID' in state 218
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[with insert_cmd INTO nm DOT ID]
parser: Input 'VALUES' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 218.
parser: ... then shift 'nm', go to state 432
parser: Reduce 114 [xfullname ::= nm DOT nm], go to state 166.
parser: ... then shift 'xfullname', go to state 298
parser: Reduce 162 [idlist_opt ::=].
parser: ... then shift 'idlist_opt', go to state 35
parser: Shift 'VALUES', go to state 528
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES]
parser: Input 'LP' in state 528
parser: Shift 'LP', go to state 28
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP]
parser: Input 'STRING' in state 28
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP STRING]
parser: Input 'COMMA' in state 539
parser: Reduce 172 [term ::= STRING], go to state 28.
parser: ... then shift 'term', go to state 70
parser: Reduce 220 [nexprlist ::= expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 413
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'STRING' in state 107
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA STRING]
parser: Input 'COMMA' in state 539
parser: Reduce 172 [term ::= STRING], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 219 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 413
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'STRING' in state 107
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA STRING]
parser: Input 'COMMA' in state 539
parser: Reduce 172 [term ::= STRING], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 219 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 413
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'VARIABLE' in state 107
parser: Shift 'VARIABLE', pending reduce 174
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA VARIABLE]
parser: Input 'COMMA' with pending reduce 174
parser: Reduce 174 [expr ::= VARIABLE], go to state 107.
parser: ... then shift 'expr', go to state 71
parser: Reduce 219 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 413
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'STRING' in state 107
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA STRING]
parser: Input 'RP' in state 539
parser: Reduce 172 [term ::= STRING], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 219 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 413
parser: Shift 'RP', pending reduce 90
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist RP]
parser: Input 'SEMI' with pending reduce 90
parser: Reduce 90 [values ::= VALUES LP nexprlist RP], go to state 35.
parser: ... then shift 'values', go to state 534
parser: Reduce 354 [oneselect ::= values], go to state 35.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 83 [select ::= selectnowith], go to state 35.
parser: ... then shift 'select', go to state 297
parser: Reduce 156 [upsert ::=].
parser: ... then shift 'upsert', pending reduce 154
parser: Reduce 154 [cmd ::= with insert_cmd INTO xfullname idlist_opt select upsert], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Input '$' with pending reduce 327
parser: Reduce 327 [ecmd ::= cmdx SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 323 [input ::= cmdlist], go to state 0.
parser: ... then shift 'input', pending reduce -2
parser: Accept!
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
SQL: [CREATE INDEX i2 ON a(b COLLATE binary)]
VDBE Trace:
   0 Init             0   32    0               00 Start at 32
  32 Transaction      3    1    2 0             01 usesStmtJournal=1
  33 Goto             0    1    0               00 
   1 Noop             0   31    0               00 
   2 CreateBtree      3    1    2               00 r[1]=root iDb=3 flags=2
REG[1] =  i:4
   3 OpenWrite        0    1    3 5             00 root=1 iDb=3; sqlite_master
   4 NewRowid         0    2    0               00 r[2]=rowid
REG[2] =  i:3
   5 String8          0    3    0 index         00 r[3]='index'
REG[3] =   t5[index](8)
   6 String8          0    4    0 i2            00 r[4]='i2'
REG[4] =   t2[i2](8)
   7 String8          0    5    0 a             00 r[5]='a'
REG[5] =   t1[a](8)
   8 Copy             1    6    0               00 r[6]=r[1]
REG[6] =  i:4
   9 String8          0    7    0 CREATE INDEX i2 ON a(b COLLATE binary) 00 r[7]='CREATE INDEX i2 ON a(b COLLATE binary)'
REG[7] =   t38[CREATE INDEX i2 ON a(b CO](8)
  10 MakeRecord       3    5    8 BBBDB         00 r[8]=mkrec(r[3..7])
REG[3] =   t5[index](8)
REG[4] =   t2[i2](8)
REG[5] =   t1[a](8)
REG[6] =  i:4
REG[7] =   t38[CREATE INDEX i2 ON a(b CO](8)
REG[8] =  sx53[0617110F0159696E6465786932610443524541544520494E44|.....Yindexi2a.CREATE IND]
  11 Insert           0    8    2               18 intkey=r[2] data=r[8]
REG[8] =  sx53[0617110F0159696E6465786932610443524541544520494E44|.....Yindexi2a.CREATE IND]
REG[2] =  i:3
  12 SorterOpen       3    0    1 k(1,B)        00 
  13 OpenRead         1    2    3 k(1,)         00 root=2 iDb=3; a
  14 Rewind           1   19    0               00 
  19 OpenWrite        2    1    3 k(1,B)        11 root=1 iDb=3
  20 SorterSort       3   25    0               00 
  25 Close            1    0    0               00 
  26 Close            2    0    0               00 
  27 Close            3    0    0               00 
  28 SetCookie        3    1    3               00 
  29 ParseSchema      3    0    0 name='i2' AND type='index' 00 
parser: [[[SELECT*FROM"vacuum_db".sqlite_master WHERE name='i2' AND type='index' ORDER BY rowid]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'STAR' in state 288
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 95 [sclp ::=].
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STAR', pending reduce 97
parser: Return. Stack=[SELECT distinct sclp scanpt STAR]
parser: Input 'FROM' with pending reduce 97
parser: Reduce 97 [selcollist ::= sclp scanpt STAR], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 104 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'DOT' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 350
parser: Shift 'DOT', go to state 245
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID' in state 245
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'WHERE' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 245.
parser: ... then shift 'nm', pending reduce 110
parser: Reduce 110 [dbnm ::= DOT nm], go to state 350.
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 123 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 349
parser: Reduce 122 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 348
parser: Reduce 127 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 105
parser: Reduce 105 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 102 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 363
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[SELECT distinct selcollist from WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 419
parser: Return. Stack=[SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr EQ STRING]
parser: Input 'AND' in state 539
parser: Reduce 172 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 186 [expr ::= expr EQ|NE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'AND', go to state 120
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID' in state 120
parser: Shift 'ID', go to state 419
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'EQ' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr EQ]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr EQ STRING]
parser: Input 'ORDER' in state 539
parser: Reduce 172 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 186 [expr ::= expr EQ|NE expr], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Reduce 183 [expr ::= expr AND expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 148 [where_opt ::= WHERE expr], go to state 363.
parser: ... then shift 'where_opt', go to state 362
parser: Reduce 138 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 361
parser: Reduce 140 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 517
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 517
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 419
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 134 [sortorder ::=].
parser: ... then shift 'sortorder', go to state 353
parser: Reduce 137 [nulls ::=].
parser: ... then shift 'nulls', pending reduce 131
parser: Reduce 131 [sortlist ::= expr sortorder nulls], go to state 26.
parser: ... then shift 'sortlist', go to state 516
parser: Reduce 129 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 360
parser: Reduce 142 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 88
parser: Reduce 88 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 83 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 80
parser: Reduce 80 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
VDBE Trace:
   0 Init             0   17    0               00 Start at 17
  17 Transaction      3    0    3 0             00 usesStmtJournal=0
  18 String8          0    2    0 i2            00 r[2]='i2'
REG[2] =   t2[i2](8)
  19 String8          0    3    0 index         00 r[3]='index'
REG[3] =   t5[index](8)
  20 Goto             0    1    0               00 
   1 Noop             1    7    0               00 
   2 OpenRead         0    1    3 5             00 root=1 iDb=3; sqlite_master
   3 Explain          3    0    0 SCAN TABLE sqlite_master 00 
   4 Rewind           0   16    0               00 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s1[a](8)
   6 Ne               2   15    1 (BINARY)      52 if r[1]!=r[2] goto 15
REG[2] =   t2[i2](8)
REG[1] =   s1[a](8)
  15 Next             0    5    0               01 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s2[ex](8)
   6 Ne               2   15    1 (BINARY)      52 if r[1]!=r[2] goto 15
REG[2] =   t2[i2](8)
REG[1] =   s2[ex](8)
  15 Next             0    5    0               01 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s2[i2](8)
   6 Ne               2   15    1 (BINARY)      52 if r[1]!=r[2] goto 15
REG[2] =   t2[i2](8)
REG[1] =   s2[i2](8)
   7 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s5[index](8)
   8 Ne               3   15    1 (BINARY)      52 if r[1]!=r[3] goto 15
REG[3] =   t5[index](8)
REG[1] =   s5[index](8)
   9 Column           0    0    4               00 r[4]=sqlite_master.type
REG[4] =   s5[index](8)
  10 Column           0    1    5               00 r[5]=sqlite_master.name
REG[5] =   s2[i2](8)
  11 Column           0    2    6               00 r[6]=sqlite_master.tbl_name
REG[6] =   s1[a](8)
  12 Column           0    3    7               00 r[7]=sqlite_master.rootpage
REG[7] =  i:4
  13 Column           0    4    8               00 r[8]=sqlite_master.sql
REG[8] =   s38[CREATE INDEX i2 ON a(b CO](8)
  14 ResultRow        4    5    0               00 output=r[4..8]
REG[4] =   s5[index](8)
REG[5] =   s2[i2](8)
REG[6] =   s1[a](8)
REG[7] =  i:4
REG[8] =   s38[CREATE INDEX i2 ON a(b CO](8)
parser: [[[CREATE INDEX i2 ON a(b COLLATE binary)]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'INDEX' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 225 [uniqueflag ::=].
parser: ... then shift 'uniqueflag', go to state 456
parser: Shift 'INDEX', go to state 315
parser: Return. Stack=[createkw uniqueflag INDEX]
parser: Input 'ID' in state 315
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 225
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists ID]
parser: Input 'ON' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 225.
parser: ... then shift 'nm', go to state 314
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 455
parser: Shift 'ON', go to state 224
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON]
parser: Input 'ID' in state 224
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON ID]
parser: Input 'LP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 224.
parser: ... then shift 'nm', go to state 454
parser: Shift 'LP', go to state 18
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP]
parser: Input 'ID' in state 18
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP ID]
parser: Input 'COLLATE' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 18.
parser: ... then shift 'expr', go to state 13
parser: Shift 'COLLATE', go to state 418
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP expr COLLATE]
parser: Input 'ID' in state 418
parser: Shift 'ID', pending reduce 175
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP expr COLLATE ID]
parser: Input 'RP' with pending reduce 175
parser: Reduce 175 [expr ::= expr COLLATE ID|STRING], go to state 18.
parser: ... then shift 'expr', go to state 13
parser: Reduce 134 [sortorder ::=].
parser: ... then shift 'sortorder', go to state 353
parser: Reduce 137 [nulls ::=].
parser: ... then shift 'nulls', pending reduce 131
parser: Reduce 131 [sortlist ::= expr sortorder nulls], go to state 18.
parser: ... then shift 'sortlist', go to state 402
parser: Shift 'RP', go to state 313
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP]
parser: Input 'SEMI' in state 313
parser: Reduce 147 [where_opt ::=].
parser: ... then shift 'where_opt', pending reduce 223
parser: Reduce 223 [cmd ::= createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP where_opt], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
  15 Next             0    5    0               01 
  16 Halt             0    0    0               00 
  30 Expire           0    1    0               00 
  31 Halt             0    0    0               00 
   8 Next             0    4    0               01 
   4 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s4[view](8)
   5 Ne               2    8    1 (BINARY)      52 if r[1]!=r[2] goto 8
REG[2] =   t5[index](8)
REG[1] =   s4[view](8)
   8 Next             0    4    0               01 
   9 Halt             0    0    0               00 
parser: [[[SELECT'INSERT INTO vacuum_db.'||quote(name)||' SELECT*FROM"main".'||quote(name)FROM vacuum_db.sqlite_master WHERE type='table'AND coalesce(rootpage,1)>0]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'STRING' in state 288
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 95 [sclp ::=].
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[SELECT distinct sclp scanpt STRING]
parser: Input 'CONCAT' in state 539
parser: Reduce 172 [term ::= STRING], go to state 77.
parser: ... then shift 'term', go to state 16
parser: Shift 'CONCAT', go to state 113
parser: Return. Stack=[SELECT distinct sclp scanpt term CONCAT]
parser: Input 'ID' in state 113
parser: Shift 'ID', go to state 419
parser: Return. Stack=[SELECT distinct sclp scanpt term CONCAT ID]
parser: Input 'LP' in state 419
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt term CONCAT ID LP]
parser: Input 'ID' in state 266
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 419
parser: Return. Stack=[SELECT distinct sclp scanpt term CONCAT ID LP distinct ID]
parser: Input 'RP' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 220 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 519
parser: Reduce 359 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 484
parser: Shift 'RP', go to state 146
parser: Return. Stack=[SELECT distinct sclp scanpt term CONCAT ID LP distinct exprlist RP]
parser: Input 'CONCAT' in state 146
parser: Reduce 177 [expr ::= ID|INDEXED LP distinct exprlist RP], go to state 113.
parser: ... then shift 'expr', go to state 148
parser: Reduce 190 [expr ::= expr CONCAT expr], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Shift 'CONCAT', go to state 113
parser: Return. Stack=[SELECT distinct sclp scanpt expr CONCAT]
parser: Input 'STRING' in state 113
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[SELECT distinct sclp scanpt expr CONCAT STRING]
parser: Input 'CONCAT' in state 539
parser: Reduce 172 [term ::= STRING], go to state 113.
parser: ... then shift 'term', go to state 148
parser: Reduce 190 [expr ::= expr CONCAT expr], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Shift 'CONCAT', go to state 113
parser: Return. Stack=[SELECT distinct sclp scanpt expr CONCAT]
parser: Input 'ID' in state 113
parser: Shift 'ID', go to state 419
parser: Return. Stack=[SELECT distinct sclp scanpt expr CONCAT ID]
parser: Input 'LP' in state 419
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct sclp scanpt expr CONCAT ID LP]
parser: Input 'ID' in state 266
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 419
parser: Return. Stack=[SELECT distinct sclp scanpt expr CONCAT ID LP distinct ID]
parser: Input 'RP' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 220 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 519
parser: Reduce 359 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 484
parser: Shift 'RP', go to state 146
parser: Return. Stack=[SELECT distinct sclp scanpt expr CONCAT ID LP distinct exprlist RP]
parser: Input 'FROM' in state 146
parser: Reduce 177 [expr ::= ID|INDEXED LP distinct exprlist RP], go to state 113.
parser: ... then shift 'expr', go to state 148
parser: Reduce 190 [expr ::= expr CONCAT expr], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 104 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'DOT' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 350
parser: Shift 'DOT', go to state 245
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID' in state 245
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'WHERE' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 245.
parser: ... then shift 'nm', pending reduce 110
parser: Reduce 110 [dbnm ::= DOT nm], go to state 350.
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 123 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 349
parser: Reduce 122 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 348
parser: Reduce 127 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 105
parser: Reduce 105 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 102 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 363
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[SELECT distinct selcollist from WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 419
parser: Return. Stack=[SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr EQ STRING]
parser: Input 'AND' in state 539
parser: Reduce 172 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 186 [expr ::= expr EQ|NE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'AND', go to state 120
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID' in state 120
parser: Shift 'ID', go to state 419
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'LP' in state 419
parser: Shift 'LP', go to state 266
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND ID LP]
parser: Input 'ID' in state 266
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 419
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND ID LP distinct ID]
parser: Input 'COMMA' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 220 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 519
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND ID LP distinct nexprlist COMMA]
parser: Input 'INTEGER' in state 107
parser: Shift 'INTEGER', pending reduce 173
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND ID LP distinct nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 173
parser: Reduce 173 [term ::= INTEGER], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 219 [nexprlist ::= nexprlist COMMA expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 519
parser: Reduce 359 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 484
parser: Shift 'RP', go to state 146
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND ID LP distinct exprlist RP]
parser: Input 'GT' in state 146
parser: Reduce 177 [expr ::= ID|INDEXED LP distinct exprlist RP], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Shift 'GT', go to state 118
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr GT]
parser: Input 'INTEGER' in state 118
parser: Shift 'INTEGER', pending reduce 173
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr GT INTEGER]
parser: Input 'SEMI' with pending reduce 173
parser: Reduce 173 [term ::= INTEGER], go to state 118.
parser: ... then shift 'term', go to state 130
parser: Reduce 185 [expr ::= expr LT|GT|GE|LE expr], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Reduce 183 [expr ::= expr AND expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 148 [where_opt ::= WHERE expr], go to state 363.
parser: ... then shift 'where_opt', go to state 362
parser: Reduce 138 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 361
parser: Reduce 140 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 128 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 360
parser: Reduce 142 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 88
parser: Reduce 88 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 83 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 80
parser: Reduce 80 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
SQL: [SELECT'INSERT INTO vacuum_db.'||quote(name)||' SELECT*FROM"main".'||quote(name)FROM vacuum_db.sqlite_master WHERE type='table'AND coalesce(rootpage,1)>0]
VDBE Trace:
   0 Init             0   20    0               00 Start at 20
  20 Transaction      3    0    3 0             01 usesStmtJournal=0
  21 String8          0    2    0 table         00 r[2]='table'
REG[2] =   t5[table](8)
  22 Integer          0    3    0               00 r[3]=0
REG[3] =  i:0
  23 String8          0    6    0 INSERT INTO vacuum_db. 00 r[6]='INSERT INTO vacuum_db.'
REG[6] =   t22[INSERT INTO vacuum_db.](8)
  24 String8          0    9    0  SELECT*FROM"main". 00 r[9]=' SELECT*FROM"main".'
REG[9] =   t19[ SELECT*FROM"main".](8)
  25 Goto             0    1    0               00 
   1 OpenRead         0    1    3 4             00 root=1 iDb=3; sqlite_master
   2 Explain          2    0    0 SCAN TABLE sqlite_master 00 
   3 Rewind           0   19    0               00 
   4 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s5[table](8)
   5 Ne               2   18    1 (BINARY)      52 if r[1]!=r[2] goto 18
REG[2] =   t5[table](8)
REG[1] =   s5[table](8)
   6 Column           0    3    1               00 r[1]=sqlite_master.rootpage
REG[1] =  i:2
   7 NotNull          1    9    0               00 if r[1]!=NULL goto 9
REG[1] =  i:2
   9 Le               3   18    1               50 if r[1]<=r[3] goto 18
REG[3] =  i:0
REG[1] =  i:2
  10 Column           0    1    8               00 r[8]=sqlite_master.name
REG[8] =   s1[a](8)
  11 Function0        0    8    7 quote(1)      01 r[7]=func(r[8])
REG[8] =   s1[a](8)
REG[7] =   z3['a'](8)
  12 Concat           7    6    5               00 r[5]=r[6]+r[7]
REG[7] =   z3['a'](8)
REG[6] =   t22[INSERT INTO vacuum_db.](8)
REG[5] =   s25[INSERT INTO vacuum_db.'a'](8)
  13 Concat           9    5    1               00 r[1]=r[5]+r[9]
REG[9] =   t19[ SELECT*FROM"main".](8)
REG[5] =   s25[INSERT INTO vacuum_db.'a'](8)
REG[1] =   s44[INSERT INTO vacuum_db.'a'](8)
  14 Column           0    1    7               00 r[7]=sqlite_master.name
REG[7] =   s1[a](8)
  15 Function0        0    7    5 quote(1)      01 r[5]=func(r[7])
REG[7] =   s1[a](8)
REG[5] =   z3['a'](8)
  16 Concat           5    1    4               00 r[4]=r[1]+r[5]
REG[5] =   z3['a'](8)
REG[1] =   s44[INSERT INTO vacuum_db.'a'](8)
REG[4] =   s47[INSERT INTO vacuum_db.'a'](8)
  17 ResultRow        4    1    0               00 output=r[4]
REG[4] =   s47[INSERT INTO vacuum_db.'a'](8)
parser: [[[INSERT INTO vacuum_db.'a' SELECT*FROM"main".'a']]]
parser: Input 'INSERT' in state 0
parser: Reduce 380 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'INSERT', go to state 311
parser: Return. Stack=[with INSERT]
parser: Input 'INTO' in state 311
parser: Reduce 71 [orconf ::=].
parser: ... then shift 'orconf', pending reduce 160
parser: Reduce 160 [insert_cmd ::= INSERT orconf], go to state 219.
parser: ... then shift 'insert_cmd', go to state 430
parser: Shift 'INTO', go to state 166
parser: Return. Stack=[with insert_cmd INTO]
parser: Input 'ID' in state 166
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[with insert_cmd INTO ID]
parser: Input 'DOT' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 166.
parser: ... then shift 'nm', go to state 395
parser: Shift 'DOT', go to state 218
parser: Return. Stack=[with insert_cmd INTO nm DOT]
parser: Input 'STRING' in state 218
parser: Shift 'STRING', pending reduce 338
parser: Return. Stack=[with insert_cmd INTO nm DOT STRING]
parser: Input 'SELECT' with pending reduce 338
parser: Reduce 338 [nm ::= STRING], go to state 218.
parser: ... then shift 'nm', go to state 432
parser: Reduce 114 [xfullname ::= nm DOT nm], go to state 166.
parser: ... then shift 'xfullname', go to state 298
parser: Reduce 162 [idlist_opt ::=].
parser: ... then shift 'idlist_opt', go to state 35
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt SELECT]
parser: Input 'STAR' in state 288
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 95 [sclp ::=].
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STAR', pending reduce 97
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt SELECT distinct sclp scanpt STAR]
parser: Input 'FROM' with pending reduce 97
parser: Reduce 97 [selcollist ::= sclp scanpt STAR], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 104 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'DOT' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 350
parser: Shift 'DOT', go to state 245
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'STRING' in state 245
parser: Shift 'STRING', pending reduce 338
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt SELECT distinct selcollist FROM stl_prefix nm DOT STRING]
parser: Input 'SEMI' with pending reduce 338
parser: Reduce 338 [nm ::= STRING], go to state 245.
parser: ... then shift 'nm', pending reduce 110
parser: Reduce 110 [dbnm ::= DOT nm], go to state 350.
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 123 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 349
parser: Reduce 122 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 348
parser: Reduce 127 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 105
parser: Reduce 105 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 102 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 363
parser: Reduce 147 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 362
parser: Reduce 138 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 361
parser: Reduce 140 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 128 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 360
parser: Reduce 142 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 88
parser: Reduce 88 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 35.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 83 [select ::= selectnowith], go to state 35.
parser: ... then shift 'select', go to state 297
parser: Reduce 156 [upsert ::=].
parser: ... then shift 'upsert', pending reduce 154
parser: Reduce 154 [cmd ::= with insert_cmd INTO xfullname idlist_opt select upsert], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
SQL: [INSERT INTO vacuum_db.'a' SELECT*FROM"main".'a']
VDBE Trace:
   0 Init             0   21    0               00 Start at 21
  21 Transaction      0    0    5 0             01 usesStmtJournal=0
  22 Transaction      3    1    3 0             01 usesStmtJournal=0
  23 Goto             0    1    0               00 
   1 OpenWrite        1    2    3 k(1,)         00 root=2 iDb=3; a
   2 OpenRead         0    4    0 k(1,B)        00 root=4 iDb=0; i2
   3 OpenWrite        1    4    3 k(1,B)        01 root=4 iDb=3; i2
   4 Rewind           0    9    0               00 
   5 RowData          0    1    1               00 r[1]=data
REG[1] =  ex2[0209|..]
   6 SeekEnd          1    0    0               00 
   7 IdxInsert        1    1    0               18 key=r[1]
REG[1] =  ex2[0209|..]
   8 Next             0    5    0               00 
   5 RowData          0    1    1               00 r[1]=data
REG[1] =  ex3[020102|...]
   6 SeekEnd          1    0    0               00 
   7 IdxInsert        1    1    0               18 key=r[1]
REG[1] =  ex3[020102|...]
   8 Next             0    5    0               00 
   5 RowData          0    1    1               00 r[1]=data
REG[1] =  ex3[020103|...]
   6 SeekEnd          1    0    0               00 
   7 IdxInsert        1    1    0               18 key=r[1]
REG[1] =  ex3[020103|...]
   8 Next             0    5    0               00 
   5 RowData          0    1    1               00 r[1]=data
REG[1] =  ex3[020104|...]
   6 SeekEnd          1    0    0               00 
   7 IdxInsert        1    1    0               18 key=r[1]
REG[1] =  ex3[020104|...]
   8 Next             0    5    0               00 
   5 RowData          0    1    1               00 r[1]=data
REG[1] =  ex3[020105|...]
   6 SeekEnd          1    0    0               00 
   7 IdxInsert        1    1    0               18 key=r[1]
REG[1] =  ex3[020105|...]
   8 Next             0    5    0               00 
   5 RowData          0    1    1               00 r[1]=data
REG[1] =  ex3[020106|...]
   6 SeekEnd          1    0    0               00 
   7 IdxInsert        1    1    0               18 key=r[1]
REG[1] =  ex3[020106|...]
   8 Next             0    5    0               00 
   5 RowData          0    1    1               00 r[1]=data
REG[1] =  ex3[020107|...]
   6 SeekEnd          1    0    0               00 
   7 IdxInsert        1    1    0               18 key=r[1]
REG[1] =  ex3[020107|...]
   8 Next             0    5    0               00 
   5 RowData          0    1    1               00 r[1]=data
REG[1] =  ex3[020108|...]
   6 SeekEnd          1    0    0               00 
   7 IdxInsert        1    1    0               18 key=r[1]
REG[1] =  ex3[020108|...]
   8 Next             0    5    0               00 
   5 RowData          0    1    1               00 r[1]=data
REG[1] =  ex3[020109|...]
   6 SeekEnd          1    0    0               00 
   7 IdxInsert        1    1    0               18 key=r[1]
REG[1] =  ex3[020109|...]
   8 Next             0    5    0               00 
   9 Close            0    0    0               00 
  10 Close            1    0    0               00 
  11 OpenRead         0    2    0 k(1,)         00 root=2 iDb=0; sqlite_autoindex_a_1
  12 OpenWrite        1    2    3 k(1,)         01 root=2 iDb=3; sqlite_autoindex_a_1
  13 Rewind           0   18    0               00 
  14 RowData          0    1    1               00 r[1]=data
REG[1] =  ex2[0209|..]
  15 SeekEnd          1    0    0               00 
  16 IdxInsert        1    1    0               19 key=r[1]
REG[1] =  ex2[0209|..]
  17 Next             0   14    0               00 
  14 RowData          0    1    1               00 r[1]=data
REG[1] =  ex3[020102|...]
  15 SeekEnd          1    0    0               00 
  16 IdxInsert        1    1    0               19 key=r[1]
REG[1] =  ex3[020102|...]
  17 Next             0   14    0               00 
  14 RowData          0    1    1               00 r[1]=data
REG[1] =  ex3[020103|...]
  15 SeekEnd          1    0    0               00 
  16 IdxInsert        1    1    0               19 key=r[1]
REG[1] =  ex3[020103|...]
  17 Next             0   14    0               00 
  14 RowData          0    1    1               00 r[1]=data
REG[1] =  ex3[020104|...]
  15 SeekEnd          1    0    0               00 
  16 IdxInsert        1    1    0               19 key=r[1]
REG[1] =  ex3[020104|...]
  17 Next             0   14    0               00 
  14 RowData          0    1    1               00 r[1]=data
REG[1] =  ex3[020105|...]
  15 SeekEnd          1    0    0               00 
  16 IdxInsert        1    1    0               19 key=r[1]
REG[1] =  ex3[020105|...]
  17 Next             0   14    0               00 
  14 RowData          0    1    1               00 r[1]=data
REG[1] =  ex3[020106|...]
  15 SeekEnd          1    0    0               00 
  16 IdxInsert        1    1    0               19 key=r[1]
REG[1] =  ex3[020106|...]
  17 Next             0   14    0               00 
  14 RowData          0    1    1               00 r[1]=data
REG[1] =  ex3[020107|...]
  15 SeekEnd          1    0    0               00 
  16 IdxInsert        1    1    0               19 key=r[1]
REG[1] =  ex3[020107|...]
  17 Next             0   14    0               00 
  14 RowData          0    1    1               00 r[1]=data
REG[1] =  ex3[020108|...]
  15 SeekEnd          1    0    0               00 
  16 IdxInsert        1    1    0               19 key=r[1]
REG[1] =  ex3[020108|...]
  17 Next             0   14    0               00 
  14 RowData          0    1    1               00 r[1]=data
REG[1] =  ex3[020109|...]
  15 SeekEnd          1    0    0               00 
  16 IdxInsert        1    1    0               19 key=r[1]
REG[1] =  ex3[020109|...]
  17 Next             0   14    0               00 
  18 Close            0    0    0               00 
  19 Close            1    0    0               00 
  20 Halt             0    0    0               00 
  18 Next             0    4    0               01 
   4 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s5[table](8)
   5 Ne               2   18    1 (BINARY)      52 if r[1]!=r[2] goto 18
REG[2] =   t5[table](8)
REG[1] =   s5[table](8)
   6 Column           0    3    1               00 r[1]=sqlite_master.rootpage
REG[1] =  i:3
   7 NotNull          1    9    0               00 if r[1]!=NULL goto 9
REG[1] =  i:3
   9 Le               3   18    1               50 if r[1]<=r[3] goto 18
REG[3] =  i:0
REG[1] =  i:3
  10 Column           0    1    8               00 r[8]=sqlite_master.name
REG[8] =   s2[ex](8)
  11 Function         0    8    7 quote(1)      01 r[7]=func(r[8])
REG[8] =   s2[ex](8)
REG[7] =   z4['ex'](8)
  12 Concat           7    6    5               00 r[5]=r[6]+r[7]
REG[7] =   z4['ex'](8)
REG[6] =   t22[INSERT INTO vacuum_db.](8)
REG[5] =   s26[INSERT INTO vacuum_db.'ex](8)
  13 Concat           9    5    1               00 r[1]=r[5]+r[9]
REG[9] =   t19[ SELECT*FROM"main".](8)
REG[5] =   s26[INSERT INTO vacuum_db.'ex](8)
REG[1] =   s45[INSERT INTO vacuum_db.'ex](8)
  14 Column           0    1    7               00 r[7]=sqlite_master.name
REG[7] =   s2[ex](8)
  15 Function         0    7    5 quote(1)      01 r[5]=func(r[7])
REG[7] =   s2[ex](8)
REG[5] =   z4['ex'](8)
  16 Concat           5    1    4               00 r[4]=r[1]+r[5]
REG[5] =   z4['ex'](8)
REG[1] =   s45[INSERT INTO vacuum_db.'ex](8)
REG[4] =   s49[INSERT INTO vacuum_db.'ex](8)
  17 ResultRow        4    1    0               00 output=r[4]
REG[4] =   s49[INSERT INTO vacuum_db.'ex](8)
parser: [[[INSERT INTO vacuum_db.'ex' SELECT*FROM"main".'ex']]]
parser: Input 'INSERT' in state 0
parser: Reduce 380 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'INSERT', go to state 311
parser: Return. Stack=[with INSERT]
parser: Input 'INTO' in state 311
parser: Reduce 71 [orconf ::=].
parser: ... then shift 'orconf', pending reduce 160
parser: Reduce 160 [insert_cmd ::= INSERT orconf], go to state 219.
parser: ... then shift 'insert_cmd', go to state 430
parser: Shift 'INTO', go to state 166
parser: Return. Stack=[with insert_cmd INTO]
parser: Input 'ID' in state 166
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[with insert_cmd INTO ID]
parser: Input 'DOT' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 166.
parser: ... then shift 'nm', go to state 395
parser: Shift 'DOT', go to state 218
parser: Return. Stack=[with insert_cmd INTO nm DOT]
parser: Input 'STRING' in state 218
parser: Shift 'STRING', pending reduce 338
parser: Return. Stack=[with insert_cmd INTO nm DOT STRING]
parser: Input 'SELECT' with pending reduce 338
parser: Reduce 338 [nm ::= STRING], go to state 218.
parser: ... then shift 'nm', go to state 432
parser: Reduce 114 [xfullname ::= nm DOT nm], go to state 166.
parser: ... then shift 'xfullname', go to state 298
parser: Reduce 162 [idlist_opt ::=].
parser: ... then shift 'idlist_opt', go to state 35
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt SELECT]
parser: Input 'STAR' in state 288
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 95 [sclp ::=].
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STAR', pending reduce 97
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt SELECT distinct sclp scanpt STAR]
parser: Input 'FROM' with pending reduce 97
parser: Reduce 97 [selcollist ::= sclp scanpt STAR], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 104 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'DOT' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 350
parser: Shift 'DOT', go to state 245
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'STRING' in state 245
parser: Shift 'STRING', pending reduce 338
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt SELECT distinct selcollist FROM stl_prefix nm DOT STRING]
parser: Input 'SEMI' with pending reduce 338
parser: Reduce 338 [nm ::= STRING], go to state 245.
parser: ... then shift 'nm', pending reduce 110
parser: Reduce 110 [dbnm ::= DOT nm], go to state 350.
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 123 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 349
parser: Reduce 122 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 348
parser: Reduce 127 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 105
parser: Reduce 105 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 102 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 363
parser: Reduce 147 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 362
parser: Reduce 138 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 361
parser: Reduce 140 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 128 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 360
parser: Reduce 142 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 88
parser: Reduce 88 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 35.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 83 [select ::= selectnowith], go to state 35.
parser: ... then shift 'select', go to state 297
parser: Reduce 156 [upsert ::=].
parser: ... then shift 'upsert', pending reduce 154
parser: Reduce 154 [cmd ::= with insert_cmd INTO xfullname idlist_opt select upsert], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
SQL: [INSERT INTO vacuum_db.'ex' SELECT*FROM"main".'ex']
VDBE Trace:
   0 Init             0   12    0               00 Start at 12
  12 Transaction      0    0    5 0             01 usesStmtJournal=0
  13 Transaction      3    1    3 0             01 usesStmtJournal=0
  14 Goto             0    1    0               00 
   1 OpenWrite        1    3    3 1             00 root=3 iDb=3; ex
   2 OpenRead         0    3    0 1             00 root=3 iDb=0; ex
   3 Rewind           0   11    0               00 
  11 Halt             0    0    0               00 
  18 Next             0    4    0               01 
   4 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s5[index](8)
   5 Ne               2   18    1 (BINARY)      52 if r[1]!=r[2] goto 18
REG[2] =   t5[table](8)
REG[1] =   s5[index](8)
  18 Next             0    4    0               01 
  19 Halt             0    0    0               00 
parser: [[[INSERT INTO vacuum_db.sqlite_master SELECT*FROM "main".sqlite_master WHERE type IN('view','trigger') OR(type='table'AND rootpage=0)]]]
parser: Input 'INSERT' in state 0
parser: Reduce 380 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'INSERT', go to state 311
parser: Return. Stack=[with INSERT]
parser: Input 'INTO' in state 311
parser: Reduce 71 [orconf ::=].
parser: ... then shift 'orconf', pending reduce 160
parser: Reduce 160 [insert_cmd ::= INSERT orconf], go to state 219.
parser: ... then shift 'insert_cmd', go to state 430
parser: Shift 'INTO', go to state 166
parser: Return. Stack=[with insert_cmd INTO]
parser: Input 'ID' in state 166
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[with insert_cmd INTO ID]
parser: Input 'DOT' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 166.
parser: ... then shift 'nm', go to state 395
parser: Shift 'DOT', go to state 218
parser: Return. Stack=[with insert_cmd INTO nm DOT]
parser: Input 'ID' in state 218
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[with insert_cmd INTO nm DOT ID]
parser: Input 'SELECT' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 218.
parser: ... then shift 'nm', go to state 432
parser: Reduce 114 [xfullname ::= nm DOT nm], go to state 166.
parser: ... then shift 'xfullname', go to state 298
parser: Reduce 162 [idlist_opt ::=].
parser: ... then shift 'idlist_opt', go to state 35
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt SELECT]
parser: Input 'STAR' in state 288
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 95 [sclp ::=].
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STAR', pending reduce 97
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt SELECT distinct sclp scanpt STAR]
parser: Input 'FROM' with pending reduce 97
parser: Reduce 97 [selcollist ::= sclp scanpt STAR], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 104 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'DOT' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 350
parser: Shift 'DOT', go to state 245
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID' in state 245
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'WHERE' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 245.
parser: ... then shift 'nm', pending reduce 110
parser: Reduce 110 [dbnm ::= DOT nm], go to state 350.
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 123 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 349
parser: Reduce 122 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 348
parser: Reduce 127 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 105
parser: Reduce 105 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 102 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 363
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt SELECT distinct selcollist from WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 419
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt SELECT distinct selcollist from WHERE ID]
parser: Input 'IN' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'IN', pending reduce 204
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt SELECT distinct selcollist from WHERE expr IN]
parser: Input 'LP' with pending reduce 204
parser: Reduce 204 [in_op ::= IN], go to state 63.
parser: ... then shift 'in_op', go to state 209
parser: Shift 'LP', go to state 3
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt SELECT distinct selcollist from WHERE expr in_op LP]
parser: Input 'STRING' in state 3
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt SELECT distinct selcollist from WHERE expr in_op LP STRING]
parser: Input 'COMMA' in state 539
parser: Reduce 172 [term ::= STRING], go to state 3.
parser: ... then shift 'term', go to state 70
parser: Reduce 220 [nexprlist ::= expr], go to state 3.
parser: ... then shift 'nexprlist', go to state 519
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt SELECT distinct selcollist from WHERE expr in_op LP nexprlist COMMA]
parser: Input 'STRING' in state 107
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt SELECT distinct selcollist from WHERE expr in_op LP nexprlist COMMA STRING]
parser: Input 'RP' in state 539
parser: Reduce 172 [term ::= STRING], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 219 [nexprlist ::= nexprlist COMMA expr], go to state 3.
parser: ... then shift 'nexprlist', go to state 519
parser: Reduce 359 [exprlist ::= nexprlist], go to state 3.
parser: ... then shift 'exprlist', go to state 521
parser: Shift 'RP', pending reduce 206
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt SELECT distinct selcollist from WHERE expr in_op LP exprlist RP]
parser: Input 'OR' with pending reduce 206
parser: Reduce 206 [expr ::= expr in_op LP exprlist RP], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'OR', go to state 119
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt SELECT distinct selcollist from WHERE expr OR]
parser: Input 'LP' in state 119
parser: Shift 'LP', go to state 4
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt SELECT distinct selcollist from WHERE expr OR LP]
parser: Input 'ID' in state 4
parser: Shift 'ID', go to state 419
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt SELECT distinct selcollist from WHERE expr OR LP ID]
parser: Input 'EQ' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 4.
parser: ... then shift 'expr', go to state 50
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt SELECT distinct selcollist from WHERE expr OR LP expr EQ]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt SELECT distinct selcollist from WHERE expr OR LP expr EQ STRING]
parser: Input 'AND' in state 539
parser: Reduce 172 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 186 [expr ::= expr EQ|NE expr], go to state 4.
parser: ... then shift 'expr', go to state 50
parser: Shift 'AND', go to state 120
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt SELECT distinct selcollist from WHERE expr OR LP expr AND]
parser: Input 'ID' in state 120
parser: Shift 'ID', go to state 419
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt SELECT distinct selcollist from WHERE expr OR LP expr AND ID]
parser: Input 'EQ' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt SELECT distinct selcollist from WHERE expr OR LP expr AND expr EQ]
parser: Input 'INTEGER' in state 117
parser: Shift 'INTEGER', pending reduce 173
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt SELECT distinct selcollist from WHERE expr OR LP expr AND expr EQ INTEGER]
parser: Input 'RP' with pending reduce 173
parser: Reduce 173 [term ::= INTEGER], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 186 [expr ::= expr EQ|NE expr], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Reduce 183 [expr ::= expr AND expr], go to state 4.
parser: ... then shift 'expr', go to state 50
parser: Shift 'RP', pending reduce 166
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt SELECT distinct selcollist from WHERE expr OR LP expr RP]
parser: Input 'SEMI' with pending reduce 166
parser: Reduce 166 [expr ::= LP expr RP], go to state 119.
parser: ... then shift 'expr', go to state 74
parser: Reduce 184 [expr ::= expr OR expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 148 [where_opt ::= WHERE expr], go to state 363.
parser: ... then shift 'where_opt', go to state 362
parser: Reduce 138 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 361
parser: Reduce 140 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 128 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 360
parser: Reduce 142 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 88
parser: Reduce 88 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 35.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 83 [select ::= selectnowith], go to state 35.
parser: ... then shift 'select', go to state 297
parser: Reduce 156 [upsert ::=].
parser: ... then shift 'upsert', pending reduce 154
parser: Reduce 154 [cmd ::= with insert_cmd INTO xfullname idlist_opt select upsert], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
SQL: [INSERT INTO vacuum_db.sqlite_master SELECT*FROM "main".sqlite_master WHERE type IN('view','trigger') OR(type='table'AND rootpage=0)]
VDBE Trace:
   0 Init             0   29    0               00 Start at 29
  29 Transaction      0    0    5 0             01 usesStmtJournal=0
  30 Transaction      3    1    3 0             01 usesStmtJournal=0
  31 String8          0    9    0 view          00 r[9]='view'
REG[9] =   t4[view](8)
  32 String8          0   10    0 trigger       00 r[10]='trigger'
REG[10] =   t7[trigger](8)
  33 String8          0   12    0 table         00 r[12]='table'
REG[12] =   t5[table](8)
  34 Integer          0   13    0               00 r[13]=0
REG[13] =  i:0
  35 Goto             0    1    0               00 
   1 InitCoroutine    7   22    2               00 
  22 OpenWrite        2    1    3 5             00 root=1 iDb=3; sqlite_master
  23 Yield            7   28    0               00 
REG[7] =  i:1
REG[7] =  i:23
   2 OpenRead         0    1    0 5             00 root=1 iDb=0; sqlite_master
   3 Explain          3    0    0 SCAN TABLE sqlite_master 00 
   4 Rewind           0   21    0               00 
   5 Noop             0    0    0               00 begin IN expr
   6 Column           0    0    8               00 r[8]=sqlite_master.type
REG[8] =   s4[view](8)
   7 Eq               8    9    9 (BINARY)      42 if r[9]==r[8] goto 9
REG[8] =   s4[view](8)
REG[9] =   t4[view](8)
   9 Goto             0   14    0               00 
  14 Column           0    0    2               00 r[2]=sqlite_master.type
REG[2] =   s4[view](8)
  15 Column           0    1    3               00 r[3]=sqlite_master.name
REG[3] =   s2[t1](8)
  16 Column           0    2    4               00 r[4]=sqlite_master.tbl_name
REG[4] =   s2[t1](8)
  17 Column           0    3    5               00 r[5]=sqlite_master.rootpage
REG[5] =  i:0
  18 Column           0    4    6               00 r[6]=sqlite_master.sql
REG[6] =   s210[CREATE VIEW t1 AS SELECT ](8)
  19 Yield            7    0    0               00 
REG[7] =  i:23
REG[7] =  i:19
  24 NewRowid         2    1    0               00 r[1]=rowid
REG[1] =  i:4
  25 MakeRecord       2    5   14 BBBDB         00 r[14]=mkrec(r[2..6])
REG[2] =   s4[view](8)
REG[3] =   s2[t1](8)
REG[4] =   s2[t1](8)
REG[5] =  i:0
REG[6] =   s210[CREATE VIEW t1 AS SELECT ](8)
REG[14] =  sx225[07151111088331766965777431743143524541544520564945|......1viewt1t1CREATE VIE]
  26 Insert           2   14    1 sqlite_master 39 intkey=r[1] data=r[14]
REG[14] =  sx225[07151111088331766965777431743143524541544520564945|......1viewt1t1CREATE VIE]
REG[1] =  i:4
  27 Goto             0   23    0               00 
  23 Yield            7   28    0               00 
REG[7] =  i:19
REG[7] =  i:23
  20 Next             0    5    0               01 
   5 Noop             0    0    0               00 begin IN expr
   6 Column           0    0    8               00 r[8]=sqlite_master.type
REG[8] =   s5[table](8)
   7 Eq               8    9    9 (BINARY)      42 if r[9]==r[8] goto 9
REG[8] =   s5[table](8)
REG[9] =   t4[view](8)
   8 Ne               8   10   10 (BINARY)      52 if r[10]!=r[8] goto 10; end IN expr
REG[8] =   s5[table](8)
REG[10] =   t7[trigger](8)
  10 Column           0    0   11               00 r[11]=sqlite_master.type
REG[11] =   s5[table](8)
  11 Ne              12   20   11 (BINARY)      52 if r[11]!=r[12] goto 20
REG[12] =   t5[table](8)
REG[11] =   s5[table](8)
  12 Column           0    3   11               00 r[11]=sqlite_master.rootpage
REG[11] =  i:2
  13 Ne              13   20   11 (BINARY)      54 if r[11]!=r[13] goto 20
REG[13] =  i:0
REG[11] =  i:2
  20 Next             0    5    0               01 
   5 Noop             0    0    0               00 begin IN expr
   6 Column           0    0    8               00 r[8]=sqlite_master.type
REG[8] =   s5[table](8)
   7 Eq               8    9    9 (BINARY)      42 if r[9]==r[8] goto 9
REG[8] =   s5[table](8)
REG[9] =   t4[view](8)
   8 Ne               8   10   10 (BINARY)      52 if r[10]!=r[8] goto 10; end IN expr
REG[8] =   s5[table](8)
REG[10] =   t7[trigger](8)
  10 Column           0    0   11               00 r[11]=sqlite_master.type
REG[11] =   s5[table](8)
  11 Ne              12   20   11 (BINARY)      52 if r[11]!=r[12] goto 20
REG[12] =   t5[table](8)
REG[11] =   s5[table](8)
  12 Column           0    3   11               00 r[11]=sqlite_master.rootpage
REG[11] =  i:3
  13 Ne              13   20   11 (BINARY)      54 if r[11]!=r[13] goto 20
REG[13] =  i:0
REG[11] =  i:3
  20 Next             0    5    0               01 
   5 Noop             0    0    0               00 begin IN expr
   6 Column           0    0    8               00 r[8]=sqlite_master.type
REG[8] =   s5[index](8)
   7 Eq               8    9    9 (BINARY)      42 if r[9]==r[8] goto 9
REG[8] =   s5[index](8)
REG[9] =   t4[view](8)
   8 Ne               8   10   10 (BINARY)      52 if r[10]!=r[8] goto 10; end IN expr
REG[8] =   s5[index](8)
REG[10] =   t7[trigger](8)
  10 Column           0    0   11               00 r[11]=sqlite_master.type
REG[11] =   s5[index](8)
  11 Ne              12   20   11 (BINARY)      52 if r[11]!=r[12] goto 20
REG[12] =   t5[table](8)
REG[11] =   s5[index](8)
  20 Next             0    5    0               01 
   5 Noop             0    0    0               00 begin IN expr
   6 Column           0    0    8               00 r[8]=sqlite_master.type
REG[8] =   s4[view](8)
   7 Eq               8    9    9 (BINARY)      42 if r[9]==r[8] goto 9
REG[8] =   s4[view](8)
REG[9] =   t4[view](8)
   9 Goto             0   14    0               00 
  14 Column           0    0    2               00 r[2]=sqlite_master.type
REG[2] =   s4[view](8)
  15 Column           0    1    3               00 r[3]=sqlite_master.name
REG[3] =   s2[t2](8)
  16 Column           0    2    4               00 r[4]=sqlite_master.tbl_name
REG[4] =   s2[t2](8)
  17 Column           0    3    5               00 r[5]=sqlite_master.rootpage
REG[5] =  i:0
  18 Column           0    4    6               00 r[6]=sqlite_master.sql
REG[6] =   s396[CREATE VIEW t2 AS .  SELE](8)
  19 Yield            7    0    0               00 
REG[7] =  i:23
REG[7] =  i:19
  24 NewRowid         2    1    0               00 r[1]=rowid
REG[1] =  i:5
  25 MakeRecord       2    5   14 BBBDB         00 r[14]=mkrec(r[2..6])
REG[2] =   s4[view](8)
REG[3] =   s2[t2](8)
REG[4] =   s2[t2](8)
REG[5] =  i:0
REG[6] =   s396[CREATE VIEW t2 AS .  SELE](8)
REG[14] =  sx411[07151111088625766965777432743243524541544520564945|......%viewt2t2CREATE VIE]
  26 Insert           2   14    1 sqlite_master 39 intkey=r[1] data=r[14]
REG[14] =  sx411[07151111088625766965777432743243524541544520564945|......%viewt2t2CREATE VIE]
REG[1] =  i:5
  27 Goto             0   23    0               00 
  23 Yield            7   28    0               00 
REG[7] =  i:19
REG[7] =  i:23
  20 Next             0    5    0               01 
  21 EndCoroutine     7    0    0               00 
REG[7] =  i:23
  28 Halt             0    0    0               00 
   2 Halt             0    0    0               00 
parser: [[[;
;SELECT * FROM a ORDER BY b, b;;
;SELECT * FROM a ORDER BY b DESC, b DESC;CREATE INDEX t3 ON a(b)
;SELECT*FROM"temp".sqlite_temp_master ORDER BY rowid
;SELECT x.b || '/' || y.b FROM a x, a y ORDER BY x.b, x.b DESC
  
;SELECT x.b || '/' || y.b FROM a x, a y ORDER BY x.b, x.b||x.b
  
;SELECT x.b || '/' || y.b FROM a x, a y ORDER BY x.b, x.b, y.b||y.b
  
;SELECT x.b || '/' || y.b FROM a x, a y ORDER BY x.b, y.b||y.b DESC
  
;SELECT x.b || '/' || y.b FROM a x, a y ORDER BY x.b, x.b||y.b
  
;SELECT*FROM"temp".sqlite_temp_master ORDER BY rowid
;;
;CREATE TABLE x(y INTEGER PRIMARY KEY, t2i1);ALTER TABLE x ADD t1i1
    
;;
;SELECT x.RowID id FROM a, x WHERE a.b = x.RowID AND id = 2;SELECT*FROM"temp".sqlite_temp_master ORDER BY rowid
;ALTER TABLE x ADD abc
    
;CREATE INDEX c ON a(b)
;CREATE INDEX v1 ON a(b)
;ALTER TABLE ex ADD v2
    
;CREATE TABLE tr1(t1a, t1b);;SELECT y, v2 FROM x, ex WHERE y>v2;;
;SELECT DISTINCT b FROM a LEFT JOIN ex ON b=v2 ORDER BY +v2;CREATE INDEX x1 ON a(b)
;CREATE INDEX z ON a(b)
;CREATE INDEX example ON ex(v2)
;;SELECT count(*) FROM sqlite_master WHERE tbl_name = 'e' AND type = 'index';;
;CREATE TABLE example_idx_00000042(id PRIMARY KEY, UNIQUE(id) );;BEGIN;;CREATE UNIQUE INDEX IF NOT EXISTS a_id ON a(b==0);;SELECT * FROM ex;]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 326
parser: Return. Stack=[SEMI]
parser: Input 'SEMI' with pending reduce 326
parser: Reduce 326 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Shift 'SEMI', pending reduce 326
parser: Return. Stack=[ecmd SEMI]
parser: Input 'SELECT' with pending reduce 326
parser: Reduce 326 [ecmd ::= SEMI], go to state 1.
parser: ... then shift 'ecmd', pending reduce 324
parser: Reduce 324 [cmdlist ::= cmdlist ecmd], go to state 0.
parser: ... then shift 'cmdlist', go to state 1
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[cmdlist SELECT]
parser: Input 'STAR' in state 288
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 95 [sclp ::=].
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STAR', pending reduce 97
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt STAR]
parser: Input 'FROM' with pending reduce 97
parser: Reduce 97 [selcollist ::= sclp scanpt STAR], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[cmdlist SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 104 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[cmdlist SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'ORDER' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 350
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 123 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 349
parser: Reduce 122 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 348
parser: Reduce 127 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 105
parser: Reduce 105 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 102 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 363
parser: Reduce 147 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 362
parser: Reduce 138 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 361
parser: Reduce 140 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 517
parser: Return. Stack=[cmdlist SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 517
parser: Shift 'BY', go to state 26
parser: Return. Stack=[cmdlist SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 419
parser: Return. Stack=[cmdlist SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'COMMA' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 134 [sortorder ::=].
parser: ... then shift 'sortorder', go to state 353
parser: Reduce 137 [nulls ::=].
parser: ... then shift 'nulls', pending reduce 131
parser: Reduce 131 [sortlist ::= expr sortorder nulls], go to state 26.
parser: ... then shift 'sortlist', go to state 516
parser: Shift 'COMMA', go to state 95
parser: Return. Stack=[cmdlist SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY sortlist COMMA]
parser: Input 'ID' in state 95
parser: Shift 'ID', go to state 419
parser: Return. Stack=[cmdlist SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY sortlist COMMA ID]
parser: Input 'SEMI' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 95.
parser: ... then shift 'expr', go to state 14
parser: Reduce 134 [sortorder ::=].
parser: ... then shift 'sortorder', go to state 354
parser: Reduce 137 [nulls ::=].
parser: ... then shift 'nulls', pending reduce 130
parser: Reduce 130 [sortlist ::= sortlist COMMA expr sortorder nulls], go to state 26.
parser: ... then shift 'sortlist', go to state 516
parser: Reduce 129 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 360
parser: Reduce 142 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 88
parser: Reduce 88 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 1.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 83 [select ::= selectnowith], go to state 1.
parser: ... then shift 'select', pending reduce 80
parser: Reduce 80 [cmd ::= select], go to state 1.
parser: [[[CREATE TABLE x(type text,name text,tbl_name text,rootpage int,sql text)]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 390
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 0.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP ID]
parser: Input 'ID' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 192
parser: Shift 'ID', pending reduce 341
parser: Return. Stack=[create_table LP nm ID]
parser: Input 'COMMA' with pending reduce 341
parser: Reduce 341 [typename ::= ID|STRING], go to state 192.
parser: ... then shift 'typename', go to state 392
parser: Reduce 340 [typetoken ::= typename], go to state 192.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 379
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 152
parser: Reduce 336 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'ID' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Shift 'ID', pending reduce 341
parser: Return. Stack=[create_table LP columnlist COMMA nm ID]
parser: Input 'COMMA' with pending reduce 341
parser: Reduce 341 [typename ::= ID|STRING], go to state 192.
parser: ... then shift 'typename', go to state 392
parser: Reduce 340 [typetoken ::= typename], go to state 192.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'ID' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Shift 'ID', pending reduce 341
parser: Return. Stack=[create_table LP columnlist COMMA nm ID]
parser: Input 'COMMA' with pending reduce 341
parser: Reduce 341 [typename ::= ID|STRING], go to state 192.
parser: ... then shift 'typename', go to state 392
parser: Reduce 340 [typetoken ::= typename], go to state 192.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'ID' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Shift 'ID', pending reduce 341
parser: Return. Stack=[create_table LP columnlist COMMA nm ID]
parser: Input 'COMMA' with pending reduce 341
parser: Reduce 341 [typename ::= ID|STRING], go to state 192.
parser: ... then shift 'typename', go to state 392
parser: Reduce 340 [typetoken ::= typename], go to state 192.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'ID' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Shift 'ID', pending reduce 341
parser: Return. Stack=[create_table LP columnlist COMMA nm ID]
parser: Input 'RP' with pending reduce 341
parser: Reduce 341 [typename ::= ID|STRING], go to state 192.
parser: ... then shift 'typename', go to state 392
parser: Reduce 340 [typetoken ::= typename], go to state 192.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Reduce 61 [conslist_opt ::=].
parser: ... then shift 'conslist_opt', go to state 540
parser: Shift 'RP', go to state 364
parser: Return. Stack=[create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 364
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: ... then shift 'create_table_args', pending reduce 334
parser: Reduce 334 [cmd ::= create_table create_table_args], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT*FROM"main".sqlite_master ORDER BY rowid]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'STAR' in state 288
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 95 [sclp ::=].
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STAR', pending reduce 97
parser: Return. Stack=[SELECT distinct sclp scanpt STAR]
parser: Input 'FROM' with pending reduce 97
parser: Reduce 97 [selcollist ::= sclp scanpt STAR], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 104 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'DOT' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 350
parser: Shift 'DOT', go to state 245
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID' in state 245
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'ORDER' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 245.
parser: ... then shift 'nm', pending reduce 110
parser: Reduce 110 [dbnm ::= DOT nm], go to state 350.
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 123 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 349
parser: Reduce 122 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 348
parser: Reduce 127 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 105
parser: Reduce 105 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 102 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 363
parser: Reduce 147 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 362
parser: Reduce 138 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 361
parser: Reduce 140 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 517
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 517
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 419
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 134 [sortorder ::=].
parser: ... then shift 'sortorder', go to state 353
parser: Reduce 137 [nulls ::=].
parser: ... then shift 'nulls', pending reduce 131
parser: Reduce 131 [sortlist ::= expr sortorder nulls], go to state 26.
parser: ... then shift 'sortlist', go to state 516
parser: Reduce 129 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 360
parser: Reduce 142 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 88
parser: Reduce 88 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 83 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 80
parser: Reduce 80 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
VDBE Trace:
   0 Init             0   13    0               00 Start at 13
  13 Transaction      0    0    6 1             00 usesStmtJournal=0
  14 Goto             0    1    0               00 
   1 Noop             1    7    0               00 
   2 OpenRead         0    1    0 5             00 root=1 iDb=0; sqlite_master
   3 Explain          3    0    0 SCAN TABLE sqlite_master 00 
   4 Rewind           0   12    0               00 
   5 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s5[table](8)
   6 Column           0    1    2               00 r[2]=sqlite_master.name
REG[2] =   s1[a](8)
   7 Column           0    2    3               00 r[3]=sqlite_master.tbl_name
REG[3] =   s1[a](8)
   8 Column           0    3    4               00 r[4]=sqlite_master.rootpage
REG[4] =  i:2
   9 Column           0    4    5               00 r[5]=sqlite_master.sql
REG[5] =   s56[CREATE TABLE a (b INTEGER](8)
  10 ResultRow        1    5    0               00 output=r[1..5]
REG[1] =   s5[table](8)
REG[2] =   s1[a](8)
REG[3] =   s1[a](8)
REG[4] =  i:2
REG[5] =   s56[CREATE TABLE a (b INTEGER](8)
parser: [[[CREATE TABLE a (b INTEGER, PRIMARY KEY(b)) WITHOUT ROWID]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 390
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 0.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP ID]
parser: Input 'ID' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 192
parser: Shift 'ID', pending reduce 341
parser: Return. Stack=[create_table LP nm ID]
parser: Input 'COMMA' with pending reduce 341
parser: Reduce 341 [typename ::= ID|STRING], go to state 192.
parser: ... then shift 'typename', go to state 392
parser: Reduce 340 [typetoken ::= typename], go to state 192.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 379
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 152
parser: Reduce 336 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'PRIMARY' in state 34
parser: Shift 'PRIMARY', go to state 475
parser: Return. Stack=[create_table LP columnlist COMMA PRIMARY]
parser: Input 'KEY' in state 475
parser: Shift 'KEY', go to state 474
parser: Return. Stack=[create_table LP columnlist COMMA PRIMARY KEY]
parser: Input 'LP' in state 474
parser: Shift 'LP', go to state 20
parser: Return. Stack=[create_table LP columnlist COMMA PRIMARY KEY LP]
parser: Input 'ID' in state 20
parser: Shift 'ID', go to state 419
parser: Return. Stack=[create_table LP columnlist COMMA PRIMARY KEY LP ID]
parser: Input 'RP' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 20.
parser: ... then shift 'expr', go to state 13
parser: Reduce 134 [sortorder ::=].
parser: ... then shift 'sortorder', go to state 353
parser: Reduce 137 [nulls ::=].
parser: ... then shift 'nulls', pending reduce 131
parser: Reduce 131 [sortlist ::= expr sortorder nulls], go to state 20.
parser: ... then shift 'sortlist', go to state 277
parser: Reduce 43 [autoinc ::=].
parser: ... then shift 'autoinc', go to state 473
parser: Shift 'RP', go to state 328
parser: Return. Stack=[create_table LP columnlist COMMA PRIMARY KEY LP sortlist autoinc RP]
parser: Input 'RP' in state 328
parser: Reduce 69 [onconf ::=].
parser: ... then shift 'onconf', pending reduce 64
parser: Reduce 64 [tcons ::= PRIMARY KEY LP sortlist autoinc RP onconf], go to state 34.
parser: ... then shift 'tcons', go to state 278
parser: Reduce 347 [conslist_opt ::= COMMA conslist], go to state 365.
parser: ... then shift 'conslist_opt', go to state 540
parser: Shift 'RP', go to state 364
parser: Return. Stack=[create_table LP columnlist conslist_opt RP]
parser: Input 'WITHOUT' in state 364
parser: Shift 'WITHOUT', go to state 251
parser: Return. Stack=[create_table LP columnlist conslist_opt RP WITHOUT]
parser: Input 'ID' in state 251
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist conslist_opt RP WITHOUT ID]
parser: Input 'SEMI' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 251.
parser: ... then shift 'nm', pending reduce 22
parser: Reduce 22 [table_options ::= WITHOUT nm], go to state 364.
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: ... then shift 'create_table_args', pending reduce 334
parser: Reduce 334 [cmd ::= create_table create_table_args], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
  11 Next             0    5    0               01 
   5 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s5[table](8)
   6 Column           0    1    2               00 r[2]=sqlite_master.name
REG[2] =   s2[ex](8)
   7 Column           0    2    3               00 r[3]=sqlite_master.tbl_name
REG[3] =   s2[ex](8)
   8 Column           0    3    4               00 r[4]=sqlite_master.rootpage
REG[4] =  i:3
   9 Column           0    4    5               00 r[5]=sqlite_master.sql
REG[5] =   s19[CREATE TABLE ex(i1)](8)
  10 ResultRow        1    5    0               00 output=r[1..5]
REG[1] =   s5[table](8)
REG[2] =   s2[ex](8)
REG[3] =   s2[ex](8)
REG[4] =  i:3
REG[5] =   s19[CREATE TABLE ex(i1)](8)
parser: [[[CREATE TABLE ex(i1)]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 390
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 0.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP ID]
parser: Input 'RP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 192
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 379
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 152
parser: Reduce 336 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Reduce 61 [conslist_opt ::=].
parser: ... then shift 'conslist_opt', go to state 540
parser: Shift 'RP', go to state 364
parser: Return. Stack=[create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 364
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: ... then shift 'create_table_args', pending reduce 334
parser: Reduce 334 [cmd ::= create_table create_table_args], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
  11 Next             0    5    0               01 
   5 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s5[index](8)
   6 Column           0    1    2               00 r[2]=sqlite_master.name
REG[2] =   s2[i2](8)
   7 Column           0    2    3               00 r[3]=sqlite_master.tbl_name
REG[3] =   s1[a](8)
   8 Column           0    3    4               00 r[4]=sqlite_master.rootpage
REG[4] =  i:4
   9 Column           0    4    5               00 r[5]=sqlite_master.sql
REG[5] =   s38[CREATE INDEX i2 ON a(b CO](8)
  10 ResultRow        1    5    0               00 output=r[1..5]
REG[1] =   s5[index](8)
REG[2] =   s2[i2](8)
REG[3] =   s1[a](8)
REG[4] =  i:4
REG[5] =   s38[CREATE INDEX i2 ON a(b CO](8)
parser: [[[CREATE INDEX i2 ON a(b COLLATE binary)]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'INDEX' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 225 [uniqueflag ::=].
parser: ... then shift 'uniqueflag', go to state 456
parser: Shift 'INDEX', go to state 315
parser: Return. Stack=[createkw uniqueflag INDEX]
parser: Input 'ID' in state 315
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 225
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists ID]
parser: Input 'ON' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 225.
parser: ... then shift 'nm', go to state 314
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 455
parser: Shift 'ON', go to state 224
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON]
parser: Input 'ID' in state 224
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON ID]
parser: Input 'LP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 224.
parser: ... then shift 'nm', go to state 454
parser: Shift 'LP', go to state 18
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP]
parser: Input 'ID' in state 18
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP ID]
parser: Input 'COLLATE' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 18.
parser: ... then shift 'expr', go to state 13
parser: Shift 'COLLATE', go to state 418
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP expr COLLATE]
parser: Input 'ID' in state 418
parser: Shift 'ID', pending reduce 175
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP expr COLLATE ID]
parser: Input 'RP' with pending reduce 175
parser: Reduce 175 [expr ::= expr COLLATE ID|STRING], go to state 18.
parser: ... then shift 'expr', go to state 13
parser: Reduce 134 [sortorder ::=].
parser: ... then shift 'sortorder', go to state 353
parser: Reduce 137 [nulls ::=].
parser: ... then shift 'nulls', pending reduce 131
parser: Reduce 131 [sortlist ::= expr sortorder nulls], go to state 18.
parser: ... then shift 'sortlist', go to state 402
parser: Shift 'RP', go to state 313
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP]
parser: Input 'SEMI' in state 313
parser: Reduce 147 [where_opt ::=].
parser: ... then shift 'where_opt', pending reduce 223
parser: Reduce 223 [cmd ::= createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP where_opt], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
  11 Next             0    5    0               01 
   5 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s4[view](8)
   6 Column           0    1    2               00 r[2]=sqlite_master.name
REG[2] =   s2[t1](8)
   7 Column           0    2    3               00 r[3]=sqlite_master.tbl_name
REG[3] =   s2[t1](8)
   8 Column           0    3    4               00 r[4]=sqlite_master.rootpage
REG[4] =  i:0
   9 Column           0    4    5               00 r[5]=sqlite_master.sql
REG[5] =   s210[CREATE VIEW t1 AS SELECT ](8)
  10 ResultRow        1    5    0               00 output=r[1..5]
REG[1] =   s4[view](8)
REG[2] =   s2[t1](8)
REG[3] =   s2[t1](8)
REG[4] =  i:0
REG[5] =   s210[CREATE VIEW t1 AS SELECT ](8)
parser: [[[CREATE VIEW t1 AS SELECT 123
    
      WINDOW x AS (
        RANGE BETWEEN UNBOUNDED PRECEDING AND INDEXED() OVER(
          PARTITION BY ( WITH x AS(VALUES(col1)) VALUES(453) )
        )
      FOLLOWING
    )]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'VIEW' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: FALLBACK VIEW => ID
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 390
parser: Shift 'VIEW', go to state 322
parser: Return. Stack=[createkw temp VIEW]
parser: Input 'ID' in state 322
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 228
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw temp VIEW ifnotexists ID]
parser: Input 'AS' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 228.
parser: ... then shift 'nm', go to state 321
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 320
parser: Reduce 226 [eidlist_opt ::=].
parser: ... then shift 'eidlist_opt', go to state 464
parser: Shift 'AS', go to state 37
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS]
parser: Input 'SELECT' in state 37
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT]
parser: Input 'INTEGER' in state 288
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 95 [sclp ::=].
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'INTEGER', pending reduce 173
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt INTEGER]
parser: Input 'WINDOW' with pending reduce 173
parser: Reduce 173 [term ::= INTEGER], go to state 77.
parser: ... then shift 'term', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Reduce 101 [from ::=].
parser: ... then shift 'from', go to state 363
parser: Reduce 147 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 362
parser: Reduce 138 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 361
parser: Reduce 140 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'WINDOW', go to state 136
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW]
parser: Input 'ID' in state 136
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW ID]
parser: Input 'AS' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 136.
parser: ... then shift 'nm', go to state 514
parser: Shift 'AS', go to state 513
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS]
parser: Input 'LP' in state 513
parser: Shift 'LP', go to state 33
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP]
parser: Input 'RANGE' in state 33
parser: Shift 'RANGE', pending reduce 304
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP RANGE]
parser: Input 'BETWEEN' with pending reduce 304
parser: Reduce 304 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 33.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP range_or_rows BETWEEN]
parser: Input 'UNBOUNDED' in state 8
parser: Shift 'UNBOUNDED', go to state 505
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP range_or_rows BETWEEN UNBOUNDED]
parser: Input 'PRECEDING' in state 505
parser: Shift 'PRECEDING', pending reduce 306
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP range_or_rows BETWEEN UNBOUNDED PRECEDING]
parser: Input 'AND' with pending reduce 306
parser: Reduce 306 [frame_bound_s ::= UNBOUNDED PRECEDING], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 508
parser: Shift 'AND', go to state 7
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'INDEXED' in state 7
parser: Shift 'INDEXED', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP range_or_rows BETWEEN frame_bound_s AND INDEXED]
parser: Input 'LP' in state 419
parser: Shift 'LP', go to state 266
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP range_or_rows BETWEEN frame_bound_s AND INDEXED LP]
parser: Input 'RP' in state 266
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Reduce 218 [exprlist ::=].
parser: ... then shift 'exprlist', go to state 484
parser: Shift 'RP', go to state 146
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP range_or_rows BETWEEN frame_bound_s AND INDEXED LP distinct exprlist RP]
parser: Input 'OVER' in state 146
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP range_or_rows BETWEEN frame_bound_s AND INDEXED LP distinct exprlist RP OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP range_or_rows BETWEEN frame_bound_s AND INDEXED LP distinct exprlist RP OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 511
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP range_or_rows BETWEEN frame_bound_s AND INDEXED LP distinct exprlist RP OVER LP PARTITION]
parser: Input 'BY' in state 511
parser: Shift 'BY', go to state 25
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP range_or_rows BETWEEN frame_bound_s AND INDEXED LP distinct exprlist RP OVER LP PARTITION BY]
parser: Input 'LP' in state 25
parser: Shift 'LP', go to state 4
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP range_or_rows BETWEEN frame_bound_s AND INDEXED LP distinct exprlist RP OVER LP PARTITION BY LP]
parser: Input 'WITH' in state 4
parser: Shift 'WITH', go to state 162
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP range_or_rows BETWEEN frame_bound_s AND INDEXED LP distinct exprlist RP OVER LP PARTITION BY LP WITH]
parser: Input 'ID' in state 162
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP range_or_rows BETWEEN frame_bound_s AND INDEXED LP distinct exprlist RP OVER LP PARTITION BY LP WITH ID]
parser: Input 'AS' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 162.
parser: ... then shift 'nm', go to state 338
parser: Reduce 226 [eidlist_opt ::=].
parser: ... then shift 'eidlist_opt', go to state 489
parser: Shift 'AS', go to state 488
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP range_or_rows BETWEEN frame_bound_s AND INDEXED LP distinct exprlist RP OVER LP PARTITION BY LP WITH nm eidlist_opt AS]
parser: Input 'LP' in state 488
parser: Shift 'LP', go to state 39
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP range_or_rows BETWEEN frame_bound_s AND INDEXED LP distinct exprlist RP OVER LP PARTITION BY LP WITH nm eidlist_opt AS LP]
parser: Input 'VALUES' in state 39
parser: Shift 'VALUES', go to state 528
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP range_or_rows BETWEEN frame_bound_s AND INDEXED LP distinct exprlist RP OVER LP PARTITION BY LP WITH nm eidlist_opt AS LP VALUES]
parser: Input 'LP' in state 528
parser: Shift 'LP', go to state 28
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP range_or_rows BETWEEN frame_bound_s AND INDEXED LP distinct exprlist RP OVER LP PARTITION BY LP WITH nm eidlist_opt AS LP VALUES LP]
parser: Input 'ID' in state 28
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP range_or_rows BETWEEN frame_bound_s AND INDEXED LP distinct exprlist RP OVER LP PARTITION BY LP WITH nm eidlist_opt AS LP VALUES LP ID]
parser: Input 'RP' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 28.
parser: ... then shift 'expr', go to state 70
parser: Reduce 220 [nexprlist ::= expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 413
parser: Shift 'RP', pending reduce 90
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP range_or_rows BETWEEN frame_bound_s AND INDEXED LP distinct exprlist RP OVER LP PARTITION BY LP WITH nm eidlist_opt AS LP VALUES LP nexprlist RP]
parser: Input 'RP' with pending reduce 90
parser: Reduce 90 [values ::= VALUES LP nexprlist RP], go to state 39.
parser: ... then shift 'values', go to state 534
parser: Reduce 354 [oneselect ::= values], go to state 39.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 83 [select ::= selectnowith], go to state 39.
parser: ... then shift 'select', go to state 487
parser: Shift 'RP', pending reduce 290
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP range_or_rows BETWEEN frame_bound_s AND INDEXED LP distinct exprlist RP OVER LP PARTITION BY LP WITH nm eidlist_opt AS LP select RP]
parser: Input 'VALUES' with pending reduce 290
parser: Reduce 290 [wqlist ::= nm eidlist_opt AS LP select RP], go to state 162.
parser: ... then shift 'wqlist', go to state 143
parser: Shift 'VALUES', go to state 528
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP range_or_rows BETWEEN frame_bound_s AND INDEXED LP distinct exprlist RP OVER LP PARTITION BY LP WITH wqlist VALUES]
parser: Input 'LP' in state 528
parser: Shift 'LP', go to state 28
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP range_or_rows BETWEEN frame_bound_s AND INDEXED LP distinct exprlist RP OVER LP PARTITION BY LP WITH wqlist VALUES LP]
parser: Input 'INTEGER' in state 28
parser: Shift 'INTEGER', pending reduce 173
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP range_or_rows BETWEEN frame_bound_s AND INDEXED LP distinct exprlist RP OVER LP PARTITION BY LP WITH wqlist VALUES LP INTEGER]
parser: Input 'RP' with pending reduce 173
parser: Reduce 173 [term ::= INTEGER], go to state 28.
parser: ... then shift 'term', go to state 70
parser: Reduce 220 [nexprlist ::= expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 413
parser: Shift 'RP', pending reduce 90
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP range_or_rows BETWEEN frame_bound_s AND INDEXED LP distinct exprlist RP OVER LP PARTITION BY LP WITH wqlist VALUES LP nexprlist RP]
parser: Input 'RP' with pending reduce 90
parser: Reduce 90 [values ::= VALUES LP nexprlist RP], go to state 143.
parser: ... then shift 'values', go to state 534
parser: Reduce 354 [oneselect ::= values], go to state 143.
parser: ... then shift 'oneselect', go to state 265
parser: Reduce 81 [select ::= WITH wqlist selectnowith], go to state 4.
parser: ... then shift 'select', go to state 485
parser: Shift 'RP', pending reduce 207
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP range_or_rows BETWEEN frame_bound_s AND INDEXED LP distinct exprlist RP OVER LP PARTITION BY LP select RP]
parser: Input 'RP' with pending reduce 207
parser: Reduce 207 [expr ::= LP select RP], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 220 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Reduce 128 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 191
parser: Reduce 301 [frame_opt ::=].
parser: ... then shift 'frame_opt', pending reduce 295
parser: Reduce 295 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 483
parser: Shift 'RP', pending reduce 320
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP range_or_rows BETWEEN frame_bound_s AND INDEXED LP distinct exprlist RP OVER LP window RP]
parser: Input 'FOLLOWING' with pending reduce 320
parser: Reduce 320 [over_clause ::= OVER LP window RP], go to state 146.
parser: ... then shift 'over_clause', pending reduce 318
parser: Reduce 318 [filter_over ::= over_clause], go to state 146.
parser: ... then shift 'filter_over', pending reduce 179
parser: Reduce 179 [expr ::= ID|INDEXED LP distinct exprlist RP filter_over], go to state 7.
parser: ... then shift 'expr', go to state 42
parser: Shift 'FOLLOWING', pending reduce 309
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP range_or_rows BETWEEN frame_bound_s AND expr FOLLOWING]
parser: Input 'RP' with pending reduce 309
parser: Reduce 309 [frame_bound ::= expr PRECEDING|FOLLOWING], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 307
parser: Reduce 307 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 351
parser: Reduce 311 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 303
parser: Reduce 303 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 33.
parser: ... then shift 'frame_opt', pending reduce 299
parser: Reduce 299 [window ::= frame_opt], go to state 33.
parser: ... then shift 'window', go to state 512
parser: Shift 'RP', pending reduce 294
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP window RP]
parser: Input 'SEMI' with pending reduce 294
parser: Reduce 294 [windowdefn ::= nm AS LP window RP], go to state 136.
parser: ... then shift 'windowdefn', pending reduce 292
parser: Reduce 292 [windowdefn_list ::= windowdefn], go to state 136.
parser: ... then shift 'windowdefn_list', go to state 515
parser: Reduce 316 [window_clause ::= WINDOW windowdefn_list], go to state 194.
parser: ... then shift 'window_clause', go to state 356
parser: Reduce 128 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 355
parser: Reduce 142 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 89
parser: Reduce 89 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt window_clause orderby_opt limit_opt], go to state 37.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 83 [select ::= selectnowith], go to state 37.
parser: ... then shift 'select', pending reduce 78
parser: Reduce 78 [cmd ::= createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
  11 Next             0    5    0               01 
   5 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s4[view](8)
   6 Column           0    1    2               00 r[2]=sqlite_master.name
REG[2] =   s2[t2](8)
   7 Column           0    2    3               00 r[3]=sqlite_master.tbl_name
REG[3] =   s2[t2](8)
   8 Column           0    3    4               00 r[4]=sqlite_master.rootpage
REG[4] =  i:0
   9 Column           0    4    5               00 r[5]=sqlite_master.sql
REG[5] =   s396[CREATE VIEW t2 AS .  SELE](8)
  10 ResultRow        1    5    0               00 output=r[1..5]
REG[1] =   s4[view](8)
REG[2] =   s2[t2](8)
REG[3] =   s2[t2](8)
REG[4] =  i:0
REG[5] =   s396[CREATE VIEW t2 AS .  SELE](8)
parser: [[[CREATE VIEW t2 AS 
  SELECT sum(b) FILTER( WHERE b>9 ),
         sum(b) FILTER( WHERE b>8 ),
         sum(b) FILTER( WHERE b>7 ),
         sum(b) FILTER( WHERE b>6 ),
         sum(b) FILTER( WHERE b>5 ),
         sum(b) FILTER( WHERE b>4 ),
         sum(b) FILTER( WHERE b>3 ),
         sum(b) FILTER( WHERE b>2 ),
         sum(b) FILTER( WHERE b>1 ),
         sum(b) FILTER( WHERE b>0 )
  FROM a]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'VIEW' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: FALLBACK VIEW => ID
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 390
parser: Shift 'VIEW', go to state 322
parser: Return. Stack=[createkw temp VIEW]
parser: Input 'ID' in state 322
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 228
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw temp VIEW ifnotexists ID]
parser: Input 'AS' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 228.
parser: ... then shift 'nm', go to state 321
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 320
parser: Reduce 226 [eidlist_opt ::=].
parser: ... then shift 'eidlist_opt', go to state 464
parser: Shift 'AS', go to state 37
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS]
parser: Input 'SELECT' in state 37
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT]
parser: Input 'ID' in state 288
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 95 [sclp ::=].
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 419
parser: Shift 'LP', go to state 266
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 220 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 519
parser: Reduce 359 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 484
parser: Shift 'RP', go to state 146
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'FILTER' in state 146
parser: Shift 'FILTER', go to state 482
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER]
parser: Input 'LP' in state 482
parser: Shift 'LP', go to state 481
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP]
parser: Input 'WHERE' in state 481
parser: Shift 'WHERE', go to state 90
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE]
parser: Input 'ID' in state 90
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE ID]
parser: Input 'GT' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'GT', go to state 118
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT]
parser: Input 'INTEGER' in state 118
parser: Shift 'INTEGER', pending reduce 173
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT INTEGER]
parser: Input 'RP' with pending reduce 173
parser: Reduce 173 [term ::= INTEGER], go to state 118.
parser: ... then shift 'term', go to state 130
parser: Reduce 185 [expr ::= expr LT|GT|GE|LE expr], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'RP', pending reduce 322
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr RP]
parser: Input 'COMMA' with pending reduce 322
parser: Reduce 322 [filter_clause ::= FILTER LP WHERE expr RP], go to state 146.
parser: ... then shift 'filter_clause', go to state 337
parser: Reduce 319 [filter_over ::= filter_clause], go to state 146.
parser: ... then shift 'filter_over', pending reduce 179
parser: Reduce 179 [expr ::= ID|INDEXED LP distinct exprlist RP filter_over], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 355
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 355
parser: Reduce 355 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 419
parser: Shift 'LP', go to state 266
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 220 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 519
parser: Reduce 359 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 484
parser: Shift 'RP', go to state 146
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'FILTER' in state 146
parser: Shift 'FILTER', go to state 482
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER]
parser: Input 'LP' in state 482
parser: Shift 'LP', go to state 481
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP]
parser: Input 'WHERE' in state 481
parser: Shift 'WHERE', go to state 90
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE]
parser: Input 'ID' in state 90
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE ID]
parser: Input 'GT' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'GT', go to state 118
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT]
parser: Input 'INTEGER' in state 118
parser: Shift 'INTEGER', pending reduce 173
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT INTEGER]
parser: Input 'RP' with pending reduce 173
parser: Reduce 173 [term ::= INTEGER], go to state 118.
parser: ... then shift 'term', go to state 130
parser: Reduce 185 [expr ::= expr LT|GT|GE|LE expr], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'RP', pending reduce 322
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr RP]
parser: Input 'COMMA' with pending reduce 322
parser: Reduce 322 [filter_clause ::= FILTER LP WHERE expr RP], go to state 146.
parser: ... then shift 'filter_clause', go to state 337
parser: Reduce 319 [filter_over ::= filter_clause], go to state 146.
parser: ... then shift 'filter_over', pending reduce 179
parser: Reduce 179 [expr ::= ID|INDEXED LP distinct exprlist RP filter_over], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 355
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 355
parser: Reduce 355 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 419
parser: Shift 'LP', go to state 266
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 220 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 519
parser: Reduce 359 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 484
parser: Shift 'RP', go to state 146
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'FILTER' in state 146
parser: Shift 'FILTER', go to state 482
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER]
parser: Input 'LP' in state 482
parser: Shift 'LP', go to state 481
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP]
parser: Input 'WHERE' in state 481
parser: Shift 'WHERE', go to state 90
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE]
parser: Input 'ID' in state 90
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE ID]
parser: Input 'GT' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'GT', go to state 118
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT]
parser: Input 'INTEGER' in state 118
parser: Shift 'INTEGER', pending reduce 173
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT INTEGER]
parser: Input 'RP' with pending reduce 173
parser: Reduce 173 [term ::= INTEGER], go to state 118.
parser: ... then shift 'term', go to state 130
parser: Reduce 185 [expr ::= expr LT|GT|GE|LE expr], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'RP', pending reduce 322
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr RP]
parser: Input 'COMMA' with pending reduce 322
parser: Reduce 322 [filter_clause ::= FILTER LP WHERE expr RP], go to state 146.
parser: ... then shift 'filter_clause', go to state 337
parser: Reduce 319 [filter_over ::= filter_clause], go to state 146.
parser: ... then shift 'filter_over', pending reduce 179
parser: Reduce 179 [expr ::= ID|INDEXED LP distinct exprlist RP filter_over], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 355
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 355
parser: Reduce 355 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 419
parser: Shift 'LP', go to state 266
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 220 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 519
parser: Reduce 359 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 484
parser: Shift 'RP', go to state 146
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'FILTER' in state 146
parser: Shift 'FILTER', go to state 482
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER]
parser: Input 'LP' in state 482
parser: Shift 'LP', go to state 481
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP]
parser: Input 'WHERE' in state 481
parser: Shift 'WHERE', go to state 90
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE]
parser: Input 'ID' in state 90
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE ID]
parser: Input 'GT' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'GT', go to state 118
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT]
parser: Input 'INTEGER' in state 118
parser: Shift 'INTEGER', pending reduce 173
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT INTEGER]
parser: Input 'RP' with pending reduce 173
parser: Reduce 173 [term ::= INTEGER], go to state 118.
parser: ... then shift 'term', go to state 130
parser: Reduce 185 [expr ::= expr LT|GT|GE|LE expr], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'RP', pending reduce 322
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr RP]
parser: Input 'COMMA' with pending reduce 322
parser: Reduce 322 [filter_clause ::= FILTER LP WHERE expr RP], go to state 146.
parser: ... then shift 'filter_clause', go to state 337
parser: Reduce 319 [filter_over ::= filter_clause], go to state 146.
parser: ... then shift 'filter_over', pending reduce 179
parser: Reduce 179 [expr ::= ID|INDEXED LP distinct exprlist RP filter_over], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 355
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 355
parser: Reduce 355 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 419
parser: Shift 'LP', go to state 266
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 220 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 519
parser: Reduce 359 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 484
parser: Shift 'RP', go to state 146
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'FILTER' in state 146
parser: Shift 'FILTER', go to state 482
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER]
parser: Input 'LP' in state 482
parser: Shift 'LP', go to state 481
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP]
parser: Input 'WHERE' in state 481
parser: Shift 'WHERE', go to state 90
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE]
parser: Input 'ID' in state 90
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE ID]
parser: Input 'GT' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'GT', go to state 118
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT]
parser: Input 'INTEGER' in state 118
parser: Shift 'INTEGER', pending reduce 173
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT INTEGER]
parser: Input 'RP' with pending reduce 173
parser: Reduce 173 [term ::= INTEGER], go to state 118.
parser: ... then shift 'term', go to state 130
parser: Reduce 185 [expr ::= expr LT|GT|GE|LE expr], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'RP', pending reduce 322
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr RP]
parser: Input 'COMMA' with pending reduce 322
parser: Reduce 322 [filter_clause ::= FILTER LP WHERE expr RP], go to state 146.
parser: ... then shift 'filter_clause', go to state 337
parser: Reduce 319 [filter_over ::= filter_clause], go to state 146.
parser: ... then shift 'filter_over', pending reduce 179
parser: Reduce 179 [expr ::= ID|INDEXED LP distinct exprlist RP filter_over], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 355
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 355
parser: Reduce 355 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 419
parser: Shift 'LP', go to state 266
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 220 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 519
parser: Reduce 359 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 484
parser: Shift 'RP', go to state 146
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'FILTER' in state 146
parser: Shift 'FILTER', go to state 482
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER]
parser: Input 'LP' in state 482
parser: Shift 'LP', go to state 481
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP]
parser: Input 'WHERE' in state 481
parser: Shift 'WHERE', go to state 90
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE]
parser: Input 'ID' in state 90
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE ID]
parser: Input 'GT' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'GT', go to state 118
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT]
parser: Input 'INTEGER' in state 118
parser: Shift 'INTEGER', pending reduce 173
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT INTEGER]
parser: Input 'RP' with pending reduce 173
parser: Reduce 173 [term ::= INTEGER], go to state 118.
parser: ... then shift 'term', go to state 130
parser: Reduce 185 [expr ::= expr LT|GT|GE|LE expr], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'RP', pending reduce 322
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr RP]
parser: Input 'COMMA' with pending reduce 322
parser: Reduce 322 [filter_clause ::= FILTER LP WHERE expr RP], go to state 146.
parser: ... then shift 'filter_clause', go to state 337
parser: Reduce 319 [filter_over ::= filter_clause], go to state 146.
parser: ... then shift 'filter_over', pending reduce 179
parser: Reduce 179 [expr ::= ID|INDEXED LP distinct exprlist RP filter_over], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 355
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 355
parser: Reduce 355 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 419
parser: Shift 'LP', go to state 266
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 220 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 519
parser: Reduce 359 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 484
parser: Shift 'RP', go to state 146
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'FILTER' in state 146
parser: Shift 'FILTER', go to state 482
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER]
parser: Input 'LP' in state 482
parser: Shift 'LP', go to state 481
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP]
parser: Input 'WHERE' in state 481
parser: Shift 'WHERE', go to state 90
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE]
parser: Input 'ID' in state 90
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE ID]
parser: Input 'GT' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'GT', go to state 118
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT]
parser: Input 'INTEGER' in state 118
parser: Shift 'INTEGER', pending reduce 173
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT INTEGER]
parser: Input 'RP' with pending reduce 173
parser: Reduce 173 [term ::= INTEGER], go to state 118.
parser: ... then shift 'term', go to state 130
parser: Reduce 185 [expr ::= expr LT|GT|GE|LE expr], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'RP', pending reduce 322
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr RP]
parser: Input 'COMMA' with pending reduce 322
parser: Reduce 322 [filter_clause ::= FILTER LP WHERE expr RP], go to state 146.
parser: ... then shift 'filter_clause', go to state 337
parser: Reduce 319 [filter_over ::= filter_clause], go to state 146.
parser: ... then shift 'filter_over', pending reduce 179
parser: Reduce 179 [expr ::= ID|INDEXED LP distinct exprlist RP filter_over], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 355
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 355
parser: Reduce 355 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 419
parser: Shift 'LP', go to state 266
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 220 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 519
parser: Reduce 359 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 484
parser: Shift 'RP', go to state 146
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'FILTER' in state 146
parser: Shift 'FILTER', go to state 482
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER]
parser: Input 'LP' in state 482
parser: Shift 'LP', go to state 481
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP]
parser: Input 'WHERE' in state 481
parser: Shift 'WHERE', go to state 90
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE]
parser: Input 'ID' in state 90
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE ID]
parser: Input 'GT' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'GT', go to state 118
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT]
parser: Input 'INTEGER' in state 118
parser: Shift 'INTEGER', pending reduce 173
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT INTEGER]
parser: Input 'RP' with pending reduce 173
parser: Reduce 173 [term ::= INTEGER], go to state 118.
parser: ... then shift 'term', go to state 130
parser: Reduce 185 [expr ::= expr LT|GT|GE|LE expr], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'RP', pending reduce 322
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr RP]
parser: Input 'COMMA' with pending reduce 322
parser: Reduce 322 [filter_clause ::= FILTER LP WHERE expr RP], go to state 146.
parser: ... then shift 'filter_clause', go to state 337
parser: Reduce 319 [filter_over ::= filter_clause], go to state 146.
parser: ... then shift 'filter_over', pending reduce 179
parser: Reduce 179 [expr ::= ID|INDEXED LP distinct exprlist RP filter_over], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 355
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 355
parser: Reduce 355 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 419
parser: Shift 'LP', go to state 266
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 220 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 519
parser: Reduce 359 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 484
parser: Shift 'RP', go to state 146
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'FILTER' in state 146
parser: Shift 'FILTER', go to state 482
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER]
parser: Input 'LP' in state 482
parser: Shift 'LP', go to state 481
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP]
parser: Input 'WHERE' in state 481
parser: Shift 'WHERE', go to state 90
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE]
parser: Input 'ID' in state 90
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE ID]
parser: Input 'GT' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'GT', go to state 118
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT]
parser: Input 'INTEGER' in state 118
parser: Shift 'INTEGER', pending reduce 173
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT INTEGER]
parser: Input 'RP' with pending reduce 173
parser: Reduce 173 [term ::= INTEGER], go to state 118.
parser: ... then shift 'term', go to state 130
parser: Reduce 185 [expr ::= expr LT|GT|GE|LE expr], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'RP', pending reduce 322
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr RP]
parser: Input 'COMMA' with pending reduce 322
parser: Reduce 322 [filter_clause ::= FILTER LP WHERE expr RP], go to state 146.
parser: ... then shift 'filter_clause', go to state 337
parser: Reduce 319 [filter_over ::= filter_clause], go to state 146.
parser: ... then shift 'filter_over', pending reduce 179
parser: Reduce 179 [expr ::= ID|INDEXED LP distinct exprlist RP filter_over], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 355
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 355
parser: Reduce 355 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 419
parser: Shift 'LP', go to state 266
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 220 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 519
parser: Reduce 359 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 484
parser: Shift 'RP', go to state 146
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'FILTER' in state 146
parser: Shift 'FILTER', go to state 482
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER]
parser: Input 'LP' in state 482
parser: Shift 'LP', go to state 481
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP]
parser: Input 'WHERE' in state 481
parser: Shift 'WHERE', go to state 90
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE]
parser: Input 'ID' in state 90
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE ID]
parser: Input 'GT' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'GT', go to state 118
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT]
parser: Input 'INTEGER' in state 118
parser: Shift 'INTEGER', pending reduce 173
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT INTEGER]
parser: Input 'RP' with pending reduce 173
parser: Reduce 173 [term ::= INTEGER], go to state 118.
parser: ... then shift 'term', go to state 130
parser: Reduce 185 [expr ::= expr LT|GT|GE|LE expr], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'RP', pending reduce 322
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr RP]
parser: Input 'FROM' with pending reduce 322
parser: Reduce 322 [filter_clause ::= FILTER LP WHERE expr RP], go to state 146.
parser: ... then shift 'filter_clause', go to state 337
parser: Reduce 319 [filter_over ::= filter_clause], go to state 146.
parser: ... then shift 'filter_over', pending reduce 179
parser: Reduce 179 [expr ::= ID|INDEXED LP distinct exprlist RP filter_over], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 104 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'SEMI' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 350
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 123 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 349
parser: Reduce 122 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 348
parser: Reduce 127 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 105
parser: Reduce 105 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 102 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 363
parser: Reduce 147 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 362
parser: Reduce 138 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 361
parser: Reduce 140 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 128 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 360
parser: Reduce 142 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 88
parser: Reduce 88 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 37.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 83 [select ::= selectnowith], go to state 37.
parser: ... then shift 'select', pending reduce 78
parser: Reduce 78 [cmd ::= createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
  11 Next             0    5    0               01 
  12 Halt             0    0    0               00 
parser: [[[CREATE TABLE x(type text,name text,tbl_name text,rootpage int,sql text)]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 390
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 0.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP ID]
parser: Input 'ID' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 192
parser: Shift 'ID', pending reduce 341
parser: Return. Stack=[create_table LP nm ID]
parser: Input 'COMMA' with pending reduce 341
parser: Reduce 341 [typename ::= ID|STRING], go to state 192.
parser: ... then shift 'typename', go to state 392
parser: Reduce 340 [typetoken ::= typename], go to state 192.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 379
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 152
parser: Reduce 336 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'ID' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Shift 'ID', pending reduce 341
parser: Return. Stack=[create_table LP columnlist COMMA nm ID]
parser: Input 'COMMA' with pending reduce 341
parser: Reduce 341 [typename ::= ID|STRING], go to state 192.
parser: ... then shift 'typename', go to state 392
parser: Reduce 340 [typetoken ::= typename], go to state 192.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'ID' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Shift 'ID', pending reduce 341
parser: Return. Stack=[create_table LP columnlist COMMA nm ID]
parser: Input 'COMMA' with pending reduce 341
parser: Reduce 341 [typename ::= ID|STRING], go to state 192.
parser: ... then shift 'typename', go to state 392
parser: Reduce 340 [typetoken ::= typename], go to state 192.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'ID' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Shift 'ID', pending reduce 341
parser: Return. Stack=[create_table LP columnlist COMMA nm ID]
parser: Input 'COMMA' with pending reduce 341
parser: Reduce 341 [typename ::= ID|STRING], go to state 192.
parser: ... then shift 'typename', go to state 392
parser: Reduce 340 [typetoken ::= typename], go to state 192.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'ID' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Shift 'ID', pending reduce 341
parser: Return. Stack=[create_table LP columnlist COMMA nm ID]
parser: Input 'RP' with pending reduce 341
parser: Reduce 341 [typename ::= ID|STRING], go to state 192.
parser: ... then shift 'typename', go to state 392
parser: Reduce 340 [typetoken ::= typename], go to state 192.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Reduce 61 [conslist_opt ::=].
parser: ... then shift 'conslist_opt', go to state 540
parser: Shift 'RP', go to state 364
parser: Return. Stack=[create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 364
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: ... then shift 'create_table_args', pending reduce 334
parser: Reduce 334 [cmd ::= create_table create_table_args], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT*FROM"aux".sqlite_master ORDER BY rowid]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'STAR' in state 288
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 95 [sclp ::=].
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STAR', pending reduce 97
parser: Return. Stack=[SELECT distinct sclp scanpt STAR]
parser: Input 'FROM' with pending reduce 97
parser: Reduce 97 [selcollist ::= sclp scanpt STAR], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 104 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'DOT' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 350
parser: Shift 'DOT', go to state 245
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID' in state 245
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'ORDER' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 245.
parser: ... then shift 'nm', pending reduce 110
parser: Reduce 110 [dbnm ::= DOT nm], go to state 350.
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 123 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 349
parser: Reduce 122 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 348
parser: Reduce 127 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 105
parser: Reduce 105 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 102 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 363
parser: Reduce 147 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 362
parser: Reduce 138 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 361
parser: Reduce 140 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 517
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 517
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 419
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 134 [sortorder ::=].
parser: ... then shift 'sortorder', go to state 353
parser: Reduce 137 [nulls ::=].
parser: ... then shift 'nulls', pending reduce 131
parser: Reduce 131 [sortlist ::= expr sortorder nulls], go to state 26.
parser: ... then shift 'sortlist', go to state 516
parser: Reduce 129 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 360
parser: Reduce 142 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 88
parser: Reduce 88 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 83 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 80
parser: Reduce 80 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
VDBE Trace:
   0 Init             0   13    0               00 Start at 13
  13 Transaction      2    0   36 1             00 usesStmtJournal=0
  14 TableLock        2    1    0 sqlite_master 00 iDb=2 root=1 write=0
  15 Goto             0    1    0               00 
   1 Noop             1    7    0               00 
   2 OpenRead         0    1    2 5             00 root=1 iDb=2; sqlite_master
   3 Explain          3    0    0 SCAN TABLE sqlite_master 00 
   4 Rewind           0   12    0               00 
   5 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s5[table](8)
   6 Column           0    1    2               00 r[2]=sqlite_master.name
REG[2] =   s5[stuff](8)
   7 Column           0    2    3               00 r[3]=sqlite_master.tbl_name
REG[3] =   s5[stuff](8)
   8 Column           0    3    4               00 r[4]=sqlite_master.rootpage
REG[4] =  i:2
   9 Column           0    4    5               00 r[5]=sqlite_master.sql
REG[5] =   s45[CREATE TABLE stuff(descri](8)
  10 ResultRow        1    5    0               00 output=r[1..5]
REG[1] =   s5[table](8)
REG[2] =   s5[stuff](8)
REG[3] =   s5[stuff](8)
REG[4] =  i:2
REG[5] =   s45[CREATE TABLE stuff(descri](8)
parser: [[[CREATE TABLE stuff(description, shape, color)]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 390
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 0.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP ID]
parser: Input 'COMMA' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 192
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 379
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 152
parser: Reduce 336 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'COMMA' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'RP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Reduce 61 [conslist_opt ::=].
parser: ... then shift 'conslist_opt', go to state 540
parser: Shift 'RP', go to state 364
parser: Return. Stack=[create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 364
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: ... then shift 'create_table_args', pending reduce 334
parser: Reduce 334 [cmd ::= create_table create_table_args], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
  11 Next             0    5    0               01 
   5 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s5[table](8)
   6 Column           0    1    2               00 r[2]=sqlite_master.name
REG[2] =   s10[insert_log](8)
   7 Column           0    2    3               00 r[3]=sqlite_master.tbl_name
REG[3] =   s10[insert_log](8)
   8 Column           0    3    4               00 r[4]=sqlite_master.rootpage
REG[4] =  i:3
   9 Column           0    4    5               00 r[5]=sqlite_master.sql
REG[5] =   s36[CREATE TABLE insert_log(d](8)
  10 ResultRow        1    5    0               00 output=r[1..5]
REG[1] =   s5[table](8)
REG[2] =   s10[insert_log](8)
REG[3] =   s10[insert_log](8)
REG[4] =  i:3
REG[5] =   s36[CREATE TABLE insert_log(d](8)
parser: [[[CREATE TABLE insert_log(db, d, e, f)]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 390
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 0.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP ID]
parser: Input 'COMMA' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 192
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 379
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 152
parser: Reduce 336 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'COMMA' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'COMMA' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'RP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Reduce 61 [conslist_opt ::=].
parser: ... then shift 'conslist_opt', go to state 540
parser: Shift 'RP', go to state 364
parser: Return. Stack=[create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 364
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: ... then shift 'create_table_args', pending reduce 334
parser: Reduce 334 [cmd ::= create_table create_table_args], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
  11 Next             0    5    0               01 
   5 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s5[table](8)
   6 Column           0    1    2               00 r[2]=sqlite_master.name
REG[2] =   s3[ghi](8)
   7 Column           0    2    3               00 r[3]=sqlite_master.tbl_name
REG[3] =   s3[ghi](8)
   8 Column           0    3    4               00 r[4]=sqlite_master.rootpage
REG[4] =  i:4
   9 Column           0    4    5               00 r[5]=sqlite_master.sql
REG[5] =   s25[CREATE TABLE ghi(g, h, i)](8)
  10 ResultRow        1    5    0               00 output=r[1..5]
REG[1] =   s5[table](8)
REG[2] =   s3[ghi](8)
REG[3] =   s3[ghi](8)
REG[4] =  i:4
REG[5] =   s25[CREATE TABLE ghi(g, h, i)](8)
parser: [[[CREATE TABLE ghi(g, h, i)]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 390
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 0.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP ID]
parser: Input 'COMMA' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 192
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 379
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 152
parser: Reduce 336 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'COMMA' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'RP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Reduce 61 [conslist_opt ::=].
parser: ... then shift 'conslist_opt', go to state 540
parser: Shift 'RP', go to state 364
parser: Return. Stack=[create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 364
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: ... then shift 'create_table_args', pending reduce 334
parser: Reduce 334 [cmd ::= create_table create_table_args], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
  11 Next             0    5    0               01 
   5 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s5[table](8)
   6 Column           0    1    2               00 r[2]=sqlite_master.name
REG[2] =   s5[files](8)
   7 Column           0    2    3               00 r[3]=sqlite_master.tbl_name
REG[3] =   s5[files](8)
   8 Column           0    3    4               00 r[4]=sqlite_master.rootpage
REG[4] =  i:5
   9 Column           0    4    5               00 r[5]=sqlite_master.sql
REG[5] =   s30[CREATE TABLE files(name, ](8)
  10 ResultRow        1    5    0               00 output=r[1..5]
REG[1] =   s5[table](8)
REG[2] =   s5[files](8)
REG[3] =   s5[files](8)
REG[4] =  i:5
REG[5] =   s30[CREATE TABLE files(name, ](8)
parser: [[[CREATE TABLE files(name, text)]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 390
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 0.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP ID]
parser: Input 'COMMA' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 192
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 379
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 152
parser: Reduce 336 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'RP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Reduce 61 [conslist_opt ::=].
parser: ... then shift 'conslist_opt', go to state 540
parser: Shift 'RP', go to state 364
parser: Return. Stack=[create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 364
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: ... then shift 'create_table_args', pending reduce 334
parser: Reduce 334 [cmd ::= create_table create_table_args], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
  11 Next             0    5    0               01 
   5 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s5[table](8)
   6 Column           0    1    2               00 r[2]=sqlite_master.name
REG[2] =   s2[ab](8)
   7 Column           0    2    3               00 r[3]=sqlite_master.tbl_name
REG[3] =   s2[ab](8)
   8 Column           0    3    4               00 r[4]=sqlite_master.rootpage
REG[4] =  i:6
   9 Column           0    4    5               00 r[5]=sqlite_master.sql
REG[5] =   s21[CREATE TABLE ab(a, b)](8)
  10 ResultRow        1    5    0               00 output=r[1..5]
REG[1] =   s5[table](8)
REG[2] =   s2[ab](8)
REG[3] =   s2[ab](8)
REG[4] =  i:6
REG[5] =   s21[CREATE TABLE ab(a, b)](8)
parser: [[[CREATE TABLE ab(a, b)]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 390
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 0.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP ID]
parser: Input 'COMMA' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 192
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 379
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 152
parser: Reduce 336 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'RP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Reduce 61 [conslist_opt ::=].
parser: ... then shift 'conslist_opt', go to state 540
parser: Shift 'RP', go to state 364
parser: Return. Stack=[create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 364
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: ... then shift 'create_table_args', pending reduce 334
parser: Reduce 334 [cmd ::= create_table create_table_args], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
  11 Next             0    5    0               01 
   5 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s5[table](8)
   6 Column           0    1    2               00 r[2]=sqlite_master.name
REG[2] =   s3[def](8)
   7 Column           0    2    3               00 r[3]=sqlite_master.tbl_name
REG[3] =   s3[def](8)
   8 Column           0    3    4               00 r[4]=sqlite_master.rootpage
REG[4] =  i:7
   9 Column           0    4    5               00 r[5]=sqlite_master.sql
REG[5] =   s25[CREATE TABLE def(d, e, f)](8)
  10 ResultRow        1    5    0               00 output=r[1..5]
REG[1] =   s5[table](8)
REG[2] =   s3[def](8)
REG[3] =   s3[def](8)
REG[4] =  i:7
REG[5] =   s25[CREATE TABLE def(d, e, f)](8)
parser: [[[CREATE TABLE def(d, e, f)]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 390
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 0.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP ID]
parser: Input 'COMMA' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 192
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 379
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 152
parser: Reduce 336 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'COMMA' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'RP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Reduce 61 [conslist_opt ::=].
parser: ... then shift 'conslist_opt', go to state 540
parser: Shift 'RP', go to state 364
parser: Return. Stack=[create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 364
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: ... then shift 'create_table_args', pending reduce 334
parser: Reduce 334 [cmd ::= create_table create_table_args], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
  11 Next             0    5    0               01 
   5 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s5[table](8)
   6 Column           0    1    2               00 r[2]=sqlite_master.name
REG[2] =   s12[sqlite_stat1](8)
   7 Column           0    2    3               00 r[3]=sqlite_master.tbl_name
REG[3] =   s12[sqlite_stat1](8)
   8 Column           0    3    4               00 r[4]=sqlite_master.rootpage
REG[4] =  i:8
   9 Column           0    4    5               00 r[5]=sqlite_master.sql
REG[5] =   s39[CREATE TABLE sqlite_stat1](8)
  10 ResultRow        1    5    0               00 output=r[1..5]
REG[1] =   s5[table](8)
REG[2] =   s12[sqlite_stat1](8)
REG[3] =   s12[sqlite_stat1](8)
REG[4] =  i:8
REG[5] =   s39[CREATE TABLE sqlite_stat1](8)
parser: [[[CREATE TABLE sqlite_stat1(tbl,idx,stat)]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 390
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 0.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP ID]
parser: Input 'COMMA' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 192
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 379
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 152
parser: Reduce 336 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'COMMA' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'RP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Reduce 61 [conslist_opt ::=].
parser: ... then shift 'conslist_opt', go to state 540
parser: Shift 'RP', go to state 364
parser: Return. Stack=[create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 364
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: ... then shift 'create_table_args', pending reduce 334
parser: Reduce 334 [cmd ::= create_table create_table_args], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
  11 Next             0    5    0               01 
   5 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s5[table](8)
   6 Column           0    1    2               00 r[2]=sqlite_master.name
REG[2] =   s8[f3_rules](8)
   7 Column           0    2    3               00 r[3]=sqlite_master.tbl_name
REG[3] =   s8[f3_rules](8)
   8 Column           0    3    4               00 r[4]=sqlite_master.rootpage
REG[4] =  i:10
   9 Column           0    4    5               00 r[5]=sqlite_master.sql
REG[5] =   s48[CREATE TABLE f3_rules(rul](8)
  10 ResultRow        1    5    0               00 output=r[1..5]
REG[1] =   s5[table](8)
REG[2] =   s8[f3_rules](8)
REG[3] =   s8[f3_rules](8)
REG[4] =  i:10
REG[5] =   s48[CREATE TABLE f3_rules(rul](8)
parser: [[[CREATE TABLE f3_rules(ruleset, cfrom, cto, cost)]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 390
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 0.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP ID]
parser: Input 'COMMA' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 192
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 379
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 152
parser: Reduce 336 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'COMMA' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'COMMA' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'RP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Reduce 61 [conslist_opt ::=].
parser: ... then shift 'conslist_opt', go to state 540
parser: Shift 'RP', go to state 364
parser: Return. Stack=[create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 364
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: ... then shift 'create_table_args', pending reduce 334
parser: Reduce 334 [cmd ::= create_table create_table_args], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
  11 Next             0    5    0               01 
   5 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s5[table](8)
   6 Column           0    1    2               00 r[2]=sqlite_master.name
REG[2] =   s3[t28](8)
   7 Column           0    2    3               00 r[3]=sqlite_master.tbl_name
REG[3] =   s3[t28](8)
   8 Column           0    3    4               00 r[4]=sqlite_master.rootpage
REG[4] =  i:11
   9 Column           0    4    5               00 r[5]=sqlite_master.sql
REG[5] =   s48[CREATE TABLE t28 (a INTEG](8)
  10 ResultRow        1    5    0               00 output=r[1..5]
REG[1] =   s5[table](8)
REG[2] =   s3[t28](8)
REG[3] =   s3[t28](8)
REG[4] =  i:11
REG[5] =   s48[CREATE TABLE t28 (a INTEG](8)
parser: [[[CREATE TABLE t28 (a INTEGER PRIMARY KEY, b TEXT)]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 390
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 0.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP ID]
parser: Input 'ID' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 192
parser: Shift 'ID', pending reduce 341
parser: Return. Stack=[create_table LP nm ID]
parser: Input 'PRIMARY' with pending reduce 341
parser: Reduce 341 [typename ::= ID|STRING], go to state 192.
parser: ... then shift 'typename', go to state 392
parser: Reduce 340 [typetoken ::= typename], go to state 192.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 379
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 152
parser: Shift 'PRIMARY', go to state 478
parser: Return. Stack=[create_table LP columnname carglist PRIMARY]
parser: Input 'KEY' in state 478
parser: Shift 'KEY', go to state 280
parser: Return. Stack=[create_table LP columnname carglist PRIMARY KEY]
parser: Input 'COMMA' in state 280
parser: Reduce 134 [sortorder ::=].
parser: ... then shift 'sortorder', go to state 333
parser: Reduce 69 [onconf ::=].
parser: ... then shift 'onconf', go to state 332
parser: Reduce 43 [autoinc ::=].
parser: ... then shift 'autoinc', pending reduce 37
parser: Reduce 37 [ccons ::= PRIMARY KEY sortorder onconf autoinc], go to state 152.
parser: ... then shift 'ccons', pending reduce 344
parser: Reduce 344 [carglist ::= carglist ccons], go to state 379.
parser: ... then shift 'carglist', go to state 152
parser: Reduce 336 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'ID' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Shift 'ID', pending reduce 341
parser: Return. Stack=[create_table LP columnlist COMMA nm ID]
parser: Input 'RP' with pending reduce 341
parser: Reduce 341 [typename ::= ID|STRING], go to state 192.
parser: ... then shift 'typename', go to state 392
parser: Reduce 340 [typetoken ::= typename], go to state 192.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Reduce 61 [conslist_opt ::=].
parser: ... then shift 'conslist_opt', go to state 540
parser: Shift 'RP', go to state 364
parser: Return. Stack=[create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 364
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: ... then shift 'create_table_args', pending reduce 334
parser: Reduce 334 [cmd ::= create_table create_table_args], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
  11 Next             0    5    0               01 
   5 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s5[table](8)
   6 Column           0    1    2               00 r[2]=sqlite_master.name
REG[2] =   s5[t1new](8)
   7 Column           0    2    3               00 r[3]=sqlite_master.tbl_name
REG[3] =   s5[t1new](8)
   8 Column           0    3    4               00 r[4]=sqlite_master.rootpage
REG[4] =  i:13
   9 Column           0    4    5               00 r[5]=sqlite_master.sql
REG[5] =   s29[CREATE TABLE "t1new"(a, b](8)
  10 ResultRow        1    5    0               00 output=r[1..5]
REG[1] =   s5[table](8)
REG[2] =   s5[t1new](8)
REG[3] =   s5[t1new](8)
REG[4] =  i:13
REG[5] =   s29[CREATE TABLE "t1new"(a, b](8)
parser: [[[CREATE TABLE "t1new"(a, b, c)]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 390
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 0.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP ID]
parser: Input 'COMMA' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 192
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 379
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 152
parser: Reduce 336 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'COMMA' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'RP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Reduce 61 [conslist_opt ::=].
parser: ... then shift 'conslist_opt', go to state 540
parser: Shift 'RP', go to state 364
parser: Return. Stack=[create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 364
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: ... then shift 'create_table_args', pending reduce 334
parser: Reduce 334 [cmd ::= create_table create_table_args], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
  11 Next             0    5    0               01 
   5 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s5[table](8)
   6 Column           0    1    2               00 r[2]=sqlite_master.name
REG[2] =   s3[t16](8)
   7 Column           0    2    3               00 r[3]=sqlite_master.tbl_name
REG[3] =   s3[t16](8)
   8 Column           0    3    4               00 r[4]=sqlite_master.rootpage
REG[4] =  i:14
   9 Column           0    4    5               00 r[5]=sqlite_master.sql
REG[5] =   s48[CREATE TABLE t16 (a INTEG](8)
  10 ResultRow        1    5    0               00 output=r[1..5]
REG[1] =   s5[table](8)
REG[2] =   s3[t16](8)
REG[3] =   s3[t16](8)
REG[4] =  i:14
REG[5] =   s48[CREATE TABLE t16 (a INTEG](8)
parser: [[[CREATE TABLE t16 (a INTEGER PRIMARY KEY, b TEXT)]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 390
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 0.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP ID]
parser: Input 'ID' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 192
parser: Shift 'ID', pending reduce 341
parser: Return. Stack=[create_table LP nm ID]
parser: Input 'PRIMARY' with pending reduce 341
parser: Reduce 341 [typename ::= ID|STRING], go to state 192.
parser: ... then shift 'typename', go to state 392
parser: Reduce 340 [typetoken ::= typename], go to state 192.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 379
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 152
parser: Shift 'PRIMARY', go to state 478
parser: Return. Stack=[create_table LP columnname carglist PRIMARY]
parser: Input 'KEY' in state 478
parser: Shift 'KEY', go to state 280
parser: Return. Stack=[create_table LP columnname carglist PRIMARY KEY]
parser: Input 'COMMA' in state 280
parser: Reduce 134 [sortorder ::=].
parser: ... then shift 'sortorder', go to state 333
parser: Reduce 69 [onconf ::=].
parser: ... then shift 'onconf', go to state 332
parser: Reduce 43 [autoinc ::=].
parser: ... then shift 'autoinc', pending reduce 37
parser: Reduce 37 [ccons ::= PRIMARY KEY sortorder onconf autoinc], go to state 152.
parser: ... then shift 'ccons', pending reduce 344
parser: Reduce 344 [carglist ::= carglist ccons], go to state 379.
parser: ... then shift 'carglist', go to state 152
parser: Reduce 336 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'ID' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Shift 'ID', pending reduce 341
parser: Return. Stack=[create_table LP columnlist COMMA nm ID]
parser: Input 'RP' with pending reduce 341
parser: Reduce 341 [typename ::= ID|STRING], go to state 192.
parser: ... then shift 'typename', go to state 392
parser: Reduce 340 [typetoken ::= typename], go to state 192.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Reduce 61 [conslist_opt ::=].
parser: ... then shift 'conslist_opt', go to state 540
parser: Shift 'RP', go to state 364
parser: Return. Stack=[create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 364
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: ... then shift 'create_table_args', pending reduce 334
parser: Reduce 334 [cmd ::= create_table create_table_args], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
  11 Next             0    5    0               01 
   5 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s5[table](8)
   6 Column           0    1    2               00 r[2]=sqlite_master.name
REG[2] =   s5[t20_3](8)
   7 Column           0    2    3               00 r[3]=sqlite_master.tbl_name
REG[3] =   s5[t20_3](8)
   8 Column           0    3    4               00 r[4]=sqlite_master.rootpage
REG[4] =  i:15
   9 Column           0    4    5               00 r[5]=sqlite_master.sql
REG[5] =   s21[CREATE TABLE t20_3(z)](8)
  10 ResultRow        1    5    0               00 output=r[1..5]
REG[1] =   s5[table](8)
REG[2] =   s5[t20_3](8)
REG[3] =   s5[t20_3](8)
REG[4] =  i:15
REG[5] =   s21[CREATE TABLE t20_3(z)](8)
parser: [[[CREATE TABLE t20_3(z)]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 390
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 0.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP ID]
parser: Input 'RP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 192
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 379
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 152
parser: Reduce 336 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Reduce 61 [conslist_opt ::=].
parser: ... then shift 'conslist_opt', go to state 540
parser: Shift 'RP', go to state 364
parser: Return. Stack=[create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 364
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: ... then shift 'create_table_args', pending reduce 334
parser: Reduce 334 [cmd ::= create_table create_table_args], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
  11 Next             0    5    0               01 
   5 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s5[table](8)
   6 Column           0    1    2               00 r[2]=sqlite_master.name
REG[2] =   s4[t xx](8)
   7 Column           0    2    3               00 r[3]=sqlite_master.tbl_name
REG[3] =   s4[t xx](8)
   8 Column           0    3    4               00 r[4]=sqlite_master.rootpage
REG[4] =  i:16
   9 Column           0    4    5               00 r[5]=sqlite_master.sql
REG[5] =   s28[CREATE TABLE "t xx"(a, b,](8)
  10 ResultRow        1    5    0               00 output=r[1..5]
REG[1] =   s5[table](8)
REG[2] =   s4[t xx](8)
REG[3] =   s4[t xx](8)
REG[4] =  i:16
REG[5] =   s28[CREATE TABLE "t xx"(a, b,](8)
parser: [[[CREATE TABLE "t xx"(a, b, c)]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 390
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 0.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP ID]
parser: Input 'COMMA' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 192
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 379
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 152
parser: Reduce 336 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'COMMA' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'RP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Reduce 61 [conslist_opt ::=].
parser: ... then shift 'conslist_opt', go to state 540
parser: Shift 'RP', go to state 364
parser: Return. Stack=[create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 364
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: ... then shift 'create_table_args', pending reduce 334
parser: Reduce 334 [cmd ::= create_table create_table_args], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
  11 Next             0    5    0               01 
   5 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s5[table](8)
   6 Column           0    1    2               00 r[2]=sqlite_master.name
REG[2] =   s5[t20_2](8)
   7 Column           0    2    3               00 r[3]=sqlite_master.tbl_name
REG[3] =   s5[t20_2](8)
   8 Column           0    3    4               00 r[4]=sqlite_master.rootpage
REG[4] =  i:17
   9 Column           0    4    5               00 r[5]=sqlite_master.sql
REG[5] =   s21[CREATE TABLE t20_2(y)](8)
  10 ResultRow        1    5    0               00 output=r[1..5]
REG[1] =   s5[table](8)
REG[2] =   s5[t20_2](8)
REG[3] =   s5[t20_2](8)
REG[4] =  i:17
REG[5] =   s21[CREATE TABLE t20_2(y)](8)
parser: [[[CREATE TABLE t20_2(y)]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 390
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 0.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP ID]
parser: Input 'RP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 192
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 379
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 152
parser: Reduce 336 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Reduce 61 [conslist_opt ::=].
parser: ... then shift 'conslist_opt', go to state 540
parser: Shift 'RP', go to state 364
parser: Return. Stack=[create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 364
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: ... then shift 'create_table_args', pending reduce 334
parser: Reduce 334 [cmd ::= create_table create_table_args], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
  11 Next             0    5    0               01 
   5 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s5[table](8)
   6 Column           0    1    2               00 r[2]=sqlite_master.name
REG[2] =   s4[bool](8)
   7 Column           0    2    3               00 r[3]=sqlite_master.tbl_name
REG[3] =   s4[bool](8)
   8 Column           0    3    4               00 r[4]=sqlite_master.rootpage
REG[4] =  i:18
   9 Column           0    4    5               00 r[5]=sqlite_master.sql
REG[5] =   s74[CREATE TABLE "bool" ( a i](8)
  10 ResultRow        1    5    0               00 output=r[1..5]
REG[1] =   s5[table](8)
REG[2] =   s4[bool](8)
REG[3] =   s4[bool](8)
REG[4] =  i:18
REG[5] =   s74[CREATE TABLE "bool" ( a i](8)
parser: [[[CREATE TABLE "bool" ( a integer , abc, v1, i2, t2, t3, x, y, t2i1, ex, i1)]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 390
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 0.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP ID]
parser: Input 'ID' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 192
parser: Shift 'ID', pending reduce 341
parser: Return. Stack=[create_table LP nm ID]
parser: Input 'COMMA' with pending reduce 341
parser: Reduce 341 [typename ::= ID|STRING], go to state 192.
parser: ... then shift 'typename', go to state 392
parser: Reduce 340 [typetoken ::= typename], go to state 192.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 379
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 152
parser: Reduce 336 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'COMMA' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'COMMA' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'COMMA' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'COMMA' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'COMMA' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'COMMA' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'COMMA' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'COMMA' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'COMMA' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'RP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Reduce 61 [conslist_opt ::=].
parser: ... then shift 'conslist_opt', go to state 540
parser: Shift 'RP', go to state 364
parser: Return. Stack=[create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 364
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: ... then shift 'create_table_args', pending reduce 334
parser: Reduce 334 [cmd ::= create_table create_table_args], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
  11 Next             0    5    0               01 
   5 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s5[table](8)
   6 Column           0    1    2               00 r[2]=sqlite_master.name
REG[2] =   s3[t19](8)
   7 Column           0    2    3               00 r[3]=sqlite_master.tbl_name
REG[3] =   s3[t19](8)
   8 Column           0    3    4               00 r[4]=sqlite_master.rootpage
REG[4] =  i:19
   9 Column           0    4    5               00 r[5]=sqlite_master.sql
REG[5] =   s48[CREATE TABLE t19 (a INTEG](8)
  10 ResultRow        1    5    0               00 output=r[1..5]
REG[1] =   s5[table](8)
REG[2] =   s3[t19](8)
REG[3] =   s3[t19](8)
REG[4] =  i:19
REG[5] =   s48[CREATE TABLE t19 (a INTEG](8)
parser: [[[CREATE TABLE t19 (a INTEGER PRIMARY KEY, b TEXT)]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 390
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 0.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP ID]
parser: Input 'ID' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 192
parser: Shift 'ID', pending reduce 341
parser: Return. Stack=[create_table LP nm ID]
parser: Input 'PRIMARY' with pending reduce 341
parser: Reduce 341 [typename ::= ID|STRING], go to state 192.
parser: ... then shift 'typename', go to state 392
parser: Reduce 340 [typetoken ::= typename], go to state 192.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 379
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 152
parser: Shift 'PRIMARY', go to state 478
parser: Return. Stack=[create_table LP columnname carglist PRIMARY]
parser: Input 'KEY' in state 478
parser: Shift 'KEY', go to state 280
parser: Return. Stack=[create_table LP columnname carglist PRIMARY KEY]
parser: Input 'COMMA' in state 280
parser: Reduce 134 [sortorder ::=].
parser: ... then shift 'sortorder', go to state 333
parser: Reduce 69 [onconf ::=].
parser: ... then shift 'onconf', go to state 332
parser: Reduce 43 [autoinc ::=].
parser: ... then shift 'autoinc', pending reduce 37
parser: Reduce 37 [ccons ::= PRIMARY KEY sortorder onconf autoinc], go to state 152.
parser: ... then shift 'ccons', pending reduce 344
parser: Reduce 344 [carglist ::= carglist ccons], go to state 379.
parser: ... then shift 'carglist', go to state 152
parser: Reduce 336 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'ID' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Shift 'ID', pending reduce 341
parser: Return. Stack=[create_table LP columnlist COMMA nm ID]
parser: Input 'RP' with pending reduce 341
parser: Reduce 341 [typename ::= ID|STRING], go to state 192.
parser: ... then shift 'typename', go to state 392
parser: Reduce 340 [typetoken ::= typename], go to state 192.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Reduce 61 [conslist_opt ::=].
parser: ... then shift 'conslist_opt', go to state 540
parser: Shift 'RP', go to state 364
parser: Return. Stack=[create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 364
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: ... then shift 'create_table_args', pending reduce 334
parser: Reduce 334 [cmd ::= create_table create_table_args], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
  11 Next             0    5    0               01 
   5 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s5[table](8)
   6 Column           0    1    2               00 r[2]=sqlite_master.name
REG[2] =   s2[x3](8)
   7 Column           0    2    3               00 r[3]=sqlite_master.tbl_name
REG[3] =   s2[x3](8)
   8 Column           0    3    4               00 r[4]=sqlite_master.rootpage
REG[4] =  i:21
   9 Column           0    4    5               00 r[5]=sqlite_master.sql
REG[5] =   s54[CREATE TABLE x3(a INTEGER](8)
  10 ResultRow        1    5    0               00 output=r[1..5]
REG[1] =   s5[table](8)
REG[2] =   s2[x3](8)
REG[3] =   s2[x3](8)
REG[4] =  i:21
REG[5] =   s54[CREATE TABLE x3(a INTEGER](8)
parser: [[[CREATE TABLE x3(a INTEGER PRIMARY KEY, b TEXT, c BLOB)]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 390
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 0.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP ID]
parser: Input 'ID' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 192
parser: Shift 'ID', pending reduce 341
parser: Return. Stack=[create_table LP nm ID]
parser: Input 'PRIMARY' with pending reduce 341
parser: Reduce 341 [typename ::= ID|STRING], go to state 192.
parser: ... then shift 'typename', go to state 392
parser: Reduce 340 [typetoken ::= typename], go to state 192.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 379
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 152
parser: Shift 'PRIMARY', go to state 478
parser: Return. Stack=[create_table LP columnname carglist PRIMARY]
parser: Input 'KEY' in state 478
parser: Shift 'KEY', go to state 280
parser: Return. Stack=[create_table LP columnname carglist PRIMARY KEY]
parser: Input 'COMMA' in state 280
parser: Reduce 134 [sortorder ::=].
parser: ... then shift 'sortorder', go to state 333
parser: Reduce 69 [onconf ::=].
parser: ... then shift 'onconf', go to state 332
parser: Reduce 43 [autoinc ::=].
parser: ... then shift 'autoinc', pending reduce 37
parser: Reduce 37 [ccons ::= PRIMARY KEY sortorder onconf autoinc], go to state 152.
parser: ... then shift 'ccons', pending reduce 344
parser: Reduce 344 [carglist ::= carglist ccons], go to state 379.
parser: ... then shift 'carglist', go to state 152
parser: Reduce 336 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'ID' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Shift 'ID', pending reduce 341
parser: Return. Stack=[create_table LP columnlist COMMA nm ID]
parser: Input 'COMMA' with pending reduce 341
parser: Reduce 341 [typename ::= ID|STRING], go to state 192.
parser: ... then shift 'typename', go to state 392
parser: Reduce 340 [typetoken ::= typename], go to state 192.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'ID' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Shift 'ID', pending reduce 341
parser: Return. Stack=[create_table LP columnlist COMMA nm ID]
parser: Input 'RP' with pending reduce 341
parser: Reduce 341 [typename ::= ID|STRING], go to state 192.
parser: ... then shift 'typename', go to state 392
parser: Reduce 340 [typetoken ::= typename], go to state 192.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Reduce 61 [conslist_opt ::=].
parser: ... then shift 'conslist_opt', go to state 540
parser: Shift 'RP', go to state 364
parser: Return. Stack=[create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 364
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: ... then shift 'create_table_args', pending reduce 334
parser: Reduce 334 [cmd ::= create_table create_table_args], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
  11 Next             0    5    0               01 
   5 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s5[table](8)
   6 Column           0    1    2               00 r[2]=sqlite_master.name
REG[2] =   s4[t2i1](8)
   7 Column           0    2    3               00 r[3]=sqlite_master.tbl_name
REG[3] =   s4[t2i1](8)
   8 Column           0    3    4               00 r[4]=sqlite_master.rootpage
REG[4] =  i:22
   9 Column           0    4    5               00 r[5]=sqlite_master.sql
REG[5] =   s47[CREATE TABLE t2i1(t1i1 IN](8)
  10 ResultRow        1    5    0               00 output=r[1..5]
REG[1] =   s5[table](8)
REG[2] =   s4[t2i1](8)
REG[3] =   s4[t2i1](8)
REG[4] =  i:22
REG[5] =   s47[CREATE TABLE t2i1(t1i1 IN](8)
parser: [[[CREATE TABLE t2i1(t1i1 INT,abc, c VARCHAR(128))]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 390
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 0.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP ID]
parser: Input 'ID' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 192
parser: Shift 'ID', pending reduce 341
parser: Return. Stack=[create_table LP nm ID]
parser: Input 'COMMA' with pending reduce 341
parser: Reduce 341 [typename ::= ID|STRING], go to state 192.
parser: ... then shift 'typename', go to state 392
parser: Reduce 340 [typetoken ::= typename], go to state 192.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 379
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 152
parser: Reduce 336 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'COMMA' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'ID' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Shift 'ID', pending reduce 341
parser: Return. Stack=[create_table LP columnlist COMMA nm ID]
parser: Input 'LP' with pending reduce 341
parser: Reduce 341 [typename ::= ID|STRING], go to state 192.
parser: ... then shift 'typename', go to state 392
parser: Shift 'LP', go to state 138
parser: Return. Stack=[create_table LP columnlist COMMA nm typename LP]
parser: Input 'INTEGER' in state 138
parser: Shift 'INTEGER', pending reduce 365
parser: Return. Stack=[create_table LP columnlist COMMA nm typename LP INTEGER]
parser: Input 'RP' with pending reduce 365
parser: Reduce 365 [plus_num ::= INTEGER|FLOAT], go to state 138.
parser: ... then shift 'plus_num', go to state 416
parser: Shift 'RP', pending reduce 25
parser: Return. Stack=[create_table LP columnlist COMMA nm typename LP plus_num RP]
parser: Input 'RP' with pending reduce 25
parser: Reduce 25 [typetoken ::= typename LP signed RP], go to state 192.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Reduce 61 [conslist_opt ::=].
parser: ... then shift 'conslist_opt', go to state 540
parser: Shift 'RP', go to state 364
parser: Return. Stack=[create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 364
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: ... then shift 'create_table_args', pending reduce 334
parser: Reduce 334 [cmd ::= create_table create_table_args], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
  11 Next             0    5    0               01 
   5 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s5[table](8)
   6 Column           0    1    2               00 r[2]=sqlite_master.name
REG[2] =   s2[t3](8)
   7 Column           0    2    3               00 r[3]=sqlite_master.tbl_name
REG[3] =   s2[t3](8)
   8 Column           0    3    4               00 r[4]=sqlite_master.rootpage
REG[4] =  i:23
   9 Column           0    4    5               00 r[5]=sqlite_master.sql
REG[5] =   s21[CREATE TABLE t3(e, f)](8)
  10 ResultRow        1    5    0               00 output=r[1..5]
REG[1] =   s5[table](8)
REG[2] =   s2[t3](8)
REG[3] =   s2[t3](8)
REG[4] =  i:23
REG[5] =   s21[CREATE TABLE t3(e, f)](8)
parser: [[[CREATE TABLE t3(e, f)]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 390
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 0.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP ID]
parser: Input 'COMMA' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 192
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 379
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 152
parser: Reduce 336 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'RP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Reduce 61 [conslist_opt ::=].
parser: ... then shift 'conslist_opt', go to state 540
parser: Shift 'RP', go to state 364
parser: Return. Stack=[create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 364
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: ... then shift 'create_table_args', pending reduce 334
parser: Reduce 334 [cmd ::= create_table create_table_args], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
  11 Next             0    5    0               01 
   5 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s4[view](8)
   6 Column           0    1    2               00 r[2]=sqlite_master.name
REG[2] =   s1[y](8)
   7 Column           0    2    3               00 r[3]=sqlite_master.tbl_name
REG[3] =   s1[y](8)
   8 Column           0    3    4               00 r[4]=sqlite_master.rootpage
REG[4] =  i:0
   9 Column           0    4    5               00 r[5]=sqlite_master.sql
REG[5] =   s33[CREATE VIEW y AS SELECT *](8)
  10 ResultRow        1    5    0               00 output=r[1..5]
REG[1] =   s4[view](8)
REG[2] =   s1[y](8)
REG[3] =   s1[y](8)
REG[4] =  i:0
REG[5] =   s33[CREATE VIEW y AS SELECT *](8)
parser: [[[CREATE VIEW y AS SELECT * FROM i1]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'VIEW' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: FALLBACK VIEW => ID
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 390
parser: Shift 'VIEW', go to state 322
parser: Return. Stack=[createkw temp VIEW]
parser: Input 'ID' in state 322
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 228
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw temp VIEW ifnotexists ID]
parser: Input 'AS' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 228.
parser: ... then shift 'nm', go to state 321
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 320
parser: Reduce 226 [eidlist_opt ::=].
parser: ... then shift 'eidlist_opt', go to state 464
parser: Shift 'AS', go to state 37
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS]
parser: Input 'SELECT' in state 37
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT]
parser: Input 'STAR' in state 288
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 95 [sclp ::=].
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STAR', pending reduce 97
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt STAR]
parser: Input 'FROM' with pending reduce 97
parser: Reduce 97 [selcollist ::= sclp scanpt STAR], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 104 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'SEMI' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 350
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 123 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 349
parser: Reduce 122 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 348
parser: Reduce 127 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 105
parser: Reduce 105 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 102 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 363
parser: Reduce 147 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 362
parser: Reduce 138 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 361
parser: Reduce 140 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 128 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 360
parser: Reduce 142 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 88
parser: Reduce 88 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 37.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 83 [select ::= selectnowith], go to state 37.
parser: ... then shift 'select', pending reduce 78
parser: Reduce 78 [cmd ::= createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
  11 Next             0    5    0               01 
   5 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s4[view](8)
   6 Column           0    1    2               00 r[2]=sqlite_master.name
REG[2] =   s2[v3](8)
   7 Column           0    2    3               00 r[3]=sqlite_master.tbl_name
REG[3] =   s2[v3](8)
   8 Column           0    3    4               00 r[4]=sqlite_master.rootpage
REG[4] =  i:0
   9 Column           0    4    5               00 r[5]=sqlite_master.sql
REG[5] =   s27[CREATE VIEW v3 AS VALUES(](8)
  10 ResultRow        1    5    0               00 output=r[1..5]
REG[1] =   s4[view](8)
REG[2] =   s2[v3](8)
REG[3] =   s2[v3](8)
REG[4] =  i:0
REG[5] =   s27[CREATE VIEW v3 AS VALUES(](8)
parser: [[[CREATE VIEW v3 AS VALUES(1)]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'VIEW' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: FALLBACK VIEW => ID
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 390
parser: Shift 'VIEW', go to state 322
parser: Return. Stack=[createkw temp VIEW]
parser: Input 'ID' in state 322
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 228
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw temp VIEW ifnotexists ID]
parser: Input 'AS' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 228.
parser: ... then shift 'nm', go to state 321
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 320
parser: Reduce 226 [eidlist_opt ::=].
parser: ... then shift 'eidlist_opt', go to state 464
parser: Shift 'AS', go to state 37
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS]
parser: Input 'VALUES' in state 37
parser: Shift 'VALUES', go to state 528
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS VALUES]
parser: Input 'LP' in state 528
parser: Shift 'LP', go to state 28
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS VALUES LP]
parser: Input 'INTEGER' in state 28
parser: Shift 'INTEGER', pending reduce 173
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS VALUES LP INTEGER]
parser: Input 'RP' with pending reduce 173
parser: Reduce 173 [term ::= INTEGER], go to state 28.
parser: ... then shift 'term', go to state 70
parser: Reduce 220 [nexprlist ::= expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 413
parser: Shift 'RP', pending reduce 90
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS VALUES LP nexprlist RP]
parser: Input 'SEMI' with pending reduce 90
parser: Reduce 90 [values ::= VALUES LP nexprlist RP], go to state 37.
parser: ... then shift 'values', go to state 534
parser: Reduce 354 [oneselect ::= values], go to state 37.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 83 [select ::= selectnowith], go to state 37.
parser: ... then shift 'select', pending reduce 78
parser: Reduce 78 [cmd ::= createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
  11 Next             0    5    0               01 
   5 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s4[view](8)
   6 Column           0    1    2               00 r[2]=sqlite_master.name
REG[2] =   s2[ex](8)
   7 Column           0    2    3               00 r[3]=sqlite_master.tbl_name
REG[3] =   s2[ex](8)
   8 Column           0    3    4               00 r[4]=sqlite_master.rootpage
REG[4] =  i:0
   9 Column           0    4    5               00 r[5]=sqlite_master.sql
REG[5] =   s38[CREATE VIEW ex AS SELECT ](8)
  10 ResultRow        1    5    0               00 output=r[1..5]
REG[1] =   s4[view](8)
REG[2] =   s2[ex](8)
REG[3] =   s2[ex](8)
REG[4] =  i:0
REG[5] =   s38[CREATE VIEW ex AS SELECT ](8)
parser: [[[CREATE VIEW ex AS SELECT * FROM "bool"]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'VIEW' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: FALLBACK VIEW => ID
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 390
parser: Shift 'VIEW', go to state 322
parser: Return. Stack=[createkw temp VIEW]
parser: Input 'ID' in state 322
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 228
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw temp VIEW ifnotexists ID]
parser: Input 'AS' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 228.
parser: ... then shift 'nm', go to state 321
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 320
parser: Reduce 226 [eidlist_opt ::=].
parser: ... then shift 'eidlist_opt', go to state 464
parser: Shift 'AS', go to state 37
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS]
parser: Input 'SELECT' in state 37
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT]
parser: Input 'STAR' in state 288
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 95 [sclp ::=].
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STAR', pending reduce 97
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt STAR]
parser: Input 'FROM' with pending reduce 97
parser: Reduce 97 [selcollist ::= sclp scanpt STAR], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 104 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'SEMI' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 350
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 123 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 349
parser: Reduce 122 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 348
parser: Reduce 127 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 105
parser: Reduce 105 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 102 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 363
parser: Reduce 147 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 362
parser: Reduce 138 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 361
parser: Reduce 140 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 128 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 360
parser: Reduce 142 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 88
parser: Reduce 88 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 37.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 83 [select ::= selectnowith], go to state 37.
parser: ... then shift 'select', pending reduce 78
parser: Reduce 78 [cmd ::= createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
  11 Next             0    5    0               01 
   5 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s5[table](8)
   6 Column           0    1    2               00 r[2]=sqlite_master.name
REG[2] =   s2[e2](8)
   7 Column           0    2    3               00 r[3]=sqlite_master.tbl_name
REG[3] =   s2[e2](8)
   8 Column           0    3    4               00 r[4]=sqlite_master.rootpage
REG[4] =  i:0
   9 Column           0    4    5               00 r[5]=sqlite_master.sql
REG[5] =   s38[CREATE VIRTUAL TABLE e2 U](8)
  10 ResultRow        1    5    0               00 output=r[1..5]
REG[1] =   s5[table](8)
REG[2] =   s2[e2](8)
REG[3] =   s2[e2](8)
REG[4] =  i:0
REG[5] =   s38[CREATE VIRTUAL TABLE e2 U](8)
parser: [[[CREATE VIRTUAL TABLE e2 USING echo(i1)]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'VIRTUAL' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Shift 'VIRTUAL', go to state 436
parser: Return. Stack=[createkw VIRTUAL]
parser: Input 'TABLE' in state 436
parser: Shift 'TABLE', go to state 306
parser: Return. Stack=[createkw VIRTUAL TABLE]
parser: Input 'ID' in state 306
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 221
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw VIRTUAL TABLE ifnotexists ID]
parser: Input 'USING' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 221.
parser: ... then shift 'nm', go to state 305
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 435
parser: Shift 'USING', go to state 220
parser: Return. Stack=[createkw VIRTUAL TABLE ifnotexists nm dbnm USING]
parser: Input 'ID' in state 220
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw VIRTUAL TABLE ifnotexists nm dbnm USING ID]
parser: Input 'LP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 220.
parser: ... then shift 'nm', pending reduce 283
parser: Reduce 283 [create_vtab ::= createkw VIRTUAL TABLE ifnotexists nm dbnm USING nm], go to state 0.
parser: ... then shift 'create_vtab', go to state 422
parser: Shift 'LP', go to state 196
parser: Return. Stack=[create_vtab LP]
parser: Input 'ID' in state 196
parser: Reduce 284 [vtabarg ::=].
parser: ... then shift 'vtabarg', go to state 163
parser: WILDCARD ID => ANY
parser: Shift 'ID', pending reduce 285
parser: Return. Stack=[create_vtab LP vtabarg ID]
parser: Input 'RP' with pending reduce 285
parser: Reduce 285 [vtabargtoken ::= ANY], go to state 163.
parser: ... then shift 'vtabargtoken', pending reduce 376
parser: Reduce 376 [vtabarg ::= vtabarg vtabargtoken], go to state 196.
parser: ... then shift 'vtabarg', go to state 163
parser: Reduce 374 [vtabarglist ::= vtabarg], go to state 196.
parser: ... then shift 'vtabarglist', go to state 393
parser: Shift 'RP', pending reduce 282
parser: Return. Stack=[create_vtab LP vtabarglist RP]
parser: Input 'SEMI' with pending reduce 282
parser: Reduce 282 [cmd ::= create_vtab LP vtabarglist RP], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
  11 Next             0    5    0               01 
   5 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s4[view](8)
   6 Column           0    1    2               00 r[2]=sqlite_master.name
REG[2] =   s2[v2](8)
   7 Column           0    2    3               00 r[3]=sqlite_master.tbl_name
REG[3] =   s2[v2](8)
   8 Column           0    3    4               00 r[4]=sqlite_master.rootpage
REG[4] =  i:0
   9 Column           0    4    5               00 r[5]=sqlite_master.sql
REG[5] =   s34[CREATE VIEW v2 AS SELECT ](8)
  10 ResultRow        1    5    0               00 output=r[1..5]
REG[1] =   s4[view](8)
REG[2] =   s2[v2](8)
REG[3] =   s2[v2](8)
REG[4] =  i:0
REG[5] =   s34[CREATE VIEW v2 AS SELECT ](8)
parser: [[[CREATE VIEW v2 AS SELECT * FROM t1]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'VIEW' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: FALLBACK VIEW => ID
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 390
parser: Shift 'VIEW', go to state 322
parser: Return. Stack=[createkw temp VIEW]
parser: Input 'ID' in state 322
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 228
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw temp VIEW ifnotexists ID]
parser: Input 'AS' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 228.
parser: ... then shift 'nm', go to state 321
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 320
parser: Reduce 226 [eidlist_opt ::=].
parser: ... then shift 'eidlist_opt', go to state 464
parser: Shift 'AS', go to state 37
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS]
parser: Input 'SELECT' in state 37
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT]
parser: Input 'STAR' in state 288
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 95 [sclp ::=].
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STAR', pending reduce 97
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt STAR]
parser: Input 'FROM' with pending reduce 97
parser: Reduce 97 [selcollist ::= sclp scanpt STAR], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 104 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'SEMI' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 350
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 123 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 349
parser: Reduce 122 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 348
parser: Reduce 127 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 105
parser: Reduce 105 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 102 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 363
parser: Reduce 147 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 362
parser: Reduce 138 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 361
parser: Reduce 140 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 128 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 360
parser: Reduce 142 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 88
parser: Reduce 88 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 37.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 83 [select ::= selectnowith], go to state 37.
parser: ... then shift 'select', pending reduce 78
parser: Reduce 78 [cmd ::= createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
  11 Next             0    5    0               01 
   5 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s7[trigger](8)
   6 Column           0    1    2               00 r[2]=sqlite_master.name
REG[2] =   s3[tr1](8)
   7 Column           0    2    3               00 r[3]=sqlite_master.tbl_name
REG[3] =   s2[t3](8)
   8 Column           0    3    4               00 r[4]=sqlite_master.rootpage
REG[4] =  i:0
   9 Column           0    4    5               00 r[5]=sqlite_master.sql
REG[5] =   s98[CREATE TRIGGER tr1 AFTER ](8)
  10 ResultRow        1    5    0               00 output=r[1..5]
REG[1] =   s7[trigger](8)
REG[2] =   s3[tr1](8)
REG[3] =   s2[t3](8)
REG[4] =  i:0
REG[5] =   s98[CREATE TRIGGER tr1 AFTER ](8)
parser: [[[CREATE TRIGGER tr1 AFTER INSERT ON t3 BEGIN
      INSERT INTO t3 VALUES(new.e*2, new.f*2);
    END]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TRIGGER' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: FALLBACK TRIGGER => ID
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 390
parser: Shift 'TRIGGER', go to state 319
parser: Return. Stack=[createkw temp TRIGGER]
parser: Input 'ID' in state 319
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 227
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw temp TRIGGER ifnotexists ID]
parser: Input 'AFTER' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 227.
parser: ... then shift 'nm', go to state 318
parser: FALLBACK AFTER => ID
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 257
parser: Shift 'AFTER', pending reduce 246
parser: Return. Stack=[createkw temp TRIGGER ifnotexists nm dbnm AFTER]
parser: Input 'INSERT' with pending reduce 246
parser: Reduce 246 [trigger_time ::= BEFORE|AFTER], go to state 257.
parser: ... then shift 'trigger_time', go to state 256
parser: Shift 'INSERT', pending reduce 249
parser: Return. Stack=[createkw temp TRIGGER ifnotexists nm dbnm trigger_time INSERT]
parser: Input 'ON' with pending reduce 249
parser: Reduce 249 [trigger_event ::= DELETE|INSERT], go to state 256.
parser: ... then shift 'trigger_event', go to state 463
parser: Shift 'ON', go to state 181
parser: Return. Stack=[createkw temp TRIGGER ifnotexists nm dbnm trigger_time trigger_event ON]
parser: Input 'ID' in state 181
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw temp TRIGGER ifnotexists nm dbnm trigger_time trigger_event ON ID]
parser: Input 'BEGIN' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 181.
parser: ... then shift 'nm', go to state 462
parser: FALLBACK BEGIN => ID
parser: Reduce 111 [fullname ::= nm], go to state 181.
parser: ... then shift 'fullname', go to state 317
parser: FALLBACK BEGIN => ID
parser: Reduce 366 [foreach_clause ::=].
parser: ... then shift 'foreach_clause', go to state 316
parser: FALLBACK BEGIN => ID
parser: Reduce 252 [when_clause ::=].
parser: ... then shift 'when_clause', pending reduce 245
parser: Reduce 245 [trigger_decl ::= temp TRIGGER ifnotexists nm dbnm trigger_time trigger_event ON fullname foreach_clause when_clause], go to state 134.
parser: ... then shift 'trigger_decl', go to state 453
parser: Shift 'BEGIN', go to state 144
parser: Return. Stack=[createkw trigger_decl BEGIN]
parser: Input 'INSERT' in state 144
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 12
parser: Shift 'INSERT', go to state 311
parser: Return. Stack=[createkw trigger_decl BEGIN scanpt INSERT]
parser: Input 'INTO' in state 311
parser: Reduce 71 [orconf ::=].
parser: ... then shift 'orconf', pending reduce 160
parser: Reduce 160 [insert_cmd ::= INSERT orconf], go to state 12.
parser: ... then shift 'insert_cmd', go to state 443
parser: Shift 'INTO', go to state 176
parser: Return. Stack=[createkw trigger_decl BEGIN scanpt insert_cmd INTO]
parser: Input 'ID' in state 176
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw trigger_decl BEGIN scanpt insert_cmd INTO ID]
parser: Input 'VALUES' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 176.
parser: ... then shift 'nm', go to state 451
parser: Reduce 368 [trnm ::= nm], go to state 176.
parser: ... then shift 'trnm', go to state 310
parser: Reduce 162 [idlist_opt ::=].
parser: ... then shift 'idlist_opt', go to state 36
parser: Shift 'VALUES', go to state 528
parser: Return. Stack=[createkw trigger_decl BEGIN scanpt insert_cmd INTO trnm idlist_opt VALUES]
parser: Input 'LP' in state 528
parser: Shift 'LP', go to state 28
parser: Return. Stack=[createkw trigger_decl BEGIN scanpt insert_cmd INTO trnm idlist_opt VALUES LP]
parser: Input 'ID' in state 28
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw trigger_decl BEGIN scanpt insert_cmd INTO trnm idlist_opt VALUES LP ID]
parser: Input 'DOT' in state 419
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 28.
parser: ... then shift 'nm', go to state 537
parser: Shift 'DOT', go to state 249
parser: Return. Stack=[createkw trigger_decl BEGIN scanpt insert_cmd INTO trnm idlist_opt VALUES LP nm DOT]
parser: Input 'ID' in state 249
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw trigger_decl BEGIN scanpt insert_cmd INTO trnm idlist_opt VALUES LP nm DOT ID]
parser: Input 'STAR' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 249.
parser: ... then shift 'nm', go to state 536
parser: Reduce 169 [expr ::= nm DOT nm], go to state 28.
parser: ... then shift 'expr', go to state 70
parser: Shift 'STAR', go to state 114
parser: Return. Stack=[createkw trigger_decl BEGIN scanpt insert_cmd INTO trnm idlist_opt VALUES LP expr STAR]
parser: Input 'INTEGER' in state 114
parser: Shift 'INTEGER', pending reduce 173
parser: Return. Stack=[createkw trigger_decl BEGIN scanpt insert_cmd INTO trnm idlist_opt VALUES LP expr STAR INTEGER]
parser: Input 'COMMA' with pending reduce 173
parser: Reduce 173 [term ::= INTEGER], go to state 114.
parser: ... then shift 'term', go to state 147
parser: Reduce 189 [expr ::= expr STAR|SLASH|REM expr], go to state 28.
parser: ... then shift 'expr', go to state 70
parser: Reduce 220 [nexprlist ::= expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 413
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[createkw trigger_decl BEGIN scanpt insert_cmd INTO trnm idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'ID' in state 107
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw trigger_decl BEGIN scanpt insert_cmd INTO trnm idlist_opt VALUES LP nexprlist COMMA ID]
parser: Input 'DOT' in state 419
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 107.
parser: ... then shift 'nm', go to state 537
parser: Shift 'DOT', go to state 249
parser: Return. Stack=[createkw trigger_decl BEGIN scanpt insert_cmd INTO trnm idlist_opt VALUES LP nexprlist COMMA nm DOT]
parser: Input 'ID' in state 249
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw trigger_decl BEGIN scanpt insert_cmd INTO trnm idlist_opt VALUES LP nexprlist COMMA nm DOT ID]
parser: Input 'STAR' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 249.
parser: ... then shift 'nm', go to state 536
parser: Reduce 169 [expr ::= nm DOT nm], go to state 107.
parser: ... then shift 'expr', go to state 71
parser: Shift 'STAR', go to state 114
parser: Return. Stack=[createkw trigger_decl BEGIN scanpt insert_cmd INTO trnm idlist_opt VALUES LP nexprlist COMMA expr STAR]
parser: Input 'INTEGER' in state 114
parser: Shift 'INTEGER', pending reduce 173
parser: Return. Stack=[createkw trigger_decl BEGIN scanpt insert_cmd INTO trnm idlist_opt VALUES LP nexprlist COMMA expr STAR INTEGER]
parser: Input 'RP' with pending reduce 173
parser: Reduce 173 [term ::= INTEGER], go to state 114.
parser: ... then shift 'term', go to state 147
parser: Reduce 189 [expr ::= expr STAR|SLASH|REM expr], go to state 107.
parser: ... then shift 'expr', go to state 71
parser: Reduce 219 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 413
parser: Shift 'RP', pending reduce 90
parser: Return. Stack=[createkw trigger_decl BEGIN scanpt insert_cmd INTO trnm idlist_opt VALUES LP nexprlist RP]
parser: Input 'SEMI' with pending reduce 90
parser: Reduce 90 [values ::= VALUES LP nexprlist RP], go to state 36.
parser: ... then shift 'values', go to state 534
parser: Reduce 354 [oneselect ::= values], go to state 36.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 83 [select ::= selectnowith], go to state 36.
parser: ... then shift 'select', go to state 309
parser: Reduce 156 [upsert ::=].
parser: ... then shift 'upsert', go to state 377
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', pending reduce 260
parser: Reduce 260 [trigger_cmd ::= scanpt insert_cmd INTO trnm idlist_opt select upsert scanpt], go to state 144.
parser: ... then shift 'trigger_cmd', go to state 437
parser: Shift 'SEMI', pending reduce 255
parser: Return. Stack=[createkw trigger_decl BEGIN trigger_cmd SEMI]
parser: Input 'END' with pending reduce 255
parser: Reduce 255 [trigger_cmd_list ::= trigger_cmd SEMI], go to state 144.
parser: ... then shift 'trigger_cmd_list', go to state 189
parser: Shift 'END', pending reduce 244
parser: Return. Stack=[createkw trigger_decl BEGIN trigger_cmd_list END]
parser: Input 'SEMI' with pending reduce 244
parser: Reduce 244 [cmd ::= createkw trigger_decl BEGIN trigger_cmd_list END], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
  11 Next             0    5    0               01 
   5 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s5[index](8)
   6 Column           0    1    2               00 r[2]=sqlite_master.name
REG[2] =   s2[i1](8)
   7 Column           0    2    3               00 r[3]=sqlite_master.tbl_name
REG[3] =   s2[t3](8)
   8 Column           0    3    4               00 r[4]=sqlite_master.rootpage
REG[4] =  i:72
   9 Column           0    4    5               00 r[5]=sqlite_master.sql
REG[5] =   s24[CREATE INDEX i1 on t3(e)](8)
  10 ResultRow        1    5    0               00 output=r[1..5]
REG[1] =   s5[index](8)
REG[2] =   s2[i1](8)
REG[3] =   s2[t3](8)
REG[4] =  i:72
REG[5] =   s24[CREATE INDEX i1 on t3(e)](8)
parser: [[[CREATE INDEX i1 on t3(e)]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'INDEX' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 225 [uniqueflag ::=].
parser: ... then shift 'uniqueflag', go to state 456
parser: Shift 'INDEX', go to state 315
parser: Return. Stack=[createkw uniqueflag INDEX]
parser: Input 'ID' in state 315
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 225
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists ID]
parser: Input 'ON' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 225.
parser: ... then shift 'nm', go to state 314
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 455
parser: Shift 'ON', go to state 224
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON]
parser: Input 'ID' in state 224
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON ID]
parser: Input 'LP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 224.
parser: ... then shift 'nm', go to state 454
parser: Shift 'LP', go to state 18
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP]
parser: Input 'ID' in state 18
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP ID]
parser: Input 'RP' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 18.
parser: ... then shift 'expr', go to state 13
parser: Reduce 134 [sortorder ::=].
parser: ... then shift 'sortorder', go to state 353
parser: Reduce 137 [nulls ::=].
parser: ... then shift 'nulls', pending reduce 131
parser: Reduce 131 [sortlist ::= expr sortorder nulls], go to state 18.
parser: ... then shift 'sortlist', go to state 402
parser: Shift 'RP', go to state 313
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP]
parser: Input 'SEMI' in state 313
parser: Reduce 147 [where_opt ::=].
parser: ... then shift 'where_opt', pending reduce 223
parser: Reduce 223 [cmd ::= createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP where_opt], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
  11 Next             0    5    0               01 
  12 Halt             0    0    0               00 
parser: [[[SELECT tbl,idx,stat FROM 'aux'.sqlite_stat1]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 95 [sclp ::=].
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 419
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 355
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 355
parser: Reduce 355 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 419
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 355
parser: Return. Stack=[SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 355
parser: Reduce 355 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 419
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'FROM' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'STRING' in state 197
parser: Reduce 104 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'STRING', pending reduce 338
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix STRING]
parser: Input 'DOT' with pending reduce 338
parser: Reduce 338 [nm ::= STRING], go to state 206.
parser: ... then shift 'nm', go to state 350
parser: Shift 'DOT', go to state 245
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID' in state 245
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'SEMI' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 245.
parser: ... then shift 'nm', pending reduce 110
parser: Reduce 110 [dbnm ::= DOT nm], go to state 350.
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 123 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 349
parser: Reduce 122 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 348
parser: Reduce 127 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 105
parser: Reduce 105 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 102 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 363
parser: Reduce 147 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 362
parser: Reduce 138 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 361
parser: Reduce 140 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 128 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 360
parser: Reduce 142 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 88
parser: Reduce 88 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 83 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 80
parser: Reduce 80 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
VDBE Trace:
   0 Init             0   10    0               00 Start at 10
  10 Transaction      2    0   36 1             00 usesStmtJournal=0
  11 TableLock        2    8    0 sqlite_stat1  00 iDb=2 root=8 write=0
  12 Goto             0    1    0               00 
   1 OpenRead         0    8    2 3             00 root=8 iDb=2; sqlite_stat1
   2 Explain          2    0    0 SCAN TABLE sqlite_stat1 00 
   3 Rewind           0    9    0               00 
   4 Column           0    0    1               00 r[1]=sqlite_stat1.tbl
REG[1] =   s10[insert_log](8)
   5 Column           0    1    2               00 r[2]=sqlite_stat1.idx
REG[2] =  NULL
   6 Column           0    2    3               00 r[3]=sqlite_stat1.stat
REG[3] =   s2[30](8)
   7 ResultRow        1    3    0               00 output=r[1..3]
REG[1] =   s10[insert_log](8)
REG[2] =  NULL
REG[3] =   s2[30](8)
   8 Next             0    4    0               01 
   4 Column           0    0    1               00 r[1]=sqlite_stat1.tbl
REG[1] =   s5[stuff](8)
   5 Column           0    1    2               00 r[2]=sqlite_stat1.idx
REG[2] =  NULL
   6 Column           0    2    3               00 r[3]=sqlite_stat1.stat
REG[3] =   s2[60](8)
   7 ResultRow        1    3    0               00 output=r[1..3]
REG[1] =   s5[stuff](8)
REG[2] =  NULL
REG[3] =   s2[60](8)
   8 Next             0    4    0               01 
   4 Column           0    0    1               00 r[1]=sqlite_stat1.tbl
REG[1] =   s5[files](8)
   5 Column           0    1    2               00 r[2]=sqlite_stat1.idx
REG[2] =  NULL
   6 Column           0    2    3               00 r[3]=sqlite_stat1.stat
REG[3] =   s3[305](8)
   7 ResultRow        1    3    0               00 output=r[1..3]
REG[1] =   s5[files](8)
REG[2] =  NULL
REG[3] =   s3[305](8)
   8 Next             0    4    0               01 
   4 Column           0    0    1               00 r[1]=sqlite_stat1.tbl
REG[1] =   s2[ab](8)
   5 Column           0    1    2               00 r[2]=sqlite_stat1.idx
REG[2] =  NULL
   6 Column           0    2    3               00 r[3]=sqlite_stat1.stat
REG[3] =   s2[70](8)
   7 ResultRow        1    3    0               00 output=r[1..3]
REG[1] =   s2[ab](8)
REG[2] =  NULL
REG[3] =   s2[70](8)
   8 Next             0    4    0               01 
   4 Column           0    0    1               00 r[1]=sqlite_stat1.tbl
REG[1] =   s2[t3](8)
   5 Column           0    1    2               00 r[2]=sqlite_stat1.idx
REG[2] =   s2[i1](8)
   6 Column           0    2    3               00 r[3]=sqlite_stat1.stat
REG[3] =   s3[2 1](8)
   7 ResultRow        1    3    0               00 output=r[1..3]
REG[1] =   s2[t3](8)
REG[2] =   s2[i1](8)
REG[3] =   s3[2 1](8)
   8 Next             0    4    0               01 
   4 Column           0    0    1               00 r[1]=sqlite_stat1.tbl
REG[1] =   s2[x3](8)
   5 Column           0    1    2               00 r[2]=sqlite_stat1.idx
REG[2] =  NULL
   6 Column           0    2    3               00 r[3]=sqlite_stat1.stat
REG[3] =   s1[4](8)
   7 ResultRow        1    3    0               00 output=r[1..3]
REG[1] =   s2[x3](8)
REG[2] =  NULL
REG[3] =   s1[4](8)
   8 Next             0    4    0               01 
   4 Column           0    0    1               00 r[1]=sqlite_stat1.tbl
REG[1] =   s3[def](8)
   5 Column           0    1    2               00 r[2]=sqlite_stat1.idx
REG[2] =  NULL
   6 Column           0    2    3               00 r[3]=sqlite_stat1.stat
REG[3] =   s4[1320](8)
   7 ResultRow        1    3    0               00 output=r[1..3]
REG[1] =   s3[def](8)
REG[2] =  NULL
REG[3] =   s4[1320](8)
   8 Next             0    4    0               01 
   4 Column           0    0    1               00 r[1]=sqlite_stat1.tbl
REG[1] =   s8[f3_rules](8)
   5 Column           0    1    2               00 r[2]=sqlite_stat1.idx
REG[2] =  NULL
   6 Column           0    2    3               00 r[3]=sqlite_stat1.stat
REG[3] =   s2[10](8)
   7 ResultRow        1    3    0               00 output=r[1..3]
REG[1] =   s8[f3_rules](8)
REG[2] =  NULL
REG[3] =   s2[10](8)
   8 Next             0    4    0               01 
   9 Halt             0    0    0               00 
parser: [[[CREATE TABLE x(type text,name text,tbl_name text,rootpage int,sql text)]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 390
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 0.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP ID]
parser: Input 'ID' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 192
parser: Shift 'ID', pending reduce 341
parser: Return. Stack=[create_table LP nm ID]
parser: Input 'COMMA' with pending reduce 341
parser: Reduce 341 [typename ::= ID|STRING], go to state 192.
parser: ... then shift 'typename', go to state 392
parser: Reduce 340 [typetoken ::= typename], go to state 192.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 379
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 152
parser: Reduce 336 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'ID' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Shift 'ID', pending reduce 341
parser: Return. Stack=[create_table LP columnlist COMMA nm ID]
parser: Input 'COMMA' with pending reduce 341
parser: Reduce 341 [typename ::= ID|STRING], go to state 192.
parser: ... then shift 'typename', go to state 392
parser: Reduce 340 [typetoken ::= typename], go to state 192.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'ID' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Shift 'ID', pending reduce 341
parser: Return. Stack=[create_table LP columnlist COMMA nm ID]
parser: Input 'COMMA' with pending reduce 341
parser: Reduce 341 [typename ::= ID|STRING], go to state 192.
parser: ... then shift 'typename', go to state 392
parser: Reduce 340 [typetoken ::= typename], go to state 192.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'ID' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Shift 'ID', pending reduce 341
parser: Return. Stack=[create_table LP columnlist COMMA nm ID]
parser: Input 'COMMA' with pending reduce 341
parser: Reduce 341 [typename ::= ID|STRING], go to state 192.
parser: ... then shift 'typename', go to state 392
parser: Reduce 340 [typetoken ::= typename], go to state 192.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'ID' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Shift 'ID', pending reduce 341
parser: Return. Stack=[create_table LP columnlist COMMA nm ID]
parser: Input 'RP' with pending reduce 341
parser: Reduce 341 [typename ::= ID|STRING], go to state 192.
parser: ... then shift 'typename', go to state 392
parser: Reduce 340 [typetoken ::= typename], go to state 192.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Reduce 61 [conslist_opt ::=].
parser: ... then shift 'conslist_opt', go to state 540
parser: Shift 'RP', go to state 364
parser: Return. Stack=[create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 364
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: ... then shift 'create_table_args', pending reduce 334
parser: Reduce 334 [cmd ::= create_table create_table_args], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT*FROM"temp".sqlite_temp_master ORDER BY rowid]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'STAR' in state 288
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 95 [sclp ::=].
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STAR', pending reduce 97
parser: Return. Stack=[SELECT distinct sclp scanpt STAR]
parser: Input 'FROM' with pending reduce 97
parser: Reduce 97 [selcollist ::= sclp scanpt STAR], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 104 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'DOT' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 350
parser: Shift 'DOT', go to state 245
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID' in state 245
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'ORDER' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 245.
parser: ... then shift 'nm', pending reduce 110
parser: Reduce 110 [dbnm ::= DOT nm], go to state 350.
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 123 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 349
parser: Reduce 122 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 348
parser: Reduce 127 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 105
parser: Reduce 105 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 102 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 363
parser: Reduce 147 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 362
parser: Reduce 138 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 361
parser: Reduce 140 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 517
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 517
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 419
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 134 [sortorder ::=].
parser: ... then shift 'sortorder', go to state 353
parser: Reduce 137 [nulls ::=].
parser: ... then shift 'nulls', pending reduce 131
parser: Reduce 131 [sortlist ::= expr sortorder nulls], go to state 26.
parser: ... then shift 'sortlist', go to state 516
parser: Reduce 129 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 360
parser: Reduce 142 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 88
parser: Reduce 88 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 83 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 80
parser: Reduce 80 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
VDBE Trace:
   0 Init             0   13    0               00 Start at 13
  13 Transaction      1    0    0 1             00 usesStmtJournal=0
  14 Goto             0    1    0               00 
   1 Noop             1    7    0               00 
   2 OpenRead         0    1    1 5             00 root=1 iDb=1; sqlite_temp_master
   3 Explain          3    0    0 SCAN TABLE sqlite_temp_master 00 
   4 Rewind           0   12    0               00 
  12 Halt             0    0    0               00 
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdlist cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping cmdlist
SQL: [;
;SELECT * FROM a ORDER BY b, b;]
VDBE Trace:
   0 Init             0    9    0               00 Start at 9
   9 Transaction      0    0    6 1             01 usesStmtJournal=0
  10 Goto             0    1    0               00 
   1 Noop             1    4    0               00 
   2 OpenRead         2    2    0 k(1,)         00 root=2 iDb=0; sqlite_autoindex_a_1
   3 Explain          3    0    0 SCAN TABLE a  00 
   4 Rewind           2    8    1 0             00 
   5 Column           2    0    1               00 r[1]=a.b
REG[1] =  i:1
   6 ResultRow        1    1    0               00 output=r[1]
REG[1] =  i:1
   7 Next             2    5    0               01 
   5 Column           2    0    1               00 r[1]=a.b
REG[1] =  i:2
   6 ResultRow        1    1    0               00 output=r[1]
REG[1] =  i:2
   7 Next             2    5    0               01 
   5 Column           2    0    1               00 r[1]=a.b
REG[1] =  i:3
   6 ResultRow        1    1    0               00 output=r[1]
REG[1] =  i:3
   7 Next             2    5    0               01 
   5 Column           2    0    1               00 r[1]=a.b
REG[1] =  i:4
   6 ResultRow        1    1    0               00 output=r[1]
REG[1] =  i:4
   7 Next             2    5    0               01 
   5 Column           2    0    1               00 r[1]=a.b
REG[1] =  i:5
   6 ResultRow        1    1    0               00 output=r[1]
REG[1] =  i:5
   7 Next             2    5    0               01 
   5 Column           2    0    1               00 r[1]=a.b
REG[1] =  i:6
   6 ResultRow        1    1    0               00 output=r[1]
REG[1] =  i:6
   7 Next             2    5    0               01 
   5 Column           2    0    1               00 r[1]=a.b
REG[1] =  i:7
   6 ResultRow        1    1    0               00 output=r[1]
REG[1] =  i:7
   7 Next             2    5    0               01 
   5 Column           2    0    1               00 r[1]=a.b
REG[1] =  i:8
   6 ResultRow        1    1    0               00 output=r[1]
REG[1] =  i:8
   7 Next             2    5    0               01 
   5 Column           2    0    1               00 r[1]=a.b
REG[1] =  i:9
   6 ResultRow        1    1    0               00 output=r[1]
REG[1] =  i:9
   7 Next             2    5    0               01 
   8 Halt             0    0    0               00 
parser: [[[;
;SELECT * FROM a ORDER BY b DESC, b DESC;CREATE INDEX t3 ON a(b)
;SELECT*FROM"temp".sqlite_temp_master ORDER BY rowid
;SELECT x.b || '/' || y.b FROM a x, a y ORDER BY x.b, x.b DESC
  
;SELECT x.b || '/' || y.b FROM a x, a y ORDER BY x.b, x.b||x.b
  
;SELECT x.b || '/' || y.b FROM a x, a y ORDER BY x.b, x.b, y.b||y.b
  
;SELECT x.b || '/' || y.b FROM a x, a y ORDER BY x.b, y.b||y.b DESC
  
;SELECT x.b || '/' || y.b FROM a x, a y ORDER BY x.b, x.b||y.b
  
;SELECT*FROM"temp".sqlite_temp_master ORDER BY rowid
;;
;CREATE TABLE x(y INTEGER PRIMARY KEY, t2i1);ALTER TABLE x ADD t1i1
    
;;
;SELECT x.RowID id FROM a, x WHERE a.b = x.RowID AND id = 2;SELECT*FROM"temp".sqlite_temp_master ORDER BY rowid
;ALTER TABLE x ADD abc
    
;CREATE INDEX c ON a(b)
;CREATE INDEX v1 ON a(b)
;ALTER TABLE ex ADD v2
    
;CREATE TABLE tr1(t1a, t1b);;SELECT y, v2 FROM x, ex WHERE y>v2;;
;SELECT DISTINCT b FROM a LEFT JOIN ex ON b=v2 ORDER BY +v2;CREATE INDEX x1 ON a(b)
;CREATE INDEX z ON a(b)
;CREATE INDEX example ON ex(v2)
;;SELECT count(*) FROM sqlite_master WHERE tbl_name = 'e' AND type = 'index';;
;CREATE TABLE example_idx_00000042(id PRIMARY KEY, UNIQUE(id) );;BEGIN;;CREATE UNIQUE INDEX IF NOT EXISTS a_id ON a(b==0);;SELECT * FROM ex;]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 326
parser: Return. Stack=[SEMI]
parser: Input 'SEMI' with pending reduce 326
parser: Reduce 326 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Shift 'SEMI', pending reduce 326
parser: Return. Stack=[ecmd SEMI]
parser: Input 'SELECT' with pending reduce 326
parser: Reduce 326 [ecmd ::= SEMI], go to state 1.
parser: ... then shift 'ecmd', pending reduce 324
parser: Reduce 324 [cmdlist ::= cmdlist ecmd], go to state 0.
parser: ... then shift 'cmdlist', go to state 1
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[cmdlist SELECT]
parser: Input 'STAR' in state 288
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 95 [sclp ::=].
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STAR', pending reduce 97
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt STAR]
parser: Input 'FROM' with pending reduce 97
parser: Reduce 97 [selcollist ::= sclp scanpt STAR], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[cmdlist SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 104 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[cmdlist SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'ORDER' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 350
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 123 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 349
parser: Reduce 122 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 348
parser: Reduce 127 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 105
parser: Reduce 105 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 102 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 363
parser: Reduce 147 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 362
parser: Reduce 138 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 361
parser: Reduce 140 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 517
parser: Return. Stack=[cmdlist SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 517
parser: Shift 'BY', go to state 26
parser: Return. Stack=[cmdlist SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 419
parser: Return. Stack=[cmdlist SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'DESC' in state 419
parser: FALLBACK DESC => ID
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Shift 'DESC', pending reduce 133
parser: Return. Stack=[cmdlist SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY expr DESC]
parser: Input 'COMMA' with pending reduce 133
parser: Reduce 133 [sortorder ::= DESC], go to state 13.
parser: ... then shift 'sortorder', go to state 353
parser: Reduce 137 [nulls ::=].
parser: ... then shift 'nulls', pending reduce 131
parser: Reduce 131 [sortlist ::= expr sortorder nulls], go to state 26.
parser: ... then shift 'sortlist', go to state 516
parser: Shift 'COMMA', go to state 95
parser: Return. Stack=[cmdlist SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY sortlist COMMA]
parser: Input 'ID' in state 95
parser: Shift 'ID', go to state 419
parser: Return. Stack=[cmdlist SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY sortlist COMMA ID]
parser: Input 'DESC' in state 419
parser: FALLBACK DESC => ID
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 95.
parser: ... then shift 'expr', go to state 14
parser: Shift 'DESC', pending reduce 133
parser: Return. Stack=[cmdlist SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY sortlist COMMA expr DESC]
parser: Input 'SEMI' with pending reduce 133
parser: Reduce 133 [sortorder ::= DESC], go to state 14.
parser: ... then shift 'sortorder', go to state 354
parser: Reduce 137 [nulls ::=].
parser: ... then shift 'nulls', pending reduce 130
parser: Reduce 130 [sortlist ::= sortlist COMMA expr sortorder nulls], go to state 26.
parser: ... then shift 'sortlist', go to state 516
parser: Reduce 129 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 360
parser: Reduce 142 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 88
parser: Reduce 88 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 1.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 83 [select ::= selectnowith], go to state 1.
parser: ... then shift 'select', pending reduce 80
parser: Reduce 80 [cmd ::= select], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdlist cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping cmdlist
SQL: [;
;SELECT * FROM a ORDER BY b DESC, b DESC;]
VDBE Trace:
   0 Init             0    9    0               00 Start at 9
   9 Transaction      0    0    6 1             01 usesStmtJournal=0
  10 Goto             0    1    0               00 
   1 Noop             1    4    0               00 
   2 OpenRead         2    2    0 k(1,)         00 root=2 iDb=0; sqlite_autoindex_a_1
   3 Explain          3    0    0 SCAN TABLE a  00 
   4 Last             2    8    1 0             00 
   5 Column           2    0    1               00 r[1]=a.b
REG[1] =  i:9
   6 ResultRow        1    1    0               00 output=r[1]
REG[1] =  i:9
   7 Prev             2    5    0               01 
   5 Column           2    0    1               00 r[1]=a.b
REG[1] =  i:8
   6 ResultRow        1    1    0               00 output=r[1]
REG[1] =  i:8
   7 Prev             2    5    0               01 
   5 Column           2    0    1               00 r[1]=a.b
REG[1] =  i:7
   6 ResultRow        1    1    0               00 output=r[1]
REG[1] =  i:7
   7 Prev             2    5    0               01 
   5 Column           2    0    1               00 r[1]=a.b
REG[1] =  i:6
   6 ResultRow        1    1    0               00 output=r[1]
REG[1] =  i:6
   7 Prev             2    5    0               01 
   5 Column           2    0    1               00 r[1]=a.b
REG[1] =  i:5
   6 ResultRow        1    1    0               00 output=r[1]
REG[1] =  i:5
   7 Prev             2    5    0               01 
   5 Column           2    0    1               00 r[1]=a.b
REG[1] =  i:4
   6 ResultRow        1    1    0               00 output=r[1]
REG[1] =  i:4
   7 Prev             2    5    0               01 
   5 Column           2    0    1               00 r[1]=a.b
REG[1] =  i:3
   6 ResultRow        1    1    0               00 output=r[1]
REG[1] =  i:3
   7 Prev             2    5    0               01 
   5 Column           2    0    1               00 r[1]=a.b
REG[1] =  i:2
   6 ResultRow        1    1    0               00 output=r[1]
REG[1] =  i:2
   7 Prev             2    5    0               01 
   5 Column           2    0    1               00 r[1]=a.b
REG[1] =  i:1
   6 ResultRow        1    1    0               00 output=r[1]
REG[1] =  i:1
   7 Prev             2    5    0               01 
   8 Halt             0    0    0               00 
parser: [[[CREATE INDEX t3 ON a(b)
;SELECT*FROM"temp".sqlite_temp_master ORDER BY rowid
;SELECT x.b || '/' || y.b FROM a x, a y ORDER BY x.b, x.b DESC
  
;SELECT x.b || '/' || y.b FROM a x, a y ORDER BY x.b, x.b||x.b
  
;SELECT x.b || '/' || y.b FROM a x, a y ORDER BY x.b, x.b, y.b||y.b
  
;SELECT x.b || '/' || y.b FROM a x, a y ORDER BY x.b, y.b||y.b DESC
  
;SELECT x.b || '/' || y.b FROM a x, a y ORDER BY x.b, x.b||y.b
  
;SELECT*FROM"temp".sqlite_temp_master ORDER BY rowid
;;
;CREATE TABLE x(y INTEGER PRIMARY KEY, t2i1);ALTER TABLE x ADD t1i1
    
;;
;SELECT x.RowID id FROM a, x WHERE a.b = x.RowID AND id = 2;SELECT*FROM"temp".sqlite_temp_master ORDER BY rowid
;ALTER TABLE x ADD abc
    
;CREATE INDEX c ON a(b)
;CREATE INDEX v1 ON a(b)
;ALTER TABLE ex ADD v2
    
;CREATE TABLE tr1(t1a, t1b);;SELECT y, v2 FROM x, ex WHERE y>v2;;
;SELECT DISTINCT b FROM a LEFT JOIN ex ON b=v2 ORDER BY +v2;CREATE INDEX x1 ON a(b)
;CREATE INDEX z ON a(b)
;CREATE INDEX example ON ex(v2)
;;SELECT count(*) FROM sqlite_master WHERE tbl_name = 'e' AND type = 'index';;
;CREATE TABLE example_idx_00000042(id PRIMARY KEY, UNIQUE(id) );;BEGIN;;CREATE UNIQUE INDEX IF NOT EXISTS a_id ON a(b==0);;SELECT * FROM ex;]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'INDEX' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 225 [uniqueflag ::=].
parser: ... then shift 'uniqueflag', go to state 456
parser: Shift 'INDEX', go to state 315
parser: Return. Stack=[createkw uniqueflag INDEX]
parser: Input 'ID' in state 315
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 225
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists ID]
parser: Input 'ON' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 225.
parser: ... then shift 'nm', go to state 314
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 455
parser: Shift 'ON', go to state 224
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON]
parser: Input 'ID' in state 224
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON ID]
parser: Input 'LP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 224.
parser: ... then shift 'nm', go to state 454
parser: Shift 'LP', go to state 18
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP]
parser: Input 'ID' in state 18
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP ID]
parser: Input 'RP' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 18.
parser: ... then shift 'expr', go to state 13
parser: Reduce 134 [sortorder ::=].
parser: ... then shift 'sortorder', go to state 353
parser: Reduce 137 [nulls ::=].
parser: ... then shift 'nulls', pending reduce 131
parser: Reduce 131 [sortlist ::= expr sortorder nulls], go to state 18.
parser: ... then shift 'sortlist', go to state 402
parser: Shift 'RP', go to state 313
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP]
parser: Input 'SEMI' in state 313
parser: Reduce 147 [where_opt ::=].
parser: ... then shift 'where_opt', pending reduce 223
parser: Reduce 223 [cmd ::= createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP where_opt], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT*FROM"temp".sqlite_temp_master ORDER BY rowid
;SELECT x.b || '/' || y.b FROM a x, a y ORDER BY x.b, x.b DESC
  
;SELECT x.b || '/' || y.b FROM a x, a y ORDER BY x.b, x.b||x.b
  
;SELECT x.b || '/' || y.b FROM a x, a y ORDER BY x.b, x.b, y.b||y.b
  
;SELECT x.b || '/' || y.b FROM a x, a y ORDER BY x.b, y.b||y.b DESC
  
;SELECT x.b || '/' || y.b FROM a x, a y ORDER BY x.b, x.b||y.b
  
;SELECT*FROM"temp".sqlite_temp_master ORDER BY rowid
;;
;CREATE TABLE x(y INTEGER PRIMARY KEY, t2i1);ALTER TABLE x ADD t1i1
    
;;
;SELECT x.RowID id FROM a, x WHERE a.b = x.RowID AND id = 2;SELECT*FROM"temp".sqlite_temp_master ORDER BY rowid
;ALTER TABLE x ADD abc
    
;CREATE INDEX c ON a(b)
;CREATE INDEX v1 ON a(b)
;ALTER TABLE ex ADD v2
    
;CREATE TABLE tr1(t1a, t1b);;SELECT y, v2 FROM x, ex WHERE y>v2;;
;SELECT DISTINCT b FROM a LEFT JOIN ex ON b=v2 ORDER BY +v2;CREATE INDEX x1 ON a(b)
;CREATE INDEX z ON a(b)
;CREATE INDEX example ON ex(v2)
;;SELECT count(*) FROM sqlite_master WHERE tbl_name = 'e' AND type = 'index';;
;CREATE TABLE example_idx_00000042(id PRIMARY KEY, UNIQUE(id) );;BEGIN;;CREATE UNIQUE INDEX IF NOT EXISTS a_id ON a(b==0);;SELECT * FROM ex;]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'STAR' in state 288
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 95 [sclp ::=].
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STAR', pending reduce 97
parser: Return. Stack=[SELECT distinct sclp scanpt STAR]
parser: Input 'FROM' with pending reduce 97
parser: Reduce 97 [selcollist ::= sclp scanpt STAR], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 104 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'DOT' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 350
parser: Shift 'DOT', go to state 245
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID' in state 245
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'ORDER' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 245.
parser: ... then shift 'nm', pending reduce 110
parser: Reduce 110 [dbnm ::= DOT nm], go to state 350.
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 123 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 349
parser: Reduce 122 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 348
parser: Reduce 127 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 105
parser: Reduce 105 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 102 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 363
parser: Reduce 147 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 362
parser: Reduce 138 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 361
parser: Reduce 140 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 517
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 517
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 419
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 134 [sortorder ::=].
parser: ... then shift 'sortorder', go to state 353
parser: Reduce 137 [nulls ::=].
parser: ... then shift 'nulls', pending reduce 131
parser: Reduce 131 [sortlist ::= expr sortorder nulls], go to state 26.
parser: ... then shift 'sortlist', go to state 516
parser: Reduce 129 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 360
parser: Reduce 142 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 88
parser: Reduce 88 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 83 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 80
parser: Reduce 80 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
SQL: [SELECT*FROM"temp".sqlite_temp_master ORDER BY rowid
;]
VDBE Trace:
   0 Init             0   13    0               00 Start at 13
  13 Transaction      1    0    0 1             01 usesStmtJournal=0
  14 Goto             0    1    0               00 
   1 Noop             1    7    0               00 
   2 OpenRead         0    1    1 5             00 root=1 iDb=1; sqlite_temp_master
   3 Explain          3    0    0 SCAN TABLE sqlite_temp_master 00 
   4 Rewind           0   12    0               00 
  12 Halt             0    0    0               00 
parser: [[[SELECT x.b || '/' || y.b FROM a x, a y ORDER BY x.b, x.b DESC
  
;SELECT x.b || '/' || y.b FROM a x, a y ORDER BY x.b, x.b||x.b
  
;SELECT x.b || '/' || y.b FROM a x, a y ORDER BY x.b, x.b, y.b||y.b
  
;SELECT x.b || '/' || y.b FROM a x, a y ORDER BY x.b, y.b||y.b DESC
  
;SELECT x.b || '/' || y.b FROM a x, a y ORDER BY x.b, x.b||y.b
  
;SELECT*FROM"temp".sqlite_temp_master ORDER BY rowid
;;
;CREATE TABLE x(y INTEGER PRIMARY KEY, t2i1);ALTER TABLE x ADD t1i1
    
;;
;SELECT x.RowID id FROM a, x WHERE a.b = x.RowID AND id = 2;SELECT*FROM"temp".sqlite_temp_master ORDER BY rowid
;ALTER TABLE x ADD abc
    
;CREATE INDEX c ON a(b)
;CREATE INDEX v1 ON a(b)
;ALTER TABLE ex ADD v2
    
;CREATE TABLE tr1(t1a, t1b);;SELECT y, v2 FROM x, ex WHERE y>v2;;
;SELECT DISTINCT b FROM a LEFT JOIN ex ON b=v2 ORDER BY +v2;CREATE INDEX x1 ON a(b)
;CREATE INDEX z ON a(b)
;CREATE INDEX example ON ex(v2)
;;SELECT count(*) FROM sqlite_master WHERE tbl_name = 'e' AND type = 'index';;
;CREATE TABLE example_idx_00000042(id PRIMARY KEY, UNIQUE(id) );;BEGIN;;CREATE UNIQUE INDEX IF NOT EXISTS a_id ON a(b==0);;SELECT * FROM ex;]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 95 [sclp ::=].
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 419
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'DOT' in state 419
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 77.
parser: ... then shift 'nm', go to state 493
parser: Shift 'DOT', go to state 205
parser: Return. Stack=[SELECT distinct sclp scanpt nm DOT]
parser: Input 'ID' in state 205
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[SELECT distinct sclp scanpt nm DOT ID]
parser: Input 'CONCAT' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 205.
parser: ... then shift 'nm', go to state 536
parser: Reduce 169 [expr ::= nm DOT nm], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Shift 'CONCAT', go to state 113
parser: Return. Stack=[SELECT distinct sclp scanpt expr CONCAT]
parser: Input 'STRING' in state 113
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[SELECT distinct sclp scanpt expr CONCAT STRING]
parser: Input 'CONCAT' in state 539
parser: Reduce 172 [term ::= STRING], go to state 113.
parser: ... then shift 'term', go to state 148
parser: Reduce 190 [expr ::= expr CONCAT expr], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Shift 'CONCAT', go to state 113
parser: Return. Stack=[SELECT distinct sclp scanpt expr CONCAT]
parser: Input 'ID' in state 113
parser: Shift 'ID', go to state 419
parser: Return. Stack=[SELECT distinct sclp scanpt expr CONCAT ID]
parser: Input 'DOT' in state 419
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 113.
parser: ... then shift 'nm', go to state 537
parser: Shift 'DOT', go to state 249
parser: Return. Stack=[SELECT distinct sclp scanpt expr CONCAT nm DOT]
parser: Input 'ID' in state 249
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[SELECT distinct sclp scanpt expr CONCAT nm DOT ID]
parser: Input 'FROM' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 249.
parser: ... then shift 'nm', go to state 536
parser: Reduce 169 [expr ::= nm DOT nm], go to state 113.
parser: ... then shift 'expr', go to state 148
parser: Reduce 190 [expr ::= expr CONCAT expr], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 104 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'ID' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 350
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Shift 'ID', pending reduce 356
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm dbnm ID]
parser: Input 'COMMA' with pending reduce 356
parser: Reduce 356 [as ::= ID|STRING], go to state 243.
parser: ... then shift 'as', go to state 283
parser: Reduce 123 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 349
parser: Reduce 122 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 348
parser: Reduce 127 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 105
parser: Reduce 105 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Shift 'COMMA', pending reduce 117
parser: Return. Stack=[SELECT distinct selcollist FROM seltablist COMMA]
parser: Input 'ID' with pending reduce 117
parser: Reduce 117 [joinop ::= COMMA|JOIN], go to state 263.
parser: ... then shift 'joinop', pending reduce 103
parser: Reduce 103 [stl_prefix ::= seltablist joinop], go to state 197.
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'ID' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 350
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Shift 'ID', pending reduce 356
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm dbnm ID]
parser: Input 'ORDER' with pending reduce 356
parser: Reduce 356 [as ::= ID|STRING], go to state 243.
parser: ... then shift 'as', go to state 283
parser: Reduce 123 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 349
parser: Reduce 122 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 348
parser: Reduce 127 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 105
parser: Reduce 105 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 102 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 363
parser: Reduce 147 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 362
parser: Reduce 138 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 361
parser: Reduce 140 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 517
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 517
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 419
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'DOT' in state 419
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 26.
parser: ... then shift 'nm', go to state 537
parser: Shift 'DOT', go to state 249
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY nm DOT]
parser: Input 'ID' in state 249
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY nm DOT ID]
parser: Input 'COMMA' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 249.
parser: ... then shift 'nm', go to state 536
parser: Reduce 169 [expr ::= nm DOT nm], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 134 [sortorder ::=].
parser: ... then shift 'sortorder', go to state 353
parser: Reduce 137 [nulls ::=].
parser: ... then shift 'nulls', pending reduce 131
parser: Reduce 131 [sortlist ::= expr sortorder nulls], go to state 26.
parser: ... then shift 'sortlist', go to state 516
parser: Shift 'COMMA', go to state 95
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY sortlist COMMA]
parser: Input 'ID' in state 95
parser: Shift 'ID', go to state 419
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY sortlist COMMA ID]
parser: Input 'DOT' in state 419
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 95.
parser: ... then shift 'nm', go to state 537
parser: Shift 'DOT', go to state 249
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY sortlist COMMA nm DOT]
parser: Input 'ID' in state 249
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY sortlist COMMA nm DOT ID]
parser: Input 'DESC' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 249.
parser: ... then shift 'nm', go to state 536
parser: FALLBACK DESC => ID
parser: Reduce 169 [expr ::= nm DOT nm], go to state 95.
parser: ... then shift 'expr', go to state 14
parser: Shift 'DESC', pending reduce 133
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY sortlist COMMA expr DESC]
parser: Input 'SEMI' with pending reduce 133
parser: Reduce 133 [sortorder ::= DESC], go to state 14.
parser: ... then shift 'sortorder', go to state 354
parser: Reduce 137 [nulls ::=].
parser: ... then shift 'nulls', pending reduce 130
parser: Reduce 130 [sortlist ::= sortlist COMMA expr sortorder nulls], go to state 26.
parser: ... then shift 'sortlist', go to state 516
parser: Reduce 129 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 360
parser: Reduce 142 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 88
parser: Reduce 88 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 83 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 80
parser: Reduce 80 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
SQL: [SELECT x.b || '/' || y.b FROM a x, a y ORDER BY x.b, x.b DESC
  
;]
VDBE Trace:
   0 Init             0   16    0               00 Start at 16
  16 Transaction      0    0    6 1             01 usesStmtJournal=0
  17 String8          0    4    0 /             00 r[4]='/'
REG[4] =   t1[/](8)
  18 Goto             0    1    0               00 
   1 Noop             2    4    0               00 
   2 OpenRead         3    2    0 k(1,)         00 root=2 iDb=0; sqlite_autoindex_a_1
   3 OpenRead         4    4    0 k(1,B)        00 root=4 iDb=0; i2
   4 Explain          4    0    0 SCAN TABLE a AS x 00 
   5 Rewind           3   15    1 0             00 
   6 Explain          6    0    0 SCAN TABLE a AS y USING COVERING INDEX i2 00 
   7 Rewind           4   14    1 0             00 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:1
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:1
REG[2] =   s2[1/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:1
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:1
REG[2] =   s2[1/](8)
REG[1] =   s3[1/1](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[1/1](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:1
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:1
REG[2] =   s2[1/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:2
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:2
REG[2] =   s2[1/](8)
REG[1] =   s3[1/2](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[1/2](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:1
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:1
REG[2] =   s2[1/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:3
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:3
REG[2] =   s2[1/](8)
REG[1] =   s3[1/3](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[1/3](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:1
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:1
REG[2] =   s2[1/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:4
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:4
REG[2] =   s2[1/](8)
REG[1] =   s3[1/4](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[1/4](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:1
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:1
REG[2] =   s2[1/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:5
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:5
REG[2] =   s2[1/](8)
REG[1] =   s3[1/5](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[1/5](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:1
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:1
REG[2] =   s2[1/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:6
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:6
REG[2] =   s2[1/](8)
REG[1] =   s3[1/6](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[1/6](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:1
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:1
REG[2] =   s2[1/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:7
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:7
REG[2] =   s2[1/](8)
REG[1] =   s3[1/7](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[1/7](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:1
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:1
REG[2] =   s2[1/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:8
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:8
REG[2] =   s2[1/](8)
REG[1] =   s3[1/8](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[1/8](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:1
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:1
REG[2] =   s2[1/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:9
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:9
REG[2] =   s2[1/](8)
REG[1] =   s3[1/9](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[1/9](8)
  13 Next             4    8    0               01 
  14 Next             3    6    0               01 
   6 Explain          6    0    0 SCAN TABLE a AS y USING COVERING INDEX i2 00 
   7 Rewind           4   14    1 0             00 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:2
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:2
REG[2] =   s2[2/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:1
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:1
REG[2] =   s2[2/](8)
REG[1] =   s3[2/1](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[2/1](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:2
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:2
REG[2] =   s2[2/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:2
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:2
REG[2] =   s2[2/](8)
REG[1] =   s3[2/2](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[2/2](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:2
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:2
REG[2] =   s2[2/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:3
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:3
REG[2] =   s2[2/](8)
REG[1] =   s3[2/3](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[2/3](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:2
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:2
REG[2] =   s2[2/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:4
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:4
REG[2] =   s2[2/](8)
REG[1] =   s3[2/4](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[2/4](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:2
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:2
REG[2] =   s2[2/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:5
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:5
REG[2] =   s2[2/](8)
REG[1] =   s3[2/5](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[2/5](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:2
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:2
REG[2] =   s2[2/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:6
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:6
REG[2] =   s2[2/](8)
REG[1] =   s3[2/6](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[2/6](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:2
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:2
REG[2] =   s2[2/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:7
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:7
REG[2] =   s2[2/](8)
REG[1] =   s3[2/7](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[2/7](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:2
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:2
REG[2] =   s2[2/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:8
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:8
REG[2] =   s2[2/](8)
REG[1] =   s3[2/8](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[2/8](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:2
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:2
REG[2] =   s2[2/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:9
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:9
REG[2] =   s2[2/](8)
REG[1] =   s3[2/9](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[2/9](8)
  13 Next             4    8    0               01 
  14 Next             3    6    0               01 
   6 Explain          6    0    0 SCAN TABLE a AS y USING COVERING INDEX i2 00 
   7 Rewind           4   14    1 0             00 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:3
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:3
REG[2] =   s2[3/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:1
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:1
REG[2] =   s2[3/](8)
REG[1] =   s3[3/1](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[3/1](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:3
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:3
REG[2] =   s2[3/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:2
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:2
REG[2] =   s2[3/](8)
REG[1] =   s3[3/2](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[3/2](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:3
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:3
REG[2] =   s2[3/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:3
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:3
REG[2] =   s2[3/](8)
REG[1] =   s3[3/3](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[3/3](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:3
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:3
REG[2] =   s2[3/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:4
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:4
REG[2] =   s2[3/](8)
REG[1] =   s3[3/4](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[3/4](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:3
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:3
REG[2] =   s2[3/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:5
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:5
REG[2] =   s2[3/](8)
REG[1] =   s3[3/5](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[3/5](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:3
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:3
REG[2] =   s2[3/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:6
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:6
REG[2] =   s2[3/](8)
REG[1] =   s3[3/6](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[3/6](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:3
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:3
REG[2] =   s2[3/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:7
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:7
REG[2] =   s2[3/](8)
REG[1] =   s3[3/7](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[3/7](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:3
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:3
REG[2] =   s2[3/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:8
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:8
REG[2] =   s2[3/](8)
REG[1] =   s3[3/8](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[3/8](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:3
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:3
REG[2] =   s2[3/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:9
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:9
REG[2] =   s2[3/](8)
REG[1] =   s3[3/9](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[3/9](8)
  13 Next             4    8    0               01 
  14 Next             3    6    0               01 
   6 Explain          6    0    0 SCAN TABLE a AS y USING COVERING INDEX i2 00 
   7 Rewind           4   14    1 0             00 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:4
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:4
REG[2] =   s2[4/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:1
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:1
REG[2] =   s2[4/](8)
REG[1] =   s3[4/1](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[4/1](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:4
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:4
REG[2] =   s2[4/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:2
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:2
REG[2] =   s2[4/](8)
REG[1] =   s3[4/2](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[4/2](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:4
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:4
REG[2] =   s2[4/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:3
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:3
REG[2] =   s2[4/](8)
REG[1] =   s3[4/3](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[4/3](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:4
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:4
REG[2] =   s2[4/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:4
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:4
REG[2] =   s2[4/](8)
REG[1] =   s3[4/4](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[4/4](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:4
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:4
REG[2] =   s2[4/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:5
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:5
REG[2] =   s2[4/](8)
REG[1] =   s3[4/5](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[4/5](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:4
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:4
REG[2] =   s2[4/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:6
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:6
REG[2] =   s2[4/](8)
REG[1] =   s3[4/6](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[4/6](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:4
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:4
REG[2] =   s2[4/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:7
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:7
REG[2] =   s2[4/](8)
REG[1] =   s3[4/7](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[4/7](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:4
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:4
REG[2] =   s2[4/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:8
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:8
REG[2] =   s2[4/](8)
REG[1] =   s3[4/8](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[4/8](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:4
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:4
REG[2] =   s2[4/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:9
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:9
REG[2] =   s2[4/](8)
REG[1] =   s3[4/9](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[4/9](8)
  13 Next             4    8    0               01 
  14 Next             3    6    0               01 
   6 Explain          6    0    0 SCAN TABLE a AS y USING COVERING INDEX i2 00 
   7 Rewind           4   14    1 0             00 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:5
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:5
REG[2] =   s2[5/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:1
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:1
REG[2] =   s2[5/](8)
REG[1] =   s3[5/1](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[5/1](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:5
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:5
REG[2] =   s2[5/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:2
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:2
REG[2] =   s2[5/](8)
REG[1] =   s3[5/2](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[5/2](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:5
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:5
REG[2] =   s2[5/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:3
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:3
REG[2] =   s2[5/](8)
REG[1] =   s3[5/3](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[5/3](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:5
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:5
REG[2] =   s2[5/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:4
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:4
REG[2] =   s2[5/](8)
REG[1] =   s3[5/4](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[5/4](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:5
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:5
REG[2] =   s2[5/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:5
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:5
REG[2] =   s2[5/](8)
REG[1] =   s3[5/5](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[5/5](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:5
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:5
REG[2] =   s2[5/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:6
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:6
REG[2] =   s2[5/](8)
REG[1] =   s3[5/6](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[5/6](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:5
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:5
REG[2] =   s2[5/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:7
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:7
REG[2] =   s2[5/](8)
REG[1] =   s3[5/7](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[5/7](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:5
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:5
REG[2] =   s2[5/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:8
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:8
REG[2] =   s2[5/](8)
REG[1] =   s3[5/8](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[5/8](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:5
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:5
REG[2] =   s2[5/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:9
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:9
REG[2] =   s2[5/](8)
REG[1] =   s3[5/9](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[5/9](8)
  13 Next             4    8    0               01 
  14 Next             3    6    0               01 
   6 Explain          6    0    0 SCAN TABLE a AS y USING COVERING INDEX i2 00 
   7 Rewind           4   14    1 0             00 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:6
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:6
REG[2] =   s2[6/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:1
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:1
REG[2] =   s2[6/](8)
REG[1] =   s3[6/1](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[6/1](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:6
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:6
REG[2] =   s2[6/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:2
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:2
REG[2] =   s2[6/](8)
REG[1] =   s3[6/2](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[6/2](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:6
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:6
REG[2] =   s2[6/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:3
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:3
REG[2] =   s2[6/](8)
REG[1] =   s3[6/3](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[6/3](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:6
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:6
REG[2] =   s2[6/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:4
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:4
REG[2] =   s2[6/](8)
REG[1] =   s3[6/4](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[6/4](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:6
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:6
REG[2] =   s2[6/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:5
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:5
REG[2] =   s2[6/](8)
REG[1] =   s3[6/5](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[6/5](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:6
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:6
REG[2] =   s2[6/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:6
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:6
REG[2] =   s2[6/](8)
REG[1] =   s3[6/6](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[6/6](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:6
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:6
REG[2] =   s2[6/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:7
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:7
REG[2] =   s2[6/](8)
REG[1] =   s3[6/7](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[6/7](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:6
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:6
REG[2] =   s2[6/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:8
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:8
REG[2] =   s2[6/](8)
REG[1] =   s3[6/8](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[6/8](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:6
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:6
REG[2] =   s2[6/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:9
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:9
REG[2] =   s2[6/](8)
REG[1] =   s3[6/9](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[6/9](8)
  13 Next             4    8    0               01 
  14 Next             3    6    0               01 
   6 Explain          6    0    0 SCAN TABLE a AS y USING COVERING INDEX i2 00 
   7 Rewind           4   14    1 0             00 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:7
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:7
REG[2] =   s2[7/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:1
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:1
REG[2] =   s2[7/](8)
REG[1] =   s3[7/1](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[7/1](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:7
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:7
REG[2] =   s2[7/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:2
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:2
REG[2] =   s2[7/](8)
REG[1] =   s3[7/2](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[7/2](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:7
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:7
REG[2] =   s2[7/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:3
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:3
REG[2] =   s2[7/](8)
REG[1] =   s3[7/3](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[7/3](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:7
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:7
REG[2] =   s2[7/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:4
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:4
REG[2] =   s2[7/](8)
REG[1] =   s3[7/4](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[7/4](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:7
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:7
REG[2] =   s2[7/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:5
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:5
REG[2] =   s2[7/](8)
REG[1] =   s3[7/5](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[7/5](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:7
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:7
REG[2] =   s2[7/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:6
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:6
REG[2] =   s2[7/](8)
REG[1] =   s3[7/6](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[7/6](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:7
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:7
REG[2] =   s2[7/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:7
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:7
REG[2] =   s2[7/](8)
REG[1] =   s3[7/7](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[7/7](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:7
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:7
REG[2] =   s2[7/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:8
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:8
REG[2] =   s2[7/](8)
REG[1] =   s3[7/8](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[7/8](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:7
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:7
REG[2] =   s2[7/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:9
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:9
REG[2] =   s2[7/](8)
REG[1] =   s3[7/9](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[7/9](8)
  13 Next             4    8    0               01 
  14 Next             3    6    0               01 
   6 Explain          6    0    0 SCAN TABLE a AS y USING COVERING INDEX i2 00 
   7 Rewind           4   14    1 0             00 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:8
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:8
REG[2] =   s2[8/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:1
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:1
REG[2] =   s2[8/](8)
REG[1] =   s3[8/1](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[8/1](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:8
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:8
REG[2] =   s2[8/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:2
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:2
REG[2] =   s2[8/](8)
REG[1] =   s3[8/2](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[8/2](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:8
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:8
REG[2] =   s2[8/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:3
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:3
REG[2] =   s2[8/](8)
REG[1] =   s3[8/3](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[8/3](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:8
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:8
REG[2] =   s2[8/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:4
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:4
REG[2] =   s2[8/](8)
REG[1] =   s3[8/4](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[8/4](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:8
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:8
REG[2] =   s2[8/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:5
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:5
REG[2] =   s2[8/](8)
REG[1] =   s3[8/5](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[8/5](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:8
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:8
REG[2] =   s2[8/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:6
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:6
REG[2] =   s2[8/](8)
REG[1] =   s3[8/6](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[8/6](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:8
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:8
REG[2] =   s2[8/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:7
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:7
REG[2] =   s2[8/](8)
REG[1] =   s3[8/7](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[8/7](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:8
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:8
REG[2] =   s2[8/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:8
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:8
REG[2] =   s2[8/](8)
REG[1] =   s3[8/8](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[8/8](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:8
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:8
REG[2] =   s2[8/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:9
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:9
REG[2] =   s2[8/](8)
REG[1] =   s3[8/9](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[8/9](8)
  13 Next             4    8    0               01 
  14 Next             3    6    0               01 
   6 Explain          6    0    0 SCAN TABLE a AS y USING COVERING INDEX i2 00 
   7 Rewind           4   14    1 0             00 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:9
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:9
REG[2] =   s2[9/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:1
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:1
REG[2] =   s2[9/](8)
REG[1] =   s3[9/1](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[9/1](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:9
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:9
REG[2] =   s2[9/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:2
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:2
REG[2] =   s2[9/](8)
REG[1] =   s3[9/2](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[9/2](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:9
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:9
REG[2] =   s2[9/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:3
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:3
REG[2] =   s2[9/](8)
REG[1] =   s3[9/3](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[9/3](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:9
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:9
REG[2] =   s2[9/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:4
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:4
REG[2] =   s2[9/](8)
REG[1] =   s3[9/4](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[9/4](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:9
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:9
REG[2] =   s2[9/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:5
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:5
REG[2] =   s2[9/](8)
REG[1] =   s3[9/5](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[9/5](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:9
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:9
REG[2] =   s2[9/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:6
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:6
REG[2] =   s2[9/](8)
REG[1] =   s3[9/6](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[9/6](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:9
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:9
REG[2] =   s2[9/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:7
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:7
REG[2] =   s2[9/](8)
REG[1] =   s3[9/7](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[9/7](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:9
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:9
REG[2] =   s2[9/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:8
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:8
REG[2] =   s2[9/](8)
REG[1] =   s3[9/8](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[9/8](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:9
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:9
REG[2] =   s2[9/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:9
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:9
REG[2] =   s2[9/](8)
REG[1] =   s3[9/9](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[9/9](8)
  13 Next             4    8    0               01 
  14 Next             3    6    0               01 
  15 Halt             0    0    0               00 
parser: [[[SELECT x.b || '/' || y.b FROM a x, a y ORDER BY x.b, x.b||x.b
  
;SELECT x.b || '/' || y.b FROM a x, a y ORDER BY x.b, x.b, y.b||y.b
  
;SELECT x.b || '/' || y.b FROM a x, a y ORDER BY x.b, y.b||y.b DESC
  
;SELECT x.b || '/' || y.b FROM a x, a y ORDER BY x.b, x.b||y.b
  
;SELECT*FROM"temp".sqlite_temp_master ORDER BY rowid
;;
;CREATE TABLE x(y INTEGER PRIMARY KEY, t2i1);ALTER TABLE x ADD t1i1
    
;;
;SELECT x.RowID id FROM a, x WHERE a.b = x.RowID AND id = 2;SELECT*FROM"temp".sqlite_temp_master ORDER BY rowid
;ALTER TABLE x ADD abc
    
;CREATE INDEX c ON a(b)
;CREATE INDEX v1 ON a(b)
;ALTER TABLE ex ADD v2
    
;CREATE TABLE tr1(t1a, t1b);;SELECT y, v2 FROM x, ex WHERE y>v2;;
;SELECT DISTINCT b FROM a LEFT JOIN ex ON b=v2 ORDER BY +v2;CREATE INDEX x1 ON a(b)
;CREATE INDEX z ON a(b)
;CREATE INDEX example ON ex(v2)
;;SELECT count(*) FROM sqlite_master WHERE tbl_name = 'e' AND type = 'index';;
;CREATE TABLE example_idx_00000042(id PRIMARY KEY, UNIQUE(id) );;BEGIN;;CREATE UNIQUE INDEX IF NOT EXISTS a_id ON a(b==0);;SELECT * FROM ex;]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 95 [sclp ::=].
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 419
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'DOT' in state 419
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 77.
parser: ... then shift 'nm', go to state 493
parser: Shift 'DOT', go to state 205
parser: Return. Stack=[SELECT distinct sclp scanpt nm DOT]
parser: Input 'ID' in state 205
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[SELECT distinct sclp scanpt nm DOT ID]
parser: Input 'CONCAT' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 205.
parser: ... then shift 'nm', go to state 536
parser: Reduce 169 [expr ::= nm DOT nm], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Shift 'CONCAT', go to state 113
parser: Return. Stack=[SELECT distinct sclp scanpt expr CONCAT]
parser: Input 'STRING' in state 113
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[SELECT distinct sclp scanpt expr CONCAT STRING]
parser: Input 'CONCAT' in state 539
parser: Reduce 172 [term ::= STRING], go to state 113.
parser: ... then shift 'term', go to state 148
parser: Reduce 190 [expr ::= expr CONCAT expr], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Shift 'CONCAT', go to state 113
parser: Return. Stack=[SELECT distinct sclp scanpt expr CONCAT]
parser: Input 'ID' in state 113
parser: Shift 'ID', go to state 419
parser: Return. Stack=[SELECT distinct sclp scanpt expr CONCAT ID]
parser: Input 'DOT' in state 419
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 113.
parser: ... then shift 'nm', go to state 537
parser: Shift 'DOT', go to state 249
parser: Return. Stack=[SELECT distinct sclp scanpt expr CONCAT nm DOT]
parser: Input 'ID' in state 249
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[SELECT distinct sclp scanpt expr CONCAT nm DOT ID]
parser: Input 'FROM' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 249.
parser: ... then shift 'nm', go to state 536
parser: Reduce 169 [expr ::= nm DOT nm], go to state 113.
parser: ... then shift 'expr', go to state 148
parser: Reduce 190 [expr ::= expr CONCAT expr], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 104 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'ID' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 350
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Shift 'ID', pending reduce 356
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm dbnm ID]
parser: Input 'COMMA' with pending reduce 356
parser: Reduce 356 [as ::= ID|STRING], go to state 243.
parser: ... then shift 'as', go to state 283
parser: Reduce 123 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 349
parser: Reduce 122 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 348
parser: Reduce 127 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 105
parser: Reduce 105 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Shift 'COMMA', pending reduce 117
parser: Return. Stack=[SELECT distinct selcollist FROM seltablist COMMA]
parser: Input 'ID' with pending reduce 117
parser: Reduce 117 [joinop ::= COMMA|JOIN], go to state 263.
parser: ... then shift 'joinop', pending reduce 103
parser: Reduce 103 [stl_prefix ::= seltablist joinop], go to state 197.
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'ID' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 350
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Shift 'ID', pending reduce 356
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm dbnm ID]
parser: Input 'ORDER' with pending reduce 356
parser: Reduce 356 [as ::= ID|STRING], go to state 243.
parser: ... then shift 'as', go to state 283
parser: Reduce 123 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 349
parser: Reduce 122 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 348
parser: Reduce 127 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 105
parser: Reduce 105 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 102 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 363
parser: Reduce 147 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 362
parser: Reduce 138 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 361
parser: Reduce 140 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 517
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 517
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 419
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'DOT' in state 419
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 26.
parser: ... then shift 'nm', go to state 537
parser: Shift 'DOT', go to state 249
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY nm DOT]
parser: Input 'ID' in state 249
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY nm DOT ID]
parser: Input 'COMMA' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 249.
parser: ... then shift 'nm', go to state 536
parser: Reduce 169 [expr ::= nm DOT nm], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 134 [sortorder ::=].
parser: ... then shift 'sortorder', go to state 353
parser: Reduce 137 [nulls ::=].
parser: ... then shift 'nulls', pending reduce 131
parser: Reduce 131 [sortlist ::= expr sortorder nulls], go to state 26.
parser: ... then shift 'sortlist', go to state 516
parser: Shift 'COMMA', go to state 95
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY sortlist COMMA]
parser: Input 'ID' in state 95
parser: Shift 'ID', go to state 419
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY sortlist COMMA ID]
parser: Input 'DOT' in state 419
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 95.
parser: ... then shift 'nm', go to state 537
parser: Shift 'DOT', go to state 249
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY sortlist COMMA nm DOT]
parser: Input 'ID' in state 249
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY sortlist COMMA nm DOT ID]
parser: Input 'CONCAT' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 249.
parser: ... then shift 'nm', go to state 536
parser: Reduce 169 [expr ::= nm DOT nm], go to state 95.
parser: ... then shift 'expr', go to state 14
parser: Shift 'CONCAT', go to state 113
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY sortlist COMMA expr CONCAT]
parser: Input 'ID' in state 113
parser: Shift 'ID', go to state 419
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY sortlist COMMA expr CONCAT ID]
parser: Input 'DOT' in state 419
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 113.
parser: ... then shift 'nm', go to state 537
parser: Shift 'DOT', go to state 249
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY sortlist COMMA expr CONCAT nm DOT]
parser: Input 'ID' in state 249
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY sortlist COMMA expr CONCAT nm DOT ID]
parser: Input 'SEMI' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 249.
parser: ... then shift 'nm', go to state 536
parser: Reduce 169 [expr ::= nm DOT nm], go to state 113.
parser: ... then shift 'expr', go to state 148
parser: Reduce 190 [expr ::= expr CONCAT expr], go to state 95.
parser: ... then shift 'expr', go to state 14
parser: Reduce 134 [sortorder ::=].
parser: ... then shift 'sortorder', go to state 354
parser: Reduce 137 [nulls ::=].
parser: ... then shift 'nulls', pending reduce 130
parser: Reduce 130 [sortlist ::= sortlist COMMA expr sortorder nulls], go to state 26.
parser: ... then shift 'sortlist', go to state 516
parser: Reduce 129 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 360
parser: Reduce 142 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 88
parser: Reduce 88 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 83 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 80
parser: Reduce 80 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
SQL: [SELECT x.b || '/' || y.b FROM a x, a y ORDER BY x.b, x.b||x.b
  
;]
VDBE Trace:
   0 Init             0   16    0               00 Start at 16
  16 Transaction      0    0    6 1             01 usesStmtJournal=0
  17 String8          0    4    0 /             00 r[4]='/'
REG[4] =   t1[/](8)
  18 Goto             0    1    0               00 
   1 Noop             2    4    0               00 
   2 OpenRead         3    2    0 k(1,)         00 root=2 iDb=0; sqlite_autoindex_a_1
   3 OpenRead         4    4    0 k(1,B)        00 root=4 iDb=0; i2
   4 Explain          4    0    0 SCAN TABLE a AS x 00 
   5 Rewind           3   15    1 0             00 
   6 Explain          6    0    0 SCAN TABLE a AS y USING COVERING INDEX i2 00 
   7 Rewind           4   14    1 0             00 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:1
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:1
REG[2] =   s2[1/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:1
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:1
REG[2] =   s2[1/](8)
REG[1] =   s3[1/1](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[1/1](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:1
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:1
REG[2] =   s2[1/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:2
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:2
REG[2] =   s2[1/](8)
REG[1] =   s3[1/2](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[1/2](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:1
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:1
REG[2] =   s2[1/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:3
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:3
REG[2] =   s2[1/](8)
REG[1] =   s3[1/3](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[1/3](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:1
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:1
REG[2] =   s2[1/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:4
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:4
REG[2] =   s2[1/](8)
REG[1] =   s3[1/4](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[1/4](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:1
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:1
REG[2] =   s2[1/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:5
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:5
REG[2] =   s2[1/](8)
REG[1] =   s3[1/5](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[1/5](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:1
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:1
REG[2] =   s2[1/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:6
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:6
REG[2] =   s2[1/](8)
REG[1] =   s3[1/6](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[1/6](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:1
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:1
REG[2] =   s2[1/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:7
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:7
REG[2] =   s2[1/](8)
REG[1] =   s3[1/7](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[1/7](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:1
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:1
REG[2] =   s2[1/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:8
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:8
REG[2] =   s2[1/](8)
REG[1] =   s3[1/8](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[1/8](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:1
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:1
REG[2] =   s2[1/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:9
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:9
REG[2] =   s2[1/](8)
REG[1] =   s3[1/9](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[1/9](8)
  13 Next             4    8    0               01 
  14 Next             3    6    0               01 
   6 Explain          6    0    0 SCAN TABLE a AS y USING COVERING INDEX i2 00 
   7 Rewind           4   14    1 0             00 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:2
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:2
REG[2] =   s2[2/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:1
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:1
REG[2] =   s2[2/](8)
REG[1] =   s3[2/1](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[2/1](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:2
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:2
REG[2] =   s2[2/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:2
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:2
REG[2] =   s2[2/](8)
REG[1] =   s3[2/2](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[2/2](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:2
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:2
REG[2] =   s2[2/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:3
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:3
REG[2] =   s2[2/](8)
REG[1] =   s3[2/3](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[2/3](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:2
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:2
REG[2] =   s2[2/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:4
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:4
REG[2] =   s2[2/](8)
REG[1] =   s3[2/4](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[2/4](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:2
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:2
REG[2] =   s2[2/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:5
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:5
REG[2] =   s2[2/](8)
REG[1] =   s3[2/5](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[2/5](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:2
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:2
REG[2] =   s2[2/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:6
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:6
REG[2] =   s2[2/](8)
REG[1] =   s3[2/6](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[2/6](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:2
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:2
REG[2] =   s2[2/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:7
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:7
REG[2] =   s2[2/](8)
REG[1] =   s3[2/7](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[2/7](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:2
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:2
REG[2] =   s2[2/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:8
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:8
REG[2] =   s2[2/](8)
REG[1] =   s3[2/8](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[2/8](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:2
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:2
REG[2] =   s2[2/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:9
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:9
REG[2] =   s2[2/](8)
REG[1] =   s3[2/9](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[2/9](8)
  13 Next             4    8    0               01 
  14 Next             3    6    0               01 
   6 Explain          6    0    0 SCAN TABLE a AS y USING COVERING INDEX i2 00 
   7 Rewind           4   14    1 0             00 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:3
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:3
REG[2] =   s2[3/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:1
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:1
REG[2] =   s2[3/](8)
REG[1] =   s3[3/1](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[3/1](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:3
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:3
REG[2] =   s2[3/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:2
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:2
REG[2] =   s2[3/](8)
REG[1] =   s3[3/2](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[3/2](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:3
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:3
REG[2] =   s2[3/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:3
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:3
REG[2] =   s2[3/](8)
REG[1] =   s3[3/3](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[3/3](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:3
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:3
REG[2] =   s2[3/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:4
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:4
REG[2] =   s2[3/](8)
REG[1] =   s3[3/4](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[3/4](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:3
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:3
REG[2] =   s2[3/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:5
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:5
REG[2] =   s2[3/](8)
REG[1] =   s3[3/5](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[3/5](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:3
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:3
REG[2] =   s2[3/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:6
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:6
REG[2] =   s2[3/](8)
REG[1] =   s3[3/6](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[3/6](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:3
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:3
REG[2] =   s2[3/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:7
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:7
REG[2] =   s2[3/](8)
REG[1] =   s3[3/7](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[3/7](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:3
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:3
REG[2] =   s2[3/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:8
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:8
REG[2] =   s2[3/](8)
REG[1] =   s3[3/8](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[3/8](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:3
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:3
REG[2] =   s2[3/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:9
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:9
REG[2] =   s2[3/](8)
REG[1] =   s3[3/9](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[3/9](8)
  13 Next             4    8    0               01 
  14 Next             3    6    0               01 
   6 Explain          6    0    0 SCAN TABLE a AS y USING COVERING INDEX i2 00 
   7 Rewind           4   14    1 0             00 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:4
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:4
REG[2] =   s2[4/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:1
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:1
REG[2] =   s2[4/](8)
REG[1] =   s3[4/1](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[4/1](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:4
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:4
REG[2] =   s2[4/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:2
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:2
REG[2] =   s2[4/](8)
REG[1] =   s3[4/2](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[4/2](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:4
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:4
REG[2] =   s2[4/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:3
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:3
REG[2] =   s2[4/](8)
REG[1] =   s3[4/3](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[4/3](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:4
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:4
REG[2] =   s2[4/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:4
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:4
REG[2] =   s2[4/](8)
REG[1] =   s3[4/4](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[4/4](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:4
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:4
REG[2] =   s2[4/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:5
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:5
REG[2] =   s2[4/](8)
REG[1] =   s3[4/5](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[4/5](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:4
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:4
REG[2] =   s2[4/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:6
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:6
REG[2] =   s2[4/](8)
REG[1] =   s3[4/6](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[4/6](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:4
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:4
REG[2] =   s2[4/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:7
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:7
REG[2] =   s2[4/](8)
REG[1] =   s3[4/7](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[4/7](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:4
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:4
REG[2] =   s2[4/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:8
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:8
REG[2] =   s2[4/](8)
REG[1] =   s3[4/8](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[4/8](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:4
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:4
REG[2] =   s2[4/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:9
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:9
REG[2] =   s2[4/](8)
REG[1] =   s3[4/9](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[4/9](8)
  13 Next             4    8    0               01 
  14 Next             3    6    0               01 
   6 Explain          6    0    0 SCAN TABLE a AS y USING COVERING INDEX i2 00 
   7 Rewind           4   14    1 0             00 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:5
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:5
REG[2] =   s2[5/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:1
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:1
REG[2] =   s2[5/](8)
REG[1] =   s3[5/1](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[5/1](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:5
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:5
REG[2] =   s2[5/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:2
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:2
REG[2] =   s2[5/](8)
REG[1] =   s3[5/2](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[5/2](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:5
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:5
REG[2] =   s2[5/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:3
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:3
REG[2] =   s2[5/](8)
REG[1] =   s3[5/3](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[5/3](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:5
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:5
REG[2] =   s2[5/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:4
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:4
REG[2] =   s2[5/](8)
REG[1] =   s3[5/4](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[5/4](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:5
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:5
REG[2] =   s2[5/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:5
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:5
REG[2] =   s2[5/](8)
REG[1] =   s3[5/5](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[5/5](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:5
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:5
REG[2] =   s2[5/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:6
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:6
REG[2] =   s2[5/](8)
REG[1] =   s3[5/6](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[5/6](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:5
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:5
REG[2] =   s2[5/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:7
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:7
REG[2] =   s2[5/](8)
REG[1] =   s3[5/7](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[5/7](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:5
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:5
REG[2] =   s2[5/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:8
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:8
REG[2] =   s2[5/](8)
REG[1] =   s3[5/8](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[5/8](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:5
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:5
REG[2] =   s2[5/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:9
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:9
REG[2] =   s2[5/](8)
REG[1] =   s3[5/9](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[5/9](8)
  13 Next             4    8    0               01 
  14 Next             3    6    0               01 
   6 Explain          6    0    0 SCAN TABLE a AS y USING COVERING INDEX i2 00 
   7 Rewind           4   14    1 0             00 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:6
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:6
REG[2] =   s2[6/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:1
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:1
REG[2] =   s2[6/](8)
REG[1] =   s3[6/1](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[6/1](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:6
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:6
REG[2] =   s2[6/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:2
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:2
REG[2] =   s2[6/](8)
REG[1] =   s3[6/2](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[6/2](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:6
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:6
REG[2] =   s2[6/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:3
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:3
REG[2] =   s2[6/](8)
REG[1] =   s3[6/3](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[6/3](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:6
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:6
REG[2] =   s2[6/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:4
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:4
REG[2] =   s2[6/](8)
REG[1] =   s3[6/4](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[6/4](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:6
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:6
REG[2] =   s2[6/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:5
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:5
REG[2] =   s2[6/](8)
REG[1] =   s3[6/5](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[6/5](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:6
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:6
REG[2] =   s2[6/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:6
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:6
REG[2] =   s2[6/](8)
REG[1] =   s3[6/6](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[6/6](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:6
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:6
REG[2] =   s2[6/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:7
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:7
REG[2] =   s2[6/](8)
REG[1] =   s3[6/7](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[6/7](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:6
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:6
REG[2] =   s2[6/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:8
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:8
REG[2] =   s2[6/](8)
REG[1] =   s3[6/8](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[6/8](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:6
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:6
REG[2] =   s2[6/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:9
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:9
REG[2] =   s2[6/](8)
REG[1] =   s3[6/9](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[6/9](8)
  13 Next             4    8    0               01 
  14 Next             3    6    0               01 
   6 Explain          6    0    0 SCAN TABLE a AS y USING COVERING INDEX i2 00 
   7 Rewind           4   14    1 0             00 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:7
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:7
REG[2] =   s2[7/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:1
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:1
REG[2] =   s2[7/](8)
REG[1] =   s3[7/1](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[7/1](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:7
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:7
REG[2] =   s2[7/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:2
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:2
REG[2] =   s2[7/](8)
REG[1] =   s3[7/2](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[7/2](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:7
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:7
REG[2] =   s2[7/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:3
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:3
REG[2] =   s2[7/](8)
REG[1] =   s3[7/3](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[7/3](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:7
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:7
REG[2] =   s2[7/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:4
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:4
REG[2] =   s2[7/](8)
REG[1] =   s3[7/4](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[7/4](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:7
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:7
REG[2] =   s2[7/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:5
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:5
REG[2] =   s2[7/](8)
REG[1] =   s3[7/5](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[7/5](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:7
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:7
REG[2] =   s2[7/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:6
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:6
REG[2] =   s2[7/](8)
REG[1] =   s3[7/6](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[7/6](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:7
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:7
REG[2] =   s2[7/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:7
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:7
REG[2] =   s2[7/](8)
REG[1] =   s3[7/7](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[7/7](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:7
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:7
REG[2] =   s2[7/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:8
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:8
REG[2] =   s2[7/](8)
REG[1] =   s3[7/8](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[7/8](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:7
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:7
REG[2] =   s2[7/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:9
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:9
REG[2] =   s2[7/](8)
REG[1] =   s3[7/9](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[7/9](8)
  13 Next             4    8    0               01 
  14 Next             3    6    0               01 
   6 Explain          6    0    0 SCAN TABLE a AS y USING COVERING INDEX i2 00 
   7 Rewind           4   14    1 0             00 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:8
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:8
REG[2] =   s2[8/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:1
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:1
REG[2] =   s2[8/](8)
REG[1] =   s3[8/1](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[8/1](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:8
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:8
REG[2] =   s2[8/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:2
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:2
REG[2] =   s2[8/](8)
REG[1] =   s3[8/2](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[8/2](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:8
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:8
REG[2] =   s2[8/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:3
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:3
REG[2] =   s2[8/](8)
REG[1] =   s3[8/3](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[8/3](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:8
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:8
REG[2] =   s2[8/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:4
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:4
REG[2] =   s2[8/](8)
REG[1] =   s3[8/4](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[8/4](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:8
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:8
REG[2] =   s2[8/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:5
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:5
REG[2] =   s2[8/](8)
REG[1] =   s3[8/5](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[8/5](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:8
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:8
REG[2] =   s2[8/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:6
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:6
REG[2] =   s2[8/](8)
REG[1] =   s3[8/6](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[8/6](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:8
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:8
REG[2] =   s2[8/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:7
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:7
REG[2] =   s2[8/](8)
REG[1] =   s3[8/7](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[8/7](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:8
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:8
REG[2] =   s2[8/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:8
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:8
REG[2] =   s2[8/](8)
REG[1] =   s3[8/8](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[8/8](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:8
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:8
REG[2] =   s2[8/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:9
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:9
REG[2] =   s2[8/](8)
REG[1] =   s3[8/9](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[8/9](8)
  13 Next             4    8    0               01 
  14 Next             3    6    0               01 
   6 Explain          6    0    0 SCAN TABLE a AS y USING COVERING INDEX i2 00 
   7 Rewind           4   14    1 0             00 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:9
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:9
REG[2] =   s2[9/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:1
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:1
REG[2] =   s2[9/](8)
REG[1] =   s3[9/1](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[9/1](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:9
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:9
REG[2] =   s2[9/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:2
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:2
REG[2] =   s2[9/](8)
REG[1] =   s3[9/2](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[9/2](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:9
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:9
REG[2] =   s2[9/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:3
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:3
REG[2] =   s2[9/](8)
REG[1] =   s3[9/3](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[9/3](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:9
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:9
REG[2] =   s2[9/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:4
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:4
REG[2] =   s2[9/](8)
REG[1] =   s3[9/4](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[9/4](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:9
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:9
REG[2] =   s2[9/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:5
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:5
REG[2] =   s2[9/](8)
REG[1] =   s3[9/5](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[9/5](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:9
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:9
REG[2] =   s2[9/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:6
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:6
REG[2] =   s2[9/](8)
REG[1] =   s3[9/6](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[9/6](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:9
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:9
REG[2] =   s2[9/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:7
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:7
REG[2] =   s2[9/](8)
REG[1] =   s3[9/7](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[9/7](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:9
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:9
REG[2] =   s2[9/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:8
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:8
REG[2] =   s2[9/](8)
REG[1] =   s3[9/8](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[9/8](8)
  13 Next             4    8    0               01 
   8 Column           3    0    3               00 r[3]=a.b
REG[3] =  i:9
   9 Concat           4    3    2               00 r[2]=r[3]+r[4]
REG[4] =   t1[/](8)
REG[3] =  i:9
REG[2] =   s2[9/](8)
  10 Column           4    0    3               00 r[3]=a.b
REG[3] =  i:9
  11 Concat           3    2    1               00 r[1]=r[2]+r[3]
REG[3] =  i:9
REG[2] =   s2[9/](8)
REG[1] =   s3[9/9](8)
  12 ResultRow        1    1    0               00 output=r[1]
REG[1] =   s3[9/9](8)
  13 Next             4    8    0               01 
  14 Next             3    6    0               01 
  15 Halt             0    0    0               00 
parser: [[[SELECT x.b || '/' || y.b FROM a x, a y ORDER BY x.b, x.b, y.b||y.b
  
;SELECT x.b || '/' || y.b FROM a x, a y ORDER BY x.b, y.b||y.b DESC
  
;SELECT x.b || '/' || y.b FROM a x, a y ORDER BY x.b, x.b||y.b
  
;SELECT*FROM"temp".sqlite_temp_master ORDER BY rowid
;;
;CREATE TABLE x(y INTEGER PRIMARY KEY, t2i1);ALTER TABLE x ADD t1i1
    
;;
;SELECT x.RowID id FROM a, x WHERE a.b = x.RowID AND id = 2;SELECT*FROM"temp".sqlite_temp_master ORDER BY rowid
;ALTER TABLE x ADD abc
    
;CREATE INDEX c ON a(b)
;CREATE INDEX v1 ON a(b)
;ALTER TABLE ex ADD v2
    
;CREATE TABLE tr1(t1a, t1b);;SELECT y, v2 FROM x, ex WHERE y>v2;;
;SELECT DISTINCT b FROM a LEFT JOIN ex ON b=v2 ORDER BY +v2;CREATE INDEX x1 ON a(b)
;CREATE INDEX z ON a(b)
;CREATE INDEX example ON ex(v2)
;;SELECT count(*) FROM sqlite_master WHERE tbl_name = 'e' AND type = 'index';;
;CREATE TABLE example_idx_00000042(id PRIMARY KEY, UNIQUE(id) );;BEGIN;;CREATE UNIQUE INDEX IF NOT EXISTS a_id ON a(b==0);;SELECT * FROM ex;]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 95 [sclp ::=].
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 419
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'DOT' in state 419
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 77.
parser: ... then shift 'nm', go to state 493
parser: Shift 'DOT', go to state 205
parser: Return. Stack=[SELECT distinct sclp scanpt nm DOT]
parser: Input 'ID' in state 205
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[SELECT distinct sclp scanpt nm DOT ID]
parser: Input 'CONCAT' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 205.
parser: ... then shift 'nm', go to state 536
parser: Reduce 169 [expr ::= nm DOT nm], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Shift 'CONCAT', go to state 113
parser: Return. Stack=[SELECT distinct sclp scanpt expr CONCAT]
parser: Input 'STRING' in state 113
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[SELECT distinct sclp scanpt expr CONCAT STRING]
parser: Input 'CONCAT' in state 539
parser: Reduce 172 [term ::= STRING], go to state 113.
parser: ... then shift 'term', go to state 148
parser: Reduce 190 [expr ::= expr CONCAT expr], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Shift 'CONCAT', go to state 113
parser: Return. Stack=[SELECT distinct sclp scanpt expr CONCAT]
parser: Input 'ID' in state 113
parser: Shift 'ID', go to state 419
parser: Return. Stack=[SELECT distinct sclp scanpt expr CONCAT ID]
parser: Input 'DOT' in state 419
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 113.
parser: ... then shift 'nm', go to state 537
parser: Shift 'DOT', go to state 249
parser: Return. Stack=[SELECT distinct sclp scanpt expr CONCAT nm DOT]
parser: Input 'ID' in state 249
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[SELECT distinct sclp scanpt expr CONCAT nm DOT ID]
parser: Input 'FROM' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 249.
parser: ... then shift 'nm', go to state 536
parser: Reduce 169 [expr ::= nm DOT nm], go to state 113.
parser: ... then shift 'expr', go to state 148
parser: Reduce 190 [expr ::= expr CONCAT expr], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 104 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'ID' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 350
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Shift 'ID', pending reduce 356
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm dbnm ID]
parser: Input 'COMMA' with pending reduce 356
parser: Reduce 356 [as ::= ID|STRING], go to state 243.
parser: ... then shift 'as', go to state 283
parser: Reduce 123 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 349
parser: Reduce 122 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 348
parser: Reduce 127 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 105
parser: Reduce 105 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Shift 'COMMA', pending reduce 117
parser: Return. Stack=[SELECT distinct selcollist FROM seltablist COMMA]
parser: Input 'ID' with pending reduce 117
parser: Reduce 117 [joinop ::= COMMA|JOIN], go to state 263.
parser: ... then shift 'joinop', pending reduce 103
parser: Reduce 103 [stl_prefix ::= seltablist joinop], go to state 197.
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'ID' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 350
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Shift 'ID', pending reduce 356
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm dbnm ID]
parser: Input 'ORDER' with pending reduce 356
parser: Reduce 356 [as ::= ID|STRING], go to state 243.
parser: ... then shift 'as', go to state 283
parser: Reduce 123 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 349
parser: Reduce 122 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 348
parser: Reduce 127 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 105
parser: Reduce 105 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 102 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 363
parser: Reduce 147 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 362
parser: Reduce 138 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 361
parser: Reduce 140 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 517
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 517
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 419
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'DOT' in state 419
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 26.
parser: ... then shift 'nm', go to state 537
parser: Shift 'DOT', go to state 249
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY nm DOT]
parser: Input 'ID' in state 249
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY nm DOT ID]
parser: Input 'COMMA' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 249.
parser: ... then shift 'nm', go to state 536
parser: Reduce 169 [expr ::= nm DOT nm], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 134 [sortorder ::=].
parser: ... then shift 'sortorder', go to state 353
parser: Reduce 137 [nulls ::=].
parser: ... then shift 'nulls', pending reduce 131
parser: Reduce 131 [sortlist ::= expr sortorder nulls], go to state 26.
parser: ... then shift 'sortlist', go to state 516
parser: Shift 'COMMA', go to state 95
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY sortlist COMMA]
parser: Input 'ID' in state 95
parser: Shift 'ID', go to state 419
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY sortlist COMMA ID]
parser: Input 'DOT' in state 419
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 95.
parser: ... then shift 'nm', go to state 537
parser: Shift 'DOT', go to state 249
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY sortlist COMMA nm DOT]
parser: Input 'ID' in state 249
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY sortlist COMMA nm DOT ID]
parser: Input 'COMMA' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 249.
parser: ... then shift 'nm', go to state 536
parser: Reduce 169 [expr ::= nm DOT nm], go to state 95.
parser: ... then shift 'expr', go to state 14
parser: Reduce 134 [sortorder ::=].
parser: ... then shift 'sortorder', go to state 354
parser: Reduce 137 [nulls ::=].
parser: ... then shift 'nulls', pending reduce 130
parser: Reduce 130 [sortlist ::= sortlist COMMA expr sortorder nulls], go to state 26.
parser: ... then shift 'sortlist', go to state 516
parser: Shift 'COMMA', go to state 95
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY sortlist COMMA]
parser: Input 'ID' in state 95
parser: Shift 'ID', go to state 419
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY sortlist COMMA ID]
parser: Input 'DOT' in state 419
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 95.
parser: ... then shift 'nm', go to state 537
parser: Shift 'DOT', go to state 249
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY sortlist COMMA nm DOT]
parser: Input 'ID' in state 249
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY sortlist COMMA nm DOT ID]
parser: Input 'CONCAT' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 249.
parser: ... then shift 'nm', go to state 536
parser: Reduce 169 [expr ::= nm DOT nm], go to state 95.
parser: ... then shift 'expr', go to state 14
parser: Shift 'CONCAT', go to state 113
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY sortlist COMMA expr CONCAT]
parser: Input 'ID' in state 113
parser: Shift 'ID', go to state 419
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY sortlist COMMA expr CONCAT ID]
parser: Input 'DOT' in state 419
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 113.
parser: ... then shift 'nm', go to state 537
parser: Shift 'DOT', go to state 249
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY sortlist COMMA expr CONCAT nm DOT]
parser: Input 'ID' in state 249
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY sortlist COMMA expr CONCAT nm DOT ID]
parser: Input 'SEMI' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 249.
parser: ... then shift 'nm', go to state 536
parser: Reduce 169 [expr ::= nm DOT nm], go to state 113.
parser: ... then shift 'expr', go to state 148
parser: Reduce 190 [expr ::= expr CONCAT expr], go to state 95.
parser: ... then shift 'expr', go to state 14
parser: Reduce 134 [sortorder ::=].
parser: ... then shift 'sortorder', go to state 354
parser: Reduce 137 [nulls ::=].
parser: ... then shift 'nulls', pending reduce 130
parser: Reduce 130 [sortlist ::= sortlist COMMA expr sortorder nulls], go to state 26.
parser: ... then shift 'sortlist', go to state 516
parser: Reduce 129 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 360
parser: Reduce 142 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 88
parser: Reduce 88 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 83 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 80
parser: Reduce 80 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
SQL: [SELECT x.b || '/' || y.b FROM a x, a y ORDER BY x.b, x.b, y.b||y.b
  
;]
VDBE Trace:
   0 Init             0   39    0               00 Start at 39
  39 Transaction      0    0    6 1             01 usesStmtJournal=0
  40 String8          0    7    0 /             00 r[7]='/'
REG[7] =   t1[/](8)
  41 Goto             0    1    0               00 
   1 SorterOpen       2    2    0 k(1,B)        00 
   2 OpenRead         3    2    0 k(1,)         00 root=2 iDb=0; sqlite_autoindex_a_1
   3 OpenRead         4    4    0 k(1,B)        00 root=4 iDb=0; i2
   4 Explain          4    0    0 SCAN TABLE a AS x 00 
   5 Rewind           3   27    1 0             00 
   6 Explain          6    0    0 SCAN TABLE a AS y USING COVERING INDEX i2 00 
   7 Rewind           4   26    1 0             00 
   8 Column           3    0    6               00 r[6]=a.b
REG[6] =  i:1
   9 Concat           7    6    5               00 r[5]=r[6]+r[7]
REG[7] =   t1[/](8)
REG[6] =  i:1
REG[5] =   s2[1/](8)
  10 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:1
  11 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =  i:1
REG[5] =   s2[1/](8)
REG[4] =   s3[1/1](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:1
  13 Column           3    0    2               00 r[2]=a.b
REG[2] =  i:1
  14 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:1
  15 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:1
  16 Concat           5    6    3               00 r[3]=r[6]+r[5]
REG[5] =  i:1
REG[6] =  i:1
REG[3] =   s2[11](8)
  17 MakeRecord       3    2    8               00 r[8]=mkrec(r[3..4])
REG[8] =  sx8[0311133131312F31|...111/1]
  18 SequenceTest     2   23    0               00 if( cursor[2].ctr++ ) pc = 23
  23 Move             1    9    2               00 r[9..10]=r[1..2]
REG[9] =  i:1
REG[10] =  i:1
  24 SorterInsert     2    8    3 2             00 key=r[8]
REG[8] =  sx8[0311133131312F31|...111/1]
  25 Next             4    8    0               01 
   8 Column           3    0    6               00 r[6]=a.b
REG[6] =  i:1
   9 Concat           7    6    5               00 r[5]=r[6]+r[7]
REG[7] =   t1[/](8)
REG[6] =  i:1
REG[5] =   s2[1/](8)
  10 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:2
  11 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =  i:2
REG[5] =   s2[1/](8)
REG[4] =   s3[1/2](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:1
  13 Column           3    0    2               00 r[2]=a.b
REG[2] =  i:1
  14 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:2
  15 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:2
  16 Concat           5    6    3               00 r[3]=r[6]+r[5]
REG[5] =  i:2
REG[6] =  i:2
REG[3] =   s2[22](8)
  17 MakeRecord       3    2    8               00 r[8]=mkrec(r[3..4])
REG[8] =  sx8[0311133232312F32|...221/2]
  18 SequenceTest     2   23    0               00 if( cursor[2].ctr++ ) pc = 23
  19 Compare          9    1    2 k(3,B,B,B)    00 r[9..10] <-> r[1..2]
REG[9] =  i:1
REG[1] =  i:1
REG[10] =  i:1
REG[2] =  i:1
  20 Jump            21   24   21               00 
  24 SorterInsert     2    8    3 2             00 key=r[8]
REG[8] =  sx8[0311133232312F32|...221/2]
  25 Next             4    8    0               01 
   8 Column           3    0    6               00 r[6]=a.b
REG[6] =  i:1
   9 Concat           7    6    5               00 r[5]=r[6]+r[7]
REG[7] =   t1[/](8)
REG[6] =  i:1
REG[5] =   s2[1/](8)
  10 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:3
  11 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =  i:3
REG[5] =   s2[1/](8)
REG[4] =   s3[1/3](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:1
  13 Column           3    0    2               00 r[2]=a.b
REG[2] =  i:1
  14 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:3
  15 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:3
  16 Concat           5    6    3               00 r[3]=r[6]+r[5]
REG[5] =  i:3
REG[6] =  i:3
REG[3] =   s2[33](8)
  17 MakeRecord       3    2    8               00 r[8]=mkrec(r[3..4])
REG[8] =  sx8[0311133333312F33|...331/3]
  18 SequenceTest     2   23    0               00 if( cursor[2].ctr++ ) pc = 23
  19 Compare          9    1    2 k(3,B,B,B)    00 r[9..10] <-> r[1..2]
REG[9] =  i:1
REG[1] =  i:1
REG[10] =  i:1
REG[2] =  i:1
  20 Jump            21   24   21               00 
  24 SorterInsert     2    8    3 2             00 key=r[8]
REG[8] =  sx8[0311133333312F33|...331/3]
  25 Next             4    8    0               01 
   8 Column           3    0    6               00 r[6]=a.b
REG[6] =  i:1
   9 Concat           7    6    5               00 r[5]=r[6]+r[7]
REG[7] =   t1[/](8)
REG[6] =  i:1
REG[5] =   s2[1/](8)
  10 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:4
  11 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =  i:4
REG[5] =   s2[1/](8)
REG[4] =   s3[1/4](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:1
  13 Column           3    0    2               00 r[2]=a.b
REG[2] =  i:1
  14 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:4
  15 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:4
  16 Concat           5    6    3               00 r[3]=r[6]+r[5]
REG[5] =  i:4
REG[6] =  i:4
REG[3] =   s2[44](8)
  17 MakeRecord       3    2    8               00 r[8]=mkrec(r[3..4])
REG[8] =  sx8[0311133434312F34|...441/4]
  18 SequenceTest     2   23    0               00 if( cursor[2].ctr++ ) pc = 23
  19 Compare          9    1    2 k(3,B,B,B)    00 r[9..10] <-> r[1..2]
REG[9] =  i:1
REG[1] =  i:1
REG[10] =  i:1
REG[2] =  i:1
  20 Jump            21   24   21               00 
  24 SorterInsert     2    8    3 2             00 key=r[8]
REG[8] =  sx8[0311133434312F34|...441/4]
  25 Next             4    8    0               01 
   8 Column           3    0    6               00 r[6]=a.b
REG[6] =  i:1
   9 Concat           7    6    5               00 r[5]=r[6]+r[7]
REG[7] =   t1[/](8)
REG[6] =  i:1
REG[5] =   s2[1/](8)
  10 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:5
  11 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =  i:5
REG[5] =   s2[1/](8)
REG[4] =   s3[1/5](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:1
  13 Column           3    0    2               00 r[2]=a.b
REG[2] =  i:1
  14 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:5
  15 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:5
  16 Concat           5    6    3               00 r[3]=r[6]+r[5]
REG[5] =  i:5
REG[6] =  i:5
REG[3] =   s2[55](8)
  17 MakeRecord       3    2    8               00 r[8]=mkrec(r[3..4])
REG[8] =  sx8[0311133535312F35|...551/5]
  18 SequenceTest     2   23    0               00 if( cursor[2].ctr++ ) pc = 23
  19 Compare          9    1    2 k(3,B,B,B)    00 r[9..10] <-> r[1..2]
REG[9] =  i:1
REG[1] =  i:1
REG[10] =  i:1
REG[2] =  i:1
  20 Jump            21   24   21               00 
  24 SorterInsert     2    8    3 2             00 key=r[8]
REG[8] =  sx8[0311133535312F35|...551/5]
  25 Next             4    8    0               01 
   8 Column           3    0    6               00 r[6]=a.b
REG[6] =  i:1
   9 Concat           7    6    5               00 r[5]=r[6]+r[7]
REG[7] =   t1[/](8)
REG[6] =  i:1
REG[5] =   s2[1/](8)
  10 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:6
  11 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =  i:6
REG[5] =   s2[1/](8)
REG[4] =   s3[1/6](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:1
  13 Column           3    0    2               00 r[2]=a.b
REG[2] =  i:1
  14 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:6
  15 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:6
  16 Concat           5    6    3               00 r[3]=r[6]+r[5]
REG[5] =  i:6
REG[6] =  i:6
REG[3] =   s2[66](8)
  17 MakeRecord       3    2    8               00 r[8]=mkrec(r[3..4])
REG[8] =  sx8[0311133636312F36|...661/6]
  18 SequenceTest     2   23    0               00 if( cursor[2].ctr++ ) pc = 23
  19 Compare          9    1    2 k(3,B,B,B)    00 r[9..10] <-> r[1..2]
REG[9] =  i:1
REG[1] =  i:1
REG[10] =  i:1
REG[2] =  i:1
  20 Jump            21   24   21               00 
  24 SorterInsert     2    8    3 2             00 key=r[8]
REG[8] =  sx8[0311133636312F36|...661/6]
  25 Next             4    8    0               01 
   8 Column           3    0    6               00 r[6]=a.b
REG[6] =  i:1
   9 Concat           7    6    5               00 r[5]=r[6]+r[7]
REG[7] =   t1[/](8)
REG[6] =  i:1
REG[5] =   s2[1/](8)
  10 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:7
  11 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =  i:7
REG[5] =   s2[1/](8)
REG[4] =   s3[1/7](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:1
  13 Column           3    0    2               00 r[2]=a.b
REG[2] =  i:1
  14 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:7
  15 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:7
  16 Concat           5    6    3               00 r[3]=r[6]+r[5]
REG[5] =  i:7
REG[6] =  i:7
REG[3] =   s2[77](8)
  17 MakeRecord       3    2    8               00 r[8]=mkrec(r[3..4])
REG[8] =  sx8[0311133737312F37|...771/7]
  18 SequenceTest     2   23    0               00 if( cursor[2].ctr++ ) pc = 23
  19 Compare          9    1    2 k(3,B,B,B)    00 r[9..10] <-> r[1..2]
REG[9] =  i:1
REG[1] =  i:1
REG[10] =  i:1
REG[2] =  i:1
  20 Jump            21   24   21               00 
  24 SorterInsert     2    8    3 2             00 key=r[8]
REG[8] =  sx8[0311133737312F37|...771/7]
  25 Next             4    8    0               01 
   8 Column           3    0    6               00 r[6]=a.b
REG[6] =  i:1
   9 Concat           7    6    5               00 r[5]=r[6]+r[7]
REG[7] =   t1[/](8)
REG[6] =  i:1
REG[5] =   s2[1/](8)
  10 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:8
  11 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =  i:8
REG[5] =   s2[1/](8)
REG[4] =   s3[1/8](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:1
  13 Column           3    0    2               00 r[2]=a.b
REG[2] =  i:1
  14 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:8
  15 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:8
  16 Concat           5    6    3               00 r[3]=r[6]+r[5]
REG[5] =  i:8
REG[6] =  i:8
REG[3] =   s2[88](8)
  17 MakeRecord       3    2    8               00 r[8]=mkrec(r[3..4])
REG[8] =  sx8[0311133838312F38|...881/8]
  18 SequenceTest     2   23    0               00 if( cursor[2].ctr++ ) pc = 23
  19 Compare          9    1    2 k(3,B,B,B)    00 r[9..10] <-> r[1..2]
REG[9] =  i:1
REG[1] =  i:1
REG[10] =  i:1
REG[2] =  i:1
  20 Jump            21   24   21               00 
  24 SorterInsert     2    8    3 2             00 key=r[8]
REG[8] =  sx8[0311133838312F38|...881/8]
  25 Next             4    8    0               01 
   8 Column           3    0    6               00 r[6]=a.b
REG[6] =  i:1
   9 Concat           7    6    5               00 r[5]=r[6]+r[7]
REG[7] =   t1[/](8)
REG[6] =  i:1
REG[5] =   s2[1/](8)
  10 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:9
  11 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =  i:9
REG[5] =   s2[1/](8)
REG[4] =   s3[1/9](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:1
  13 Column           3    0    2               00 r[2]=a.b
REG[2] =  i:1
  14 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:9
  15 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:9
  16 Concat           5    6    3               00 r[3]=r[6]+r[5]
REG[5] =  i:9
REG[6] =  i:9
REG[3] =   s2[99](8)
  17 MakeRecord       3    2    8               00 r[8]=mkrec(r[3..4])
REG[8] =  sx8[0311133939312F39|...991/9]
  18 SequenceTest     2   23    0               00 if( cursor[2].ctr++ ) pc = 23
  19 Compare          9    1    2 k(3,B,B,B)    00 r[9..10] <-> r[1..2]
REG[9] =  i:1
REG[1] =  i:1
REG[10] =  i:1
REG[2] =  i:1
  20 Jump            21   24   21               00 
  24 SorterInsert     2    8    3 2             00 key=r[8]
REG[8] =  sx8[0311133939312F39|...991/9]
  25 Next             4    8    0               01 
  26 Next             3    6    0               01 
   6 Explain          6    0    0 SCAN TABLE a AS y USING COVERING INDEX i2 00 
   7 Rewind           4   26    1 0             00 
   8 Column           3    0    6               00 r[6]=a.b
REG[6] =  i:2
   9 Concat           7    6    5               00 r[5]=r[6]+r[7]
REG[7] =   t1[/](8)
REG[6] =  i:2
REG[5] =   s2[2/](8)
  10 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:1
  11 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =  i:1
REG[5] =   s2[2/](8)
REG[4] =   s3[2/1](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:2
  13 Column           3    0    2               00 r[2]=a.b
REG[2] =  i:2
  14 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:1
  15 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:1
  16 Concat           5    6    3               00 r[3]=r[6]+r[5]
REG[5] =  i:1
REG[6] =  i:1
REG[3] =   s2[11](8)
  17 MakeRecord       3    2    8               00 r[8]=mkrec(r[3..4])
REG[8] =  sx8[0311133131322F31|...112/1]
  18 SequenceTest     2   23    0               00 if( cursor[2].ctr++ ) pc = 23
  19 Compare          9    1    2 k(3,B,B,B)    00 r[9..10] <-> r[1..2]
REG[9] =  i:1
REG[1] =  i:2
  20 Jump            21   24   21               00 
  21 Gosub           11   30    0               00 
REG[11] =  i:21
  30 Once             0   32    0               00 
  31 OpenPseudo       5   12    3               00 3 columns in r[12]
  32 SorterSort       2   38    0               00 
  33 SorterData       2   12    5               00 r[12]=data
  34 Column           5    1    4               00 r[4]=x.b || '/' || y.b
REG[4] =   s3[1/1](8)
  35 ResultRow        4    1    0               00 output=r[4]
REG[4] =   s3[1/1](8)
  36 SorterNext       2   33    0               00 
  33 SorterData       2   12    5               00 r[12]=data
  34 Column           5    1    4               00 r[4]=x.b || '/' || y.b
REG[4] =   s3[1/2](8)
  35 ResultRow        4    1    0               00 output=r[4]
REG[4] =   s3[1/2](8)
  36 SorterNext       2   33    0               00 
  33 SorterData       2   12    5               00 r[12]=data
  34 Column           5    1    4               00 r[4]=x.b || '/' || y.b
REG[4] =   s3[1/3](8)
  35 ResultRow        4    1    0               00 output=r[4]
REG[4] =   s3[1/3](8)
  36 SorterNext       2   33    0               00 
  33 SorterData       2   12    5               00 r[12]=data
  34 Column           5    1    4               00 r[4]=x.b || '/' || y.b
REG[4] =   s3[1/4](8)
  35 ResultRow        4    1    0               00 output=r[4]
REG[4] =   s3[1/4](8)
  36 SorterNext       2   33    0               00 
  33 SorterData       2   12    5               00 r[12]=data
  34 Column           5    1    4               00 r[4]=x.b || '/' || y.b
REG[4] =   s3[1/5](8)
  35 ResultRow        4    1    0               00 output=r[4]
REG[4] =   s3[1/5](8)
  36 SorterNext       2   33    0               00 
  33 SorterData       2   12    5               00 r[12]=data
  34 Column           5    1    4               00 r[4]=x.b || '/' || y.b
REG[4] =   s3[1/6](8)
  35 ResultRow        4    1    0               00 output=r[4]
REG[4] =   s3[1/6](8)
  36 SorterNext       2   33    0               00 
  33 SorterData       2   12    5               00 r[12]=data
  34 Column           5    1    4               00 r[4]=x.b || '/' || y.b
REG[4] =   s3[1/7](8)
  35 ResultRow        4    1    0               00 output=r[4]
REG[4] =   s3[1/7](8)
  36 SorterNext       2   33    0               00 
  33 SorterData       2   12    5               00 r[12]=data
  34 Column           5    1    4               00 r[4]=x.b || '/' || y.b
REG[4] =   s3[1/8](8)
  35 ResultRow        4    1    0               00 output=r[4]
REG[4] =   s3[1/8](8)
  36 SorterNext       2   33    0               00 
  33 SorterData       2   12    5               00 r[12]=data
  34 Column           5    1    4               00 r[4]=x.b || '/' || y.b
REG[4] =   s3[1/9](8)
  35 ResultRow        4    1    0               00 output=r[4]
REG[4] =   s3[1/9](8)
  36 SorterNext       2   33    0               00 
  37 Return          11    0    0               00 
REG[11] =  i:21
  22 ResetSorter      2    0    0               00 
  23 Move             1    9    2               00 r[9..10]=r[1..2]
REG[9] =  i:2
REG[10] =  i:2
  24 SorterInsert     2    8    3 2             00 key=r[8]
REG[8] =  sx8[0311133131322F31|...112/1]
  25 Next             4    8    0               01 
   8 Column           3    0    6               00 r[6]=a.b
REG[6] =  i:2
   9 Concat           7    6    5               00 r[5]=r[6]+r[7]
REG[7] =   t1[/](8)
REG[6] =  i:2
REG[5] =   s2[2/](8)
  10 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:2
  11 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =  i:2
REG[5] =   s2[2/](8)
REG[4] =   s3[2/2](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:2
  13 Column           3    0    2               00 r[2]=a.b
REG[2] =  i:2
  14 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:2
  15 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:2
  16 Concat           5    6    3               00 r[3]=r[6]+r[5]
REG[5] =  i:2
REG[6] =  i:2
REG[3] =   s2[22](8)
  17 MakeRecord       3    2    8               00 r[8]=mkrec(r[3..4])
REG[8] =  sx8[0311133232322F32|...222/2]
  18 SequenceTest     2   23    0               00 if( cursor[2].ctr++ ) pc = 23
  19 Compare          9    1    2 k(3,B,B,B)    00 r[9..10] <-> r[1..2]
REG[9] =  i:2
REG[1] =  i:2
REG[10] =  i:2
REG[2] =  i:2
  20 Jump            21   24   21               00 
  24 SorterInsert     2    8    3 2             00 key=r[8]
REG[8] =  sx8[0311133232322F32|...222/2]
  25 Next             4    8    0               01 
   8 Column           3    0    6               00 r[6]=a.b
REG[6] =  i:2
   9 Concat           7    6    5               00 r[5]=r[6]+r[7]
REG[7] =   t1[/](8)
REG[6] =  i:2
REG[5] =   s2[2/](8)
  10 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:3
  11 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =  i:3
REG[5] =   s2[2/](8)
REG[4] =   s3[2/3](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:2
  13 Column           3    0    2               00 r[2]=a.b
REG[2] =  i:2
  14 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:3
  15 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:3
  16 Concat           5    6    3               00 r[3]=r[6]+r[5]
REG[5] =  i:3
REG[6] =  i:3
REG[3] =   s2[33](8)
  17 MakeRecord       3    2    8               00 r[8]=mkrec(r[3..4])
REG[8] =  sx8[0311133333322F33|...332/3]
  18 SequenceTest     2   23    0               00 if( cursor[2].ctr++ ) pc = 23
  19 Compare          9    1    2 k(3,B,B,B)    00 r[9..10] <-> r[1..2]
REG[9] =  i:2
REG[1] =  i:2
REG[10] =  i:2
REG[2] =  i:2
  20 Jump            21   24   21               00 
  24 SorterInsert     2    8    3 2             00 key=r[8]
REG[8] =  sx8[0311133333322F33|...332/3]
  25 Next             4    8    0               01 
   8 Column           3    0    6               00 r[6]=a.b
REG[6] =  i:2
   9 Concat           7    6    5               00 r[5]=r[6]+r[7]
REG[7] =   t1[/](8)
REG[6] =  i:2
REG[5] =   s2[2/](8)
  10 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:4
  11 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =  i:4
REG[5] =   s2[2/](8)
REG[4] =   s3[2/4](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:2
  13 Column           3    0    2               00 r[2]=a.b
REG[2] =  i:2
  14 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:4
  15 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:4
  16 Concat           5    6    3               00 r[3]=r[6]+r[5]
REG[5] =  i:4
REG[6] =  i:4
REG[3] =   s2[44](8)
  17 MakeRecord       3    2    8               00 r[8]=mkrec(r[3..4])
REG[8] =  sx8[0311133434322F34|...442/4]
  18 SequenceTest     2   23    0               00 if( cursor[2].ctr++ ) pc = 23
  19 Compare          9    1    2 k(3,B,B,B)    00 r[9..10] <-> r[1..2]
REG[9] =  i:2
REG[1] =  i:2
REG[10] =  i:2
REG[2] =  i:2
  20 Jump            21   24   21               00 
  24 SorterInsert     2    8    3 2             00 key=r[8]
REG[8] =  sx8[0311133434322F34|...442/4]
  25 Next             4    8    0               01 
   8 Column           3    0    6               00 r[6]=a.b
REG[6] =  i:2
   9 Concat           7    6    5               00 r[5]=r[6]+r[7]
REG[7] =   t1[/](8)
REG[6] =  i:2
REG[5] =   s2[2/](8)
  10 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:5
  11 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =  i:5
REG[5] =   s2[2/](8)
REG[4] =   s3[2/5](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:2
  13 Column           3    0    2               00 r[2]=a.b
REG[2] =  i:2
  14 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:5
  15 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:5
  16 Concat           5    6    3               00 r[3]=r[6]+r[5]
REG[5] =  i:5
REG[6] =  i:5
REG[3] =   s2[55](8)
  17 MakeRecord       3    2    8               00 r[8]=mkrec(r[3..4])
REG[8] =  sx8[0311133535322F35|...552/5]
  18 SequenceTest     2   23    0               00 if( cursor[2].ctr++ ) pc = 23
  19 Compare          9    1    2 k(3,B,B,B)    00 r[9..10] <-> r[1..2]
REG[9] =  i:2
REG[1] =  i:2
REG[10] =  i:2
REG[2] =  i:2
  20 Jump            21   24   21               00 
  24 SorterInsert     2    8    3 2             00 key=r[8]
REG[8] =  sx8[0311133535322F35|...552/5]
  25 Next             4    8    0               01 
   8 Column           3    0    6               00 r[6]=a.b
REG[6] =  i:2
   9 Concat           7    6    5               00 r[5]=r[6]+r[7]
REG[7] =   t1[/](8)
REG[6] =  i:2
REG[5] =   s2[2/](8)
  10 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:6
  11 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =  i:6
REG[5] =   s2[2/](8)
REG[4] =   s3[2/6](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:2
  13 Column           3    0    2               00 r[2]=a.b
REG[2] =  i:2
  14 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:6
  15 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:6
  16 Concat           5    6    3               00 r[3]=r[6]+r[5]
REG[5] =  i:6
REG[6] =  i:6
REG[3] =   s2[66](8)
  17 MakeRecord       3    2    8               00 r[8]=mkrec(r[3..4])
REG[8] =  sx8[0311133636322F36|...662/6]
  18 SequenceTest     2   23    0               00 if( cursor[2].ctr++ ) pc = 23
  19 Compare          9    1    2 k(3,B,B,B)    00 r[9..10] <-> r[1..2]
REG[9] =  i:2
REG[1] =  i:2
REG[10] =  i:2
REG[2] =  i:2
  20 Jump            21   24   21               00 
  24 SorterInsert     2    8    3 2             00 key=r[8]
REG[8] =  sx8[0311133636322F36|...662/6]
  25 Next             4    8    0               01 
   8 Column           3    0    6               00 r[6]=a.b
REG[6] =  i:2
   9 Concat           7    6    5               00 r[5]=r[6]+r[7]
REG[7] =   t1[/](8)
REG[6] =  i:2
REG[5] =   s2[2/](8)
  10 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:7
  11 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =  i:7
REG[5] =   s2[2/](8)
REG[4] =   s3[2/7](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:2
  13 Column           3    0    2               00 r[2]=a.b
REG[2] =  i:2
  14 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:7
  15 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:7
  16 Concat           5    6    3               00 r[3]=r[6]+r[5]
REG[5] =  i:7
REG[6] =  i:7
REG[3] =   s2[77](8)
  17 MakeRecord       3    2    8               00 r[8]=mkrec(r[3..4])
REG[8] =  sx8[0311133737322F37|...772/7]
  18 SequenceTest     2   23    0               00 if( cursor[2].ctr++ ) pc = 23
  19 Compare          9    1    2 k(3,B,B,B)    00 r[9..10] <-> r[1..2]
REG[9] =  i:2
REG[1] =  i:2
REG[10] =  i:2
REG[2] =  i:2
  20 Jump            21   24   21               00 
  24 SorterInsert     2    8    3 2             00 key=r[8]
REG[8] =  sx8[0311133737322F37|...772/7]
  25 Next             4    8    0               01 
   8 Column           3    0    6               00 r[6]=a.b
REG[6] =  i:2
   9 Concat           7    6    5               00 r[5]=r[6]+r[7]
REG[7] =   t1[/](8)
REG[6] =  i:2
REG[5] =   s2[2/](8)
  10 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:8
  11 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =  i:8
REG[5] =   s2[2/](8)
REG[4] =   s3[2/8](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:2
  13 Column           3    0    2               00 r[2]=a.b
REG[2] =  i:2
  14 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:8
  15 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:8
  16 Concat           5    6    3               00 r[3]=r[6]+r[5]
REG[5] =  i:8
REG[6] =  i:8
REG[3] =   s2[88](8)
  17 MakeRecord       3    2    8               00 r[8]=mkrec(r[3..4])
REG[8] =  sx8[0311133838322F38|...882/8]
  18 SequenceTest     2   23    0               00 if( cursor[2].ctr++ ) pc = 23
  19 Compare          9    1    2 k(3,B,B,B)    00 r[9..10] <-> r[1..2]
REG[9] =  i:2
REG[1] =  i:2
REG[10] =  i:2
REG[2] =  i:2
  20 Jump            21   24   21               00 
  24 SorterInsert     2    8    3 2             00 key=r[8]
REG[8] =  sx8[0311133838322F38|...882/8]
  25 Next             4    8    0               01 
   8 Column           3    0    6               00 r[6]=a.b
REG[6] =  i:2
   9 Concat           7    6    5               00 r[5]=r[6]+r[7]
REG[7] =   t1[/](8)
REG[6] =  i:2
REG[5] =   s2[2/](8)
  10 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:9
  11 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =  i:9
REG[5] =   s2[2/](8)
REG[4] =   s3[2/9](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:2
  13 Column           3    0    2               00 r[2]=a.b
REG[2] =  i:2
  14 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:9
  15 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:9
  16 Concat           5    6    3               00 r[3]=r[6]+r[5]
REG[5] =  i:9
REG[6] =  i:9
REG[3] =   s2[99](8)
  17 MakeRecord       3    2    8               00 r[8]=mkrec(r[3..4])
REG[8] =  sx8[0311133939322F39|...992/9]
  18 SequenceTest     2   23    0               00 if( cursor[2].ctr++ ) pc = 23
  19 Compare          9    1    2 k(3,B,B,B)    00 r[9..10] <-> r[1..2]
REG[9] =  i:2
REG[1] =  i:2
REG[10] =  i:2
REG[2] =  i:2
  20 Jump            21   24   21               00 
  24 SorterInsert     2    8    3 2             00 key=r[8]
REG[8] =  sx8[0311133939322F39|...992/9]
  25 Next             4    8    0               01 
  26 Next             3    6    0               01 
   6 Explain          6    0    0 SCAN TABLE a AS y USING COVERING INDEX i2 00 
   7 Rewind           4   26    1 0             00 
   8 Column           3    0    6               00 r[6]=a.b
REG[6] =  i:3
   9 Concat           7    6    5               00 r[5]=r[6]+r[7]
REG[7] =   t1[/](8)
REG[6] =  i:3
REG[5] =   s2[3/](8)
  10 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:1
  11 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =  i:1
REG[5] =   s2[3/](8)
REG[4] =   s3[3/1](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:3
  13 Column           3    0    2               00 r[2]=a.b
REG[2] =  i:3
  14 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:1
  15 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:1
  16 Concat           5    6    3               00 r[3]=r[6]+r[5]
REG[5] =  i:1
REG[6] =  i:1
REG[3] =   s2[11](8)
  17 MakeRecord       3    2    8               00 r[8]=mkrec(r[3..4])
REG[8] =  sx8[0311133131332F31|...113/1]
  18 SequenceTest     2   23    0               00 if( cursor[2].ctr++ ) pc = 23
  19 Compare          9    1    2 k(3,B,B,B)    00 r[9..10] <-> r[1..2]
REG[9] =  i:2
REG[1] =  i:3
  20 Jump            21   24   21               00 
  21 Gosub           11   30    0               00 
REG[11] =  i:21
  30 Once             1   32    0               00 
  32 SorterSort       2   38    0               00 
  33 SorterData       2   12    5               00 r[12]=data
  34 Column           5    1    4               00 r[4]=x.b || '/' || y.b
REG[4] =   s3[2/1](8)
  35 ResultRow        4    1    0               00 output=r[4]
REG[4] =   s3[2/1](8)
  36 SorterNext       2   33    0               00 
  33 SorterData       2   12    5               00 r[12]=data
  34 Column           5    1    4               00 r[4]=x.b || '/' || y.b
REG[4] =   s3[2/2](8)
  35 ResultRow        4    1    0               00 output=r[4]
REG[4] =   s3[2/2](8)
  36 SorterNext       2   33    0               00 
  33 SorterData       2   12    5               00 r[12]=data
  34 Column           5    1    4               00 r[4]=x.b || '/' || y.b
REG[4] =   s3[2/3](8)
  35 ResultRow        4    1    0               00 output=r[4]
REG[4] =   s3[2/3](8)
  36 SorterNext       2   33    0               00 
  33 SorterData       2   12    5               00 r[12]=data
  34 Column           5    1    4               00 r[4]=x.b || '/' || y.b
REG[4] =   s3[2/4](8)
  35 ResultRow        4    1    0               00 output=r[4]
REG[4] =   s3[2/4](8)
  36 SorterNext       2   33    0               00 
  33 SorterData       2   12    5               00 r[12]=data
  34 Column           5    1    4               00 r[4]=x.b || '/' || y.b
REG[4] =   s3[2/5](8)
  35 ResultRow        4    1    0               00 output=r[4]
REG[4] =   s3[2/5](8)
  36 SorterNext       2   33    0               00 
  33 SorterData       2   12    5               00 r[12]=data
  34 Column           5    1    4               00 r[4]=x.b || '/' || y.b
REG[4] =   s3[2/6](8)
  35 ResultRow        4    1    0               00 output=r[4]
REG[4] =   s3[2/6](8)
  36 SorterNext       2   33    0               00 
  33 SorterData       2   12    5               00 r[12]=data
  34 Column           5    1    4               00 r[4]=x.b || '/' || y.b
REG[4] =   s3[2/7](8)
  35 ResultRow        4    1    0               00 output=r[4]
REG[4] =   s3[2/7](8)
  36 SorterNext       2   33    0               00 
  33 SorterData       2   12    5               00 r[12]=data
  34 Column           5    1    4               00 r[4]=x.b || '/' || y.b
REG[4] =   s3[2/8](8)
  35 ResultRow        4    1    0               00 output=r[4]
REG[4] =   s3[2/8](8)
  36 SorterNext       2   33    0               00 
  33 SorterData       2   12    5               00 r[12]=data
  34 Column           5    1    4               00 r[4]=x.b || '/' || y.b
REG[4] =   s3[2/9](8)
  35 ResultRow        4    1    0               00 output=r[4]
REG[4] =   s3[2/9](8)
  36 SorterNext       2   33    0               00 
  37 Return          11    0    0               00 
REG[11] =  i:21
  22 ResetSorter      2    0    0               00 
  23 Move             1    9    2               00 r[9..10]=r[1..2]
REG[9] =  i:3
REG[10] =  i:3
  24 SorterInsert     2    8    3 2             00 key=r[8]
REG[8] =  sx8[0311133131332F31|...113/1]
  25 Next             4    8    0               01 
   8 Column           3    0    6               00 r[6]=a.b
REG[6] =  i:3
   9 Concat           7    6    5               00 r[5]=r[6]+r[7]
REG[7] =   t1[/](8)
REG[6] =  i:3
REG[5] =   s2[3/](8)
  10 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:2
  11 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =  i:2
REG[5] =   s2[3/](8)
REG[4] =   s3[3/2](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:3
  13 Column           3    0    2               00 r[2]=a.b
REG[2] =  i:3
  14 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:2
  15 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:2
  16 Concat           5    6    3               00 r[3]=r[6]+r[5]
REG[5] =  i:2
REG[6] =  i:2
REG[3] =   s2[22](8)
  17 MakeRecord       3    2    8               00 r[8]=mkrec(r[3..4])
REG[8] =  sx8[0311133232332F32|...223/2]
  18 SequenceTest     2   23    0               00 if( cursor[2].ctr++ ) pc = 23
  19 Compare          9    1    2 k(3,B,B,B)    00 r[9..10] <-> r[1..2]
REG[9] =  i:3
REG[1] =  i:3
REG[10] =  i:3
REG[2] =  i:3
  20 Jump            21   24   21               00 
  24 SorterInsert     2    8    3 2             00 key=r[8]
REG[8] =  sx8[0311133232332F32|...223/2]
  25 Next             4    8    0               01 
   8 Column           3    0    6               00 r[6]=a.b
REG[6] =  i:3
   9 Concat           7    6    5               00 r[5]=r[6]+r[7]
REG[7] =   t1[/](8)
REG[6] =  i:3
REG[5] =   s2[3/](8)
  10 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:3
  11 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =  i:3
REG[5] =   s2[3/](8)
REG[4] =   s3[3/3](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:3
  13 Column           3    0    2               00 r[2]=a.b
REG[2] =  i:3
  14 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:3
  15 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:3
  16 Concat           5    6    3               00 r[3]=r[6]+r[5]
REG[5] =  i:3
REG[6] =  i:3
REG[3] =   s2[33](8)
  17 MakeRecord       3    2    8               00 r[8]=mkrec(r[3..4])
REG[8] =  sx8[0311133333332F33|...333/3]
  18 SequenceTest     2   23    0               00 if( cursor[2].ctr++ ) pc = 23
  19 Compare          9    1    2 k(3,B,B,B)    00 r[9..10] <-> r[1..2]
REG[9] =  i:3
REG[1] =  i:3
REG[10] =  i:3
REG[2] =  i:3
  20 Jump            21   24   21               00 
  24 SorterInsert     2    8    3 2             00 key=r[8]
REG[8] =  sx8[0311133333332F33|...333/3]
  25 Next             4    8    0               01 
   8 Column           3    0    6               00 r[6]=a.b
REG[6] =  i:3
   9 Concat           7    6    5               00 r[5]=r[6]+r[7]
REG[7] =   t1[/](8)
REG[6] =  i:3
REG[5] =   s2[3/](8)
  10 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:4
  11 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =  i:4
REG[5] =   s2[3/](8)
REG[4] =   s3[3/4](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:3
  13 Column           3    0    2               00 r[2]=a.b
REG[2] =  i:3
  14 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:4
  15 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:4
  16 Concat           5    6    3               00 r[3]=r[6]+r[5]
REG[5] =  i:4
REG[6] =  i:4
REG[3] =   s2[44](8)
  17 MakeRecord       3    2    8               00 r[8]=mkrec(r[3..4])
REG[8] =  sx8[0311133434332F34|...443/4]
  18 SequenceTest     2   23    0               00 if( cursor[2].ctr++ ) pc = 23
  19 Compare          9    1    2 k(3,B,B,B)    00 r[9..10] <-> r[1..2]
REG[9] =  i:3
REG[1] =  i:3
REG[10] =  i:3
REG[2] =  i:3
  20 Jump            21   24   21               00 
  24 SorterInsert     2    8    3 2             00 key=r[8]
REG[8] =  sx8[0311133434332F34|...443/4]
  25 Next             4    8    0               01 
   8 Column           3    0    6               00 r[6]=a.b
REG[6] =  i:3
   9 Concat           7    6    5               00 r[5]=r[6]+r[7]
REG[7] =   t1[/](8)
REG[6] =  i:3
REG[5] =   s2[3/](8)
  10 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:5
  11 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =  i:5
REG[5] =   s2[3/](8)
REG[4] =   s3[3/5](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:3
  13 Column           3    0    2               00 r[2]=a.b
REG[2] =  i:3
  14 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:5
  15 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:5
  16 Concat           5    6    3               00 r[3]=r[6]+r[5]
REG[5] =  i:5
REG[6] =  i:5
REG[3] =   s2[55](8)
  17 MakeRecord       3    2    8               00 r[8]=mkrec(r[3..4])
REG[8] =  sx8[0311133535332F35|...553/5]
  18 SequenceTest     2   23    0               00 if( cursor[2].ctr++ ) pc = 23
  19 Compare          9    1    2 k(3,B,B,B)    00 r[9..10] <-> r[1..2]
REG[9] =  i:3
REG[1] =  i:3
REG[10] =  i:3
REG[2] =  i:3
  20 Jump            21   24   21               00 
  24 SorterInsert     2    8    3 2             00 key=r[8]
REG[8] =  sx8[0311133535332F35|...553/5]
  25 Next             4    8    0               01 
   8 Column           3    0    6               00 r[6]=a.b
REG[6] =  i:3
   9 Concat           7    6    5               00 r[5]=r[6]+r[7]
REG[7] =   t1[/](8)
REG[6] =  i:3
REG[5] =   s2[3/](8)
  10 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:6
  11 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =  i:6
REG[5] =   s2[3/](8)
REG[4] =   s3[3/6](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:3
  13 Column           3    0    2               00 r[2]=a.b
REG[2] =  i:3
  14 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:6
  15 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:6
  16 Concat           5    6    3               00 r[3]=r[6]+r[5]
REG[5] =  i:6
REG[6] =  i:6
REG[3] =   s2[66](8)
  17 MakeRecord       3    2    8               00 r[8]=mkrec(r[3..4])
REG[8] =  sx8[0311133636332F36|...663/6]
  18 SequenceTest     2   23    0               00 if( cursor[2].ctr++ ) pc = 23
  19 Compare          9    1    2 k(3,B,B,B)    00 r[9..10] <-> r[1..2]
REG[9] =  i:3
REG[1] =  i:3
REG[10] =  i:3
REG[2] =  i:3
  20 Jump            21   24   21               00 
  24 SorterInsert     2    8    3 2             00 key=r[8]
REG[8] =  sx8[0311133636332F36|...663/6]
  25 Next             4    8    0               01 
   8 Column           3    0    6               00 r[6]=a.b
REG[6] =  i:3
   9 Concat           7    6    5               00 r[5]=r[6]+r[7]
REG[7] =   t1[/](8)
REG[6] =  i:3
REG[5] =   s2[3/](8)
  10 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:7
  11 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =  i:7
REG[5] =   s2[3/](8)
REG[4] =   s3[3/7](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:3
  13 Column           3    0    2               00 r[2]=a.b
REG[2] =  i:3
  14 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:7
  15 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:7
  16 Concat           5    6    3               00 r[3]=r[6]+r[5]
REG[5] =  i:7
REG[6] =  i:7
REG[3] =   s2[77](8)
  17 MakeRecord       3    2    8               00 r[8]=mkrec(r[3..4])
REG[8] =  sx8[0311133737332F37|...773/7]
  18 SequenceTest     2   23    0               00 if( cursor[2].ctr++ ) pc = 23
  19 Compare          9    1    2 k(3,B,B,B)    00 r[9..10] <-> r[1..2]
REG[9] =  i:3
REG[1] =  i:3
REG[10] =  i:3
REG[2] =  i:3
  20 Jump            21   24   21               00 
  24 SorterInsert     2    8    3 2             00 key=r[8]
REG[8] =  sx8[0311133737332F37|...773/7]
  25 Next             4    8    0               01 
   8 Column           3    0    6               00 r[6]=a.b
REG[6] =  i:3
   9 Concat           7    6    5               00 r[5]=r[6]+r[7]
REG[7] =   t1[/](8)
REG[6] =  i:3
REG[5] =   s2[3/](8)
  10 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:8
  11 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =  i:8
REG[5] =   s2[3/](8)
REG[4] =   s3[3/8](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:3
  13 Column           3    0    2               00 r[2]=a.b
REG[2] =  i:3
  14 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:8
  15 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:8
  16 Concat           5    6    3               00 r[3]=r[6]+r[5]
REG[5] =  i:8
REG[6] =  i:8
REG[3] =   s2[88](8)
  17 MakeRecord       3    2    8               00 r[8]=mkrec(r[3..4])
REG[8] =  sx8[0311133838332F38|...883/8]
  18 SequenceTest     2   23    0               00 if( cursor[2].ctr++ ) pc = 23
  19 Compare          9    1    2 k(3,B,B,B)    00 r[9..10] <-> r[1..2]
REG[9] =  i:3
REG[1] =  i:3
REG[10] =  i:3
REG[2] =  i:3
  20 Jump            21   24   21               00 
  24 SorterInsert     2    8    3 2             00 key=r[8]
REG[8] =  sx8[0311133838332F38|...883/8]
  25 Next             4    8    0               01 
   8 Column           3    0    6               00 r[6]=a.b
REG[6] =  i:3
   9 Concat           7    6    5               00 r[5]=r[6]+r[7]
REG[7] =   t1[/](8)
REG[6] =  i:3
REG[5] =   s2[3/](8)
  10 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:9
  11 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =  i:9
REG[5] =   s2[3/](8)
REG[4] =   s3[3/9](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:3
  13 Column           3    0    2               00 r[2]=a.b
REG[2] =  i:3
  14 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:9
  15 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:9
  16 Concat           5    6    3               00 r[3]=r[6]+r[5]
REG[5] =  i:9
REG[6] =  i:9
REG[3] =   s2[99](8)
  17 MakeRecord       3    2    8               00 r[8]=mkrec(r[3..4])
REG[8] =  sx8[0311133939332F39|...993/9]
  18 SequenceTest     2   23    0               00 if( cursor[2].ctr++ ) pc = 23
  19 Compare          9    1    2 k(3,B,B,B)    00 r[9..10] <-> r[1..2]
REG[9] =  i:3
REG[1] =  i:3
REG[10] =  i:3
REG[2] =  i:3
  20 Jump            21   24   21               00 
  24 SorterInsert     2    8    3 2             00 key=r[8]
REG[8] =  sx8[0311133939332F39|...993/9]
  25 Next             4    8    0               01 
  26 Next             3    6    0               01 
   6 Explain          6    0    0 SCAN TABLE a AS y USING COVERING INDEX i2 00 
   7 Rewind           4   26    1 0             00 
   8 Column           3    0    6               00 r[6]=a.b
REG[6] =  i:4
   9 Concat           7    6    5               00 r[5]=r[6]+r[7]
REG[7] =   t1[/](8)
REG[6] =  i:4
REG[5] =   s2[4/](8)
  10 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:1
  11 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =  i:1
REG[5] =   s2[4/](8)
REG[4] =   s3[4/1](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:4
  13 Column           3    0    2               00 r[2]=a.b
REG[2] =  i:4
  14 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:1
  15 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:1
  16 Concat           5    6    3               00 r[3]=r[6]+r[5]
REG[5] =  i:1
REG[6] =  i:1
REG[3] =   s2[11](8)
  17 MakeRecord       3    2    8               00 r[8]=mkrec(r[3..4])
REG[8] =  sx8[0311133131342F31|...114/1]
  18 SequenceTest     2   23    0               00 if( cursor[2].ctr++ ) pc = 23
  19 Compare          9    1    2 k(3,B,B,B)    00 r[9..10] <-> r[1..2]
REG[9] =  i:3
REG[1] =  i:4
  20 Jump            21   24   21               00 
  21 Gosub           11   30    0               00 
REG[11] =  i:21
  30 Once             1   32    0               00 
  32 SorterSort       2   38    0               00 
  33 SorterData       2   12    5               00 r[12]=data
  34 Column           5    1    4               00 r[4]=x.b || '/' || y.b
REG[4] =   s3[3/1](8)
  35 ResultRow        4    1    0               00 output=r[4]
REG[4] =   s3[3/1](8)
  36 SorterNext       2   33    0               00 
  33 SorterData       2   12    5               00 r[12]=data
  34 Column           5    1    4               00 r[4]=x.b || '/' || y.b
REG[4] =   s3[3/2](8)
  35 ResultRow        4    1    0               00 output=r[4]
REG[4] =   s3[3/2](8)
  36 SorterNext       2   33    0               00 
  33 SorterData       2   12    5               00 r[12]=data
  34 Column           5    1    4               00 r[4]=x.b || '/' || y.b
REG[4] =   s3[3/3](8)
  35 ResultRow        4    1    0               00 output=r[4]
REG[4] =   s3[3/3](8)
  36 SorterNext       2   33    0               00 
  33 SorterData       2   12    5               00 r[12]=data
  34 Column           5    1    4               00 r[4]=x.b || '/' || y.b
REG[4] =   s3[3/4](8)
  35 ResultRow        4    1    0               00 output=r[4]
REG[4] =   s3[3/4](8)
  36 SorterNext       2   33    0               00 
  33 SorterData       2   12    5               00 r[12]=data
  34 Column           5    1    4               00 r[4]=x.b || '/' || y.b
REG[4] =   s3[3/5](8)
  35 ResultRow        4    1    0               00 output=r[4]
REG[4] =   s3[3/5](8)
  36 SorterNext       2   33    0               00 
  33 SorterData       2   12    5               00 r[12]=data
  34 Column           5    1    4               00 r[4]=x.b || '/' || y.b
REG[4] =   s3[3/6](8)
  35 ResultRow        4    1    0               00 output=r[4]
REG[4] =   s3[3/6](8)
  36 SorterNext       2   33    0               00 
  33 SorterData       2   12    5               00 r[12]=data
  34 Column           5    1    4               00 r[4]=x.b || '/' || y.b
REG[4] =   s3[3/7](8)
  35 ResultRow        4    1    0               00 output=r[4]
REG[4] =   s3[3/7](8)
  36 SorterNext       2   33    0               00 
  33 SorterData       2   12    5               00 r[12]=data
  34 Column           5    1    4               00 r[4]=x.b || '/' || y.b
REG[4] =   s3[3/8](8)
  35 ResultRow        4    1    0               00 output=r[4]
REG[4] =   s3[3/8](8)
  36 SorterNext       2   33    0               00 
  33 SorterData       2   12    5               00 r[12]=data
  34 Column           5    1    4               00 r[4]=x.b || '/' || y.b
REG[4] =   s3[3/9](8)
  35 ResultRow        4    1    0               00 output=r[4]
REG[4] =   s3[3/9](8)
  36 SorterNext       2   33    0               00 
  37 Return          11    0    0               00 
REG[11] =  i:21
  22 ResetSorter      2    0    0               00 
  23 Move             1    9    2               00 r[9..10]=r[1..2]
REG[9] =  i:4
REG[10] =  i:4
  24 SorterInsert     2    8    3 2             00 key=r[8]
REG[8] =  sx8[0311133131342F31|...114/1]
  25 Next             4    8    0               01 
   8 Column           3    0    6               00 r[6]=a.b
REG[6] =  i:4
   9 Concat           7    6    5               00 r[5]=r[6]+r[7]
REG[7] =   t1[/](8)
REG[6] =  i:4
REG[5] =   s2[4/](8)
  10 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:2
  11 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =  i:2
REG[5] =   s2[4/](8)
REG[4] =   s3[4/2](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:4
  13 Column           3    0    2               00 r[2]=a.b
REG[2] =  i:4
  14 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:2
  15 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:2
  16 Concat           5    6    3               00 r[3]=r[6]+r[5]
REG[5] =  i:2
REG[6] =  i:2
REG[3] =   s2[22](8)
  17 MakeRecord       3    2    8               00 r[8]=mkrec(r[3..4])
REG[8] =  sx8[0311133232342F32|...224/2]
  18 SequenceTest     2   23    0               00 if( cursor[2].ctr++ ) pc = 23
  19 Compare          9    1    2 k(3,B,B,B)    00 r[9..10] <-> r[1..2]
REG[9] =  i:4
REG[1] =  i:4
REG[10] =  i:4
REG[2] =  i:4
  20 Jump            21   24   21               00 
  24 SorterInsert     2    8    3 2             00 key=r[8]
REG[8] =  sx8[0311133232342F32|...224/2]
  25 Next             4    8    0               01 
   8 Column           3    0    6               00 r[6]=a.b
REG[6] =  i:4
   9 Concat           7    6    5               00 r[5]=r[6]+r[7]
REG[7] =   t1[/](8)
REG[6] =  i:4
REG[5] =   s2[4/](8)
  10 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:3
  11 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =  i:3
REG[5] =   s2[4/](8)
REG[4] =   s3[4/3](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:4
  13 Column           3    0    2               00 r[2]=a.b
REG[2] =  i:4
  14 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:3
  15 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:3
  16 Concat           5    6    3               00 r[3]=r[6]+r[5]
REG[5] =  i:3
REG[6] =  i:3
REG[3] =   s2[33](8)
  17 MakeRecord       3    2    8               00 r[8]=mkrec(r[3..4])
REG[8] =  sx8[0311133333342F33|...334/3]
  18 SequenceTest     2   23    0               00 if( cursor[2].ctr++ ) pc = 23
  19 Compare          9    1    2 k(3,B,B,B)    00 r[9..10] <-> r[1..2]
REG[9] =  i:4
REG[1] =  i:4
REG[10] =  i:4
REG[2] =  i:4
  20 Jump            21   24   21               00 
  24 SorterInsert     2    8    3 2             00 key=r[8]
REG[8] =  sx8[0311133333342F33|...334/3]
  25 Next             4    8    0               01 
   8 Column           3    0    6               00 r[6]=a.b
REG[6] =  i:4
   9 Concat           7    6    5               00 r[5]=r[6]+r[7]
REG[7] =   t1[/](8)
REG[6] =  i:4
REG[5] =   s2[4/](8)
  10 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:4
  11 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =  i:4
REG[5] =   s2[4/](8)
REG[4] =   s3[4/4](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:4
  13 Column           3    0    2               00 r[2]=a.b
REG[2] =  i:4
  14 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:4
  15 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:4
  16 Concat           5    6    3               00 r[3]=r[6]+r[5]
REG[5] =  i:4
REG[6] =  i:4
REG[3] =   s2[44](8)
  17 MakeRecord       3    2    8               00 r[8]=mkrec(r[3..4])
REG[8] =  sx8[0311133434342F34|...444/4]
  18 SequenceTest     2   23    0               00 if( cursor[2].ctr++ ) pc = 23
  19 Compare          9    1    2 k(3,B,B,B)    00 r[9..10] <-> r[1..2]
REG[9] =  i:4
REG[1] =  i:4
REG[10] =  i:4
REG[2] =  i:4
  20 Jump            21   24   21               00 
  24 SorterInsert     2    8    3 2             00 key=r[8]
REG[8] =  sx8[0311133434342F34|...444/4]
  25 Next             4    8    0               01 
   8 Column           3    0    6               00 r[6]=a.b
REG[6] =  i:4
   9 Concat           7    6    5               00 r[5]=r[6]+r[7]
REG[7] =   t1[/](8)
REG[6] =  i:4
REG[5] =   s2[4/](8)
  10 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:5
  11 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =  i:5
REG[5] =   s2[4/](8)
REG[4] =   s3[4/5](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:4
  13 Column           3    0    2               00 r[2]=a.b
REG[2] =  i:4
  14 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:5
  15 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:5
  16 Concat           5    6    3               00 r[3]=r[6]+r[5]
REG[5] =  i:5
REG[6] =  i:5
REG[3] =   s2[55](8)
  17 MakeRecord       3    2    8               00 r[8]=mkrec(r[3..4])
REG[8] =  sx8[0311133535342F35|...554/5]
  18 SequenceTest     2   23    0               00 if( cursor[2].ctr++ ) pc = 23
  19 Compare          9    1    2 k(3,B,B,B)    00 r[9..10] <-> r[1..2]
REG[9] =  i:4
REG[1] =  i:4
REG[10] =  i:4
REG[2] =  i:4
  20 Jump            21   24   21               00 
  24 SorterInsert     2    8    3 2             00 key=r[8]
REG[8] =  sx8[0311133535342F35|...554/5]
  25 Next             4    8    0               01 
   8 Column           3    0    6               00 r[6]=a.b
REG[6] =  i:4
   9 Concat           7    6    5               00 r[5]=r[6]+r[7]
REG[7] =   t1[/](8)
REG[6] =  i:4
REG[5] =   s2[4/](8)
  10 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:6
  11 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =  i:6
REG[5] =   s2[4/](8)
REG[4] =   s3[4/6](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:4
  13 Column           3    0    2               00 r[2]=a.b
REG[2] =  i:4
  14 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:6
  15 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:6
  16 Concat           5    6    3               00 r[3]=r[6]+r[5]
REG[5] =  i:6
REG[6] =  i:6
REG[3] =   s2[66](8)
  17 MakeRecord       3    2    8               00 r[8]=mkrec(r[3..4])
REG[8] =  sx8[0311133636342F36|...664/6]
  18 SequenceTest     2   23    0               00 if( cursor[2].ctr++ ) pc = 23
  19 Compare          9    1    2 k(3,B,B,B)    00 r[9..10] <-> r[1..2]
REG[9] =  i:4
REG[1] =  i:4
REG[10] =  i:4
REG[2] =  i:4
  20 Jump            21   24   21               00 
  24 SorterInsert     2    8    3 2             00 key=r[8]
REG[8] =  sx8[0311133636342F36|...664/6]
  25 Next             4    8    0               01 
   8 Column           3    0    6               00 r[6]=a.b
REG[6] =  i:4
   9 Concat           7    6    5               00 r[5]=r[6]+r[7]
REG[7] =   t1[/](8)
REG[6] =  i:4
REG[5] =   s2[4/](8)
  10 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:7
  11 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =  i:7
REG[5] =   s2[4/](8)
REG[4] =   s3[4/7](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:4
  13 Column           3    0    2               00 r[2]=a.b
REG[2] =  i:4
  14 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:7
  15 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:7
  16 Concat           5    6    3               00 r[3]=r[6]+r[5]
REG[5] =  i:7
REG[6] =  i:7
REG[3] =   s2[77](8)
  17 MakeRecord       3    2    8               00 r[8]=mkrec(r[3..4])
REG[8] =  sx8[0311133737342F37|...774/7]
  18 SequenceTest     2   23    0               00 if( cursor[2].ctr++ ) pc = 23
  19 Compare          9    1    2 k(3,B,B,B)    00 r[9..10] <-> r[1..2]
REG[9] =  i:4
REG[1] =  i:4
REG[10] =  i:4
REG[2] =  i:4
  20 Jump            21   24   21               00 
  24 SorterInsert     2    8    3 2             00 key=r[8]
REG[8] =  sx8[0311133737342F37|...774/7]
  25 Next             4    8    0               01 
   8 Column           3    0    6               00 r[6]=a.b
REG[6] =  i:4
   9 Concat           7    6    5               00 r[5]=r[6]+r[7]
REG[7] =   t1[/](8)
REG[6] =  i:4
REG[5] =   s2[4/](8)
  10 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:8
  11 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =  i:8
REG[5] =   s2[4/](8)
REG[4] =   s3[4/8](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:4
  13 Column           3    0    2               00 r[2]=a.b
REG[2] =  i:4
  14 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:8
  15 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:8
  16 Concat           5    6    3               00 r[3]=r[6]+r[5]
REG[5] =  i:8
REG[6] =  i:8
REG[3] =   s2[88](8)
  17 MakeRecord       3    2    8               00 r[8]=mkrec(r[3..4])
REG[8] =  sx8[0311133838342F38|...884/8]
  18 SequenceTest     2   23    0               00 if( cursor[2].ctr++ ) pc = 23
  19 Compare          9    1    2 k(3,B,B,B)    00 r[9..10] <-> r[1..2]
REG[9] =  i:4
REG[1] =  i:4
REG[10] =  i:4
REG[2] =  i:4
  20 Jump            21   24   21               00 
  24 SorterInsert     2    8    3 2             00 key=r[8]
REG[8] =  sx8[0311133838342F38|...884/8]
  25 Next             4    8    0               01 
   8 Column           3    0    6               00 r[6]=a.b
REG[6] =  i:4
   9 Concat           7    6    5               00 r[5]=r[6]+r[7]
REG[7] =   t1[/](8)
REG[6] =  i:4
REG[5] =   s2[4/](8)
  10 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:9
  11 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =  i:9
REG[5] =   s2[4/](8)
REG[4] =   s3[4/9](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:4
  13 Column           3    0    2               00 r[2]=a.b
REG[2] =  i:4
  14 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:9
  15 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:9
  16 Concat           5    6    3               00 r[3]=r[6]+r[5]
REG[5] =  i:9
REG[6] =  i:9
REG[3] =   s2[99](8)
  17 MakeRecord       3    2    8               00 r[8]=mkrec(r[3..4])
REG[8] =  sx8[0311133939342F39|...994/9]
  18 SequenceTest     2   23    0               00 if( cursor[2].ctr++ ) pc = 23
  19 Compare          9    1    2 k(3,B,B,B)    00 r[9..10] <-> r[1..2]
REG[9] =  i:4
REG[1] =  i:4
REG[10] =  i:4
REG[2] =  i:4
  20 Jump            21   24   21               00 
  24 SorterInsert     2    8    3 2             00 key=r[8]
REG[8] =  sx8[0311133939342F39|...994/9]
  25 Next             4    8    0               01 
  26 Next             3    6    0               01 
   6 Explain          6    0    0 SCAN TABLE a AS y USING COVERING INDEX i2 00 
   7 Rewind           4   26    1 0             00 
   8 Column           3    0    6               00 r[6]=a.b
REG[6] =  i:5
   9 Concat           7    6    5               00 r[5]=r[6]+r[7]
REG[7] =   t1[/](8)
REG[6] =  i:5
REG[5] =   s2[5/](8)
  10 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:1
  11 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =  i:1
REG[5] =   s2[5/](8)
REG[4] =   s3[5/1](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:5
  13 Column           3    0    2               00 r[2]=a.b
REG[2] =  i:5
  14 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:1
  15 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:1
  16 Concat           5    6    3               00 r[3]=r[6]+r[5]
REG[5] =  i:1
REG[6] =  i:1
REG[3] =   s2[11](8)
  17 MakeRecord       3    2    8               00 r[8]=mkrec(r[3..4])
REG[8] =  sx8[0311133131352F31|...115/1]
  18 SequenceTest     2   23    0               00 if( cursor[2].ctr++ ) pc = 23
  19 Compare          9    1    2 k(3,B,B,B)    00 r[9..10] <-> r[1..2]
REG[9] =  i:4
REG[1] =  i:5
  20 Jump            21   24   21               00 
  21 Gosub           11   30    0               00 
REG[11] =  i:21
  30 Once             1   32    0               00 
  32 SorterSort       2   38    0               00 
  33 SorterData       2   12    5               00 r[12]=data
  34 Column           5    1    4               00 r[4]=x.b || '/' || y.b
REG[4] =   s3[4/1](8)
  35 ResultRow        4    1    0               00 output=r[4]
REG[4] =   s3[4/1](8)
  36 SorterNext       2   33    0               00 
  33 SorterData       2   12    5               00 r[12]=data
  34 Column           5    1    4               00 r[4]=x.b || '/' || y.b
REG[4] =   s3[4/2](8)
  35 ResultRow        4    1    0               00 output=r[4]
REG[4] =   s3[4/2](8)
  36 SorterNext       2   33    0               00 
  33 SorterData       2   12    5               00 r[12]=data
  34 Column           5    1    4               00 r[4]=x.b || '/' || y.b
REG[4] =   s3[4/3](8)
  35 ResultRow        4    1    0               00 output=r[4]
REG[4] =   s3[4/3](8)
  36 SorterNext       2   33    0               00 
  33 SorterData       2   12    5               00 r[12]=data
  34 Column           5    1    4               00 r[4]=x.b || '/' || y.b
REG[4] =   s3[4/4](8)
  35 ResultRow        4    1    0               00 output=r[4]
REG[4] =   s3[4/4](8)
  36 SorterNext       2   33    0               00 
  33 SorterData       2   12    5               00 r[12]=data
  34 Column           5    1    4               00 r[4]=x.b || '/' || y.b
REG[4] =   s3[4/5](8)
  35 ResultRow        4    1    0               00 output=r[4]
REG[4] =   s3[4/5](8)
  36 SorterNext       2   33    0               00 
  33 SorterData       2   12    5               00 r[12]=data
  34 Column           5    1    4               00 r[4]=x.b || '/' || y.b
REG[4] =   s3[4/6](8)
  35 ResultRow        4    1    0               00 output=r[4]
REG[4] =   s3[4/6](8)
  36 SorterNext       2   33    0               00 
  33 SorterData       2   12    5               00 r[12]=data
  34 Column           5    1    4               00 r[4]=x.b || '/' || y.b
REG[4] =   s3[4/7](8)
  35 ResultRow        4    1    0               00 output=r[4]
REG[4] =   s3[4/7](8)
  36 SorterNext       2   33    0               00 
  33 SorterData       2   12    5               00 r[12]=data
  34 Column           5    1    4               00 r[4]=x.b || '/' || y.b
REG[4] =   s3[4/8](8)
  35 ResultRow        4    1    0               00 output=r[4]
REG[4] =   s3[4/8](8)
  36 SorterNext       2   33    0               00 
  33 SorterData       2   12    5               00 r[12]=data
  34 Column           5    1    4               00 r[4]=x.b || '/' || y.b
REG[4] =   s3[4/9](8)
  35 ResultRow        4    1    0               00 output=r[4]
REG[4] =   s3[4/9](8)
  36 SorterNext       2   33    0               00 
  37 Return          11    0    0               00 
REG[11] =  i:21
  22 ResetSorter      2    0    0               00 
  23 Move             1    9    2               00 r[9..10]=r[1..2]
REG[9] =  i:5
REG[10] =  i:5
  24 SorterInsert     2    8    3 2             00 key=r[8]
REG[8] =  sx8[0311133131352F31|...115/1]
  25 Next             4    8    0               01 
   8 Column           3    0    6               00 r[6]=a.b
REG[6] =  i:5
   9 Concat           7    6    5               00 r[5]=r[6]+r[7]
REG[7] =   t1[/](8)
REG[6] =  i:5
REG[5] =   s2[5/](8)
  10 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:2
  11 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =  i:2
REG[5] =   s2[5/](8)
REG[4] =   s3[5/2](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:5
  13 Column           3    0    2               00 r[2]=a.b
REG[2] =  i:5
  14 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:2
  15 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:2
  16 Concat           5    6    3               00 r[3]=r[6]+r[5]
REG[5] =  i:2
REG[6] =  i:2
REG[3] =   s2[22](8)
  17 MakeRecord       3    2    8               00 r[8]=mkrec(r[3..4])
REG[8] =  sx8[0311133232352F32|...225/2]
  18 SequenceTest     2   23    0               00 if( cursor[2].ctr++ ) pc = 23
  19 Compare          9    1    2 k(3,B,B,B)    00 r[9..10] <-> r[1..2]
REG[9] =  i:5
REG[1] =  i:5
REG[10] =  i:5
REG[2] =  i:5
  20 Jump            21   24   21               00 
  24 SorterInsert     2    8    3 2             00 key=r[8]
REG[8] =  sx8[0311133232352F32|...225/2]
  25 Next             4    8    0               01 
   8 Column           3    0    6               00 r[6]=a.b
REG[6] =  i:5
   9 Concat           7    6    5               00 r[5]=r[6]+r[7]
REG[7] =   t1[/](8)
REG[6] =  i:5
REG[5] =   s2[5/](8)
  10 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:3
  11 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =  i:3
REG[5] =   s2[5/](8)
REG[4] =   s3[5/3](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:5
  13 Column           3    0    2               00 r[2]=a.b
REG[2] =  i:5
  14 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:3
  15 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:3
  16 Concat           5    6    3               00 r[3]=r[6]+r[5]
REG[5] =  i:3
REG[6] =  i:3
REG[3] =   s2[33](8)
  17 MakeRecord       3    2    8               00 r[8]=mkrec(r[3..4])
REG[8] =  sx8[0311133333352F33|...335/3]
  18 SequenceTest     2   23    0               00 if( cursor[2].ctr++ ) pc = 23
  19 Compare          9    1    2 k(3,B,B,B)    00 r[9..10] <-> r[1..2]
REG[9] =  i:5
REG[1] =  i:5
REG[10] =  i:5
REG[2] =  i:5
  20 Jump            21   24   21               00 
  24 SorterInsert     2    8    3 2             00 key=r[8]
REG[8] =  sx8[0311133333352F33|...335/3]
  25 Next             4    8    0               01 
   8 Column           3    0    6               00 r[6]=a.b
REG[6] =  i:5
   9 Concat           7    6    5               00 r[5]=r[6]+r[7]
REG[7] =   t1[/](8)
REG[6] =  i:5
REG[5] =   s2[5/](8)
  10 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:4
  11 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =  i:4
REG[5] =   s2[5/](8)
REG[4] =   s3[5/4](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:5
  13 Column           3    0    2               00 r[2]=a.b
REG[2] =  i:5
  14 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:4
  15 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:4
  16 Concat           5    6    3               00 r[3]=r[6]+r[5]
REG[5] =  i:4
REG[6] =  i:4
REG[3] =   s2[44](8)
  17 MakeRecord       3    2    8               00 r[8]=mkrec(r[3..4])
REG[8] =  sx8[0311133434352F34|...445/4]
  18 SequenceTest     2   23    0               00 if( cursor[2].ctr++ ) pc = 23
  19 Compare          9    1    2 k(3,B,B,B)    00 r[9..10] <-> r[1..2]
REG[9] =  i:5
REG[1] =  i:5
REG[10] =  i:5
REG[2] =  i:5
  20 Jump            21   24   21               00 
  24 SorterInsert     2    8    3 2             00 key=r[8]
REG[8] =  sx8[0311133434352F34|...445/4]
  25 Next             4    8    0               01 
   8 Column           3    0    6               00 r[6]=a.b
REG[6] =  i:5
   9 Concat           7    6    5               00 r[5]=r[6]+r[7]
REG[7] =   t1[/](8)
REG[6] =  i:5
REG[5] =   s2[5/](8)
  10 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:5
  11 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =  i:5
REG[5] =   s2[5/](8)
REG[4] =   s3[5/5](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:5
  13 Column           3    0    2               00 r[2]=a.b
REG[2] =  i:5
  14 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:5
  15 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:5
  16 Concat           5    6    3               00 r[3]=r[6]+r[5]
REG[5] =  i:5
REG[6] =  i:5
REG[3] =   s2[55](8)
  17 MakeRecord       3    2    8               00 r[8]=mkrec(r[3..4])
REG[8] =  sx8[0311133535352F35|...555/5]
  18 SequenceTest     2   23    0               00 if( cursor[2].ctr++ ) pc = 23
  19 Compare          9    1    2 k(3,B,B,B)    00 r[9..10] <-> r[1..2]
REG[9] =  i:5
REG[1] =  i:5
REG[10] =  i:5
REG[2] =  i:5
  20 Jump            21   24   21               00 
  24 SorterInsert     2    8    3 2             00 key=r[8]
REG[8] =  sx8[0311133535352F35|...555/5]
  25 Next             4    8    0               01 
   8 Column           3    0    6               00 r[6]=a.b
REG[6] =  i:5
   9 Concat           7    6    5               00 r[5]=r[6]+r[7]
REG[7] =   t1[/](8)
REG[6] =  i:5
REG[5] =   s2[5/](8)
  10 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:6
  11 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =  i:6
REG[5] =   s2[5/](8)
REG[4] =   s3[5/6](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:5
  13 Column           3    0    2               00 r[2]=a.b
REG[2] =  i:5
  14 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:6
  15 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:6
  16 Concat           5    6    3               00 r[3]=r[6]+r[5]
REG[5] =  i:6
REG[6] =  i:6
REG[3] =   s2[66](8)
  17 MakeRecord       3    2    8               00 r[8]=mkrec(r[3..4])
REG[8] =  sx8[0311133636352F36|...665/6]
  18 SequenceTest     2   23    0               00 if( cursor[2].ctr++ ) pc = 23
  19 Compare          9    1    2 k(3,B,B,B)    00 r[9..10] <-> r[1..2]
REG[9] =  i:5
REG[1] =  i:5
REG[10] =  i:5
REG[2] =  i:5
  20 Jump            21   24   21               00 
  24 SorterInsert     2    8    3 2             00 key=r[8]
REG[8] =  sx8[0311133636352F36|...665/6]
  25 Next             4    8    0               01 
   8 Column           3    0    6               00 r[6]=a.b
REG[6] =  i:5
   9 Concat           7    6    5               00 r[5]=r[6]+r[7]
REG[7] =   t1[/](8)
REG[6] =  i:5
REG[5] =   s2[5/](8)
  10 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:7
  11 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =  i:7
REG[5] =   s2[5/](8)
REG[4] =   s3[5/7](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:5
  13 Column           3    0    2               00 r[2]=a.b
REG[2] =  i:5
  14 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:7
  15 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:7
  16 Concat           5    6    3               00 r[3]=r[6]+r[5]
REG[5] =  i:7
REG[6] =  i:7
REG[3] =   s2[77](8)
  17 MakeRecord       3    2    8               00 r[8]=mkrec(r[3..4])
REG[8] =  sx8[0311133737352F37|...775/7]
  18 SequenceTest     2   23    0               00 if( cursor[2].ctr++ ) pc = 23
  19 Compare          9    1    2 k(3,B,B,B)    00 r[9..10] <-> r[1..2]
REG[9] =  i:5
REG[1] =  i:5
REG[10] =  i:5
REG[2] =  i:5
  20 Jump            21   24   21               00 
  24 SorterInsert     2    8    3 2             00 key=r[8]
REG[8] =  sx8[0311133737352F37|...775/7]
  25 Next             4    8    0               01 
   8 Column           3    0    6               00 r[6]=a.b
REG[6] =  i:5
   9 Concat           7    6    5               00 r[5]=r[6]+r[7]
REG[7] =   t1[/](8)
REG[6] =  i:5
REG[5] =   s2[5/](8)
  10 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:8
  11 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =  i:8
REG[5] =   s2[5/](8)
REG[4] =   s3[5/8](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:5
  13 Column           3    0    2               00 r[2]=a.b
REG[2] =  i:5
  14 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:8
  15 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:8
  16 Concat           5    6    3               00 r[3]=r[6]+r[5]
REG[5] =  i:8
REG[6] =  i:8
REG[3] =   s2[88](8)
  17 MakeRecord       3    2    8               00 r[8]=mkrec(r[3..4])
REG[8] =  sx8[0311133838352F38|...885/8]
  18 SequenceTest     2   23    0               00 if( cursor[2].ctr++ ) pc = 23
  19 Compare          9    1    2 k(3,B,B,B)    00 r[9..10] <-> r[1..2]
REG[9] =  i:5
REG[1] =  i:5
REG[10] =  i:5
REG[2] =  i:5
  20 Jump            21   24   21               00 
  24 SorterInsert     2    8    3 2             00 key=r[8]
REG[8] =  sx8[0311133838352F38|...885/8]
  25 Next             4    8    0               01 
   8 Column           3    0    6               00 r[6]=a.b
REG[6] =  i:5
   9 Concat           7    6    5               00 r[5]=r[6]+r[7]
REG[7] =   t1[/](8)
REG[6] =  i:5
REG[5] =   s2[5/](8)
  10 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:9
  11 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =  i:9
REG[5] =   s2[5/](8)
REG[4] =   s3[5/9](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:5
  13 Column           3    0    2               00 r[2]=a.b
REG[2] =  i:5
  14 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:9
  15 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:9
  16 Concat           5    6    3               00 r[3]=r[6]+r[5]
REG[5] =  i:9
REG[6] =  i:9
REG[3] =   s2[99](8)
  17 MakeRecord       3    2    8               00 r[8]=mkrec(r[3..4])
REG[8] =  sx8[0311133939352F39|...995/9]
  18 SequenceTest     2   23    0               00 if( cursor[2].ctr++ ) pc = 23
  19 Compare          9    1    2 k(3,B,B,B)    00 r[9..10] <-> r[1..2]
REG[9] =  i:5
REG[1] =  i:5
REG[10] =  i:5
REG[2] =  i:5
  20 Jump            21   24   21               00 
  24 SorterInsert     2    8    3 2             00 key=r[8]
REG[8] =  sx8[0311133939352F39|...995/9]
  25 Next             4    8    0               01 
  26 Next             3    6    0               01 
   6 Explain          6    0    0 SCAN TABLE a AS y USING COVERING INDEX i2 00 
   7 Rewind           4   26    1 0             00 
   8 Column           3    0    6               00 r[6]=a.b
REG[6] =  i:6
   9 Concat           7    6    5               00 r[5]=r[6]+r[7]
REG[7] =   t1[/](8)
REG[6] =  i:6
REG[5] =   s2[6/](8)
  10 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:1
  11 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =  i:1
REG[5] =   s2[6/](8)
REG[4] =   s3[6/1](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:6
  13 Column           3    0    2               00 r[2]=a.b
REG[2] =  i:6
  14 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:1
  15 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:1
  16 Concat           5    6    3               00 r[3]=r[6]+r[5]
REG[5] =  i:1
REG[6] =  i:1
REG[3] =   s2[11](8)
  17 MakeRecord       3    2    8               00 r[8]=mkrec(r[3..4])
REG[8] =  sx8[0311133131362F31|...116/1]
  18 SequenceTest     2   23    0               00 if( cursor[2].ctr++ ) pc = 23
  19 Compare          9    1    2 k(3,B,B,B)    00 r[9..10] <-> r[1..2]
REG[9] =  i:5
REG[1] =  i:6
  20 Jump            21   24   21               00 
  21 Gosub           11   30    0               00 
REG[11] =  i:21
  30 Once             1   32    0               00 
  32 SorterSort       2   38    0               00 
  33 SorterData       2   12    5               00 r[12]=data
  34 Column           5    1    4               00 r[4]=x.b || '/' || y.b
REG[4] =   s3[5/1](8)
  35 ResultRow        4    1    0               00 output=r[4]
REG[4] =   s3[5/1](8)
  36 SorterNext       2   33    0               00 
  33 SorterData       2   12    5               00 r[12]=data
  34 Column           5    1    4               00 r[4]=x.b || '/' || y.b
REG[4] =   s3[5/2](8)
  35 ResultRow        4    1    0               00 output=r[4]
REG[4] =   s3[5/2](8)
  36 SorterNext       2   33    0               00 
  33 SorterData       2   12    5               00 r[12]=data
  34 Column           5    1    4               00 r[4]=x.b || '/' || y.b
REG[4] =   s3[5/3](8)
  35 ResultRow        4    1    0               00 output=r[4]
REG[4] =   s3[5/3](8)
  36 SorterNext       2   33    0               00 
  33 SorterData       2   12    5               00 r[12]=data
  34 Column           5    1    4               00 r[4]=x.b || '/' || y.b
REG[4] =   s3[5/4](8)
  35 ResultRow        4    1    0               00 output=r[4]
REG[4] =   s3[5/4](8)
  36 SorterNext       2   33    0               00 
  33 SorterData       2   12    5               00 r[12]=data
  34 Column           5    1    4               00 r[4]=x.b || '/' || y.b
REG[4] =   s3[5/5](8)
  35 ResultRow        4    1    0               00 output=r[4]
REG[4] =   s3[5/5](8)
  36 SorterNext       2   33    0               00 
  33 SorterData       2   12    5               00 r[12]=data
  34 Column           5    1    4               00 r[4]=x.b || '/' || y.b
REG[4] =   s3[5/6](8)
  35 ResultRow        4    1    0               00 output=r[4]
REG[4] =   s3[5/6](8)
  36 SorterNext       2   33    0               00 
  33 SorterData       2   12    5               00 r[12]=data
  34 Column           5    1    4               00 r[4]=x.b || '/' || y.b
REG[4] =   s3[5/7](8)
  35 ResultRow        4    1    0               00 output=r[4]
REG[4] =   s3[5/7](8)
  36 SorterNext       2   33    0               00 
  33 SorterData       2   12    5               00 r[12]=data
  34 Column           5    1    4               00 r[4]=x.b || '/' || y.b
REG[4] =   s3[5/8](8)
  35 ResultRow        4    1    0               00 output=r[4]
REG[4] =   s3[5/8](8)
  36 SorterNext       2   33    0               00 
  33 SorterData       2   12    5               00 r[12]=data
  34 Column           5    1    4               00 r[4]=x.b || '/' || y.b
REG[4] =   s3[5/9](8)
  35 ResultRow        4    1    0               00 output=r[4]
REG[4] =   s3[5/9](8)
  36 SorterNext       2   33    0               00 
  37 Return          11    0    0               00 
REG[11] =  i:21
  22 ResetSorter      2    0    0               00 
  23 Move             1    9    2               00 r[9..10]=r[1..2]
REG[9] =  i:6
REG[10] =  i:6
  24 SorterInsert     2    8    3 2             00 key=r[8]
REG[8] =  sx8[0311133131362F31|...116/1]
  25 Next             4    8    0               01 
   8 Column           3    0    6               00 r[6]=a.b
REG[6] =  i:6
   9 Concat           7    6    5               00 r[5]=r[6]+r[7]
REG[7] =   t1[/](8)
REG[6] =  i:6
REG[5] =   s2[6/](8)
  10 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:2
  11 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =  i:2
REG[5] =   s2[6/](8)
REG[4] =   s3[6/2](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:6
  13 Column           3    0    2               00 r[2]=a.b
REG[2] =  i:6
  14 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:2
  15 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:2
  16 Concat           5    6    3               00 r[3]=r[6]+r[5]
REG[5] =  i:2
REG[6] =  i:2
REG[3] =   s2[22](8)
  17 MakeRecord       3    2    8               00 r[8]=mkrec(r[3..4])
REG[8] =  sx8[0311133232362F32|...226/2]
  18 SequenceTest     2   23    0               00 if( cursor[2].ctr++ ) pc = 23
  19 Compare          9    1    2 k(3,B,B,B)    00 r[9..10] <-> r[1..2]
REG[9] =  i:6
REG[1] =  i:6
REG[10] =  i:6
REG[2] =  i:6
  20 Jump            21   24   21               00 
  24 SorterInsert     2    8    3 2             00 key=r[8]
REG[8] =  sx8[0311133232362F32|...226/2]
  25 Next             4    8    0               01 
   8 Column           3    0    6               00 r[6]=a.b
REG[6] =  i:6
   9 Concat           7    6    5               00 r[5]=r[6]+r[7]
REG[7] =   t1[/](8)
REG[6] =  i:6
REG[5] =   s2[6/](8)
  10 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:3
  11 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =  i:3
REG[5] =   s2[6/](8)
REG[4] =   s3[6/3](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:6
  13 Column           3    0    2               00 r[2]=a.b
REG[2] =  i:6
  14 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:3
  15 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:3
  16 Concat           5    6    3               00 r[3]=r[6]+r[5]
REG[5] =  i:3
REG[6] =  i:3
REG[3] =   s2[33](8)
  17 MakeRecord       3    2    8               00 r[8]=mkrec(r[3..4])
REG[8] =  sx8[0311133333362F33|...336/3]
  18 SequenceTest     2   23    0               00 if( cursor[2].ctr++ ) pc = 23
  19 Compare          9    1    2 k(3,B,B,B)    00 r[9..10] <-> r[1..2]
REG[9] =  i:6
REG[1] =  i:6
REG[10] =  i:6
REG[2] =  i:6
  20 Jump            21   24   21               00 
  24 SorterInsert     2    8    3 2             00 key=r[8]
REG[8] =  sx8[0311133333362F33|...336/3]
  25 Next             4    8    0               01 
   8 Column           3    0    6               00 r[6]=a.b
REG[6] =  i:6
   9 Concat           7    6    5               00 r[5]=r[6]+r[7]
REG[7] =   t1[/](8)
REG[6] =  i:6
REG[5] =   s2[6/](8)
  10 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:4
  11 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =  i:4
REG[5] =   s2[6/](8)
REG[4] =   s3[6/4](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:6
  13 Column           3    0    2               00 r[2]=a.b
REG[2] =  i:6
  14 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:4
  15 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:4
  16 Concat           5    6    3               00 r[3]=r[6]+r[5]
REG[5] =  i:4
REG[6] =  i:4
REG[3] =   s2[44](8)
  17 MakeRecord       3    2    8               00 r[8]=mkrec(r[3..4])
REG[8] =  sx8[0311133434362F34|...446/4]
  18 SequenceTest     2   23    0               00 if( cursor[2].ctr++ ) pc = 23
  19 Compare          9    1    2 k(3,B,B,B)    00 r[9..10] <-> r[1..2]
REG[9] =  i:6
REG[1] =  i:6
REG[10] =  i:6
REG[2] =  i:6
  20 Jump            21   24   21               00 
  24 SorterInsert     2    8    3 2             00 key=r[8]
REG[8] =  sx8[0311133434362F34|...446/4]
  25 Next             4    8    0               01 
   8 Column           3    0    6               00 r[6]=a.b
REG[6] =  i:6
   9 Concat           7    6    5               00 r[5]=r[6]+r[7]
REG[7] =   t1[/](8)
REG[6] =  i:6
REG[5] =   s2[6/](8)
  10 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:5
  11 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =  i:5
REG[5] =   s2[6/](8)
REG[4] =   s3[6/5](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:6
  13 Column           3    0    2               00 r[2]=a.b
REG[2] =  i:6
  14 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:5
  15 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:5
  16 Concat           5    6    3               00 r[3]=r[6]+r[5]
REG[5] =  i:5
REG[6] =  i:5
REG[3] =   s2[55](8)
  17 MakeRecord       3    2    8               00 r[8]=mkrec(r[3..4])
REG[8] =  sx8[0311133535362F35|...556/5]
  18 SequenceTest     2   23    0               00 if( cursor[2].ctr++ ) pc = 23
  19 Compare          9    1    2 k(3,B,B,B)    00 r[9..10] <-> r[1..2]
REG[9] =  i:6
REG[1] =  i:6
REG[10] =  i:6
REG[2] =  i:6
  20 Jump            21   24   21               00 
  24 SorterInsert     2    8    3 2             00 key=r[8]
REG[8] =  sx8[0311133535362F35|...556/5]
  25 Next             4    8    0               01 
   8 Column           3    0    6               00 r[6]=a.b
REG[6] =  i:6
   9 Concat           7    6    5               00 r[5]=r[6]+r[7]
REG[7] =   t1[/](8)
REG[6] =  i:6
REG[5] =   s2[6/](8)
  10 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:6
  11 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =  i:6
REG[5] =   s2[6/](8)
REG[4] =   s3[6/6](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:6
  13 Column           3    0    2               00 r[2]=a.b
REG[2] =  i:6
  14 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:6
  15 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:6
  16 Concat           5    6    3               00 r[3]=r[6]+r[5]
REG[5] =  i:6
REG[6] =  i:6
REG[3] =   s2[66](8)
  17 MakeRecord       3    2    8               00 r[8]=mkrec(r[3..4])
REG[8] =  sx8[0311133636362F36|...666/6]
  18 SequenceTest     2   23    0               00 if( cursor[2].ctr++ ) pc = 23
  19 Compare          9    1    2 k(3,B,B,B)    00 r[9..10] <-> r[1..2]
REG[9] =  i:6
REG[1] =  i:6
REG[10] =  i:6
REG[2] =  i:6
  20 Jump            21   24   21               00 
  24 SorterInsert     2    8    3 2             00 key=r[8]
REG[8] =  sx8[0311133636362F36|...666/6]
  25 Next             4    8    0               01 
   8 Column           3    0    6               00 r[6]=a.b
REG[6] =  i:6
   9 Concat           7    6    5               00 r[5]=r[6]+r[7]
REG[7] =   t1[/](8)
REG[6] =  i:6
REG[5] =   s2[6/](8)
  10 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:7
  11 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =  i:7
REG[5] =   s2[6/](8)
REG[4] =   s3[6/7](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:6
  13 Column           3    0    2               00 r[2]=a.b
REG[2] =  i:6
  14 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:7
  15 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:7
  16 Concat           5    6    3               00 r[3]=r[6]+r[5]
REG[5] =  i:7
REG[6] =  i:7
REG[3] =   s2[77](8)
  17 MakeRecord       3    2    8               00 r[8]=mkrec(r[3..4])
REG[8] =  sx8[0311133737362F37|...776/7]
  18 SequenceTest     2   23    0               00 if( cursor[2].ctr++ ) pc = 23
  19 Compare          9    1    2 k(3,B,B,B)    00 r[9..10] <-> r[1..2]
REG[9] =  i:6
REG[1] =  i:6
REG[10] =  i:6
REG[2] =  i:6
  20 Jump            21   24   21               00 
  24 SorterInsert     2    8    3 2             00 key=r[8]
REG[8] =  sx8[0311133737362F37|...776/7]
  25 Next             4    8    0               01 
   8 Column           3    0    6               00 r[6]=a.b
REG[6] =  i:6
   9 Concat           7    6    5               00 r[5]=r[6]+r[7]
REG[7] =   t1[/](8)
REG[6] =  i:6
REG[5] =   s2[6/](8)
  10 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:8
  11 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =  i:8
REG[5] =   s2[6/](8)
REG[4] =   s3[6/8](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:6
  13 Column           3    0    2               00 r[2]=a.b
REG[2] =  i:6
  14 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:8
  15 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:8
  16 Concat           5    6    3               00 r[3]=r[6]+r[5]
REG[5] =  i:8
REG[6] =  i:8
REG[3] =   s2[88](8)
  17 MakeRecord       3    2    8               00 r[8]=mkrec(r[3..4])
REG[8] =  sx8[0311133838362F38|...886/8]
  18 SequenceTest     2   23    0               00 if( cursor[2].ctr++ ) pc = 23
  19 Compare          9    1    2 k(3,B,B,B)    00 r[9..10] <-> r[1..2]
REG[9] =  i:6
REG[1] =  i:6
REG[10] =  i:6
REG[2] =  i:6
  20 Jump            21   24   21               00 
  24 SorterInsert     2    8    3 2             00 key=r[8]
REG[8] =  sx8[0311133838362F38|...886/8]
  25 Next             4    8    0               01 
   8 Column           3    0    6               00 r[6]=a.b
REG[6] =  i:6
   9 Concat           7    6    5               00 r[5]=r[6]+r[7]
REG[7] =   t1[/](8)
REG[6] =  i:6
REG[5] =   s2[6/](8)
  10 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:9
  11 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =  i:9
REG[5] =   s2[6/](8)
REG[4] =   s3[6/9](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:6
  13 Column           3    0    2               00 r[2]=a.b
REG[2] =  i:6
  14 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:9
  15 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:9
  16 Concat           5    6    3               00 r[3]=r[6]+r[5]
REG[5] =  i:9
REG[6] =  i:9
REG[3] =   s2[99](8)
  17 MakeRecord       3    2    8               00 r[8]=mkrec(r[3..4])
REG[8] =  sx8[0311133939362F39|...996/9]
  18 SequenceTest     2   23    0               00 if( cursor[2].ctr++ ) pc = 23
  19 Compare          9    1    2 k(3,B,B,B)    00 r[9..10] <-> r[1..2]
REG[9] =  i:6
REG[1] =  i:6
REG[10] =  i:6
REG[2] =  i:6
  20 Jump            21   24   21               00 
  24 SorterInsert     2    8    3 2             00 key=r[8]
REG[8] =  sx8[0311133939362F39|...996/9]
  25 Next             4    8    0               01 
  26 Next             3    6    0               01 
   6 Explain          6    0    0 SCAN TABLE a AS y USING COVERING INDEX i2 00 
   7 Rewind           4   26    1 0             00 
   8 Column           3    0    6               00 r[6]=a.b
REG[6] =  i:7
   9 Concat           7    6    5               00 r[5]=r[6]+r[7]
REG[7] =   t1[/](8)
REG[6] =  i:7
REG[5] =   s2[7/](8)
  10 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:1
  11 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =  i:1
REG[5] =   s2[7/](8)
REG[4] =   s3[7/1](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:7
  13 Column           3    0    2               00 r[2]=a.b
REG[2] =  i:7
  14 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:1
  15 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:1
  16 Concat           5    6    3               00 r[3]=r[6]+r[5]
REG[5] =  i:1
REG[6] =  i:1
REG[3] =   s2[11](8)
  17 MakeRecord       3    2    8               00 r[8]=mkrec(r[3..4])
REG[8] =  sx8[0311133131372F31|...117/1]
  18 SequenceTest     2   23    0               00 if( cursor[2].ctr++ ) pc = 23
  19 Compare          9    1    2 k(3,B,B,B)    00 r[9..10] <-> r[1..2]
REG[9] =  i:6
REG[1] =  i:7
  20 Jump            21   24   21               00 
  21 Gosub           11   30    0               00 
REG[11] =  i:21
  30 Once             1   32    0               00 
  32 SorterSort       2   38    0               00 
  33 SorterData       2   12    5               00 r[12]=data
  34 Column           5    1    4               00 r[4]=x.b || '/' || y.b
REG[4] =   s3[6/1](8)
  35 ResultRow        4    1    0               00 output=r[4]
REG[4] =   s3[6/1](8)
  36 SorterNext       2   33    0               00 
  33 SorterData       2   12    5               00 r[12]=data
  34 Column           5    1    4               00 r[4]=x.b || '/' || y.b
REG[4] =   s3[6/2](8)
  35 ResultRow        4    1    0               00 output=r[4]
REG[4] =   s3[6/2](8)
  36 SorterNext       2   33    0               00 
  33 SorterData       2   12    5               00 r[12]=data
  34 Column           5    1    4               00 r[4]=x.b || '/' || y.b
REG[4] =   s3[6/3](8)
  35 ResultRow        4    1    0               00 output=r[4]
REG[4] =   s3[6/3](8)
  36 SorterNext       2   33    0               00 
  33 SorterData       2   12    5               00 r[12]=data
  34 Column           5    1    4               00 r[4]=x.b || '/' || y.b
REG[4] =   s3[6/4](8)
  35 ResultRow        4    1    0               00 output=r[4]
REG[4] =   s3[6/4](8)
  36 SorterNext       2   33    0               00 
  33 SorterData       2   12    5               00 r[12]=data
  34 Column           5    1    4               00 r[4]=x.b || '/' || y.b
REG[4] =   s3[6/5](8)
  35 ResultRow        4    1    0               00 output=r[4]
REG[4] =   s3[6/5](8)
  36 SorterNext       2   33    0               00 
  33 SorterData       2   12    5               00 r[12]=data
  34 Column           5    1    4               00 r[4]=x.b || '/' || y.b
REG[4] =   s3[6/6](8)
  35 ResultRow        4    1    0               00 output=r[4]
REG[4] =   s3[6/6](8)
  36 SorterNext       2   33    0               00 
  33 SorterData       2   12    5               00 r[12]=data
  34 Column           5    1    4               00 r[4]=x.b || '/' || y.b
REG[4] =   s3[6/7](8)
  35 ResultRow        4    1    0               00 output=r[4]
REG[4] =   s3[6/7](8)
  36 SorterNext       2   33    0               00 
  33 SorterData       2   12    5               00 r[12]=data
  34 Column           5    1    4               00 r[4]=x.b || '/' || y.b
REG[4] =   s3[6/8](8)
  35 ResultRow        4    1    0               00 output=r[4]
REG[4] =   s3[6/8](8)
  36 SorterNext       2   33    0               00 
  33 SorterData       2   12    5               00 r[12]=data
  34 Column           5    1    4               00 r[4]=x.b || '/' || y.b
REG[4] =   s3[6/9](8)
  35 ResultRow        4    1    0               00 output=r[4]
REG[4] =   s3[6/9](8)
  36 SorterNext       2   33    0               00 
  37 Return          11    0    0               00 
REG[11] =  i:21
  22 ResetSorter      2    0    0               00 
  23 Move             1    9    2               00 r[9..10]=r[1..2]
REG[9] =  i:7
REG[10] =  i:7
  24 SorterInsert     2    8    3 2             00 key=r[8]
REG[8] =  sx8[0311133131372F31|...117/1]
  25 Next             4    8    0               01 
   8 Column           3    0    6               00 r[6]=a.b
REG[6] =  i:7
   9 Concat           7    6    5               00 r[5]=r[6]+r[7]
REG[7] =   t1[/](8)
REG[6] =  i:7
REG[5] =   s2[7/](8)
  10 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:2
  11 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =  i:2
REG[5] =   s2[7/](8)
REG[4] =   s3[7/2](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:7
  13 Column           3    0    2               00 r[2]=a.b
REG[2] =  i:7
  14 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:2
  15 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:2
  16 Concat           5    6    3               00 r[3]=r[6]+r[5]
REG[5] =  i:2
REG[6] =  i:2
REG[3] =   s2[22](8)
  17 MakeRecord       3    2    8               00 r[8]=mkrec(r[3..4])
REG[8] =  sx8[0311133232372F32|...227/2]
  18 SequenceTest     2   23    0               00 if( cursor[2].ctr++ ) pc = 23
  19 Compare          9    1    2 k(3,B,B,B)    00 r[9..10] <-> r[1..2]
REG[9] =  i:7
REG[1] =  i:7
REG[10] =  i:7
REG[2] =  i:7
  20 Jump            21   24   21               00 
  24 SorterInsert     2    8    3 2             00 key=r[8]
REG[8] =  sx8[0311133232372F32|...227/2]
  25 Next             4    8    0               01 
   8 Column           3    0    6               00 r[6]=a.b
REG[6] =  i:7
   9 Concat           7    6    5               00 r[5]=r[6]+r[7]
REG[7] =   t1[/](8)
REG[6] =  i:7
REG[5] =   s2[7/](8)
  10 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:3
  11 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =  i:3
REG[5] =   s2[7/](8)
REG[4] =   s3[7/3](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:7
  13 Column           3    0    2               00 r[2]=a.b
REG[2] =  i:7
  14 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:3
  15 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:3
  16 Concat           5    6    3               00 r[3]=r[6]+r[5]
REG[5] =  i:3
REG[6] =  i:3
REG[3] =   s2[33](8)
  17 MakeRecord       3    2    8               00 r[8]=mkrec(r[3..4])
REG[8] =  sx8[0311133333372F33|...337/3]
  18 SequenceTest     2   23    0               00 if( cursor[2].ctr++ ) pc = 23
  19 Compare          9    1    2 k(3,B,B,B)    00 r[9..10] <-> r[1..2]
REG[9] =  i:7
REG[1] =  i:7
REG[10] =  i:7
REG[2] =  i:7
  20 Jump            21   24   21               00 
  24 SorterInsert     2    8    3 2             00 key=r[8]
REG[8] =  sx8[0311133333372F33|...337/3]
  25 Next             4    8    0               01 
   8 Column           3    0    6               00 r[6]=a.b
REG[6] =  i:7
   9 Concat           7    6    5               00 r[5]=r[6]+r[7]
REG[7] =   t1[/](8)
REG[6] =  i:7
REG[5] =   s2[7/](8)
  10 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:4
  11 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =  i:4
REG[5] =   s2[7/](8)
REG[4] =   s3[7/4](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:7
  13 Column           3    0    2               00 r[2]=a.b
REG[2] =  i:7
  14 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:4
  15 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:4
  16 Concat           5    6    3               00 r[3]=r[6]+r[5]
REG[5] =  i:4
REG[6] =  i:4
REG[3] =   s2[44](8)
  17 MakeRecord       3    2    8               00 r[8]=mkrec(r[3..4])
REG[8] =  sx8[0311133434372F34|...447/4]
  18 SequenceTest     2   23    0               00 if( cursor[2].ctr++ ) pc = 23
  19 Compare          9    1    2 k(3,B,B,B)    00 r[9..10] <-> r[1..2]
REG[9] =  i:7
REG[1] =  i:7
REG[10] =  i:7
REG[2] =  i:7
  20 Jump            21   24   21               00 
  24 SorterInsert     2    8    3 2             00 key=r[8]
REG[8] =  sx8[0311133434372F34|...447/4]
  25 Next             4    8    0               01 
   8 Column           3    0    6               00 r[6]=a.b
REG[6] =  i:7
   9 Concat           7    6    5               00 r[5]=r[6]+r[7]
REG[7] =   t1[/](8)
REG[6] =  i:7
REG[5] =   s2[7/](8)
  10 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:5
  11 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =  i:5
REG[5] =   s2[7/](8)
REG[4] =   s3[7/5](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:7
  13 Column           3    0    2               00 r[2]=a.b
REG[2] =  i:7
  14 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:5
  15 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:5
  16 Concat           5    6    3               00 r[3]=r[6]+r[5]
REG[5] =  i:5
REG[6] =  i:5
REG[3] =   s2[55](8)
  17 MakeRecord       3    2    8               00 r[8]=mkrec(r[3..4])
REG[8] =  sx8[0311133535372F35|...557/5]
  18 SequenceTest     2   23    0               00 if( cursor[2].ctr++ ) pc = 23
  19 Compare          9    1    2 k(3,B,B,B)    00 r[9..10] <-> r[1..2]
REG[9] =  i:7
REG[1] =  i:7
REG[10] =  i:7
REG[2] =  i:7
  20 Jump            21   24   21               00 
  24 SorterInsert     2    8    3 2             00 key=r[8]
REG[8] =  sx8[0311133535372F35|...557/5]
  25 Next             4    8    0               01 
   8 Column           3    0    6               00 r[6]=a.b
REG[6] =  i:7
   9 Concat           7    6    5               00 r[5]=r[6]+r[7]
REG[7] =   t1[/](8)
REG[6] =  i:7
REG[5] =   s2[7/](8)
  10 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:6
  11 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =  i:6
REG[5] =   s2[7/](8)
REG[4] =   s3[7/6](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:7
  13 Column           3    0    2               00 r[2]=a.b
REG[2] =  i:7
  14 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:6
  15 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:6
  16 Concat           5    6    3               00 r[3]=r[6]+r[5]
REG[5] =  i:6
REG[6] =  i:6
REG[3] =   s2[66](8)
  17 MakeRecord       3    2    8               00 r[8]=mkrec(r[3..4])
REG[8] =  sx8[0311133636372F36|...667/6]
  18 SequenceTest     2   23    0               00 if( cursor[2].ctr++ ) pc = 23
  19 Compare          9    1    2 k(3,B,B,B)    00 r[9..10] <-> r[1..2]
REG[9] =  i:7
REG[1] =  i:7
REG[10] =  i:7
REG[2] =  i:7
  20 Jump            21   24   21               00 
  24 SorterInsert     2    8    3 2             00 key=r[8]
REG[8] =  sx8[0311133636372F36|...667/6]
  25 Next             4    8    0               01 
   8 Column           3    0    6               00 r[6]=a.b
REG[6] =  i:7
   9 Concat           7    6    5               00 r[5]=r[6]+r[7]
REG[7] =   t1[/](8)
REG[6] =  i:7
REG[5] =   s2[7/](8)
  10 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:7
  11 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =  i:7
REG[5] =   s2[7/](8)
REG[4] =   s3[7/7](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:7
  13 Column           3    0    2               00 r[2]=a.b
REG[2] =  i:7
  14 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:7
  15 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:7
  16 Concat           5    6    3               00 r[3]=r[6]+r[5]
REG[5] =  i:7
REG[6] =  i:7
REG[3] =   s2[77](8)
  17 MakeRecord       3    2    8               00 r[8]=mkrec(r[3..4])
REG[8] =  sx8[0311133737372F37|...777/7]
  18 SequenceTest     2   23    0               00 if( cursor[2].ctr++ ) pc = 23
  19 Compare          9    1    2 k(3,B,B,B)    00 r[9..10] <-> r[1..2]
REG[9] =  i:7
REG[1] =  i:7
REG[10] =  i:7
REG[2] =  i:7
  20 Jump            21   24   21               00 
  24 SorterInsert     2    8    3 2             00 key=r[8]
REG[8] =  sx8[0311133737372F37|...777/7]
  25 Next             4    8    0               01 
   8 Column           3    0    6               00 r[6]=a.b
REG[6] =  i:7
   9 Concat           7    6    5               00 r[5]=r[6]+r[7]
REG[7] =   t1[/](8)
REG[6] =  i:7
REG[5] =   s2[7/](8)
  10 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:8
  11 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =  i:8
REG[5] =   s2[7/](8)
REG[4] =   s3[7/8](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:7
  13 Column           3    0    2               00 r[2]=a.b
REG[2] =  i:7
  14 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:8
  15 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:8
  16 Concat           5    6    3               00 r[3]=r[6]+r[5]
REG[5] =  i:8
REG[6] =  i:8
REG[3] =   s2[88](8)
  17 MakeRecord       3    2    8               00 r[8]=mkrec(r[3..4])
REG[8] =  sx8[0311133838372F38|...887/8]
  18 SequenceTest     2   23    0               00 if( cursor[2].ctr++ ) pc = 23
  19 Compare          9    1    2 k(3,B,B,B)    00 r[9..10] <-> r[1..2]
REG[9] =  i:7
REG[1] =  i:7
REG[10] =  i:7
REG[2] =  i:7
  20 Jump            21   24   21               00 
  24 SorterInsert     2    8    3 2             00 key=r[8]
REG[8] =  sx8[0311133838372F38|...887/8]
  25 Next             4    8    0               01 
   8 Column           3    0    6               00 r[6]=a.b
REG[6] =  i:7
   9 Concat           7    6    5               00 r[5]=r[6]+r[7]
REG[7] =   t1[/](8)
REG[6] =  i:7
REG[5] =   s2[7/](8)
  10 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:9
  11 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =  i:9
REG[5] =   s2[7/](8)
REG[4] =   s3[7/9](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:7
  13 Column           3    0    2               00 r[2]=a.b
REG[2] =  i:7
  14 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:9
  15 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:9
  16 Concat           5    6    3               00 r[3]=r[6]+r[5]
REG[5] =  i:9
REG[6] =  i:9
REG[3] =   s2[99](8)
  17 MakeRecord       3    2    8               00 r[8]=mkrec(r[3..4])
REG[8] =  sx8[0311133939372F39|...997/9]
  18 SequenceTest     2   23    0               00 if( cursor[2].ctr++ ) pc = 23
  19 Compare          9    1    2 k(3,B,B,B)    00 r[9..10] <-> r[1..2]
REG[9] =  i:7
REG[1] =  i:7
REG[10] =  i:7
REG[2] =  i:7
  20 Jump            21   24   21               00 
  24 SorterInsert     2    8    3 2             00 key=r[8]
REG[8] =  sx8[0311133939372F39|...997/9]
  25 Next             4    8    0               01 
  26 Next             3    6    0               01 
   6 Explain          6    0    0 SCAN TABLE a AS y USING COVERING INDEX i2 00 
   7 Rewind           4   26    1 0             00 
   8 Column           3    0    6               00 r[6]=a.b
REG[6] =  i:8
   9 Concat           7    6    5               00 r[5]=r[6]+r[7]
REG[7] =   t1[/](8)
REG[6] =  i:8
REG[5] =   s2[8/](8)
  10 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:1
  11 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =  i:1
REG[5] =   s2[8/](8)
REG[4] =   s3[8/1](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:8
  13 Column           3    0    2               00 r[2]=a.b
REG[2] =  i:8
  14 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:1
  15 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:1
  16 Concat           5    6    3               00 r[3]=r[6]+r[5]
REG[5] =  i:1
REG[6] =  i:1
REG[3] =   s2[11](8)
  17 MakeRecord       3    2    8               00 r[8]=mkrec(r[3..4])
REG[8] =  sx8[0311133131382F31|...118/1]
  18 SequenceTest     2   23    0               00 if( cursor[2].ctr++ ) pc = 23
  19 Compare          9    1    2 k(3,B,B,B)    00 r[9..10] <-> r[1..2]
REG[9] =  i:7
REG[1] =  i:8
  20 Jump            21   24   21               00 
  21 Gosub           11   30    0               00 
REG[11] =  i:21
  30 Once             1   32    0               00 
  32 SorterSort       2   38    0               00 
  33 SorterData       2   12    5               00 r[12]=data
  34 Column           5    1    4               00 r[4]=x.b || '/' || y.b
REG[4] =   s3[7/1](8)
  35 ResultRow        4    1    0               00 output=r[4]
REG[4] =   s3[7/1](8)
  36 SorterNext       2   33    0               00 
  33 SorterData       2   12    5               00 r[12]=data
  34 Column           5    1    4               00 r[4]=x.b || '/' || y.b
REG[4] =   s3[7/2](8)
  35 ResultRow        4    1    0               00 output=r[4]
REG[4] =   s3[7/2](8)
  36 SorterNext       2   33    0               00 
  33 SorterData       2   12    5               00 r[12]=data
  34 Column           5    1    4               00 r[4]=x.b || '/' || y.b
REG[4] =   s3[7/3](8)
  35 ResultRow        4    1    0               00 output=r[4]
REG[4] =   s3[7/3](8)
  36 SorterNext       2   33    0               00 
  33 SorterData       2   12    5               00 r[12]=data
  34 Column           5    1    4               00 r[4]=x.b || '/' || y.b
REG[4] =   s3[7/4](8)
  35 ResultRow        4    1    0               00 output=r[4]
REG[4] =   s3[7/4](8)
  36 SorterNext       2   33    0               00 
  33 SorterData       2   12    5               00 r[12]=data
  34 Column           5    1    4               00 r[4]=x.b || '/' || y.b
REG[4] =   s3[7/5](8)
  35 ResultRow        4    1    0               00 output=r[4]
REG[4] =   s3[7/5](8)
  36 SorterNext       2   33    0               00 
  33 SorterData       2   12    5               00 r[12]=data
  34 Column           5    1    4               00 r[4]=x.b || '/' || y.b
REG[4] =   s3[7/6](8)
  35 ResultRow        4    1    0               00 output=r[4]
REG[4] =   s3[7/6](8)
  36 SorterNext       2   33    0               00 
  33 SorterData       2   12    5               00 r[12]=data
  34 Column           5    1    4               00 r[4]=x.b || '/' || y.b
REG[4] =   s3[7/7](8)
  35 ResultRow        4    1    0               00 output=r[4]
REG[4] =   s3[7/7](8)
  36 SorterNext       2   33    0               00 
  33 SorterData       2   12    5               00 r[12]=data
  34 Column           5    1    4               00 r[4]=x.b || '/' || y.b
REG[4] =   s3[7/8](8)
  35 ResultRow        4    1    0               00 output=r[4]
REG[4] =   s3[7/8](8)
  36 SorterNext       2   33    0               00 
  33 SorterData       2   12    5               00 r[12]=data
  34 Column           5    1    4               00 r[4]=x.b || '/' || y.b
REG[4] =   s3[7/9](8)
  35 ResultRow        4    1    0               00 output=r[4]
REG[4] =   s3[7/9](8)
  36 SorterNext       2   33    0               00 
  37 Return          11    0    0               00 
REG[11] =  i:21
  22 ResetSorter      2    0    0               00 
  23 Move             1    9    2               00 r[9..10]=r[1..2]
REG[9] =  i:8
REG[10] =  i:8
  24 SorterInsert     2    8    3 2             00 key=r[8]
REG[8] =  sx8[0311133131382F31|...118/1]
  25 Next             4    8    0               01 
   8 Column           3    0    6               00 r[6]=a.b
REG[6] =  i:8
   9 Concat           7    6    5               00 r[5]=r[6]+r[7]
REG[7] =   t1[/](8)
REG[6] =  i:8
REG[5] =   s2[8/](8)
  10 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:2
  11 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =  i:2
REG[5] =   s2[8/](8)
REG[4] =   s3[8/2](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:8
  13 Column           3    0    2               00 r[2]=a.b
REG[2] =  i:8
  14 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:2
  15 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:2
  16 Concat           5    6    3               00 r[3]=r[6]+r[5]
REG[5] =  i:2
REG[6] =  i:2
REG[3] =   s2[22](8)
  17 MakeRecord       3    2    8               00 r[8]=mkrec(r[3..4])
REG[8] =  sx8[0311133232382F32|...228/2]
  18 SequenceTest     2   23    0               00 if( cursor[2].ctr++ ) pc = 23
  19 Compare          9    1    2 k(3,B,B,B)    00 r[9..10] <-> r[1..2]
REG[9] =  i:8
REG[1] =  i:8
REG[10] =  i:8
REG[2] =  i:8
  20 Jump            21   24   21               00 
  24 SorterInsert     2    8    3 2             00 key=r[8]
REG[8] =  sx8[0311133232382F32|...228/2]
  25 Next             4    8    0               01 
   8 Column           3    0    6               00 r[6]=a.b
REG[6] =  i:8
   9 Concat           7    6    5               00 r[5]=r[6]+r[7]
REG[7] =   t1[/](8)
REG[6] =  i:8
REG[5] =   s2[8/](8)
  10 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:3
  11 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =  i:3
REG[5] =   s2[8/](8)
REG[4] =   s3[8/3](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:8
  13 Column           3    0    2               00 r[2]=a.b
REG[2] =  i:8
  14 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:3
  15 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:3
  16 Concat           5    6    3               00 r[3]=r[6]+r[5]
REG[5] =  i:3
REG[6] =  i:3
REG[3] =   s2[33](8)
  17 MakeRecord       3    2    8               00 r[8]=mkrec(r[3..4])
REG[8] =  sx8[0311133333382F33|...338/3]
  18 SequenceTest     2   23    0               00 if( cursor[2].ctr++ ) pc = 23
  19 Compare          9    1    2 k(3,B,B,B)    00 r[9..10] <-> r[1..2]
REG[9] =  i:8
REG[1] =  i:8
REG[10] =  i:8
REG[2] =  i:8
  20 Jump            21   24   21               00 
  24 SorterInsert     2    8    3 2             00 key=r[8]
REG[8] =  sx8[0311133333382F33|...338/3]
  25 Next             4    8    0               01 
   8 Column           3    0    6               00 r[6]=a.b
REG[6] =  i:8
   9 Concat           7    6    5               00 r[5]=r[6]+r[7]
REG[7] =   t1[/](8)
REG[6] =  i:8
REG[5] =   s2[8/](8)
  10 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:4
  11 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =  i:4
REG[5] =   s2[8/](8)
REG[4] =   s3[8/4](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:8
  13 Column           3    0    2               00 r[2]=a.b
REG[2] =  i:8
  14 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:4
  15 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:4
  16 Concat           5    6    3               00 r[3]=r[6]+r[5]
REG[5] =  i:4
REG[6] =  i:4
REG[3] =   s2[44](8)
  17 MakeRecord       3    2    8               00 r[8]=mkrec(r[3..4])
REG[8] =  sx8[0311133434382F34|...448/4]
  18 SequenceTest     2   23    0               00 if( cursor[2].ctr++ ) pc = 23
  19 Compare          9    1    2 k(3,B,B,B)    00 r[9..10] <-> r[1..2]
REG[9] =  i:8
REG[1] =  i:8
REG[10] =  i:8
REG[2] =  i:8
  20 Jump            21   24   21               00 
  24 SorterInsert     2    8    3 2             00 key=r[8]
REG[8] =  sx8[0311133434382F34|...448/4]
  25 Next             4    8    0               01 
   8 Column           3    0    6               00 r[6]=a.b
REG[6] =  i:8
   9 Concat           7    6    5               00 r[5]=r[6]+r[7]
REG[7] =   t1[/](8)
REG[6] =  i:8
REG[5] =   s2[8/](8)
  10 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:5
  11 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =  i:5
REG[5] =   s2[8/](8)
REG[4] =   s3[8/5](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:8
  13 Column           3    0    2               00 r[2]=a.b
REG[2] =  i:8
  14 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:5
  15 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:5
  16 Concat           5    6    3               00 r[3]=r[6]+r[5]
REG[5] =  i:5
REG[6] =  i:5
REG[3] =   s2[55](8)
  17 MakeRecord       3    2    8               00 r[8]=mkrec(r[3..4])
REG[8] =  sx8[0311133535382F35|...558/5]
  18 SequenceTest     2   23    0               00 if( cursor[2].ctr++ ) pc = 23
  19 Compare          9    1    2 k(3,B,B,B)    00 r[9..10] <-> r[1..2]
REG[9] =  i:8
REG[1] =  i:8
REG[10] =  i:8
REG[2] =  i:8
  20 Jump            21   24   21               00 
  24 SorterInsert     2    8    3 2             00 key=r[8]
REG[8] =  sx8[0311133535382F35|...558/5]
  25 Next             4    8    0               01 
   8 Column           3    0    6               00 r[6]=a.b
REG[6] =  i:8
   9 Concat           7    6    5               00 r[5]=r[6]+r[7]
REG[7] =   t1[/](8)
REG[6] =  i:8
REG[5] =   s2[8/](8)
  10 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:6
  11 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =  i:6
REG[5] =   s2[8/](8)
REG[4] =   s3[8/6](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:8
  13 Column           3    0    2               00 r[2]=a.b
REG[2] =  i:8
  14 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:6
  15 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:6
  16 Concat           5    6    3               00 r[3]=r[6]+r[5]
REG[5] =  i:6
REG[6] =  i:6
REG[3] =   s2[66](8)
  17 MakeRecord       3    2    8               00 r[8]=mkrec(r[3..4])
REG[8] =  sx8[0311133636382F36|...668/6]
  18 SequenceTest     2   23    0               00 if( cursor[2].ctr++ ) pc = 23
  19 Compare          9    1    2 k(3,B,B,B)    00 r[9..10] <-> r[1..2]
REG[9] =  i:8
REG[1] =  i:8
REG[10] =  i:8
REG[2] =  i:8
  20 Jump            21   24   21               00 
  24 SorterInsert     2    8    3 2             00 key=r[8]
REG[8] =  sx8[0311133636382F36|...668/6]
  25 Next             4    8    0               01 
   8 Column           3    0    6               00 r[6]=a.b
REG[6] =  i:8
   9 Concat           7    6    5               00 r[5]=r[6]+r[7]
REG[7] =   t1[/](8)
REG[6] =  i:8
REG[5] =   s2[8/](8)
  10 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:7
  11 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =  i:7
REG[5] =   s2[8/](8)
REG[4] =   s3[8/7](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:8
  13 Column           3    0    2               00 r[2]=a.b
REG[2] =  i:8
  14 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:7
  15 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:7
  16 Concat           5    6    3               00 r[3]=r[6]+r[5]
REG[5] =  i:7
REG[6] =  i:7
REG[3] =   s2[77](8)
  17 MakeRecord       3    2    8               00 r[8]=mkrec(r[3..4])
REG[8] =  sx8[0311133737382F37|...778/7]
  18 SequenceTest     2   23    0               00 if( cursor[2].ctr++ ) pc = 23
  19 Compare          9    1    2 k(3,B,B,B)    00 r[9..10] <-> r[1..2]
REG[9] =  i:8
REG[1] =  i:8
REG[10] =  i:8
REG[2] =  i:8
  20 Jump            21   24   21               00 
  24 SorterInsert     2    8    3 2             00 key=r[8]
REG[8] =  sx8[0311133737382F37|...778/7]
  25 Next             4    8    0               01 
   8 Column           3    0    6               00 r[6]=a.b
REG[6] =  i:8
   9 Concat           7    6    5               00 r[5]=r[6]+r[7]
REG[7] =   t1[/](8)
REG[6] =  i:8
REG[5] =   s2[8/](8)
  10 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:8
  11 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =  i:8
REG[5] =   s2[8/](8)
REG[4] =   s3[8/8](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:8
  13 Column           3    0    2               00 r[2]=a.b
REG[2] =  i:8
  14 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:8
  15 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:8
  16 Concat           5    6    3               00 r[3]=r[6]+r[5]
REG[5] =  i:8
REG[6] =  i:8
REG[3] =   s2[88](8)
  17 MakeRecord       3    2    8               00 r[8]=mkrec(r[3..4])
REG[8] =  sx8[0311133838382F38|...888/8]
  18 SequenceTest     2   23    0               00 if( cursor[2].ctr++ ) pc = 23
  19 Compare          9    1    2 k(3,B,B,B)    00 r[9..10] <-> r[1..2]
REG[9] =  i:8
REG[1] =  i:8
REG[10] =  i:8
REG[2] =  i:8
  20 Jump            21   24   21               00 
  24 SorterInsert     2    8    3 2             00 key=r[8]
REG[8] =  sx8[0311133838382F38|...888/8]
  25 Next             4    8    0               01 
   8 Column           3    0    6               00 r[6]=a.b
REG[6] =  i:8
   9 Concat           7    6    5               00 r[5]=r[6]+r[7]
REG[7] =   t1[/](8)
REG[6] =  i:8
REG[5] =   s2[8/](8)
  10 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:9
  11 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =  i:9
REG[5] =   s2[8/](8)
REG[4] =   s3[8/9](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:8
  13 Column           3    0    2               00 r[2]=a.b
REG[2] =  i:8
  14 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:9
  15 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:9
  16 Concat           5    6    3               00 r[3]=r[6]+r[5]
REG[5] =  i:9
REG[6] =  i:9
REG[3] =   s2[99](8)
  17 MakeRecord       3    2    8               00 r[8]=mkrec(r[3..4])
REG[8] =  sx8[0311133939382F39|...998/9]
  18 SequenceTest     2   23    0               00 if( cursor[2].ctr++ ) pc = 23
  19 Compare          9    1    2 k(3,B,B,B)    00 r[9..10] <-> r[1..2]
REG[9] =  i:8
REG[1] =  i:8
REG[10] =  i:8
REG[2] =  i:8
  20 Jump            21   24   21               00 
  24 SorterInsert     2    8    3 2             00 key=r[8]
REG[8] =  sx8[0311133939382F39|...998/9]
  25 Next             4    8    0               01 
  26 Next             3    6    0               01 
   6 Explain          6    0    0 SCAN TABLE a AS y USING COVERING INDEX i2 00 
   7 Rewind           4   26    1 0             00 
   8 Column           3    0    6               00 r[6]=a.b
REG[6] =  i:9
   9 Concat           7    6    5               00 r[5]=r[6]+r[7]
REG[7] =   t1[/](8)
REG[6] =  i:9
REG[5] =   s2[9/](8)
  10 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:1
  11 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =  i:1
REG[5] =   s2[9/](8)
REG[4] =   s3[9/1](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:9
  13 Column           3    0    2               00 r[2]=a.b
REG[2] =  i:9
  14 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:1
  15 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:1
  16 Concat           5    6    3               00 r[3]=r[6]+r[5]
REG[5] =  i:1
REG[6] =  i:1
REG[3] =   s2[11](8)
  17 MakeRecord       3    2    8               00 r[8]=mkrec(r[3..4])
REG[8] =  sx8[0311133131392F31|...119/1]
  18 SequenceTest     2   23    0               00 if( cursor[2].ctr++ ) pc = 23
  19 Compare          9    1    2 k(3,B,B,B)    00 r[9..10] <-> r[1..2]
REG[9] =  i:8
REG[1] =  i:9
  20 Jump            21   24   21               00 
  21 Gosub           11   30    0               00 
REG[11] =  i:21
  30 Once             1   32    0               00 
  32 SorterSort       2   38    0               00 
  33 SorterData       2   12    5               00 r[12]=data
  34 Column           5    1    4               00 r[4]=x.b || '/' || y.b
REG[4] =   s3[8/1](8)
  35 ResultRow        4    1    0               00 output=r[4]
REG[4] =   s3[8/1](8)
  36 SorterNext       2   33    0               00 
  33 SorterData       2   12    5               00 r[12]=data
  34 Column           5    1    4               00 r[4]=x.b || '/' || y.b
REG[4] =   s3[8/2](8)
  35 ResultRow        4    1    0               00 output=r[4]
REG[4] =   s3[8/2](8)
  36 SorterNext       2   33    0               00 
  33 SorterData       2   12    5               00 r[12]=data
  34 Column           5    1    4               00 r[4]=x.b || '/' || y.b
REG[4] =   s3[8/3](8)
  35 ResultRow        4    1    0               00 output=r[4]
REG[4] =   s3[8/3](8)
  36 SorterNext       2   33    0               00 
  33 SorterData       2   12    5               00 r[12]=data
  34 Column           5    1    4               00 r[4]=x.b || '/' || y.b
REG[4] =   s3[8/4](8)
  35 ResultRow        4    1    0               00 output=r[4]
REG[4] =   s3[8/4](8)
  36 SorterNext       2   33    0               00 
  33 SorterData       2   12    5               00 r[12]=data
  34 Column           5    1    4               00 r[4]=x.b || '/' || y.b
REG[4] =   s3[8/5](8)
  35 ResultRow        4    1    0               00 output=r[4]
REG[4] =   s3[8/5](8)
  36 SorterNext       2   33    0               00 
  33 SorterData       2   12    5               00 r[12]=data
  34 Column           5    1    4               00 r[4]=x.b || '/' || y.b
REG[4] =   s3[8/6](8)
  35 ResultRow        4    1    0               00 output=r[4]
REG[4] =   s3[8/6](8)
  36 SorterNext       2   33    0               00 
  33 SorterData       2   12    5               00 r[12]=data
  34 Column           5    1    4               00 r[4]=x.b || '/' || y.b
REG[4] =   s3[8/7](8)
  35 ResultRow        4    1    0               00 output=r[4]
REG[4] =   s3[8/7](8)
  36 SorterNext       2   33    0               00 
  33 SorterData       2   12    5               00 r[12]=data
  34 Column           5    1    4               00 r[4]=x.b || '/' || y.b
REG[4] =   s3[8/8](8)
  35 ResultRow        4    1    0               00 output=r[4]
REG[4] =   s3[8/8](8)
  36 SorterNext       2   33    0               00 
  33 SorterData       2   12    5               00 r[12]=data
  34 Column           5    1    4               00 r[4]=x.b || '/' || y.b
REG[4] =   s3[8/9](8)
  35 ResultRow        4    1    0               00 output=r[4]
REG[4] =   s3[8/9](8)
  36 SorterNext       2   33    0               00 
  37 Return          11    0    0               00 
REG[11] =  i:21
  22 ResetSorter      2    0    0               00 
  23 Move             1    9    2               00 r[9..10]=r[1..2]
REG[9] =  i:9
REG[10] =  i:9
  24 SorterInsert     2    8    3 2             00 key=r[8]
REG[8] =  sx8[0311133131392F31|...119/1]
  25 Next             4    8    0               01 
   8 Column           3    0    6               00 r[6]=a.b
REG[6] =  i:9
   9 Concat           7    6    5               00 r[5]=r[6]+r[7]
REG[7] =   t1[/](8)
REG[6] =  i:9
REG[5] =   s2[9/](8)
  10 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:2
  11 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =  i:2
REG[5] =   s2[9/](8)
REG[4] =   s3[9/2](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:9
  13 Column           3    0    2               00 r[2]=a.b
REG[2] =  i:9
  14 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:2
  15 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:2
  16 Concat           5    6    3               00 r[3]=r[6]+r[5]
REG[5] =  i:2
REG[6] =  i:2
REG[3] =   s2[22](8)
  17 MakeRecord       3    2    8               00 r[8]=mkrec(r[3..4])
REG[8] =  sx8[0311133232392F32|...229/2]
  18 SequenceTest     2   23    0               00 if( cursor[2].ctr++ ) pc = 23
  19 Compare          9    1    2 k(3,B,B,B)    00 r[9..10] <-> r[1..2]
REG[9] =  i:9
REG[1] =  i:9
REG[10] =  i:9
REG[2] =  i:9
  20 Jump            21   24   21               00 
  24 SorterInsert     2    8    3 2             00 key=r[8]
REG[8] =  sx8[0311133232392F32|...229/2]
  25 Next             4    8    0               01 
   8 Column           3    0    6               00 r[6]=a.b
REG[6] =  i:9
   9 Concat           7    6    5               00 r[5]=r[6]+r[7]
REG[7] =   t1[/](8)
REG[6] =  i:9
REG[5] =   s2[9/](8)
  10 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:3
  11 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =  i:3
REG[5] =   s2[9/](8)
REG[4] =   s3[9/3](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:9
  13 Column           3    0    2               00 r[2]=a.b
REG[2] =  i:9
  14 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:3
  15 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:3
  16 Concat           5    6    3               00 r[3]=r[6]+r[5]
REG[5] =  i:3
REG[6] =  i:3
REG[3] =   s2[33](8)
  17 MakeRecord       3    2    8               00 r[8]=mkrec(r[3..4])
REG[8] =  sx8[0311133333392F33|...339/3]
  18 SequenceTest     2   23    0               00 if( cursor[2].ctr++ ) pc = 23
  19 Compare          9    1    2 k(3,B,B,B)    00 r[9..10] <-> r[1..2]
REG[9] =  i:9
REG[1] =  i:9
REG[10] =  i:9
REG[2] =  i:9
  20 Jump            21   24   21               00 
  24 SorterInsert     2    8    3 2             00 key=r[8]
REG[8] =  sx8[0311133333392F33|...339/3]
  25 Next             4    8    0               01 
   8 Column           3    0    6               00 r[6]=a.b
REG[6] =  i:9
   9 Concat           7    6    5               00 r[5]=r[6]+r[7]
REG[7] =   t1[/](8)
REG[6] =  i:9
REG[5] =   s2[9/](8)
  10 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:4
  11 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =  i:4
REG[5] =   s2[9/](8)
REG[4] =   s3[9/4](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:9
  13 Column           3    0    2               00 r[2]=a.b
REG[2] =  i:9
  14 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:4
  15 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:4
  16 Concat           5    6    3               00 r[3]=r[6]+r[5]
REG[5] =  i:4
REG[6] =  i:4
REG[3] =   s2[44](8)
  17 MakeRecord       3    2    8               00 r[8]=mkrec(r[3..4])
REG[8] =  sx8[0311133434392F34|...449/4]
  18 SequenceTest     2   23    0               00 if( cursor[2].ctr++ ) pc = 23
  19 Compare          9    1    2 k(3,B,B,B)    00 r[9..10] <-> r[1..2]
REG[9] =  i:9
REG[1] =  i:9
REG[10] =  i:9
REG[2] =  i:9
  20 Jump            21   24   21               00 
  24 SorterInsert     2    8    3 2             00 key=r[8]
REG[8] =  sx8[0311133434392F34|...449/4]
  25 Next             4    8    0               01 
   8 Column           3    0    6               00 r[6]=a.b
REG[6] =  i:9
   9 Concat           7    6    5               00 r[5]=r[6]+r[7]
REG[7] =   t1[/](8)
REG[6] =  i:9
REG[5] =   s2[9/](8)
  10 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:5
  11 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =  i:5
REG[5] =   s2[9/](8)
REG[4] =   s3[9/5](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:9
  13 Column           3    0    2               00 r[2]=a.b
REG[2] =  i:9
  14 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:5
  15 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:5
  16 Concat           5    6    3               00 r[3]=r[6]+r[5]
REG[5] =  i:5
REG[6] =  i:5
REG[3] =   s2[55](8)
  17 MakeRecord       3    2    8               00 r[8]=mkrec(r[3..4])
REG[8] =  sx8[0311133535392F35|...559/5]
  18 SequenceTest     2   23    0               00 if( cursor[2].ctr++ ) pc = 23
  19 Compare          9    1    2 k(3,B,B,B)    00 r[9..10] <-> r[1..2]
REG[9] =  i:9
REG[1] =  i:9
REG[10] =  i:9
REG[2] =  i:9
  20 Jump            21   24   21               00 
  24 SorterInsert     2    8    3 2             00 key=r[8]
REG[8] =  sx8[0311133535392F35|...559/5]
  25 Next             4    8    0               01 
   8 Column           3    0    6               00 r[6]=a.b
REG[6] =  i:9
   9 Concat           7    6    5               00 r[5]=r[6]+r[7]
REG[7] =   t1[/](8)
REG[6] =  i:9
REG[5] =   s2[9/](8)
  10 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:6
  11 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =  i:6
REG[5] =   s2[9/](8)
REG[4] =   s3[9/6](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:9
  13 Column           3    0    2               00 r[2]=a.b
REG[2] =  i:9
  14 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:6
  15 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:6
  16 Concat           5    6    3               00 r[3]=r[6]+r[5]
REG[5] =  i:6
REG[6] =  i:6
REG[3] =   s2[66](8)
  17 MakeRecord       3    2    8               00 r[8]=mkrec(r[3..4])
REG[8] =  sx8[0311133636392F36|...669/6]
  18 SequenceTest     2   23    0               00 if( cursor[2].ctr++ ) pc = 23
  19 Compare          9    1    2 k(3,B,B,B)    00 r[9..10] <-> r[1..2]
REG[9] =  i:9
REG[1] =  i:9
REG[10] =  i:9
REG[2] =  i:9
  20 Jump            21   24   21               00 
  24 SorterInsert     2    8    3 2             00 key=r[8]
REG[8] =  sx8[0311133636392F36|...669/6]
  25 Next             4    8    0               01 
   8 Column           3    0    6               00 r[6]=a.b
REG[6] =  i:9
   9 Concat           7    6    5               00 r[5]=r[6]+r[7]
REG[7] =   t1[/](8)
REG[6] =  i:9
REG[5] =   s2[9/](8)
  10 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:7
  11 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =  i:7
REG[5] =   s2[9/](8)
REG[4] =   s3[9/7](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:9
  13 Column           3    0    2               00 r[2]=a.b
REG[2] =  i:9
  14 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:7
  15 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:7
  16 Concat           5    6    3               00 r[3]=r[6]+r[5]
REG[5] =  i:7
REG[6] =  i:7
REG[3] =   s2[77](8)
  17 MakeRecord       3    2    8               00 r[8]=mkrec(r[3..4])
REG[8] =  sx8[0311133737392F37|...779/7]
  18 SequenceTest     2   23    0               00 if( cursor[2].ctr++ ) pc = 23
  19 Compare          9    1    2 k(3,B,B,B)    00 r[9..10] <-> r[1..2]
REG[9] =  i:9
REG[1] =  i:9
REG[10] =  i:9
REG[2] =  i:9
  20 Jump            21   24   21               00 
  24 SorterInsert     2    8    3 2             00 key=r[8]
REG[8] =  sx8[0311133737392F37|...779/7]
  25 Next             4    8    0               01 
   8 Column           3    0    6               00 r[6]=a.b
REG[6] =  i:9
   9 Concat           7    6    5               00 r[5]=r[6]+r[7]
REG[7] =   t1[/](8)
REG[6] =  i:9
REG[5] =   s2[9/](8)
  10 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:8
  11 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =  i:8
REG[5] =   s2[9/](8)
REG[4] =   s3[9/8](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:9
  13 Column           3    0    2               00 r[2]=a.b
REG[2] =  i:9
  14 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:8
  15 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:8
  16 Concat           5    6    3               00 r[3]=r[6]+r[5]
REG[5] =  i:8
REG[6] =  i:8
REG[3] =   s2[88](8)
  17 MakeRecord       3    2    8               00 r[8]=mkrec(r[3..4])
REG[8] =  sx8[0311133838392F38|...889/8]
  18 SequenceTest     2   23    0               00 if( cursor[2].ctr++ ) pc = 23
  19 Compare          9    1    2 k(3,B,B,B)    00 r[9..10] <-> r[1..2]
REG[9] =  i:9
REG[1] =  i:9
REG[10] =  i:9
REG[2] =  i:9
  20 Jump            21   24   21               00 
  24 SorterInsert     2    8    3 2             00 key=r[8]
REG[8] =  sx8[0311133838392F38|...889/8]
  25 Next             4    8    0               01 
   8 Column           3    0    6               00 r[6]=a.b
REG[6] =  i:9
   9 Concat           7    6    5               00 r[5]=r[6]+r[7]
REG[7] =   t1[/](8)
REG[6] =  i:9
REG[5] =   s2[9/](8)
  10 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:9
  11 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =  i:9
REG[5] =   s2[9/](8)
REG[4] =   s3[9/9](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:9
  13 Column           3    0    2               00 r[2]=a.b
REG[2] =  i:9
  14 Column           4    0    6               00 r[6]=a.b
REG[6] =  i:9
  15 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:9
  16 Concat           5    6    3               00 r[3]=r[6]+r[5]
REG[5] =  i:9
REG[6] =  i:9
REG[3] =   s2[99](8)
  17 MakeRecord       3    2    8               00 r[8]=mkrec(r[3..4])
REG[8] =  sx8[0311133939392F39|...999/9]
  18 SequenceTest     2   23    0               00 if( cursor[2].ctr++ ) pc = 23
  19 Compare          9    1    2 k(3,B,B,B)    00 r[9..10] <-> r[1..2]
REG[9] =  i:9
REG[1] =  i:9
REG[10] =  i:9
REG[2] =  i:9
  20 Jump            21   24   21               00 
  24 SorterInsert     2    8    3 2             00 key=r[8]
REG[8] =  sx8[0311133939392F39|...999/9]
  25 Next             4    8    0               01 
  26 Next             3    6    0               01 
  27 Explain         27    0    0 USE TEMP B-TREE FOR RIGHT PART OF ORDER BY 00 
  28 Gosub           11   30    0               00 
REG[11] =  i:28
  30 Once             1   32    0               00 
  32 SorterSort       2   38    0               00 
  33 SorterData       2   12    5               00 r[12]=data
  34 Column           5    1    4               00 r[4]=x.b || '/' || y.b
REG[4] =   s3[9/1](8)
  35 ResultRow        4    1    0               00 output=r[4]
REG[4] =   s3[9/1](8)
  36 SorterNext       2   33    0               00 
  33 SorterData       2   12    5               00 r[12]=data
  34 Column           5    1    4               00 r[4]=x.b || '/' || y.b
REG[4] =   s3[9/2](8)
  35 ResultRow        4    1    0               00 output=r[4]
REG[4] =   s3[9/2](8)
  36 SorterNext       2   33    0               00 
  33 SorterData       2   12    5               00 r[12]=data
  34 Column           5    1    4               00 r[4]=x.b || '/' || y.b
REG[4] =   s3[9/3](8)
  35 ResultRow        4    1    0               00 output=r[4]
REG[4] =   s3[9/3](8)
  36 SorterNext       2   33    0               00 
  33 SorterData       2   12    5               00 r[12]=data
  34 Column           5    1    4               00 r[4]=x.b || '/' || y.b
REG[4] =   s3[9/4](8)
  35 ResultRow        4    1    0               00 output=r[4]
REG[4] =   s3[9/4](8)
  36 SorterNext       2   33    0               00 
  33 SorterData       2   12    5               00 r[12]=data
  34 Column           5    1    4               00 r[4]=x.b || '/' || y.b
REG[4] =   s3[9/5](8)
  35 ResultRow        4    1    0               00 output=r[4]
REG[4] =   s3[9/5](8)
  36 SorterNext       2   33    0               00 
  33 SorterData       2   12    5               00 r[12]=data
  34 Column           5    1    4               00 r[4]=x.b || '/' || y.b
REG[4] =   s3[9/6](8)
  35 ResultRow        4    1    0               00 output=r[4]
REG[4] =   s3[9/6](8)
  36 SorterNext       2   33    0               00 
  33 SorterData       2   12    5               00 r[12]=data
  34 Column           5    1    4               00 r[4]=x.b || '/' || y.b
REG[4] =   s3[9/7](8)
  35 ResultRow        4    1    0               00 output=r[4]
REG[4] =   s3[9/7](8)
  36 SorterNext       2   33    0               00 
  33 SorterData       2   12    5               00 r[12]=data
  34 Column           5    1    4               00 r[4]=x.b || '/' || y.b
REG[4] =   s3[9/8](8)
  35 ResultRow        4    1    0               00 output=r[4]
REG[4] =   s3[9/8](8)
  36 SorterNext       2   33    0               00 
  33 SorterData       2   12    5               00 r[12]=data
  34 Column           5    1    4               00 r[4]=x.b || '/' || y.b
REG[4] =   s3[9/9](8)
  35 ResultRow        4    1    0               00 output=r[4]
REG[4] =   s3[9/9](8)
  36 SorterNext       2   33    0               00 
  37 Return          11    0    0               00 
REG[11] =  i:28
  29 Goto             0   38    0               00 
  38 Halt             0    0    0               00 
parser: [[[SELECT x.b || '/' || y.b FROM a x, a y ORDER BY x.b, y.b||y.b DESC
  
;SELECT x.b || '/' || y.b FROM a x, a y ORDER BY x.b, x.b||y.b
  
;SELECT*FROM"temp".sqlite_temp_master ORDER BY rowid
;;
;CREATE TABLE x(y INTEGER PRIMARY KEY, t2i1);ALTER TABLE x ADD t1i1
    
;;
;SELECT x.RowID id FROM a, x WHERE a.b = x.RowID AND id = 2;SELECT*FROM"temp".sqlite_temp_master ORDER BY rowid
;ALTER TABLE x ADD abc
    
;CREATE INDEX c ON a(b)
;CREATE INDEX v1 ON a(b)
;ALTER TABLE ex ADD v2
    
;CREATE TABLE tr1(t1a, t1b);;SELECT y, v2 FROM x, ex WHERE y>v2;;
;SELECT DISTINCT b FROM a LEFT JOIN ex ON b=v2 ORDER BY +v2;CREATE INDEX x1 ON a(b)
;CREATE INDEX z ON a(b)
;CREATE INDEX example ON ex(v2)
;;SELECT count(*) FROM sqlite_master WHERE tbl_name = 'e' AND type = 'index';;
;CREATE TABLE example_idx_00000042(id PRIMARY KEY, UNIQUE(id) );;BEGIN;;CREATE UNIQUE INDEX IF NOT EXISTS a_id ON a(b==0);;SELECT * FROM ex;]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 95 [sclp ::=].
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 419
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'DOT' in state 419
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 77.
parser: ... then shift 'nm', go to state 493
parser: Shift 'DOT', go to state 205
parser: Return. Stack=[SELECT distinct sclp scanpt nm DOT]
parser: Input 'ID' in state 205
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[SELECT distinct sclp scanpt nm DOT ID]
parser: Input 'CONCAT' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 205.
parser: ... then shift 'nm', go to state 536
parser: Reduce 169 [expr ::= nm DOT nm], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Shift 'CONCAT', go to state 113
parser: Return. Stack=[SELECT distinct sclp scanpt expr CONCAT]
parser: Input 'STRING' in state 113
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[SELECT distinct sclp scanpt expr CONCAT STRING]
parser: Input 'CONCAT' in state 539
parser: Reduce 172 [term ::= STRING], go to state 113.
parser: ... then shift 'term', go to state 148
parser: Reduce 190 [expr ::= expr CONCAT expr], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Shift 'CONCAT', go to state 113
parser: Return. Stack=[SELECT distinct sclp scanpt expr CONCAT]
parser: Input 'ID' in state 113
parser: Shift 'ID', go to state 419
parser: Return. Stack=[SELECT distinct sclp scanpt expr CONCAT ID]
parser: Input 'DOT' in state 419
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 113.
parser: ... then shift 'nm', go to state 537
parser: Shift 'DOT', go to state 249
parser: Return. Stack=[SELECT distinct sclp scanpt expr CONCAT nm DOT]
parser: Input 'ID' in state 249
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[SELECT distinct sclp scanpt expr CONCAT nm DOT ID]
parser: Input 'FROM' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 249.
parser: ... then shift 'nm', go to state 536
parser: Reduce 169 [expr ::= nm DOT nm], go to state 113.
parser: ... then shift 'expr', go to state 148
parser: Reduce 190 [expr ::= expr CONCAT expr], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 104 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'ID' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 350
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Shift 'ID', pending reduce 356
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm dbnm ID]
parser: Input 'COMMA' with pending reduce 356
parser: Reduce 356 [as ::= ID|STRING], go to state 243.
parser: ... then shift 'as', go to state 283
parser: Reduce 123 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 349
parser: Reduce 122 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 348
parser: Reduce 127 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 105
parser: Reduce 105 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Shift 'COMMA', pending reduce 117
parser: Return. Stack=[SELECT distinct selcollist FROM seltablist COMMA]
parser: Input 'ID' with pending reduce 117
parser: Reduce 117 [joinop ::= COMMA|JOIN], go to state 263.
parser: ... then shift 'joinop', pending reduce 103
parser: Reduce 103 [stl_prefix ::= seltablist joinop], go to state 197.
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'ID' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 350
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Shift 'ID', pending reduce 356
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm dbnm ID]
parser: Input 'ORDER' with pending reduce 356
parser: Reduce 356 [as ::= ID|STRING], go to state 243.
parser: ... then shift 'as', go to state 283
parser: Reduce 123 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 349
parser: Reduce 122 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 348
parser: Reduce 127 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 105
parser: Reduce 105 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 102 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 363
parser: Reduce 147 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 362
parser: Reduce 138 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 361
parser: Reduce 140 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 517
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 517
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 419
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'DOT' in state 419
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 26.
parser: ... then shift 'nm', go to state 537
parser: Shift 'DOT', go to state 249
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY nm DOT]
parser: Input 'ID' in state 249
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY nm DOT ID]
parser: Input 'COMMA' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 249.
parser: ... then shift 'nm', go to state 536
parser: Reduce 169 [expr ::= nm DOT nm], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 134 [sortorder ::=].
parser: ... then shift 'sortorder', go to state 353
parser: Reduce 137 [nulls ::=].
parser: ... then shift 'nulls', pending reduce 131
parser: Reduce 131 [sortlist ::= expr sortorder nulls], go to state 26.
parser: ... then shift 'sortlist', go to state 516
parser: Shift 'COMMA', go to state 95
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY sortlist COMMA]
parser: Input 'ID' in state 95
parser: Shift 'ID', go to state 419
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY sortlist COMMA ID]
parser: Input 'DOT' in state 419
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 95.
parser: ... then shift 'nm', go to state 537
parser: Shift 'DOT', go to state 249
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY sortlist COMMA nm DOT]
parser: Input 'ID' in state 249
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY sortlist COMMA nm DOT ID]
parser: Input 'CONCAT' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 249.
parser: ... then shift 'nm', go to state 536
parser: Reduce 169 [expr ::= nm DOT nm], go to state 95.
parser: ... then shift 'expr', go to state 14
parser: Shift 'CONCAT', go to state 113
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY sortlist COMMA expr CONCAT]
parser: Input 'ID' in state 113
parser: Shift 'ID', go to state 419
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY sortlist COMMA expr CONCAT ID]
parser: Input 'DOT' in state 419
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 113.
parser: ... then shift 'nm', go to state 537
parser: Shift 'DOT', go to state 249
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY sortlist COMMA expr CONCAT nm DOT]
parser: Input 'ID' in state 249
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY sortlist COMMA expr CONCAT nm DOT ID]
parser: Input 'DESC' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 249.
parser: ... then shift 'nm', go to state 536
parser: FALLBACK DESC => ID
parser: Reduce 169 [expr ::= nm DOT nm], go to state 113.
parser: ... then shift 'expr', go to state 148
parser: FALLBACK DESC => ID
parser: Reduce 190 [expr ::= expr CONCAT expr], go to state 95.
parser: ... then shift 'expr', go to state 14
parser: Shift 'DESC', pending reduce 133
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY sortlist COMMA expr DESC]
parser: Input 'SEMI' with pending reduce 133
parser: Reduce 133 [sortorder ::= DESC], go to state 14.
parser: ... then shift 'sortorder', go to state 354
parser: Reduce 137 [nulls ::=].
parser: ... then shift 'nulls', pending reduce 130
parser: Reduce 130 [sortlist ::= sortlist COMMA expr sortorder nulls], go to state 26.
parser: ... then shift 'sortlist', go to state 516
parser: Reduce 129 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 360
parser: Reduce 142 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 88
parser: Reduce 88 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 83 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 80
parser: Reduce 80 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
SQL: [SELECT x.b || '/' || y.b FROM a x, a y ORDER BY x.b, y.b||y.b DESC
  
;]
VDBE Trace:
   0 Init             0   38    0               00 Start at 38
  38 Transaction      0    0    6 1             01 usesStmtJournal=0
  39 String8          0    6    0 /             00 r[6]='/'
REG[6] =   t1[/](8)
  40 Goto             0    1    0               00 
   1 SorterOpen       2    2    0 k(1,-B)       00 
   2 OpenRead         3    4    0 k(1,B)        00 root=4 iDb=0; i2
   3 OpenRead         4    4    0 k(1,B)        00 root=4 iDb=0; i2
   4 Explain          4    0    0 SCAN TABLE a AS x USING COVERING INDEX i2 00 
   5 Rewind           3   26    1 0             00 
   6 Explain          6    0    0 SCAN TABLE a AS y USING COVERING INDEX i2 00 
   7 Rewind           4   25    1 0             00 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:1
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:1
REG[4] =   s2[1/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:1
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:1
REG[4] =   s2[1/](8)
REG[3] =   s3[1/1](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:1
  13 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:1
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:1
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:1
REG[5] =  i:1
REG[2] =   s2[11](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133131312F31|...111/1]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  22 Move             1    8    1               00 r[8]=r[1]
REG[8] =  i:1
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133131312F31|...111/1]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:1
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:1
REG[4] =   s2[1/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:2
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:2
REG[4] =   s2[1/](8)
REG[3] =   s3[1/2](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:1
  13 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:2
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:2
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:2
REG[5] =  i:2
REG[2] =   s2[22](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133232312F32|...221/2]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:1
REG[1] =  i:1
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133232312F32|...221/2]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:1
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:1
REG[4] =   s2[1/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:3
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:3
REG[4] =   s2[1/](8)
REG[3] =   s3[1/3](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:1
  13 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:3
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:3
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:3
REG[5] =  i:3
REG[2] =   s2[33](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133333312F33|...331/3]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:1
REG[1] =  i:1
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133333312F33|...331/3]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:1
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:1
REG[4] =   s2[1/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:4
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:4
REG[4] =   s2[1/](8)
REG[3] =   s3[1/4](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:1
  13 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:4
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:4
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:4
REG[5] =  i:4
REG[2] =   s2[44](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133434312F34|...441/4]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:1
REG[1] =  i:1
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133434312F34|...441/4]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:1
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:1
REG[4] =   s2[1/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:5
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:5
REG[4] =   s2[1/](8)
REG[3] =   s3[1/5](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:1
  13 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:5
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:5
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:5
REG[5] =  i:5
REG[2] =   s2[55](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133535312F35|...551/5]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:1
REG[1] =  i:1
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133535312F35|...551/5]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:1
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:1
REG[4] =   s2[1/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:6
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:6
REG[4] =   s2[1/](8)
REG[3] =   s3[1/6](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:1
  13 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:6
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:6
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:6
REG[5] =  i:6
REG[2] =   s2[66](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133636312F36|...661/6]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:1
REG[1] =  i:1
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133636312F36|...661/6]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:1
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:1
REG[4] =   s2[1/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:7
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:7
REG[4] =   s2[1/](8)
REG[3] =   s3[1/7](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:1
  13 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:7
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:7
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:7
REG[5] =  i:7
REG[2] =   s2[77](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133737312F37|...771/7]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:1
REG[1] =  i:1
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133737312F37|...771/7]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:1
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:1
REG[4] =   s2[1/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:8
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:8
REG[4] =   s2[1/](8)
REG[3] =   s3[1/8](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:1
  13 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:8
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:8
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:8
REG[5] =  i:8
REG[2] =   s2[88](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133838312F38|...881/8]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:1
REG[1] =  i:1
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133838312F38|...881/8]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:1
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:1
REG[4] =   s2[1/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:9
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:9
REG[4] =   s2[1/](8)
REG[3] =   s3[1/9](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:1
  13 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:9
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:9
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:9
REG[5] =  i:9
REG[2] =   s2[99](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133939312F39|...991/9]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:1
REG[1] =  i:1
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133939312F39|...991/9]
  24 Next             4    8    0               01 
  25 Next             3    6    0               01 
   6 Explain          6    0    0 SCAN TABLE a AS y USING COVERING INDEX i2 00 
   7 Rewind           4   25    1 0             00 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:2
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:2
REG[4] =   s2[2/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:1
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:1
REG[4] =   s2[2/](8)
REG[3] =   s3[2/1](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:2
  13 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:1
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:1
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:1
REG[5] =  i:1
REG[2] =   s2[11](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133131322F31|...112/1]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:1
REG[1] =  i:2
  19 Jump            20   23   20               00 
  20 Gosub            9   29    0               00 
REG[9] =  i:20
  29 Once             0   31    0               00 
  30 OpenPseudo       5   10    3               00 3 columns in r[10]
  31 SorterSort       2   37    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[1/9](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[1/9](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[1/8](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[1/8](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[1/7](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[1/7](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[1/6](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[1/6](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[1/5](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[1/5](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[1/4](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[1/4](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[1/3](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[1/3](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[1/2](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[1/2](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[1/1](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[1/1](8)
  35 SorterNext       2   32    0               00 
  36 Return           9    0    0               00 
REG[9] =  i:20
  21 ResetSorter      2    0    0               00 
  22 Move             1    8    1               00 r[8]=r[1]
REG[8] =  i:2
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133131322F31|...112/1]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:2
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:2
REG[4] =   s2[2/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:2
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:2
REG[4] =   s2[2/](8)
REG[3] =   s3[2/2](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:2
  13 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:2
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:2
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:2
REG[5] =  i:2
REG[2] =   s2[22](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133232322F32|...222/2]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:2
REG[1] =  i:2
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133232322F32|...222/2]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:2
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:2
REG[4] =   s2[2/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:3
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:3
REG[4] =   s2[2/](8)
REG[3] =   s3[2/3](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:2
  13 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:3
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:3
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:3
REG[5] =  i:3
REG[2] =   s2[33](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133333322F33|...332/3]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:2
REG[1] =  i:2
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133333322F33|...332/3]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:2
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:2
REG[4] =   s2[2/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:4
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:4
REG[4] =   s2[2/](8)
REG[3] =   s3[2/4](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:2
  13 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:4
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:4
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:4
REG[5] =  i:4
REG[2] =   s2[44](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133434322F34|...442/4]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:2
REG[1] =  i:2
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133434322F34|...442/4]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:2
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:2
REG[4] =   s2[2/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:5
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:5
REG[4] =   s2[2/](8)
REG[3] =   s3[2/5](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:2
  13 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:5
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:5
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:5
REG[5] =  i:5
REG[2] =   s2[55](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133535322F35|...552/5]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:2
REG[1] =  i:2
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133535322F35|...552/5]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:2
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:2
REG[4] =   s2[2/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:6
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:6
REG[4] =   s2[2/](8)
REG[3] =   s3[2/6](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:2
  13 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:6
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:6
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:6
REG[5] =  i:6
REG[2] =   s2[66](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133636322F36|...662/6]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:2
REG[1] =  i:2
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133636322F36|...662/6]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:2
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:2
REG[4] =   s2[2/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:7
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:7
REG[4] =   s2[2/](8)
REG[3] =   s3[2/7](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:2
  13 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:7
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:7
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:7
REG[5] =  i:7
REG[2] =   s2[77](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133737322F37|...772/7]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:2
REG[1] =  i:2
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133737322F37|...772/7]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:2
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:2
REG[4] =   s2[2/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:8
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:8
REG[4] =   s2[2/](8)
REG[3] =   s3[2/8](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:2
  13 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:8
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:8
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:8
REG[5] =  i:8
REG[2] =   s2[88](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133838322F38|...882/8]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:2
REG[1] =  i:2
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133838322F38|...882/8]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:2
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:2
REG[4] =   s2[2/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:9
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:9
REG[4] =   s2[2/](8)
REG[3] =   s3[2/9](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:2
  13 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:9
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:9
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:9
REG[5] =  i:9
REG[2] =   s2[99](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133939322F39|...992/9]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:2
REG[1] =  i:2
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133939322F39|...992/9]
  24 Next             4    8    0               01 
  25 Next             3    6    0               01 
   6 Explain          6    0    0 SCAN TABLE a AS y USING COVERING INDEX i2 00 
   7 Rewind           4   25    1 0             00 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:3
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:3
REG[4] =   s2[3/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:1
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:1
REG[4] =   s2[3/](8)
REG[3] =   s3[3/1](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:3
  13 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:1
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:1
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:1
REG[5] =  i:1
REG[2] =   s2[11](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133131332F31|...113/1]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:2
REG[1] =  i:3
  19 Jump            20   23   20               00 
  20 Gosub            9   29    0               00 
REG[9] =  i:20
  29 Once             1   31    0               00 
  31 SorterSort       2   37    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[2/9](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[2/9](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[2/8](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[2/8](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[2/7](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[2/7](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[2/6](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[2/6](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[2/5](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[2/5](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[2/4](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[2/4](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[2/3](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[2/3](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[2/2](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[2/2](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[2/1](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[2/1](8)
  35 SorterNext       2   32    0               00 
  36 Return           9    0    0               00 
REG[9] =  i:20
  21 ResetSorter      2    0    0               00 
  22 Move             1    8    1               00 r[8]=r[1]
REG[8] =  i:3
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133131332F31|...113/1]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:3
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:3
REG[4] =   s2[3/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:2
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:2
REG[4] =   s2[3/](8)
REG[3] =   s3[3/2](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:3
  13 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:2
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:2
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:2
REG[5] =  i:2
REG[2] =   s2[22](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133232332F32|...223/2]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:3
REG[1] =  i:3
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133232332F32|...223/2]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:3
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:3
REG[4] =   s2[3/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:3
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:3
REG[4] =   s2[3/](8)
REG[3] =   s3[3/3](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:3
  13 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:3
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:3
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:3
REG[5] =  i:3
REG[2] =   s2[33](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133333332F33|...333/3]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:3
REG[1] =  i:3
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133333332F33|...333/3]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:3
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:3
REG[4] =   s2[3/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:4
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:4
REG[4] =   s2[3/](8)
REG[3] =   s3[3/4](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:3
  13 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:4
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:4
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:4
REG[5] =  i:4
REG[2] =   s2[44](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133434332F34|...443/4]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:3
REG[1] =  i:3
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133434332F34|...443/4]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:3
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:3
REG[4] =   s2[3/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:5
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:5
REG[4] =   s2[3/](8)
REG[3] =   s3[3/5](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:3
  13 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:5
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:5
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:5
REG[5] =  i:5
REG[2] =   s2[55](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133535332F35|...553/5]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:3
REG[1] =  i:3
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133535332F35|...553/5]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:3
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:3
REG[4] =   s2[3/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:6
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:6
REG[4] =   s2[3/](8)
REG[3] =   s3[3/6](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:3
  13 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:6
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:6
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:6
REG[5] =  i:6
REG[2] =   s2[66](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133636332F36|...663/6]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:3
REG[1] =  i:3
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133636332F36|...663/6]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:3
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:3
REG[4] =   s2[3/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:7
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:7
REG[4] =   s2[3/](8)
REG[3] =   s3[3/7](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:3
  13 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:7
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:7
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:7
REG[5] =  i:7
REG[2] =   s2[77](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133737332F37|...773/7]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:3
REG[1] =  i:3
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133737332F37|...773/7]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:3
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:3
REG[4] =   s2[3/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:8
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:8
REG[4] =   s2[3/](8)
REG[3] =   s3[3/8](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:3
  13 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:8
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:8
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:8
REG[5] =  i:8
REG[2] =   s2[88](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133838332F38|...883/8]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:3
REG[1] =  i:3
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133838332F38|...883/8]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:3
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:3
REG[4] =   s2[3/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:9
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:9
REG[4] =   s2[3/](8)
REG[3] =   s3[3/9](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:3
  13 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:9
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:9
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:9
REG[5] =  i:9
REG[2] =   s2[99](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133939332F39|...993/9]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:3
REG[1] =  i:3
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133939332F39|...993/9]
  24 Next             4    8    0               01 
  25 Next             3    6    0               01 
   6 Explain          6    0    0 SCAN TABLE a AS y USING COVERING INDEX i2 00 
   7 Rewind           4   25    1 0             00 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:4
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:4
REG[4] =   s2[4/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:1
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:1
REG[4] =   s2[4/](8)
REG[3] =   s3[4/1](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:4
  13 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:1
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:1
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:1
REG[5] =  i:1
REG[2] =   s2[11](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133131342F31|...114/1]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:3
REG[1] =  i:4
  19 Jump            20   23   20               00 
  20 Gosub            9   29    0               00 
REG[9] =  i:20
  29 Once             1   31    0               00 
  31 SorterSort       2   37    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[3/9](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[3/9](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[3/8](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[3/8](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[3/7](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[3/7](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[3/6](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[3/6](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[3/5](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[3/5](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[3/4](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[3/4](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[3/3](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[3/3](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[3/2](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[3/2](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[3/1](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[3/1](8)
  35 SorterNext       2   32    0               00 
  36 Return           9    0    0               00 
REG[9] =  i:20
  21 ResetSorter      2    0    0               00 
  22 Move             1    8    1               00 r[8]=r[1]
REG[8] =  i:4
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133131342F31|...114/1]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:4
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:4
REG[4] =   s2[4/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:2
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:2
REG[4] =   s2[4/](8)
REG[3] =   s3[4/2](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:4
  13 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:2
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:2
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:2
REG[5] =  i:2
REG[2] =   s2[22](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133232342F32|...224/2]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:4
REG[1] =  i:4
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133232342F32|...224/2]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:4
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:4
REG[4] =   s2[4/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:3
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:3
REG[4] =   s2[4/](8)
REG[3] =   s3[4/3](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:4
  13 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:3
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:3
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:3
REG[5] =  i:3
REG[2] =   s2[33](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133333342F33|...334/3]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:4
REG[1] =  i:4
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133333342F33|...334/3]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:4
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:4
REG[4] =   s2[4/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:4
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:4
REG[4] =   s2[4/](8)
REG[3] =   s3[4/4](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:4
  13 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:4
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:4
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:4
REG[5] =  i:4
REG[2] =   s2[44](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133434342F34|...444/4]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:4
REG[1] =  i:4
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133434342F34|...444/4]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:4
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:4
REG[4] =   s2[4/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:5
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:5
REG[4] =   s2[4/](8)
REG[3] =   s3[4/5](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:4
  13 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:5
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:5
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:5
REG[5] =  i:5
REG[2] =   s2[55](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133535342F35|...554/5]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:4
REG[1] =  i:4
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133535342F35|...554/5]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:4
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:4
REG[4] =   s2[4/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:6
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:6
REG[4] =   s2[4/](8)
REG[3] =   s3[4/6](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:4
  13 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:6
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:6
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:6
REG[5] =  i:6
REG[2] =   s2[66](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133636342F36|...664/6]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:4
REG[1] =  i:4
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133636342F36|...664/6]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:4
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:4
REG[4] =   s2[4/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:7
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:7
REG[4] =   s2[4/](8)
REG[3] =   s3[4/7](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:4
  13 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:7
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:7
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:7
REG[5] =  i:7
REG[2] =   s2[77](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133737342F37|...774/7]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:4
REG[1] =  i:4
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133737342F37|...774/7]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:4
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:4
REG[4] =   s2[4/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:8
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:8
REG[4] =   s2[4/](8)
REG[3] =   s3[4/8](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:4
  13 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:8
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:8
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:8
REG[5] =  i:8
REG[2] =   s2[88](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133838342F38|...884/8]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:4
REG[1] =  i:4
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133838342F38|...884/8]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:4
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:4
REG[4] =   s2[4/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:9
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:9
REG[4] =   s2[4/](8)
REG[3] =   s3[4/9](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:4
  13 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:9
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:9
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:9
REG[5] =  i:9
REG[2] =   s2[99](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133939342F39|...994/9]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:4
REG[1] =  i:4
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133939342F39|...994/9]
  24 Next             4    8    0               01 
  25 Next             3    6    0               01 
   6 Explain          6    0    0 SCAN TABLE a AS y USING COVERING INDEX i2 00 
   7 Rewind           4   25    1 0             00 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:5
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:5
REG[4] =   s2[5/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:1
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:1
REG[4] =   s2[5/](8)
REG[3] =   s3[5/1](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:5
  13 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:1
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:1
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:1
REG[5] =  i:1
REG[2] =   s2[11](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133131352F31|...115/1]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:4
REG[1] =  i:5
  19 Jump            20   23   20               00 
  20 Gosub            9   29    0               00 
REG[9] =  i:20
  29 Once             1   31    0               00 
  31 SorterSort       2   37    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[4/9](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[4/9](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[4/8](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[4/8](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[4/7](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[4/7](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[4/6](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[4/6](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[4/5](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[4/5](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[4/4](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[4/4](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[4/3](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[4/3](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[4/2](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[4/2](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[4/1](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[4/1](8)
  35 SorterNext       2   32    0               00 
  36 Return           9    0    0               00 
REG[9] =  i:20
  21 ResetSorter      2    0    0               00 
  22 Move             1    8    1               00 r[8]=r[1]
REG[8] =  i:5
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133131352F31|...115/1]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:5
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:5
REG[4] =   s2[5/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:2
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:2
REG[4] =   s2[5/](8)
REG[3] =   s3[5/2](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:5
  13 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:2
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:2
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:2
REG[5] =  i:2
REG[2] =   s2[22](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133232352F32|...225/2]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:5
REG[1] =  i:5
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133232352F32|...225/2]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:5
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:5
REG[4] =   s2[5/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:3
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:3
REG[4] =   s2[5/](8)
REG[3] =   s3[5/3](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:5
  13 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:3
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:3
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:3
REG[5] =  i:3
REG[2] =   s2[33](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133333352F33|...335/3]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:5
REG[1] =  i:5
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133333352F33|...335/3]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:5
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:5
REG[4] =   s2[5/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:4
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:4
REG[4] =   s2[5/](8)
REG[3] =   s3[5/4](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:5
  13 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:4
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:4
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:4
REG[5] =  i:4
REG[2] =   s2[44](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133434352F34|...445/4]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:5
REG[1] =  i:5
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133434352F34|...445/4]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:5
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:5
REG[4] =   s2[5/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:5
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:5
REG[4] =   s2[5/](8)
REG[3] =   s3[5/5](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:5
  13 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:5
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:5
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:5
REG[5] =  i:5
REG[2] =   s2[55](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133535352F35|...555/5]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:5
REG[1] =  i:5
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133535352F35|...555/5]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:5
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:5
REG[4] =   s2[5/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:6
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:6
REG[4] =   s2[5/](8)
REG[3] =   s3[5/6](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:5
  13 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:6
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:6
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:6
REG[5] =  i:6
REG[2] =   s2[66](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133636352F36|...665/6]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:5
REG[1] =  i:5
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133636352F36|...665/6]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:5
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:5
REG[4] =   s2[5/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:7
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:7
REG[4] =   s2[5/](8)
REG[3] =   s3[5/7](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:5
  13 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:7
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:7
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:7
REG[5] =  i:7
REG[2] =   s2[77](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133737352F37|...775/7]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:5
REG[1] =  i:5
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133737352F37|...775/7]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:5
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:5
REG[4] =   s2[5/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:8
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:8
REG[4] =   s2[5/](8)
REG[3] =   s3[5/8](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:5
  13 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:8
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:8
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:8
REG[5] =  i:8
REG[2] =   s2[88](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133838352F38|...885/8]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:5
REG[1] =  i:5
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133838352F38|...885/8]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:5
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:5
REG[4] =   s2[5/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:9
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:9
REG[4] =   s2[5/](8)
REG[3] =   s3[5/9](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:5
  13 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:9
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:9
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:9
REG[5] =  i:9
REG[2] =   s2[99](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133939352F39|...995/9]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:5
REG[1] =  i:5
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133939352F39|...995/9]
  24 Next             4    8    0               01 
  25 Next             3    6    0               01 
   6 Explain          6    0    0 SCAN TABLE a AS y USING COVERING INDEX i2 00 
   7 Rewind           4   25    1 0             00 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:6
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:6
REG[4] =   s2[6/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:1
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:1
REG[4] =   s2[6/](8)
REG[3] =   s3[6/1](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:6
  13 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:1
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:1
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:1
REG[5] =  i:1
REG[2] =   s2[11](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133131362F31|...116/1]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:5
REG[1] =  i:6
  19 Jump            20   23   20               00 
  20 Gosub            9   29    0               00 
REG[9] =  i:20
  29 Once             1   31    0               00 
  31 SorterSort       2   37    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[5/9](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[5/9](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[5/8](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[5/8](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[5/7](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[5/7](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[5/6](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[5/6](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[5/5](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[5/5](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[5/4](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[5/4](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[5/3](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[5/3](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[5/2](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[5/2](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[5/1](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[5/1](8)
  35 SorterNext       2   32    0               00 
  36 Return           9    0    0               00 
REG[9] =  i:20
  21 ResetSorter      2    0    0               00 
  22 Move             1    8    1               00 r[8]=r[1]
REG[8] =  i:6
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133131362F31|...116/1]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:6
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:6
REG[4] =   s2[6/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:2
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:2
REG[4] =   s2[6/](8)
REG[3] =   s3[6/2](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:6
  13 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:2
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:2
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:2
REG[5] =  i:2
REG[2] =   s2[22](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133232362F32|...226/2]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:6
REG[1] =  i:6
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133232362F32|...226/2]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:6
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:6
REG[4] =   s2[6/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:3
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:3
REG[4] =   s2[6/](8)
REG[3] =   s3[6/3](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:6
  13 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:3
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:3
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:3
REG[5] =  i:3
REG[2] =   s2[33](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133333362F33|...336/3]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:6
REG[1] =  i:6
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133333362F33|...336/3]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:6
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:6
REG[4] =   s2[6/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:4
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:4
REG[4] =   s2[6/](8)
REG[3] =   s3[6/4](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:6
  13 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:4
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:4
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:4
REG[5] =  i:4
REG[2] =   s2[44](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133434362F34|...446/4]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:6
REG[1] =  i:6
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133434362F34|...446/4]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:6
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:6
REG[4] =   s2[6/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:5
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:5
REG[4] =   s2[6/](8)
REG[3] =   s3[6/5](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:6
  13 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:5
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:5
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:5
REG[5] =  i:5
REG[2] =   s2[55](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133535362F35|...556/5]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:6
REG[1] =  i:6
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133535362F35|...556/5]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:6
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:6
REG[4] =   s2[6/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:6
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:6
REG[4] =   s2[6/](8)
REG[3] =   s3[6/6](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:6
  13 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:6
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:6
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:6
REG[5] =  i:6
REG[2] =   s2[66](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133636362F36|...666/6]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:6
REG[1] =  i:6
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133636362F36|...666/6]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:6
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:6
REG[4] =   s2[6/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:7
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:7
REG[4] =   s2[6/](8)
REG[3] =   s3[6/7](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:6
  13 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:7
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:7
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:7
REG[5] =  i:7
REG[2] =   s2[77](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133737362F37|...776/7]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:6
REG[1] =  i:6
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133737362F37|...776/7]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:6
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:6
REG[4] =   s2[6/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:8
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:8
REG[4] =   s2[6/](8)
REG[3] =   s3[6/8](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:6
  13 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:8
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:8
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:8
REG[5] =  i:8
REG[2] =   s2[88](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133838362F38|...886/8]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:6
REG[1] =  i:6
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133838362F38|...886/8]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:6
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:6
REG[4] =   s2[6/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:9
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:9
REG[4] =   s2[6/](8)
REG[3] =   s3[6/9](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:6
  13 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:9
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:9
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:9
REG[5] =  i:9
REG[2] =   s2[99](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133939362F39|...996/9]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:6
REG[1] =  i:6
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133939362F39|...996/9]
  24 Next             4    8    0               01 
  25 Next             3    6    0               01 
   6 Explain          6    0    0 SCAN TABLE a AS y USING COVERING INDEX i2 00 
   7 Rewind           4   25    1 0             00 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:7
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:7
REG[4] =   s2[7/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:1
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:1
REG[4] =   s2[7/](8)
REG[3] =   s3[7/1](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:7
  13 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:1
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:1
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:1
REG[5] =  i:1
REG[2] =   s2[11](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133131372F31|...117/1]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:6
REG[1] =  i:7
  19 Jump            20   23   20               00 
  20 Gosub            9   29    0               00 
REG[9] =  i:20
  29 Once             1   31    0               00 
  31 SorterSort       2   37    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[6/9](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[6/9](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[6/8](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[6/8](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[6/7](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[6/7](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[6/6](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[6/6](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[6/5](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[6/5](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[6/4](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[6/4](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[6/3](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[6/3](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[6/2](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[6/2](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[6/1](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[6/1](8)
  35 SorterNext       2   32    0               00 
  36 Return           9    0    0               00 
REG[9] =  i:20
  21 ResetSorter      2    0    0               00 
  22 Move             1    8    1               00 r[8]=r[1]
REG[8] =  i:7
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133131372F31|...117/1]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:7
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:7
REG[4] =   s2[7/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:2
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:2
REG[4] =   s2[7/](8)
REG[3] =   s3[7/2](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:7
  13 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:2
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:2
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:2
REG[5] =  i:2
REG[2] =   s2[22](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133232372F32|...227/2]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:7
REG[1] =  i:7
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133232372F32|...227/2]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:7
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:7
REG[4] =   s2[7/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:3
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:3
REG[4] =   s2[7/](8)
REG[3] =   s3[7/3](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:7
  13 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:3
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:3
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:3
REG[5] =  i:3
REG[2] =   s2[33](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133333372F33|...337/3]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:7
REG[1] =  i:7
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133333372F33|...337/3]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:7
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:7
REG[4] =   s2[7/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:4
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:4
REG[4] =   s2[7/](8)
REG[3] =   s3[7/4](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:7
  13 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:4
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:4
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:4
REG[5] =  i:4
REG[2] =   s2[44](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133434372F34|...447/4]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:7
REG[1] =  i:7
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133434372F34|...447/4]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:7
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:7
REG[4] =   s2[7/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:5
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:5
REG[4] =   s2[7/](8)
REG[3] =   s3[7/5](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:7
  13 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:5
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:5
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:5
REG[5] =  i:5
REG[2] =   s2[55](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133535372F35|...557/5]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:7
REG[1] =  i:7
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133535372F35|...557/5]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:7
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:7
REG[4] =   s2[7/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:6
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:6
REG[4] =   s2[7/](8)
REG[3] =   s3[7/6](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:7
  13 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:6
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:6
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:6
REG[5] =  i:6
REG[2] =   s2[66](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133636372F36|...667/6]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:7
REG[1] =  i:7
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133636372F36|...667/6]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:7
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:7
REG[4] =   s2[7/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:7
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:7
REG[4] =   s2[7/](8)
REG[3] =   s3[7/7](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:7
  13 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:7
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:7
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:7
REG[5] =  i:7
REG[2] =   s2[77](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133737372F37|...777/7]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:7
REG[1] =  i:7
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133737372F37|...777/7]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:7
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:7
REG[4] =   s2[7/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:8
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:8
REG[4] =   s2[7/](8)
REG[3] =   s3[7/8](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:7
  13 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:8
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:8
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:8
REG[5] =  i:8
REG[2] =   s2[88](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133838372F38|...887/8]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:7
REG[1] =  i:7
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133838372F38|...887/8]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:7
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:7
REG[4] =   s2[7/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:9
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:9
REG[4] =   s2[7/](8)
REG[3] =   s3[7/9](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:7
  13 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:9
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:9
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:9
REG[5] =  i:9
REG[2] =   s2[99](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133939372F39|...997/9]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:7
REG[1] =  i:7
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133939372F39|...997/9]
  24 Next             4    8    0               01 
  25 Next             3    6    0               01 
   6 Explain          6    0    0 SCAN TABLE a AS y USING COVERING INDEX i2 00 
   7 Rewind           4   25    1 0             00 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:8
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:8
REG[4] =   s2[8/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:1
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:1
REG[4] =   s2[8/](8)
REG[3] =   s3[8/1](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:8
  13 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:1
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:1
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:1
REG[5] =  i:1
REG[2] =   s2[11](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133131382F31|...118/1]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:7
REG[1] =  i:8
  19 Jump            20   23   20               00 
  20 Gosub            9   29    0               00 
REG[9] =  i:20
  29 Once             1   31    0               00 
  31 SorterSort       2   37    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[7/9](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[7/9](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[7/8](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[7/8](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[7/7](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[7/7](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[7/6](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[7/6](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[7/5](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[7/5](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[7/4](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[7/4](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[7/3](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[7/3](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[7/2](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[7/2](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[7/1](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[7/1](8)
  35 SorterNext       2   32    0               00 
  36 Return           9    0    0               00 
REG[9] =  i:20
  21 ResetSorter      2    0    0               00 
  22 Move             1    8    1               00 r[8]=r[1]
REG[8] =  i:8
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133131382F31|...118/1]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:8
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:8
REG[4] =   s2[8/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:2
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:2
REG[4] =   s2[8/](8)
REG[3] =   s3[8/2](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:8
  13 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:2
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:2
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:2
REG[5] =  i:2
REG[2] =   s2[22](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133232382F32|...228/2]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:8
REG[1] =  i:8
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133232382F32|...228/2]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:8
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:8
REG[4] =   s2[8/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:3
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:3
REG[4] =   s2[8/](8)
REG[3] =   s3[8/3](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:8
  13 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:3
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:3
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:3
REG[5] =  i:3
REG[2] =   s2[33](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133333382F33|...338/3]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:8
REG[1] =  i:8
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133333382F33|...338/3]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:8
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:8
REG[4] =   s2[8/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:4
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:4
REG[4] =   s2[8/](8)
REG[3] =   s3[8/4](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:8
  13 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:4
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:4
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:4
REG[5] =  i:4
REG[2] =   s2[44](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133434382F34|...448/4]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:8
REG[1] =  i:8
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133434382F34|...448/4]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:8
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:8
REG[4] =   s2[8/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:5
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:5
REG[4] =   s2[8/](8)
REG[3] =   s3[8/5](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:8
  13 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:5
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:5
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:5
REG[5] =  i:5
REG[2] =   s2[55](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133535382F35|...558/5]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:8
REG[1] =  i:8
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133535382F35|...558/5]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:8
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:8
REG[4] =   s2[8/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:6
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:6
REG[4] =   s2[8/](8)
REG[3] =   s3[8/6](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:8
  13 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:6
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:6
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:6
REG[5] =  i:6
REG[2] =   s2[66](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133636382F36|...668/6]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:8
REG[1] =  i:8
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133636382F36|...668/6]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:8
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:8
REG[4] =   s2[8/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:7
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:7
REG[4] =   s2[8/](8)
REG[3] =   s3[8/7](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:8
  13 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:7
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:7
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:7
REG[5] =  i:7
REG[2] =   s2[77](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133737382F37|...778/7]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:8
REG[1] =  i:8
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133737382F37|...778/7]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:8
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:8
REG[4] =   s2[8/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:8
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:8
REG[4] =   s2[8/](8)
REG[3] =   s3[8/8](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:8
  13 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:8
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:8
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:8
REG[5] =  i:8
REG[2] =   s2[88](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133838382F38|...888/8]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:8
REG[1] =  i:8
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133838382F38|...888/8]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:8
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:8
REG[4] =   s2[8/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:9
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:9
REG[4] =   s2[8/](8)
REG[3] =   s3[8/9](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:8
  13 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:9
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:9
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:9
REG[5] =  i:9
REG[2] =   s2[99](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133939382F39|...998/9]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:8
REG[1] =  i:8
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133939382F39|...998/9]
  24 Next             4    8    0               01 
  25 Next             3    6    0               01 
   6 Explain          6    0    0 SCAN TABLE a AS y USING COVERING INDEX i2 00 
   7 Rewind           4   25    1 0             00 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:9
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:9
REG[4] =   s2[9/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:1
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:1
REG[4] =   s2[9/](8)
REG[3] =   s3[9/1](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:9
  13 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:1
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:1
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:1
REG[5] =  i:1
REG[2] =   s2[11](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133131392F31|...119/1]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:8
REG[1] =  i:9
  19 Jump            20   23   20               00 
  20 Gosub            9   29    0               00 
REG[9] =  i:20
  29 Once             1   31    0               00 
  31 SorterSort       2   37    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[8/9](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[8/9](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[8/8](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[8/8](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[8/7](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[8/7](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[8/6](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[8/6](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[8/5](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[8/5](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[8/4](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[8/4](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[8/3](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[8/3](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[8/2](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[8/2](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[8/1](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[8/1](8)
  35 SorterNext       2   32    0               00 
  36 Return           9    0    0               00 
REG[9] =  i:20
  21 ResetSorter      2    0    0               00 
  22 Move             1    8    1               00 r[8]=r[1]
REG[8] =  i:9
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133131392F31|...119/1]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:9
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:9
REG[4] =   s2[9/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:2
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:2
REG[4] =   s2[9/](8)
REG[3] =   s3[9/2](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:9
  13 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:2
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:2
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:2
REG[5] =  i:2
REG[2] =   s2[22](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133232392F32|...229/2]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:9
REG[1] =  i:9
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133232392F32|...229/2]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:9
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:9
REG[4] =   s2[9/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:3
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:3
REG[4] =   s2[9/](8)
REG[3] =   s3[9/3](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:9
  13 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:3
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:3
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:3
REG[5] =  i:3
REG[2] =   s2[33](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133333392F33|...339/3]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:9
REG[1] =  i:9
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133333392F33|...339/3]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:9
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:9
REG[4] =   s2[9/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:4
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:4
REG[4] =   s2[9/](8)
REG[3] =   s3[9/4](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:9
  13 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:4
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:4
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:4
REG[5] =  i:4
REG[2] =   s2[44](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133434392F34|...449/4]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:9
REG[1] =  i:9
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133434392F34|...449/4]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:9
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:9
REG[4] =   s2[9/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:5
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:5
REG[4] =   s2[9/](8)
REG[3] =   s3[9/5](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:9
  13 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:5
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:5
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:5
REG[5] =  i:5
REG[2] =   s2[55](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133535392F35|...559/5]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:9
REG[1] =  i:9
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133535392F35|...559/5]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:9
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:9
REG[4] =   s2[9/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:6
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:6
REG[4] =   s2[9/](8)
REG[3] =   s3[9/6](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:9
  13 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:6
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:6
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:6
REG[5] =  i:6
REG[2] =   s2[66](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133636392F36|...669/6]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:9
REG[1] =  i:9
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133636392F36|...669/6]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:9
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:9
REG[4] =   s2[9/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:7
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:7
REG[4] =   s2[9/](8)
REG[3] =   s3[9/7](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:9
  13 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:7
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:7
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:7
REG[5] =  i:7
REG[2] =   s2[77](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133737392F37|...779/7]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:9
REG[1] =  i:9
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133737392F37|...779/7]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:9
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:9
REG[4] =   s2[9/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:8
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:8
REG[4] =   s2[9/](8)
REG[3] =   s3[9/8](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:9
  13 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:8
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:8
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:8
REG[5] =  i:8
REG[2] =   s2[88](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133838392F38|...889/8]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:9
REG[1] =  i:9
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133838392F38|...889/8]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:9
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:9
REG[4] =   s2[9/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:9
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:9
REG[4] =   s2[9/](8)
REG[3] =   s3[9/9](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:9
  13 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:9
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:9
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:9
REG[5] =  i:9
REG[2] =   s2[99](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133939392F39|...999/9]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:9
REG[1] =  i:9
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133939392F39|...999/9]
  24 Next             4    8    0               01 
  25 Next             3    6    0               01 
  26 Explain         26    0    0 USE TEMP B-TREE FOR RIGHT PART OF ORDER BY 00 
  27 Gosub            9   29    0               00 
REG[9] =  i:27
  29 Once             1   31    0               00 
  31 SorterSort       2   37    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[9/9](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[9/9](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[9/8](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[9/8](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[9/7](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[9/7](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[9/6](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[9/6](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[9/5](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[9/5](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[9/4](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[9/4](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[9/3](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[9/3](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[9/2](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[9/2](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[9/1](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[9/1](8)
  35 SorterNext       2   32    0               00 
  36 Return           9    0    0               00 
REG[9] =  i:27
  28 Goto             0   37    0               00 
  37 Halt             0    0    0               00 
parser: [[[SELECT x.b || '/' || y.b FROM a x, a y ORDER BY x.b, x.b||y.b
  
;SELECT*FROM"temp".sqlite_temp_master ORDER BY rowid
;;
;CREATE TABLE x(y INTEGER PRIMARY KEY, t2i1);ALTER TABLE x ADD t1i1
    
;;
;SELECT x.RowID id FROM a, x WHERE a.b = x.RowID AND id = 2;SELECT*FROM"temp".sqlite_temp_master ORDER BY rowid
;ALTER TABLE x ADD abc
    
;CREATE INDEX c ON a(b)
;CREATE INDEX v1 ON a(b)
;ALTER TABLE ex ADD v2
    
;CREATE TABLE tr1(t1a, t1b);;SELECT y, v2 FROM x, ex WHERE y>v2;;
;SELECT DISTINCT b FROM a LEFT JOIN ex ON b=v2 ORDER BY +v2;CREATE INDEX x1 ON a(b)
;CREATE INDEX z ON a(b)
;CREATE INDEX example ON ex(v2)
;;SELECT count(*) FROM sqlite_master WHERE tbl_name = 'e' AND type = 'index';;
;CREATE TABLE example_idx_00000042(id PRIMARY KEY, UNIQUE(id) );;BEGIN;;CREATE UNIQUE INDEX IF NOT EXISTS a_id ON a(b==0);;SELECT * FROM ex;]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'ID' in state 288
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 95 [sclp ::=].
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 419
parser: Return. Stack=[SELECT distinct sclp scanpt ID]
parser: Input 'DOT' in state 419
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 77.
parser: ... then shift 'nm', go to state 493
parser: Shift 'DOT', go to state 205
parser: Return. Stack=[SELECT distinct sclp scanpt nm DOT]
parser: Input 'ID' in state 205
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[SELECT distinct sclp scanpt nm DOT ID]
parser: Input 'CONCAT' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 205.
parser: ... then shift 'nm', go to state 536
parser: Reduce 169 [expr ::= nm DOT nm], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Shift 'CONCAT', go to state 113
parser: Return. Stack=[SELECT distinct sclp scanpt expr CONCAT]
parser: Input 'STRING' in state 113
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[SELECT distinct sclp scanpt expr CONCAT STRING]
parser: Input 'CONCAT' in state 539
parser: Reduce 172 [term ::= STRING], go to state 113.
parser: ... then shift 'term', go to state 148
parser: Reduce 190 [expr ::= expr CONCAT expr], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Shift 'CONCAT', go to state 113
parser: Return. Stack=[SELECT distinct sclp scanpt expr CONCAT]
parser: Input 'ID' in state 113
parser: Shift 'ID', go to state 419
parser: Return. Stack=[SELECT distinct sclp scanpt expr CONCAT ID]
parser: Input 'DOT' in state 419
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 113.
parser: ... then shift 'nm', go to state 537
parser: Shift 'DOT', go to state 249
parser: Return. Stack=[SELECT distinct sclp scanpt expr CONCAT nm DOT]
parser: Input 'ID' in state 249
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[SELECT distinct sclp scanpt expr CONCAT nm DOT ID]
parser: Input 'FROM' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 249.
parser: ... then shift 'nm', go to state 536
parser: Reduce 169 [expr ::= nm DOT nm], go to state 113.
parser: ... then shift 'expr', go to state 148
parser: Reduce 190 [expr ::= expr CONCAT expr], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 104 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'ID' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 350
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Shift 'ID', pending reduce 356
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm dbnm ID]
parser: Input 'COMMA' with pending reduce 356
parser: Reduce 356 [as ::= ID|STRING], go to state 243.
parser: ... then shift 'as', go to state 283
parser: Reduce 123 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 349
parser: Reduce 122 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 348
parser: Reduce 127 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 105
parser: Reduce 105 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Shift 'COMMA', pending reduce 117
parser: Return. Stack=[SELECT distinct selcollist FROM seltablist COMMA]
parser: Input 'ID' with pending reduce 117
parser: Reduce 117 [joinop ::= COMMA|JOIN], go to state 263.
parser: ... then shift 'joinop', pending reduce 103
parser: Reduce 103 [stl_prefix ::= seltablist joinop], go to state 197.
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'ID' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 350
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Shift 'ID', pending reduce 356
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm dbnm ID]
parser: Input 'ORDER' with pending reduce 356
parser: Reduce 356 [as ::= ID|STRING], go to state 243.
parser: ... then shift 'as', go to state 283
parser: Reduce 123 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 349
parser: Reduce 122 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 348
parser: Reduce 127 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 105
parser: Reduce 105 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 102 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 363
parser: Reduce 147 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 362
parser: Reduce 138 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 361
parser: Reduce 140 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 517
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 517
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 419
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'DOT' in state 419
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 26.
parser: ... then shift 'nm', go to state 537
parser: Shift 'DOT', go to state 249
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY nm DOT]
parser: Input 'ID' in state 249
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY nm DOT ID]
parser: Input 'COMMA' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 249.
parser: ... then shift 'nm', go to state 536
parser: Reduce 169 [expr ::= nm DOT nm], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 134 [sortorder ::=].
parser: ... then shift 'sortorder', go to state 353
parser: Reduce 137 [nulls ::=].
parser: ... then shift 'nulls', pending reduce 131
parser: Reduce 131 [sortlist ::= expr sortorder nulls], go to state 26.
parser: ... then shift 'sortlist', go to state 516
parser: Shift 'COMMA', go to state 95
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY sortlist COMMA]
parser: Input 'ID' in state 95
parser: Shift 'ID', go to state 419
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY sortlist COMMA ID]
parser: Input 'DOT' in state 419
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 95.
parser: ... then shift 'nm', go to state 537
parser: Shift 'DOT', go to state 249
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY sortlist COMMA nm DOT]
parser: Input 'ID' in state 249
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY sortlist COMMA nm DOT ID]
parser: Input 'CONCAT' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 249.
parser: ... then shift 'nm', go to state 536
parser: Reduce 169 [expr ::= nm DOT nm], go to state 95.
parser: ... then shift 'expr', go to state 14
parser: Shift 'CONCAT', go to state 113
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY sortlist COMMA expr CONCAT]
parser: Input 'ID' in state 113
parser: Shift 'ID', go to state 419
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY sortlist COMMA expr CONCAT ID]
parser: Input 'DOT' in state 419
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 113.
parser: ... then shift 'nm', go to state 537
parser: Shift 'DOT', go to state 249
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY sortlist COMMA expr CONCAT nm DOT]
parser: Input 'ID' in state 249
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY sortlist COMMA expr CONCAT nm DOT ID]
parser: Input 'SEMI' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 249.
parser: ... then shift 'nm', go to state 536
parser: Reduce 169 [expr ::= nm DOT nm], go to state 113.
parser: ... then shift 'expr', go to state 148
parser: Reduce 190 [expr ::= expr CONCAT expr], go to state 95.
parser: ... then shift 'expr', go to state 14
parser: Reduce 134 [sortorder ::=].
parser: ... then shift 'sortorder', go to state 354
parser: Reduce 137 [nulls ::=].
parser: ... then shift 'nulls', pending reduce 130
parser: Reduce 130 [sortlist ::= sortlist COMMA expr sortorder nulls], go to state 26.
parser: ... then shift 'sortlist', go to state 516
parser: Reduce 129 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 360
parser: Reduce 142 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 88
parser: Reduce 88 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 83 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 80
parser: Reduce 80 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
SQL: [SELECT x.b || '/' || y.b FROM a x, a y ORDER BY x.b, x.b||y.b
  
;]
VDBE Trace:
   0 Init             0   38    0               00 Start at 38
  38 Transaction      0    0    6 1             01 usesStmtJournal=0
  39 String8          0    6    0 /             00 r[6]='/'
REG[6] =   t1[/](8)
  40 Goto             0    1    0               00 
   1 SorterOpen       2    2    0 k(1,B)        00 
   2 OpenRead         3    4    0 k(1,B)        00 root=4 iDb=0; i2
   3 OpenRead         4    4    0 k(1,B)        00 root=4 iDb=0; i2
   4 Explain          4    0    0 SCAN TABLE a AS x USING COVERING INDEX i2 00 
   5 Rewind           3   26    1 0             00 
   6 Explain          6    0    0 SCAN TABLE a AS y USING COVERING INDEX i2 00 
   7 Rewind           4   25    1 0             00 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:1
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:1
REG[4] =   s2[1/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:1
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:1
REG[4] =   s2[1/](8)
REG[3] =   s3[1/1](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:1
  13 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:1
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:1
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:1
REG[5] =  i:1
REG[2] =   s2[11](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133131312F31|...111/1]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  22 Move             1    8    1               00 r[8]=r[1]
REG[8] =  i:1
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133131312F31|...111/1]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:1
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:1
REG[4] =   s2[1/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:2
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:2
REG[4] =   s2[1/](8)
REG[3] =   s3[1/2](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:1
  13 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:1
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:2
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:2
REG[5] =  i:1
REG[2] =   s2[12](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133132312F32|...121/2]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:1
REG[1] =  i:1
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133132312F32|...121/2]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:1
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:1
REG[4] =   s2[1/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:3
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:3
REG[4] =   s2[1/](8)
REG[3] =   s3[1/3](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:1
  13 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:1
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:3
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:3
REG[5] =  i:1
REG[2] =   s2[13](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133133312F33|...131/3]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:1
REG[1] =  i:1
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133133312F33|...131/3]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:1
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:1
REG[4] =   s2[1/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:4
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:4
REG[4] =   s2[1/](8)
REG[3] =   s3[1/4](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:1
  13 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:1
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:4
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:4
REG[5] =  i:1
REG[2] =   s2[14](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133134312F34|...141/4]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:1
REG[1] =  i:1
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133134312F34|...141/4]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:1
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:1
REG[4] =   s2[1/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:5
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:5
REG[4] =   s2[1/](8)
REG[3] =   s3[1/5](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:1
  13 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:1
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:5
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:5
REG[5] =  i:1
REG[2] =   s2[15](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133135312F35|...151/5]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:1
REG[1] =  i:1
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133135312F35|...151/5]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:1
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:1
REG[4] =   s2[1/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:6
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:6
REG[4] =   s2[1/](8)
REG[3] =   s3[1/6](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:1
  13 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:1
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:6
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:6
REG[5] =  i:1
REG[2] =   s2[16](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133136312F36|...161/6]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:1
REG[1] =  i:1
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133136312F36|...161/6]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:1
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:1
REG[4] =   s2[1/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:7
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:7
REG[4] =   s2[1/](8)
REG[3] =   s3[1/7](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:1
  13 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:1
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:7
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:7
REG[5] =  i:1
REG[2] =   s2[17](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133137312F37|...171/7]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:1
REG[1] =  i:1
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133137312F37|...171/7]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:1
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:1
REG[4] =   s2[1/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:8
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:8
REG[4] =   s2[1/](8)
REG[3] =   s3[1/8](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:1
  13 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:1
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:8
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:8
REG[5] =  i:1
REG[2] =   s2[18](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133138312F38|...181/8]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:1
REG[1] =  i:1
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133138312F38|...181/8]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:1
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:1
REG[4] =   s2[1/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:9
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:9
REG[4] =   s2[1/](8)
REG[3] =   s3[1/9](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:1
  13 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:1
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:9
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:9
REG[5] =  i:1
REG[2] =   s2[19](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133139312F39|...191/9]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:1
REG[1] =  i:1
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133139312F39|...191/9]
  24 Next             4    8    0               01 
  25 Next             3    6    0               01 
   6 Explain          6    0    0 SCAN TABLE a AS y USING COVERING INDEX i2 00 
   7 Rewind           4   25    1 0             00 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:2
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:2
REG[4] =   s2[2/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:1
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:1
REG[4] =   s2[2/](8)
REG[3] =   s3[2/1](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:2
  13 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:2
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:1
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:1
REG[5] =  i:2
REG[2] =   s2[21](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133231322F31|...212/1]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:1
REG[1] =  i:2
  19 Jump            20   23   20               00 
  20 Gosub            9   29    0               00 
REG[9] =  i:20
  29 Once             0   31    0               00 
  30 OpenPseudo       5   10    3               00 3 columns in r[10]
  31 SorterSort       2   37    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[1/1](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[1/1](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[1/2](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[1/2](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[1/3](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[1/3](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[1/4](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[1/4](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[1/5](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[1/5](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[1/6](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[1/6](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[1/7](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[1/7](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[1/8](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[1/8](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[1/9](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[1/9](8)
  35 SorterNext       2   32    0               00 
  36 Return           9    0    0               00 
REG[9] =  i:20
  21 ResetSorter      2    0    0               00 
  22 Move             1    8    1               00 r[8]=r[1]
REG[8] =  i:2
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133231322F31|...212/1]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:2
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:2
REG[4] =   s2[2/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:2
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:2
REG[4] =   s2[2/](8)
REG[3] =   s3[2/2](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:2
  13 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:2
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:2
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:2
REG[5] =  i:2
REG[2] =   s2[22](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133232322F32|...222/2]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:2
REG[1] =  i:2
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133232322F32|...222/2]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:2
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:2
REG[4] =   s2[2/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:3
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:3
REG[4] =   s2[2/](8)
REG[3] =   s3[2/3](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:2
  13 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:2
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:3
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:3
REG[5] =  i:2
REG[2] =   s2[23](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133233322F33|...232/3]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:2
REG[1] =  i:2
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133233322F33|...232/3]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:2
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:2
REG[4] =   s2[2/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:4
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:4
REG[4] =   s2[2/](8)
REG[3] =   s3[2/4](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:2
  13 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:2
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:4
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:4
REG[5] =  i:2
REG[2] =   s2[24](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133234322F34|...242/4]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:2
REG[1] =  i:2
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133234322F34|...242/4]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:2
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:2
REG[4] =   s2[2/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:5
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:5
REG[4] =   s2[2/](8)
REG[3] =   s3[2/5](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:2
  13 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:2
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:5
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:5
REG[5] =  i:2
REG[2] =   s2[25](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133235322F35|...252/5]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:2
REG[1] =  i:2
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133235322F35|...252/5]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:2
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:2
REG[4] =   s2[2/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:6
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:6
REG[4] =   s2[2/](8)
REG[3] =   s3[2/6](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:2
  13 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:2
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:6
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:6
REG[5] =  i:2
REG[2] =   s2[26](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133236322F36|...262/6]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:2
REG[1] =  i:2
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133236322F36|...262/6]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:2
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:2
REG[4] =   s2[2/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:7
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:7
REG[4] =   s2[2/](8)
REG[3] =   s3[2/7](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:2
  13 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:2
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:7
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:7
REG[5] =  i:2
REG[2] =   s2[27](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133237322F37|...272/7]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:2
REG[1] =  i:2
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133237322F37|...272/7]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:2
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:2
REG[4] =   s2[2/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:8
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:8
REG[4] =   s2[2/](8)
REG[3] =   s3[2/8](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:2
  13 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:2
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:8
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:8
REG[5] =  i:2
REG[2] =   s2[28](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133238322F38|...282/8]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:2
REG[1] =  i:2
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133238322F38|...282/8]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:2
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:2
REG[4] =   s2[2/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:9
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:9
REG[4] =   s2[2/](8)
REG[3] =   s3[2/9](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:2
  13 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:2
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:9
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:9
REG[5] =  i:2
REG[2] =   s2[29](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133239322F39|...292/9]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:2
REG[1] =  i:2
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133239322F39|...292/9]
  24 Next             4    8    0               01 
  25 Next             3    6    0               01 
   6 Explain          6    0    0 SCAN TABLE a AS y USING COVERING INDEX i2 00 
   7 Rewind           4   25    1 0             00 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:3
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:3
REG[4] =   s2[3/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:1
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:1
REG[4] =   s2[3/](8)
REG[3] =   s3[3/1](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:3
  13 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:3
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:1
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:1
REG[5] =  i:3
REG[2] =   s2[31](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133331332F31|...313/1]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:2
REG[1] =  i:3
  19 Jump            20   23   20               00 
  20 Gosub            9   29    0               00 
REG[9] =  i:20
  29 Once             1   31    0               00 
  31 SorterSort       2   37    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[2/1](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[2/1](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[2/2](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[2/2](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[2/3](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[2/3](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[2/4](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[2/4](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[2/5](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[2/5](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[2/6](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[2/6](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[2/7](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[2/7](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[2/8](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[2/8](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[2/9](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[2/9](8)
  35 SorterNext       2   32    0               00 
  36 Return           9    0    0               00 
REG[9] =  i:20
  21 ResetSorter      2    0    0               00 
  22 Move             1    8    1               00 r[8]=r[1]
REG[8] =  i:3
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133331332F31|...313/1]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:3
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:3
REG[4] =   s2[3/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:2
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:2
REG[4] =   s2[3/](8)
REG[3] =   s3[3/2](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:3
  13 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:3
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:2
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:2
REG[5] =  i:3
REG[2] =   s2[32](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133332332F32|...323/2]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:3
REG[1] =  i:3
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133332332F32|...323/2]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:3
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:3
REG[4] =   s2[3/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:3
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:3
REG[4] =   s2[3/](8)
REG[3] =   s3[3/3](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:3
  13 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:3
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:3
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:3
REG[5] =  i:3
REG[2] =   s2[33](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133333332F33|...333/3]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:3
REG[1] =  i:3
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133333332F33|...333/3]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:3
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:3
REG[4] =   s2[3/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:4
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:4
REG[4] =   s2[3/](8)
REG[3] =   s3[3/4](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:3
  13 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:3
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:4
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:4
REG[5] =  i:3
REG[2] =   s2[34](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133334332F34|...343/4]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:3
REG[1] =  i:3
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133334332F34|...343/4]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:3
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:3
REG[4] =   s2[3/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:5
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:5
REG[4] =   s2[3/](8)
REG[3] =   s3[3/5](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:3
  13 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:3
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:5
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:5
REG[5] =  i:3
REG[2] =   s2[35](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133335332F35|...353/5]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:3
REG[1] =  i:3
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133335332F35|...353/5]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:3
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:3
REG[4] =   s2[3/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:6
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:6
REG[4] =   s2[3/](8)
REG[3] =   s3[3/6](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:3
  13 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:3
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:6
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:6
REG[5] =  i:3
REG[2] =   s2[36](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133336332F36|...363/6]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:3
REG[1] =  i:3
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133336332F36|...363/6]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:3
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:3
REG[4] =   s2[3/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:7
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:7
REG[4] =   s2[3/](8)
REG[3] =   s3[3/7](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:3
  13 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:3
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:7
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:7
REG[5] =  i:3
REG[2] =   s2[37](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133337332F37|...373/7]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:3
REG[1] =  i:3
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133337332F37|...373/7]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:3
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:3
REG[4] =   s2[3/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:8
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:8
REG[4] =   s2[3/](8)
REG[3] =   s3[3/8](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:3
  13 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:3
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:8
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:8
REG[5] =  i:3
REG[2] =   s2[38](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133338332F38|...383/8]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:3
REG[1] =  i:3
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133338332F38|...383/8]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:3
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:3
REG[4] =   s2[3/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:9
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:9
REG[4] =   s2[3/](8)
REG[3] =   s3[3/9](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:3
  13 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:3
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:9
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:9
REG[5] =  i:3
REG[2] =   s2[39](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133339332F39|...393/9]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:3
REG[1] =  i:3
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133339332F39|...393/9]
  24 Next             4    8    0               01 
  25 Next             3    6    0               01 
   6 Explain          6    0    0 SCAN TABLE a AS y USING COVERING INDEX i2 00 
   7 Rewind           4   25    1 0             00 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:4
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:4
REG[4] =   s2[4/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:1
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:1
REG[4] =   s2[4/](8)
REG[3] =   s3[4/1](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:4
  13 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:4
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:1
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:1
REG[5] =  i:4
REG[2] =   s2[41](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133431342F31|...414/1]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:3
REG[1] =  i:4
  19 Jump            20   23   20               00 
  20 Gosub            9   29    0               00 
REG[9] =  i:20
  29 Once             1   31    0               00 
  31 SorterSort       2   37    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[3/1](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[3/1](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[3/2](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[3/2](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[3/3](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[3/3](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[3/4](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[3/4](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[3/5](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[3/5](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[3/6](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[3/6](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[3/7](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[3/7](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[3/8](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[3/8](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[3/9](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[3/9](8)
  35 SorterNext       2   32    0               00 
  36 Return           9    0    0               00 
REG[9] =  i:20
  21 ResetSorter      2    0    0               00 
  22 Move             1    8    1               00 r[8]=r[1]
REG[8] =  i:4
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133431342F31|...414/1]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:4
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:4
REG[4] =   s2[4/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:2
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:2
REG[4] =   s2[4/](8)
REG[3] =   s3[4/2](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:4
  13 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:4
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:2
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:2
REG[5] =  i:4
REG[2] =   s2[42](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133432342F32|...424/2]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:4
REG[1] =  i:4
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133432342F32|...424/2]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:4
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:4
REG[4] =   s2[4/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:3
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:3
REG[4] =   s2[4/](8)
REG[3] =   s3[4/3](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:4
  13 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:4
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:3
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:3
REG[5] =  i:4
REG[2] =   s2[43](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133433342F33|...434/3]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:4
REG[1] =  i:4
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133433342F33|...434/3]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:4
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:4
REG[4] =   s2[4/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:4
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:4
REG[4] =   s2[4/](8)
REG[3] =   s3[4/4](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:4
  13 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:4
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:4
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:4
REG[5] =  i:4
REG[2] =   s2[44](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133434342F34|...444/4]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:4
REG[1] =  i:4
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133434342F34|...444/4]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:4
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:4
REG[4] =   s2[4/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:5
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:5
REG[4] =   s2[4/](8)
REG[3] =   s3[4/5](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:4
  13 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:4
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:5
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:5
REG[5] =  i:4
REG[2] =   s2[45](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133435342F35|...454/5]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:4
REG[1] =  i:4
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133435342F35|...454/5]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:4
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:4
REG[4] =   s2[4/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:6
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:6
REG[4] =   s2[4/](8)
REG[3] =   s3[4/6](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:4
  13 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:4
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:6
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:6
REG[5] =  i:4
REG[2] =   s2[46](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133436342F36|...464/6]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:4
REG[1] =  i:4
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133436342F36|...464/6]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:4
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:4
REG[4] =   s2[4/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:7
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:7
REG[4] =   s2[4/](8)
REG[3] =   s3[4/7](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:4
  13 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:4
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:7
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:7
REG[5] =  i:4
REG[2] =   s2[47](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133437342F37|...474/7]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:4
REG[1] =  i:4
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133437342F37|...474/7]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:4
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:4
REG[4] =   s2[4/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:8
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:8
REG[4] =   s2[4/](8)
REG[3] =   s3[4/8](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:4
  13 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:4
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:8
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:8
REG[5] =  i:4
REG[2] =   s2[48](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133438342F38|...484/8]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:4
REG[1] =  i:4
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133438342F38|...484/8]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:4
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:4
REG[4] =   s2[4/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:9
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:9
REG[4] =   s2[4/](8)
REG[3] =   s3[4/9](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:4
  13 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:4
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:9
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:9
REG[5] =  i:4
REG[2] =   s2[49](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133439342F39|...494/9]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:4
REG[1] =  i:4
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133439342F39|...494/9]
  24 Next             4    8    0               01 
  25 Next             3    6    0               01 
   6 Explain          6    0    0 SCAN TABLE a AS y USING COVERING INDEX i2 00 
   7 Rewind           4   25    1 0             00 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:5
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:5
REG[4] =   s2[5/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:1
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:1
REG[4] =   s2[5/](8)
REG[3] =   s3[5/1](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:5
  13 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:5
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:1
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:1
REG[5] =  i:5
REG[2] =   s2[51](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133531352F31|...515/1]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:4
REG[1] =  i:5
  19 Jump            20   23   20               00 
  20 Gosub            9   29    0               00 
REG[9] =  i:20
  29 Once             1   31    0               00 
  31 SorterSort       2   37    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[4/1](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[4/1](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[4/2](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[4/2](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[4/3](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[4/3](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[4/4](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[4/4](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[4/5](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[4/5](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[4/6](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[4/6](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[4/7](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[4/7](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[4/8](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[4/8](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[4/9](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[4/9](8)
  35 SorterNext       2   32    0               00 
  36 Return           9    0    0               00 
REG[9] =  i:20
  21 ResetSorter      2    0    0               00 
  22 Move             1    8    1               00 r[8]=r[1]
REG[8] =  i:5
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133531352F31|...515/1]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:5
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:5
REG[4] =   s2[5/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:2
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:2
REG[4] =   s2[5/](8)
REG[3] =   s3[5/2](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:5
  13 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:5
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:2
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:2
REG[5] =  i:5
REG[2] =   s2[52](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133532352F32|...525/2]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:5
REG[1] =  i:5
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133532352F32|...525/2]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:5
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:5
REG[4] =   s2[5/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:3
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:3
REG[4] =   s2[5/](8)
REG[3] =   s3[5/3](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:5
  13 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:5
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:3
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:3
REG[5] =  i:5
REG[2] =   s2[53](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133533352F33|...535/3]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:5
REG[1] =  i:5
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133533352F33|...535/3]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:5
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:5
REG[4] =   s2[5/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:4
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:4
REG[4] =   s2[5/](8)
REG[3] =   s3[5/4](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:5
  13 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:5
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:4
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:4
REG[5] =  i:5
REG[2] =   s2[54](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133534352F34|...545/4]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:5
REG[1] =  i:5
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133534352F34|...545/4]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:5
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:5
REG[4] =   s2[5/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:5
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:5
REG[4] =   s2[5/](8)
REG[3] =   s3[5/5](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:5
  13 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:5
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:5
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:5
REG[5] =  i:5
REG[2] =   s2[55](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133535352F35|...555/5]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:5
REG[1] =  i:5
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133535352F35|...555/5]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:5
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:5
REG[4] =   s2[5/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:6
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:6
REG[4] =   s2[5/](8)
REG[3] =   s3[5/6](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:5
  13 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:5
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:6
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:6
REG[5] =  i:5
REG[2] =   s2[56](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133536352F36|...565/6]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:5
REG[1] =  i:5
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133536352F36|...565/6]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:5
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:5
REG[4] =   s2[5/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:7
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:7
REG[4] =   s2[5/](8)
REG[3] =   s3[5/7](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:5
  13 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:5
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:7
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:7
REG[5] =  i:5
REG[2] =   s2[57](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133537352F37|...575/7]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:5
REG[1] =  i:5
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133537352F37|...575/7]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:5
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:5
REG[4] =   s2[5/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:8
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:8
REG[4] =   s2[5/](8)
REG[3] =   s3[5/8](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:5
  13 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:5
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:8
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:8
REG[5] =  i:5
REG[2] =   s2[58](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133538352F38|...585/8]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:5
REG[1] =  i:5
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133538352F38|...585/8]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:5
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:5
REG[4] =   s2[5/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:9
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:9
REG[4] =   s2[5/](8)
REG[3] =   s3[5/9](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:5
  13 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:5
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:9
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:9
REG[5] =  i:5
REG[2] =   s2[59](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133539352F39|...595/9]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:5
REG[1] =  i:5
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133539352F39|...595/9]
  24 Next             4    8    0               01 
  25 Next             3    6    0               01 
   6 Explain          6    0    0 SCAN TABLE a AS y USING COVERING INDEX i2 00 
   7 Rewind           4   25    1 0             00 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:6
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:6
REG[4] =   s2[6/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:1
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:1
REG[4] =   s2[6/](8)
REG[3] =   s3[6/1](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:6
  13 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:6
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:1
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:1
REG[5] =  i:6
REG[2] =   s2[61](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133631362F31|...616/1]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:5
REG[1] =  i:6
  19 Jump            20   23   20               00 
  20 Gosub            9   29    0               00 
REG[9] =  i:20
  29 Once             1   31    0               00 
  31 SorterSort       2   37    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[5/1](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[5/1](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[5/2](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[5/2](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[5/3](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[5/3](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[5/4](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[5/4](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[5/5](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[5/5](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[5/6](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[5/6](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[5/7](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[5/7](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[5/8](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[5/8](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[5/9](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[5/9](8)
  35 SorterNext       2   32    0               00 
  36 Return           9    0    0               00 
REG[9] =  i:20
  21 ResetSorter      2    0    0               00 
  22 Move             1    8    1               00 r[8]=r[1]
REG[8] =  i:6
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133631362F31|...616/1]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:6
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:6
REG[4] =   s2[6/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:2
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:2
REG[4] =   s2[6/](8)
REG[3] =   s3[6/2](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:6
  13 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:6
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:2
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:2
REG[5] =  i:6
REG[2] =   s2[62](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133632362F32|...626/2]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:6
REG[1] =  i:6
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133632362F32|...626/2]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:6
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:6
REG[4] =   s2[6/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:3
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:3
REG[4] =   s2[6/](8)
REG[3] =   s3[6/3](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:6
  13 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:6
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:3
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:3
REG[5] =  i:6
REG[2] =   s2[63](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133633362F33|...636/3]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:6
REG[1] =  i:6
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133633362F33|...636/3]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:6
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:6
REG[4] =   s2[6/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:4
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:4
REG[4] =   s2[6/](8)
REG[3] =   s3[6/4](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:6
  13 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:6
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:4
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:4
REG[5] =  i:6
REG[2] =   s2[64](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133634362F34|...646/4]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:6
REG[1] =  i:6
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133634362F34|...646/4]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:6
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:6
REG[4] =   s2[6/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:5
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:5
REG[4] =   s2[6/](8)
REG[3] =   s3[6/5](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:6
  13 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:6
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:5
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:5
REG[5] =  i:6
REG[2] =   s2[65](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133635362F35|...656/5]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:6
REG[1] =  i:6
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133635362F35|...656/5]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:6
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:6
REG[4] =   s2[6/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:6
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:6
REG[4] =   s2[6/](8)
REG[3] =   s3[6/6](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:6
  13 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:6
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:6
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:6
REG[5] =  i:6
REG[2] =   s2[66](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133636362F36|...666/6]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:6
REG[1] =  i:6
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133636362F36|...666/6]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:6
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:6
REG[4] =   s2[6/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:7
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:7
REG[4] =   s2[6/](8)
REG[3] =   s3[6/7](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:6
  13 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:6
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:7
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:7
REG[5] =  i:6
REG[2] =   s2[67](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133637362F37|...676/7]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:6
REG[1] =  i:6
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133637362F37|...676/7]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:6
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:6
REG[4] =   s2[6/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:8
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:8
REG[4] =   s2[6/](8)
REG[3] =   s3[6/8](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:6
  13 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:6
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:8
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:8
REG[5] =  i:6
REG[2] =   s2[68](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133638362F38|...686/8]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:6
REG[1] =  i:6
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133638362F38|...686/8]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:6
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:6
REG[4] =   s2[6/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:9
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:9
REG[4] =   s2[6/](8)
REG[3] =   s3[6/9](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:6
  13 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:6
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:9
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:9
REG[5] =  i:6
REG[2] =   s2[69](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133639362F39|...696/9]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:6
REG[1] =  i:6
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133639362F39|...696/9]
  24 Next             4    8    0               01 
  25 Next             3    6    0               01 
   6 Explain          6    0    0 SCAN TABLE a AS y USING COVERING INDEX i2 00 
   7 Rewind           4   25    1 0             00 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:7
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:7
REG[4] =   s2[7/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:1
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:1
REG[4] =   s2[7/](8)
REG[3] =   s3[7/1](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:7
  13 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:7
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:1
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:1
REG[5] =  i:7
REG[2] =   s2[71](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133731372F31|...717/1]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:6
REG[1] =  i:7
  19 Jump            20   23   20               00 
  20 Gosub            9   29    0               00 
REG[9] =  i:20
  29 Once             1   31    0               00 
  31 SorterSort       2   37    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[6/1](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[6/1](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[6/2](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[6/2](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[6/3](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[6/3](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[6/4](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[6/4](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[6/5](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[6/5](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[6/6](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[6/6](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[6/7](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[6/7](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[6/8](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[6/8](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[6/9](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[6/9](8)
  35 SorterNext       2   32    0               00 
  36 Return           9    0    0               00 
REG[9] =  i:20
  21 ResetSorter      2    0    0               00 
  22 Move             1    8    1               00 r[8]=r[1]
REG[8] =  i:7
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133731372F31|...717/1]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:7
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:7
REG[4] =   s2[7/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:2
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:2
REG[4] =   s2[7/](8)
REG[3] =   s3[7/2](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:7
  13 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:7
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:2
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:2
REG[5] =  i:7
REG[2] =   s2[72](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133732372F32|...727/2]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:7
REG[1] =  i:7
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133732372F32|...727/2]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:7
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:7
REG[4] =   s2[7/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:3
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:3
REG[4] =   s2[7/](8)
REG[3] =   s3[7/3](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:7
  13 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:7
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:3
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:3
REG[5] =  i:7
REG[2] =   s2[73](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133733372F33|...737/3]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:7
REG[1] =  i:7
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133733372F33|...737/3]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:7
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:7
REG[4] =   s2[7/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:4
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:4
REG[4] =   s2[7/](8)
REG[3] =   s3[7/4](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:7
  13 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:7
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:4
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:4
REG[5] =  i:7
REG[2] =   s2[74](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133734372F34|...747/4]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:7
REG[1] =  i:7
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133734372F34|...747/4]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:7
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:7
REG[4] =   s2[7/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:5
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:5
REG[4] =   s2[7/](8)
REG[3] =   s3[7/5](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:7
  13 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:7
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:5
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:5
REG[5] =  i:7
REG[2] =   s2[75](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133735372F35|...757/5]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:7
REG[1] =  i:7
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133735372F35|...757/5]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:7
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:7
REG[4] =   s2[7/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:6
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:6
REG[4] =   s2[7/](8)
REG[3] =   s3[7/6](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:7
  13 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:7
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:6
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:6
REG[5] =  i:7
REG[2] =   s2[76](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133736372F36|...767/6]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:7
REG[1] =  i:7
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133736372F36|...767/6]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:7
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:7
REG[4] =   s2[7/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:7
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:7
REG[4] =   s2[7/](8)
REG[3] =   s3[7/7](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:7
  13 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:7
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:7
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:7
REG[5] =  i:7
REG[2] =   s2[77](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133737372F37|...777/7]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:7
REG[1] =  i:7
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133737372F37|...777/7]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:7
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:7
REG[4] =   s2[7/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:8
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:8
REG[4] =   s2[7/](8)
REG[3] =   s3[7/8](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:7
  13 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:7
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:8
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:8
REG[5] =  i:7
REG[2] =   s2[78](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133738372F38|...787/8]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:7
REG[1] =  i:7
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133738372F38|...787/8]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:7
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:7
REG[4] =   s2[7/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:9
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:9
REG[4] =   s2[7/](8)
REG[3] =   s3[7/9](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:7
  13 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:7
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:9
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:9
REG[5] =  i:7
REG[2] =   s2[79](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133739372F39|...797/9]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:7
REG[1] =  i:7
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133739372F39|...797/9]
  24 Next             4    8    0               01 
  25 Next             3    6    0               01 
   6 Explain          6    0    0 SCAN TABLE a AS y USING COVERING INDEX i2 00 
   7 Rewind           4   25    1 0             00 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:8
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:8
REG[4] =   s2[8/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:1
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:1
REG[4] =   s2[8/](8)
REG[3] =   s3[8/1](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:8
  13 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:8
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:1
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:1
REG[5] =  i:8
REG[2] =   s2[81](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133831382F31|...818/1]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:7
REG[1] =  i:8
  19 Jump            20   23   20               00 
  20 Gosub            9   29    0               00 
REG[9] =  i:20
  29 Once             1   31    0               00 
  31 SorterSort       2   37    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[7/1](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[7/1](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[7/2](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[7/2](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[7/3](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[7/3](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[7/4](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[7/4](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[7/5](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[7/5](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[7/6](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[7/6](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[7/7](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[7/7](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[7/8](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[7/8](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[7/9](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[7/9](8)
  35 SorterNext       2   32    0               00 
  36 Return           9    0    0               00 
REG[9] =  i:20
  21 ResetSorter      2    0    0               00 
  22 Move             1    8    1               00 r[8]=r[1]
REG[8] =  i:8
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133831382F31|...818/1]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:8
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:8
REG[4] =   s2[8/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:2
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:2
REG[4] =   s2[8/](8)
REG[3] =   s3[8/2](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:8
  13 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:8
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:2
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:2
REG[5] =  i:8
REG[2] =   s2[82](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133832382F32|...828/2]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:8
REG[1] =  i:8
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133832382F32|...828/2]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:8
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:8
REG[4] =   s2[8/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:3
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:3
REG[4] =   s2[8/](8)
REG[3] =   s3[8/3](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:8
  13 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:8
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:3
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:3
REG[5] =  i:8
REG[2] =   s2[83](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133833382F33|...838/3]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:8
REG[1] =  i:8
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133833382F33|...838/3]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:8
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:8
REG[4] =   s2[8/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:4
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:4
REG[4] =   s2[8/](8)
REG[3] =   s3[8/4](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:8
  13 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:8
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:4
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:4
REG[5] =  i:8
REG[2] =   s2[84](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133834382F34|...848/4]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:8
REG[1] =  i:8
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133834382F34|...848/4]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:8
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:8
REG[4] =   s2[8/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:5
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:5
REG[4] =   s2[8/](8)
REG[3] =   s3[8/5](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:8
  13 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:8
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:5
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:5
REG[5] =  i:8
REG[2] =   s2[85](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133835382F35|...858/5]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:8
REG[1] =  i:8
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133835382F35|...858/5]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:8
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:8
REG[4] =   s2[8/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:6
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:6
REG[4] =   s2[8/](8)
REG[3] =   s3[8/6](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:8
  13 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:8
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:6
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:6
REG[5] =  i:8
REG[2] =   s2[86](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133836382F36|...868/6]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:8
REG[1] =  i:8
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133836382F36|...868/6]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:8
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:8
REG[4] =   s2[8/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:7
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:7
REG[4] =   s2[8/](8)
REG[3] =   s3[8/7](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:8
  13 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:8
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:7
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:7
REG[5] =  i:8
REG[2] =   s2[87](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133837382F37|...878/7]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:8
REG[1] =  i:8
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133837382F37|...878/7]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:8
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:8
REG[4] =   s2[8/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:8
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:8
REG[4] =   s2[8/](8)
REG[3] =   s3[8/8](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:8
  13 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:8
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:8
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:8
REG[5] =  i:8
REG[2] =   s2[88](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133838382F38|...888/8]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:8
REG[1] =  i:8
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133838382F38|...888/8]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:8
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:8
REG[4] =   s2[8/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:9
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:9
REG[4] =   s2[8/](8)
REG[3] =   s3[8/9](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:8
  13 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:8
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:9
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:9
REG[5] =  i:8
REG[2] =   s2[89](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133839382F39|...898/9]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:8
REG[1] =  i:8
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133839382F39|...898/9]
  24 Next             4    8    0               01 
  25 Next             3    6    0               01 
   6 Explain          6    0    0 SCAN TABLE a AS y USING COVERING INDEX i2 00 
   7 Rewind           4   25    1 0             00 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:9
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:9
REG[4] =   s2[9/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:1
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:1
REG[4] =   s2[9/](8)
REG[3] =   s3[9/1](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:9
  13 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:9
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:1
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:1
REG[5] =  i:9
REG[2] =   s2[91](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133931392F31|...919/1]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:8
REG[1] =  i:9
  19 Jump            20   23   20               00 
  20 Gosub            9   29    0               00 
REG[9] =  i:20
  29 Once             1   31    0               00 
  31 SorterSort       2   37    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[8/1](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[8/1](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[8/2](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[8/2](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[8/3](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[8/3](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[8/4](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[8/4](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[8/5](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[8/5](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[8/6](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[8/6](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[8/7](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[8/7](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[8/8](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[8/8](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[8/9](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[8/9](8)
  35 SorterNext       2   32    0               00 
  36 Return           9    0    0               00 
REG[9] =  i:20
  21 ResetSorter      2    0    0               00 
  22 Move             1    8    1               00 r[8]=r[1]
REG[8] =  i:9
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133931392F31|...919/1]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:9
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:9
REG[4] =   s2[9/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:2
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:2
REG[4] =   s2[9/](8)
REG[3] =   s3[9/2](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:9
  13 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:9
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:2
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:2
REG[5] =  i:9
REG[2] =   s2[92](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133932392F32|...929/2]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:9
REG[1] =  i:9
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133932392F32|...929/2]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:9
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:9
REG[4] =   s2[9/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:3
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:3
REG[4] =   s2[9/](8)
REG[3] =   s3[9/3](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:9
  13 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:9
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:3
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:3
REG[5] =  i:9
REG[2] =   s2[93](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133933392F33|...939/3]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:9
REG[1] =  i:9
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133933392F33|...939/3]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:9
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:9
REG[4] =   s2[9/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:4
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:4
REG[4] =   s2[9/](8)
REG[3] =   s3[9/4](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:9
  13 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:9
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:4
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:4
REG[5] =  i:9
REG[2] =   s2[94](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133934392F34|...949/4]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:9
REG[1] =  i:9
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133934392F34|...949/4]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:9
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:9
REG[4] =   s2[9/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:5
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:5
REG[4] =   s2[9/](8)
REG[3] =   s3[9/5](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:9
  13 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:9
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:5
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:5
REG[5] =  i:9
REG[2] =   s2[95](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133935392F35|...959/5]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:9
REG[1] =  i:9
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133935392F35|...959/5]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:9
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:9
REG[4] =   s2[9/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:6
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:6
REG[4] =   s2[9/](8)
REG[3] =   s3[9/6](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:9
  13 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:9
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:6
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:6
REG[5] =  i:9
REG[2] =   s2[96](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133936392F36|...969/6]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:9
REG[1] =  i:9
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133936392F36|...969/6]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:9
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:9
REG[4] =   s2[9/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:7
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:7
REG[4] =   s2[9/](8)
REG[3] =   s3[9/7](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:9
  13 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:9
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:7
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:7
REG[5] =  i:9
REG[2] =   s2[97](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133937392F37|...979/7]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:9
REG[1] =  i:9
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133937392F37|...979/7]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:9
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:9
REG[4] =   s2[9/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:8
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:8
REG[4] =   s2[9/](8)
REG[3] =   s3[9/8](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:9
  13 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:9
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:8
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:8
REG[5] =  i:9
REG[2] =   s2[98](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133938392F38|...989/8]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:9
REG[1] =  i:9
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133938392F38|...989/8]
  24 Next             4    8    0               01 
   8 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:9
   9 Concat           6    5    4               00 r[4]=r[5]+r[6]
REG[6] =   t1[/](8)
REG[5] =  i:9
REG[4] =   s2[9/](8)
  10 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:9
  11 Concat           5    4    3               00 r[3]=r[4]+r[5]
REG[5] =  i:9
REG[4] =   s2[9/](8)
REG[3] =   s3[9/9](8)
  12 Column           3    0    1               00 r[1]=a.b
REG[1] =  i:9
  13 Column           3    0    5               00 r[5]=a.b
REG[5] =  i:9
  14 Column           4    0    4               00 r[4]=a.b
REG[4] =  i:9
  15 Concat           4    5    2               00 r[2]=r[5]+r[4]
REG[4] =  i:9
REG[5] =  i:9
REG[2] =   s2[99](8)
  16 MakeRecord       2    2    7               00 r[7]=mkrec(r[2..3])
REG[7] =  sx8[0311133939392F39|...999/9]
  17 SequenceTest     2   22    0               00 if( cursor[2].ctr++ ) pc = 22
  18 Compare          8    1    1 k(2,B,B)      00 r[8] <-> r[1]
REG[8] =  i:9
REG[1] =  i:9
  19 Jump            20   23   20               00 
  23 SorterInsert     2    7    2 2             00 key=r[7]
REG[7] =  sx8[0311133939392F39|...999/9]
  24 Next             4    8    0               01 
  25 Next             3    6    0               01 
  26 Explain         26    0    0 USE TEMP B-TREE FOR RIGHT PART OF ORDER BY 00 
  27 Gosub            9   29    0               00 
REG[9] =  i:27
  29 Once             1   31    0               00 
  31 SorterSort       2   37    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[9/1](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[9/1](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[9/2](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[9/2](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[9/3](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[9/3](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[9/4](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[9/4](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[9/5](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[9/5](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[9/6](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[9/6](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[9/7](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[9/7](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[9/8](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[9/8](8)
  35 SorterNext       2   32    0               00 
  32 SorterData       2   10    5               00 r[10]=data
  33 Column           5    1    3               00 r[3]=x.b || '/' || y.b
REG[3] =   s3[9/9](8)
  34 ResultRow        3    1    0               00 output=r[3]
REG[3] =   s3[9/9](8)
  35 SorterNext       2   32    0               00 
  36 Return           9    0    0               00 
REG[9] =  i:27
  28 Goto             0   37    0               00 
  37 Halt             0    0    0               00 
parser: [[[SELECT*FROM"temp".sqlite_temp_master ORDER BY rowid
;;
;CREATE TABLE x(y INTEGER PRIMARY KEY, t2i1);ALTER TABLE x ADD t1i1
    
;;
;SELECT x.RowID id FROM a, x WHERE a.b = x.RowID AND id = 2;SELECT*FROM"temp".sqlite_temp_master ORDER BY rowid
;ALTER TABLE x ADD abc
    
;CREATE INDEX c ON a(b)
;CREATE INDEX v1 ON a(b)
;ALTER TABLE ex ADD v2
    
;CREATE TABLE tr1(t1a, t1b);;SELECT y, v2 FROM x, ex WHERE y>v2;;
;SELECT DISTINCT b FROM a LEFT JOIN ex ON b=v2 ORDER BY +v2;CREATE INDEX x1 ON a(b)
;CREATE INDEX z ON a(b)
;CREATE INDEX example ON ex(v2)
;;SELECT count(*) FROM sqlite_master WHERE tbl_name = 'e' AND type = 'index';;
;CREATE TABLE example_idx_00000042(id PRIMARY KEY, UNIQUE(id) );;BEGIN;;CREATE UNIQUE INDEX IF NOT EXISTS a_id ON a(b==0);;SELECT * FROM ex;]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'STAR' in state 288
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 95 [sclp ::=].
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STAR', pending reduce 97
parser: Return. Stack=[SELECT distinct sclp scanpt STAR]
parser: Input 'FROM' with pending reduce 97
parser: Reduce 97 [selcollist ::= sclp scanpt STAR], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 104 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'DOT' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 350
parser: Shift 'DOT', go to state 245
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID' in state 245
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'ORDER' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 245.
parser: ... then shift 'nm', pending reduce 110
parser: Reduce 110 [dbnm ::= DOT nm], go to state 350.
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 123 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 349
parser: Reduce 122 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 348
parser: Reduce 127 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 105
parser: Reduce 105 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 102 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 363
parser: Reduce 147 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 362
parser: Reduce 138 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 361
parser: Reduce 140 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 517
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 517
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 419
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 134 [sortorder ::=].
parser: ... then shift 'sortorder', go to state 353
parser: Reduce 137 [nulls ::=].
parser: ... then shift 'nulls', pending reduce 131
parser: Reduce 131 [sortlist ::= expr sortorder nulls], go to state 26.
parser: ... then shift 'sortlist', go to state 516
parser: Reduce 129 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 360
parser: Reduce 142 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 88
parser: Reduce 88 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 83 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 80
parser: Reduce 80 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
SQL: [SELECT*FROM"temp".sqlite_temp_master ORDER BY rowid
;]
VDBE Trace:
   0 Init             0   13    0               00 Start at 13
  13 Transaction      1    0    0 1             01 usesStmtJournal=0
  14 Goto             0    1    0               00 
   1 Noop             1    7    0               00 
   2 OpenRead         0    1    1 5             00 root=1 iDb=1; sqlite_temp_master
   3 Explain          3    0    0 SCAN TABLE sqlite_temp_master 00 
   4 Rewind           0   12    0               00 
  12 Halt             0    0    0               00 
parser: [[[;
;CREATE TABLE x(y INTEGER PRIMARY KEY, t2i1);ALTER TABLE x ADD t1i1
    
;;
;SELECT x.RowID id FROM a, x WHERE a.b = x.RowID AND id = 2;SELECT*FROM"temp".sqlite_temp_master ORDER BY rowid
;ALTER TABLE x ADD abc
    
;CREATE INDEX c ON a(b)
;CREATE INDEX v1 ON a(b)
;ALTER TABLE ex ADD v2
    
;CREATE TABLE tr1(t1a, t1b);;SELECT y, v2 FROM x, ex WHERE y>v2;;
;SELECT DISTINCT b FROM a LEFT JOIN ex ON b=v2 ORDER BY +v2;CREATE INDEX x1 ON a(b)
;CREATE INDEX z ON a(b)
;CREATE INDEX example ON ex(v2)
;;SELECT count(*) FROM sqlite_master WHERE tbl_name = 'e' AND type = 'index';;
;CREATE TABLE example_idx_00000042(id PRIMARY KEY, UNIQUE(id) );;BEGIN;;CREATE UNIQUE INDEX IF NOT EXISTS a_id ON a(b==0);;SELECT * FROM ex;]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 326
parser: Return. Stack=[SEMI]
parser: Input 'SEMI' with pending reduce 326
parser: Reduce 326 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Shift 'SEMI', pending reduce 326
parser: Return. Stack=[ecmd SEMI]
parser: Input 'CREATE' with pending reduce 326
parser: Reduce 326 [ecmd ::= SEMI], go to state 1.
parser: ... then shift 'ecmd', pending reduce 324
parser: Reduce 324 [cmdlist ::= cmdlist ecmd], go to state 0.
parser: ... then shift 'cmdlist', go to state 1
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[cmdlist CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 1.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 390
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[cmdlist createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[cmdlist createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 1.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[cmdlist create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[cmdlist create_table LP ID]
parser: Input 'ID' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 192
parser: Shift 'ID', pending reduce 341
parser: Return. Stack=[cmdlist create_table LP nm ID]
parser: Input 'PRIMARY' with pending reduce 341
parser: Reduce 341 [typename ::= ID|STRING], go to state 192.
parser: ... then shift 'typename', go to state 392
parser: Reduce 340 [typetoken ::= typename], go to state 192.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 379
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 152
parser: Shift 'PRIMARY', go to state 478
parser: Return. Stack=[cmdlist create_table LP columnname carglist PRIMARY]
parser: Input 'KEY' in state 478
parser: Shift 'KEY', go to state 280
parser: Return. Stack=[cmdlist create_table LP columnname carglist PRIMARY KEY]
parser: Input 'COMMA' in state 280
parser: Reduce 134 [sortorder ::=].
parser: ... then shift 'sortorder', go to state 333
parser: Reduce 69 [onconf ::=].
parser: ... then shift 'onconf', go to state 332
parser: Reduce 43 [autoinc ::=].
parser: ... then shift 'autoinc', pending reduce 37
parser: Reduce 37 [ccons ::= PRIMARY KEY sortorder onconf autoinc], go to state 152.
parser: ... then shift 'ccons', pending reduce 344
parser: Reduce 344 [carglist ::= carglist ccons], go to state 379.
parser: ... then shift 'carglist', go to state 152
parser: Reduce 336 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[cmdlist create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[cmdlist create_table LP columnlist COMMA ID]
parser: Input 'RP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Reduce 61 [conslist_opt ::=].
parser: ... then shift 'conslist_opt', go to state 540
parser: Shift 'RP', go to state 364
parser: Return. Stack=[cmdlist create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 364
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: [[[UPDATE 'main'.sqlite_master SET type='table', name='x', tbl_name='x', rootpage=#2, sql='CREATE TABLE x(y INTEGER PRIMARY KEY, t2i1)' WHERE rowid=#1]]]
parser: Input 'UPDATE' in state 0
parser: Reduce 380 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'UPDATE', go to state 299
parser: Return. Stack=[with UPDATE]
parser: Input 'STRING' in state 299
parser: Reduce 71 [orconf ::=].
parser: ... then shift 'orconf', go to state 167
parser: Shift 'STRING', pending reduce 338
parser: Return. Stack=[with UPDATE orconf STRING]
parser: Input 'DOT' with pending reduce 338
parser: Reduce 338 [nm ::= STRING], go to state 167.
parser: ... then shift 'nm', go to state 395
parser: Shift 'DOT', go to state 218
parser: Return. Stack=[with UPDATE orconf nm DOT]
parser: Input 'ID' in state 218
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[with UPDATE orconf nm DOT ID]
parser: Input 'SET' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 218.
parser: ... then shift 'nm', go to state 432
parser: Reduce 114 [xfullname ::= nm DOT nm], go to state 167.
parser: ... then shift 'xfullname', go to state 271
parser: Reduce 123 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 431
parser: Shift 'SET', go to state 155
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET]
parser: Input 'ID' in state 155
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET ID]
parser: Input 'EQ' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 155.
parser: ... then shift 'nm', go to state 445
parser: Shift 'EQ', go to state 84
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ]
parser: Input 'STRING' in state 84
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ STRING]
parser: Input 'COMMA' in state 539
parser: Reduce 172 [term ::= STRING], go to state 84.
parser: ... then shift 'term', go to state 58
parser: Reduce 152 [setlist ::= nm EQ expr], go to state 155.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 447
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING' in state 86
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'COMMA' in state 539
parser: Reduce 172 [term ::= STRING], go to state 86.
parser: ... then shift 'term', go to state 60
parser: Reduce 150 [setlist ::= setlist COMMA nm EQ expr], go to state 155.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 447
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING' in state 86
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'COMMA' in state 539
parser: Reduce 172 [term ::= STRING], go to state 86.
parser: ... then shift 'term', go to state 60
parser: Reduce 150 [setlist ::= setlist COMMA nm EQ expr], go to state 155.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 447
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'VARIABLE' in state 86
parser: Shift 'VARIABLE', pending reduce 174
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ VARIABLE]
parser: Input 'COMMA' with pending reduce 174
parser: Reduce 174 [expr ::= VARIABLE], go to state 86.
parser: ... then shift 'expr', go to state 60
parser: Reduce 150 [setlist ::= setlist COMMA nm EQ expr], go to state 155.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 447
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING' in state 86
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'WHERE' in state 539
parser: Reduce 172 [term ::= STRING], go to state 86.
parser: ... then shift 'term', go to state 60
parser: Reduce 150 [setlist ::= setlist COMMA nm EQ expr], go to state 155.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 419
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE ID]
parser: Input 'EQ' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr EQ]
parser: Input 'VARIABLE' in state 117
parser: Shift 'VARIABLE', pending reduce 174
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr EQ VARIABLE]
parser: Input 'SEMI' with pending reduce 174
parser: Reduce 174 [expr ::= VARIABLE], go to state 117.
parser: ... then shift 'expr', go to state 129
parser: Reduce 186 [expr ::= expr EQ|NE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 148 [where_opt ::= WHERE expr], go to state 270.
parser: ... then shift 'where_opt', pending reduce 149
parser: Reduce 149 [cmd ::= with UPDATE orconf xfullname indexed_opt SET setlist where_opt], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Input '$' with pending reduce 327
parser: Reduce 327 [ecmd ::= cmdx SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 323 [input ::= cmdlist], go to state 0.
parser: ... then shift 'input', pending reduce -2
parser: Accept!
parser: ... then shift 'create_table_args', pending reduce 334
parser: Reduce 334 [cmd ::= create_table create_table_args], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdlist cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping cmdlist
SQL: [;
;CREATE TABLE x(y INTEGER PRIMARY KEY, t2i1);]
VDBE Trace:
   0 Init             0   28    0               00 Start at 28
  28 Transaction      0    1    6 1             01 usesStmtJournal=0
  29 Goto             0    1    0               00 
   1 ReadCookie       0    3    2               00 
REG[3] =  i:4
   2 If               3    5    0               00 
REG[3] =  i:4
   5 CreateBtree      0    2    1               00 r[2]=root iDb=0 flags=1
REG[2] =  i:5
   6 OpenWrite        0    1    0 5             00 root=1 iDb=0
   7 NewRowid         0    1    0               00 r[1]=rowid
REG[1] =  i:6
   8 Blob             6    3    0              00 r[3]= (len=6)
REG[3] =  tx6[060000000000|......]
   9 Insert           0    3    1               08 intkey=r[1] data=r[3]
REG[3] =  tx6[060000000000|......]
REG[1] =  i:6
  10 Close            0    0    0               00 
  11 Close            0    0    0               00 
  12 Null             0    4    5               00 r[4..5]=NULL
REG[4] =  NULL
  13 OpenWrite        1    1    0 5             00 root=1 iDb=0; sqlite_master
  14 Explain         14    0    0 SEARCH TABLE sqlite_master USING INTEGER PRIMARY KEY (rowid=?) 00 
  15 SeekRowid        1   17    1               00 intkey=r[1]
REG[1] =  i:6
  16 Rowid            1    5    0               00 r[5]=rowid
REG[5] =  i:6
  17 IsNull           5   25    0               00 if r[5]==NULL goto 25
REG[5] =  i:6
  18 String8          0    6    0 table         00 r[6]='table'
REG[6] =   t5[table](8)
  19 String8          0    7    0 x             00 r[7]='x'
REG[7] =   t1[x](8)
  20 String8          0    8    0 x             00 r[8]='x'
REG[8] =   t1[x](8)
  21 Copy             2    9    0               00 r[9]=r[2]
REG[9] =  i:5
  22 String8          0   10    0 CREATE TABLE x(y INTEGER PRIMARY KEY, t2i1) 00 r[10]='CREATE TABLE x(y INTEGER PRIMARY KEY, t2i1)'
REG[10] =   t43[CREATE TABLE x(y INTEGER ](8)
  23 MakeRecord       6    5    4 BBBDB         00 r[4]=mkrec(r[6..10])
REG[6] =   t5[table](8)
REG[7] =   t1[x](8)
REG[8] =   t1[x](8)
REG[9] =  i:5
REG[10] =   t43[CREATE TABLE x(y INTEGER ](8)
REG[4] =  sx57[06170F0F01637461626C65787805435245415445205441424C|.....ctablexx.CREATE TABL]
  24 Insert           1    4    5               00 intkey=r[5] data=r[4]
REG[4] =  sx57[06170F0F01637461626C65787805435245415445205441424C|.....ctablexx.CREATE TABL]
REG[5] =  i:6
  25 SetCookie        0    1    7               00 
  26 ParseSchema      0    0    0 tbl_name='x' AND type!='trigger' 00 
parser: [[[SELECT*FROM"main".sqlite_master WHERE tbl_name='x' AND type!='trigger' ORDER BY rowid]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'STAR' in state 288
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 95 [sclp ::=].
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STAR', pending reduce 97
parser: Return. Stack=[SELECT distinct sclp scanpt STAR]
parser: Input 'FROM' with pending reduce 97
parser: Reduce 97 [selcollist ::= sclp scanpt STAR], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 104 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'DOT' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 350
parser: Shift 'DOT', go to state 245
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID' in state 245
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'WHERE' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 245.
parser: ... then shift 'nm', pending reduce 110
parser: Reduce 110 [dbnm ::= DOT nm], go to state 350.
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 123 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 349
parser: Reduce 122 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 348
parser: Reduce 127 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 105
parser: Reduce 105 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 102 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 363
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[SELECT distinct selcollist from WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 419
parser: Return. Stack=[SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr EQ STRING]
parser: Input 'AND' in state 539
parser: Reduce 172 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 186 [expr ::= expr EQ|NE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'AND', go to state 120
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID' in state 120
parser: Shift 'ID', go to state 419
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'NE' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Shift 'NE', go to state 117
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr NE]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr NE STRING]
parser: Input 'ORDER' in state 539
parser: Reduce 172 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 186 [expr ::= expr EQ|NE expr], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Reduce 183 [expr ::= expr AND expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 148 [where_opt ::= WHERE expr], go to state 363.
parser: ... then shift 'where_opt', go to state 362
parser: Reduce 138 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 361
parser: Reduce 140 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 517
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 517
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 419
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 134 [sortorder ::=].
parser: ... then shift 'sortorder', go to state 353
parser: Reduce 137 [nulls ::=].
parser: ... then shift 'nulls', pending reduce 131
parser: Reduce 131 [sortlist ::= expr sortorder nulls], go to state 26.
parser: ... then shift 'sortlist', go to state 516
parser: Reduce 129 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 360
parser: Reduce 142 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 88
parser: Reduce 88 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 83 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 80
parser: Reduce 80 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
VDBE Trace:
   0 Init             0   17    0               00 Start at 17
  17 Transaction      0    0    7 1             00 usesStmtJournal=0
  18 String8          0    2    0 x             00 r[2]='x'
REG[2] =   t1[x](8)
  19 String8          0    3    0 trigger       00 r[3]='trigger'
REG[3] =   t7[trigger](8)
  20 Goto             0    1    0               00 
   1 Noop             1    7    0               00 
   2 OpenRead         0    1    0 5             00 root=1 iDb=0; sqlite_master
   3 Explain          3    0    0 SCAN TABLE sqlite_master 00 
   4 Rewind           0   16    0               00 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s1[a](8)
   6 Ne               2   15    1 (BINARY)      52 if r[1]!=r[2] goto 15
REG[2] =   t1[x](8)
REG[1] =   s1[a](8)
  15 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s2[ex](8)
   6 Ne               2   15    1 (BINARY)      52 if r[1]!=r[2] goto 15
REG[2] =   t1[x](8)
REG[1] =   s2[ex](8)
  15 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s1[a](8)
   6 Ne               2   15    1 (BINARY)      52 if r[1]!=r[2] goto 15
REG[2] =   t1[x](8)
REG[1] =   s1[a](8)
  15 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s2[t1](8)
   6 Ne               2   15    1 (BINARY)      52 if r[1]!=r[2] goto 15
REG[2] =   t1[x](8)
REG[1] =   s2[t1](8)
  15 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s2[t2](8)
   6 Ne               2   15    1 (BINARY)      52 if r[1]!=r[2] goto 15
REG[2] =   t1[x](8)
REG[1] =   s2[t2](8)
  15 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s1[x](8)
   6 Ne               2   15    1 (BINARY)      52 if r[1]!=r[2] goto 15
REG[2] =   t1[x](8)
REG[1] =   s1[x](8)
   7 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s5[table](8)
   8 Eq               3   15    1 (BINARY)      52 if r[1]==r[3] goto 15
REG[3] =   t7[trigger](8)
REG[1] =   s5[table](8)
   9 Column           0    0    4               00 r[4]=sqlite_master.type
REG[4] =   s5[table](8)
  10 Column           0    1    5               00 r[5]=sqlite_master.name
REG[5] =   s1[x](8)
  11 Column           0    2    6               00 r[6]=sqlite_master.tbl_name
REG[6] =   s1[x](8)
  12 Column           0    3    7               00 r[7]=sqlite_master.rootpage
REG[7] =  i:5
  13 Column           0    4    8               00 r[8]=sqlite_master.sql
REG[8] =   s43[CREATE TABLE x(y INTEGER ](8)
  14 ResultRow        4    5    0               00 output=r[4..8]
REG[4] =   s5[table](8)
REG[5] =   s1[x](8)
REG[6] =   s1[x](8)
REG[7] =  i:5
REG[8] =   s43[CREATE TABLE x(y INTEGER ](8)
parser: [[[CREATE TABLE x(y INTEGER PRIMARY KEY, t2i1)]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 390
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 0.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP ID]
parser: Input 'ID' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 192
parser: Shift 'ID', pending reduce 341
parser: Return. Stack=[create_table LP nm ID]
parser: Input 'PRIMARY' with pending reduce 341
parser: Reduce 341 [typename ::= ID|STRING], go to state 192.
parser: ... then shift 'typename', go to state 392
parser: Reduce 340 [typetoken ::= typename], go to state 192.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 379
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 152
parser: Shift 'PRIMARY', go to state 478
parser: Return. Stack=[create_table LP columnname carglist PRIMARY]
parser: Input 'KEY' in state 478
parser: Shift 'KEY', go to state 280
parser: Return. Stack=[create_table LP columnname carglist PRIMARY KEY]
parser: Input 'COMMA' in state 280
parser: Reduce 134 [sortorder ::=].
parser: ... then shift 'sortorder', go to state 333
parser: Reduce 69 [onconf ::=].
parser: ... then shift 'onconf', go to state 332
parser: Reduce 43 [autoinc ::=].
parser: ... then shift 'autoinc', pending reduce 37
parser: Reduce 37 [ccons ::= PRIMARY KEY sortorder onconf autoinc], go to state 152.
parser: ... then shift 'ccons', pending reduce 344
parser: Reduce 344 [carglist ::= carglist ccons], go to state 379.
parser: ... then shift 'carglist', go to state 152
parser: Reduce 336 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'RP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Reduce 61 [conslist_opt ::=].
parser: ... then shift 'conslist_opt', go to state 540
parser: Shift 'RP', go to state 364
parser: Return. Stack=[create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 364
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: ... then shift 'create_table_args', pending reduce 334
parser: Reduce 334 [cmd ::= create_table create_table_args], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
  15 Next             0    5    0               01 
  16 Halt             0    0    0               00 
  27 Halt             0    0    0               00 
parser: [[[ALTER TABLE x ADD t1i1
    
;;
;SELECT x.RowID id FROM a, x WHERE a.b = x.RowID AND id = 2;SELECT*FROM"temp".sqlite_temp_master ORDER BY rowid
;ALTER TABLE x ADD abc
    
;CREATE INDEX c ON a(b)
;CREATE INDEX v1 ON a(b)
;ALTER TABLE ex ADD v2
    
;CREATE TABLE tr1(t1a, t1b);;SELECT y, v2 FROM x, ex WHERE y>v2;;
;SELECT DISTINCT b FROM a LEFT JOIN ex ON b=v2 ORDER BY +v2;CREATE INDEX x1 ON a(b)
;CREATE INDEX z ON a(b)
;CREATE INDEX example ON ex(v2)
;;SELECT count(*) FROM sqlite_master WHERE tbl_name = 'e' AND type = 'index';;
;CREATE TABLE example_idx_00000042(id PRIMARY KEY, UNIQUE(id) );;BEGIN;;CREATE UNIQUE INDEX IF NOT EXISTS a_id ON a(b==0);;SELECT * FROM ex;]]]
parser: Input 'ALTER' in state 0
parser: Shift 'ALTER', go to state 426
parser: Return. Stack=[ALTER]
parser: Input 'TABLE' in state 426
parser: Shift 'TABLE', go to state 133
parser: Return. Stack=[ALTER TABLE]
parser: Input 'ID' in state 133
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[ALTER TABLE ID]
parser: Input 'ADD' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 133.
parser: ... then shift 'nm', go to state 462
parser: Reduce 111 [fullname ::= nm], go to state 133.
parser: ... then shift 'fullname', go to state 425
parser: Reduce 279 [add_column_fullname ::= fullname], go to state 133.
parser: ... then shift 'add_column_fullname', go to state 423
parser: Shift 'ADD', go to state 290
parser: Return. Stack=[ALTER TABLE add_column_fullname ADD]
parser: Input 'ID' in state 290
parser: Reduce 372 [kwcolumn_opt ::=].
parser: ... then shift 'kwcolumn_opt', go to state 165
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[ALTER TABLE add_column_fullname ADD kwcolumn_opt ID]
parser: Input 'SEMI' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 165.
parser: ... then shift 'nm', go to state 192
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 165.
parser: ... then shift 'columnname', go to state 374
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 151
parser: Reduce 278 [cmd ::= ALTER TABLE add_column_fullname ADD kwcolumn_opt columnname carglist], go to state 0.
parser: [[[UPDATE "main".sqlite_master SET sql = substr(sql,1,42) || ', ' || 't1i1' || substr(sql,43) WHERE type = 'table' AND name = 'x']]]
parser: Input 'UPDATE' in state 0
parser: Reduce 380 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'UPDATE', go to state 299
parser: Return. Stack=[with UPDATE]
parser: Input 'ID' in state 299
parser: Reduce 71 [orconf ::=].
parser: ... then shift 'orconf', go to state 167
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[with UPDATE orconf ID]
parser: Input 'DOT' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 167.
parser: ... then shift 'nm', go to state 395
parser: Shift 'DOT', go to state 218
parser: Return. Stack=[with UPDATE orconf nm DOT]
parser: Input 'ID' in state 218
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[with UPDATE orconf nm DOT ID]
parser: Input 'SET' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 218.
parser: ... then shift 'nm', go to state 432
parser: Reduce 114 [xfullname ::= nm DOT nm], go to state 167.
parser: ... then shift 'xfullname', go to state 271
parser: Reduce 123 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 431
parser: Shift 'SET', go to state 155
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET]
parser: Input 'ID' in state 155
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET ID]
parser: Input 'EQ' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 155.
parser: ... then shift 'nm', go to state 445
parser: Shift 'EQ', go to state 84
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ]
parser: Input 'ID' in state 84
parser: Shift 'ID', go to state 419
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ ID]
parser: Input 'LP' in state 419
parser: Shift 'LP', go to state 266
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ ID LP]
parser: Input 'ID' in state 266
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 419
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ ID LP distinct ID]
parser: Input 'COMMA' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 220 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 519
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ ID LP distinct nexprlist COMMA]
parser: Input 'INTEGER' in state 107
parser: Shift 'INTEGER', pending reduce 173
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ ID LP distinct nexprlist COMMA INTEGER]
parser: Input 'COMMA' with pending reduce 173
parser: Reduce 173 [term ::= INTEGER], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 219 [nexprlist ::= nexprlist COMMA expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 519
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ ID LP distinct nexprlist COMMA]
parser: Input 'INTEGER' in state 107
parser: Shift 'INTEGER', pending reduce 173
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ ID LP distinct nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 173
parser: Reduce 173 [term ::= INTEGER], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 219 [nexprlist ::= nexprlist COMMA expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 519
parser: Reduce 359 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 484
parser: Shift 'RP', go to state 146
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ ID LP distinct exprlist RP]
parser: Input 'CONCAT' in state 146
parser: Reduce 177 [expr ::= ID|INDEXED LP distinct exprlist RP], go to state 84.
parser: ... then shift 'expr', go to state 58
parser: Shift 'CONCAT', go to state 113
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ expr CONCAT]
parser: Input 'STRING' in state 113
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ expr CONCAT STRING]
parser: Input 'CONCAT' in state 539
parser: Reduce 172 [term ::= STRING], go to state 113.
parser: ... then shift 'term', go to state 148
parser: Reduce 190 [expr ::= expr CONCAT expr], go to state 84.
parser: ... then shift 'expr', go to state 58
parser: Shift 'CONCAT', go to state 113
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ expr CONCAT]
parser: Input 'STRING' in state 113
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ expr CONCAT STRING]
parser: Input 'CONCAT' in state 539
parser: Reduce 172 [term ::= STRING], go to state 113.
parser: ... then shift 'term', go to state 148
parser: Reduce 190 [expr ::= expr CONCAT expr], go to state 84.
parser: ... then shift 'expr', go to state 58
parser: Shift 'CONCAT', go to state 113
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ expr CONCAT]
parser: Input 'ID' in state 113
parser: Shift 'ID', go to state 419
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ expr CONCAT ID]
parser: Input 'LP' in state 419
parser: Shift 'LP', go to state 266
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ expr CONCAT ID LP]
parser: Input 'ID' in state 266
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 419
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ expr CONCAT ID LP distinct ID]
parser: Input 'COMMA' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 220 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 519
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ expr CONCAT ID LP distinct nexprlist COMMA]
parser: Input 'INTEGER' in state 107
parser: Shift 'INTEGER', pending reduce 173
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ expr CONCAT ID LP distinct nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 173
parser: Reduce 173 [term ::= INTEGER], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 219 [nexprlist ::= nexprlist COMMA expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 519
parser: Reduce 359 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 484
parser: Shift 'RP', go to state 146
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ expr CONCAT ID LP distinct exprlist RP]
parser: Input 'WHERE' in state 146
parser: Reduce 177 [expr ::= ID|INDEXED LP distinct exprlist RP], go to state 113.
parser: ... then shift 'expr', go to state 148
parser: Reduce 190 [expr ::= expr CONCAT expr], go to state 84.
parser: ... then shift 'expr', go to state 58
parser: Reduce 152 [setlist ::= nm EQ expr], go to state 155.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 419
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE ID]
parser: Input 'EQ' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr EQ]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr EQ STRING]
parser: Input 'AND' in state 539
parser: Reduce 172 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 186 [expr ::= expr EQ|NE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'AND', go to state 120
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr AND]
parser: Input 'ID' in state 120
parser: Shift 'ID', go to state 419
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr AND ID]
parser: Input 'EQ' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr AND expr EQ]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr AND expr EQ STRING]
parser: Input 'SEMI' in state 539
parser: Reduce 172 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 186 [expr ::= expr EQ|NE expr], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Reduce 183 [expr ::= expr AND expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 148 [where_opt ::= WHERE expr], go to state 270.
parser: ... then shift 'where_opt', pending reduce 149
parser: Reduce 149 [cmd ::= with UPDATE orconf xfullname indexed_opt SET setlist where_opt], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Input '$' with pending reduce 327
parser: Reduce 327 [ecmd ::= cmdx SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 323 [input ::= cmdlist], go to state 0.
parser: ... then shift 'input', pending reduce -2
parser: Accept!
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
SQL: [ALTER TABLE x ADD t1i1
    
;]
VDBE Trace:
   0 Init             0   37    0               00 Start at 37
  37 Transaction      0    1    7 1             01 usesStmtJournal=1
  38 String8          0    9    0 table         00 r[9]='table'
REG[9] =   t5[table](8)
  39 String8          0   10    0 x             00 r[10]='x'
REG[10] =   t1[x](8)
  40 Integer          1   15    0               00 r[15]=1
REG[15] =  i:1
  41 Integer         42   16    0               00 r[16]=42
REG[16] =  i:42
  42 String8          0   17    0 ,             00 r[17]=', '
REG[17] =   t2[, ](8)
  43 String8          0   18    0 t1i1          00 r[18]='t1i1'
REG[18] =   t4[t1i1](8)
  44 Integer         43   20    0               00 r[20]=43
REG[20] =  i:43
  45 Goto             0    1    0               00 
   1 Null             0    1    2               00 r[1..2]=NULL
REG[1] =  NULL
   2 OpenRead         0    1    0 2             00 root=1 iDb=0; sqlite_master
   3 Explain          3    0    0 SCAN TABLE sqlite_master 00 
   4 Rewind           0   12    0               00 
   5 Column           0    0    8               00 r[8]=sqlite_master.type
REG[8] =   s5[table](8)
   6 Ne               9   11    8 (BINARY)      52 if r[8]!=r[9] goto 11
REG[9] =   t5[table](8)
REG[8] =   s5[table](8)
   7 Column           0    1    8               00 r[8]=sqlite_master.name
REG[8] =   s1[a](8)
   8 Ne              10   11    8 (BINARY)      52 if r[8]!=r[10] goto 11
REG[10] =   t1[x](8)
REG[8] =   s1[a](8)
  11 Next             0    5    0               01 
   5 Column           0    0    8               00 r[8]=sqlite_master.type
REG[8] =   s5[table](8)
   6 Ne               9   11    8 (BINARY)      52 if r[8]!=r[9] goto 11
REG[9] =   t5[table](8)
REG[8] =   s5[table](8)
   7 Column           0    1    8               00 r[8]=sqlite_master.name
REG[8] =   s2[ex](8)
   8 Ne              10   11    8 (BINARY)      52 if r[8]!=r[10] goto 11
REG[10] =   t1[x](8)
REG[8] =   s2[ex](8)
  11 Next             0    5    0               01 
   5 Column           0    0    8               00 r[8]=sqlite_master.type
REG[8] =   s5[index](8)
   6 Ne               9   11    8 (BINARY)      52 if r[8]!=r[9] goto 11
REG[9] =   t5[table](8)
REG[8] =   s5[index](8)
  11 Next             0    5    0               01 
   5 Column           0    0    8               00 r[8]=sqlite_master.type
REG[8] =   s4[view](8)
   6 Ne               9   11    8 (BINARY)      52 if r[8]!=r[9] goto 11
REG[9] =   t5[table](8)
REG[8] =   s4[view](8)
  11 Next             0    5    0               01 
   5 Column           0    0    8               00 r[8]=sqlite_master.type
REG[8] =   s4[view](8)
   6 Ne               9   11    8 (BINARY)      52 if r[8]!=r[9] goto 11
REG[9] =   t5[table](8)
REG[8] =   s4[view](8)
  11 Next             0    5    0               01 
   5 Column           0    0    8               00 r[8]=sqlite_master.type
REG[8] =   s5[table](8)
   6 Ne               9   11    8 (BINARY)      52 if r[8]!=r[9] goto 11
REG[9] =   t5[table](8)
REG[8] =   s5[table](8)
   7 Column           0    1    8               00 r[8]=sqlite_master.name
REG[8] =   s1[x](8)
   8 Ne              10   11    8 (BINARY)      52 if r[8]!=r[10] goto 11
REG[10] =   t1[x](8)
REG[8] =   s1[x](8)
   9 Rowid            0    2    0               00 r[2]=rowid
REG[2] =  i:6
  10 RowSetAdd        1    2    0               00 rowset(1)=r[2]
REG[1] =  NULL
REG[2] =  i:6
  11 Next             0    5    0               01 
  12 OpenWrite        0    1    0 5             00 root=1 iDb=0; sqlite_master
  13 RowSetRead       1   29    2               00 r[2]=rowset(1)
REG[1] =  (rowset)
REG[2] =  i:6
  14 NotExists        0   13    2               00 intkey=r[2]
REG[2] =  i:6
  15 Column           0    0    3               00 r[3]=sqlite_master.type
REG[3] =   s5[table](8)
  16 Column           0    1    4               00 r[4]=sqlite_master.name
REG[4] =   s1[x](8)
  17 Column           0    2    5               00 r[5]=sqlite_master.tbl_name
REG[5] =   s1[x](8)
  18 Column           0    3    6               00 r[6]=sqlite_master.rootpage
REG[6] =  i:5
  19 Column           0    4   14               00 r[14]=sqlite_master.sql
REG[14] =   s43[CREATE TABLE x(y INTEGER ](8)
  20 Function0        6   14   13 substr(3)     03 r[13]=func(r[14..16])
REG[14] =   s43[CREATE TABLE x(y INTEGER ](8)
REG[15] =  i:1
REG[16] =  i:42
REG[13] =   s42[CREATE TABLE x(y INTEGER ](8)
  21 Concat          17   13   12               00 r[12]=r[13]+r[17]
REG[17] =   t2[, ](8)
REG[13] =   s42[CREATE TABLE x(y INTEGER ](8)
REG[12] =   s44[CREATE TABLE x(y INTEGER ](8)
  22 Concat          18   12    8               00 r[8]=r[12]+r[18]
REG[18] =   t4[t1i1](8)
REG[12] =   s44[CREATE TABLE x(y INTEGER ](8)
REG[8] =   s48[CREATE TABLE x(y INTEGER ](8)
  23 Column           0    4   19               00 r[19]=sqlite_master.sql
REG[19] =   s43[CREATE TABLE x(y INTEGER ](8)
  24 Function0        2   19   12 substr(2)     02 r[12]=func(r[19..20])
REG[19] =   s43[CREATE TABLE x(y INTEGER ](8)
REG[20] =  i:43
REG[12] =   s1[)](8)
  25 Concat          12    8    7               00 r[7]=r[8]+r[12]
REG[12] =   s1[)](8)
REG[8] =   s48[CREATE TABLE x(y INTEGER ](8)
REG[7] =   s49[CREATE TABLE x(y INTEGER ](8)
  26 MakeRecord       3    5   11 BBBDB         00 r[11]=mkrec(r[3..7])
REG[3] =   s5[table](8)
REG[4] =   s1[x](8)
REG[5] =   s1[x](8)
REG[6] =  i:5
REG[7] =   s49[CREATE TABLE x(y INTEGER ](8)
REG[11] =  sx63[06170F0F016F7461626C65787805435245415445205441424C|.....otablexx.CREATE TABL]
  27 Insert           0   11    2               00 intkey=r[2] data=r[11]
REG[11] =  sx63[06170F0F016F7461626C65787805435245415445205441424C|.....otablexx.CREATE TABL]
REG[2] =  i:6
  28 Goto             0   13    0               00 
  13 RowSetRead       1   29    2               00 r[2]=rowset(1)
REG[1] =  (rowset)
REG[2] =  i:6
  29 ReadCookie       0   12    2               00 
REG[12] =  i:4
  30 AddImm          12   -2    0               00 r[12]=r[12]+-2
REG[12] =  i:4
  31 IfPos           12   33    0               00 if r[12]>0 then r[12]-=0, goto 33
REG[12] =  i:2
  33 SetCookie        0    1    8               00 
  34 ParseSchema      0    0    0               00 
parser: [[[CREATE TABLE x(type text,name text,tbl_name text,rootpage int,sql text)]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 390
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 0.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP ID]
parser: Input 'ID' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 192
parser: Shift 'ID', pending reduce 341
parser: Return. Stack=[create_table LP nm ID]
parser: Input 'COMMA' with pending reduce 341
parser: Reduce 341 [typename ::= ID|STRING], go to state 192.
parser: ... then shift 'typename', go to state 392
parser: Reduce 340 [typetoken ::= typename], go to state 192.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 379
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 152
parser: Reduce 336 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'ID' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Shift 'ID', pending reduce 341
parser: Return. Stack=[create_table LP columnlist COMMA nm ID]
parser: Input 'COMMA' with pending reduce 341
parser: Reduce 341 [typename ::= ID|STRING], go to state 192.
parser: ... then shift 'typename', go to state 392
parser: Reduce 340 [typetoken ::= typename], go to state 192.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'ID' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Shift 'ID', pending reduce 341
parser: Return. Stack=[create_table LP columnlist COMMA nm ID]
parser: Input 'COMMA' with pending reduce 341
parser: Reduce 341 [typename ::= ID|STRING], go to state 192.
parser: ... then shift 'typename', go to state 392
parser: Reduce 340 [typetoken ::= typename], go to state 192.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'ID' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Shift 'ID', pending reduce 341
parser: Return. Stack=[create_table LP columnlist COMMA nm ID]
parser: Input 'COMMA' with pending reduce 341
parser: Reduce 341 [typename ::= ID|STRING], go to state 192.
parser: ... then shift 'typename', go to state 392
parser: Reduce 340 [typetoken ::= typename], go to state 192.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'ID' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Shift 'ID', pending reduce 341
parser: Return. Stack=[create_table LP columnlist COMMA nm ID]
parser: Input 'RP' with pending reduce 341
parser: Reduce 341 [typename ::= ID|STRING], go to state 192.
parser: ... then shift 'typename', go to state 392
parser: Reduce 340 [typetoken ::= typename], go to state 192.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Reduce 61 [conslist_opt ::=].
parser: ... then shift 'conslist_opt', go to state 540
parser: Shift 'RP', go to state 364
parser: Return. Stack=[create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 364
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: ... then shift 'create_table_args', pending reduce 334
parser: Reduce 334 [cmd ::= create_table create_table_args], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT*FROM"main".sqlite_master ORDER BY rowid]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'STAR' in state 288
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 95 [sclp ::=].
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STAR', pending reduce 97
parser: Return. Stack=[SELECT distinct sclp scanpt STAR]
parser: Input 'FROM' with pending reduce 97
parser: Reduce 97 [selcollist ::= sclp scanpt STAR], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 104 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'DOT' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 350
parser: Shift 'DOT', go to state 245
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID' in state 245
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'ORDER' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 245.
parser: ... then shift 'nm', pending reduce 110
parser: Reduce 110 [dbnm ::= DOT nm], go to state 350.
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 123 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 349
parser: Reduce 122 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 348
parser: Reduce 127 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 105
parser: Reduce 105 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 102 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 363
parser: Reduce 147 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 362
parser: Reduce 138 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 361
parser: Reduce 140 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 517
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 517
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 419
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 134 [sortorder ::=].
parser: ... then shift 'sortorder', go to state 353
parser: Reduce 137 [nulls ::=].
parser: ... then shift 'nulls', pending reduce 131
parser: Reduce 131 [sortlist ::= expr sortorder nulls], go to state 26.
parser: ... then shift 'sortlist', go to state 516
parser: Reduce 129 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 360
parser: Reduce 142 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 88
parser: Reduce 88 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 83 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 80
parser: Reduce 80 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
VDBE Trace:
   0 Init             0   13    0               00 Start at 13
  13 Transaction      0    0    8 2             00 usesStmtJournal=0
  14 Goto             0    1    0               00 
   1 Noop             1    7    0               00 
   2 OpenRead         0    1    0 5             00 root=1 iDb=0; sqlite_master
   3 Explain          3    0    0 SCAN TABLE sqlite_master 00 
   4 Rewind           0   12    0               00 
   5 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s5[table](8)
   6 Column           0    1    2               00 r[2]=sqlite_master.name
REG[2] =   s1[a](8)
   7 Column           0    2    3               00 r[3]=sqlite_master.tbl_name
REG[3] =   s1[a](8)
   8 Column           0    3    4               00 r[4]=sqlite_master.rootpage
REG[4] =  i:2
   9 Column           0    4    5               00 r[5]=sqlite_master.sql
REG[5] =   s56[CREATE TABLE a (b INTEGER](8)
  10 ResultRow        1    5    0               00 output=r[1..5]
REG[1] =   s5[table](8)
REG[2] =   s1[a](8)
REG[3] =   s1[a](8)
REG[4] =  i:2
REG[5] =   s56[CREATE TABLE a (b INTEGER](8)
parser: [[[CREATE TABLE a (b INTEGER, PRIMARY KEY(b)) WITHOUT ROWID]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 390
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 0.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP ID]
parser: Input 'ID' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 192
parser: Shift 'ID', pending reduce 341
parser: Return. Stack=[create_table LP nm ID]
parser: Input 'COMMA' with pending reduce 341
parser: Reduce 341 [typename ::= ID|STRING], go to state 192.
parser: ... then shift 'typename', go to state 392
parser: Reduce 340 [typetoken ::= typename], go to state 192.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 379
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 152
parser: Reduce 336 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'PRIMARY' in state 34
parser: Shift 'PRIMARY', go to state 475
parser: Return. Stack=[create_table LP columnlist COMMA PRIMARY]
parser: Input 'KEY' in state 475
parser: Shift 'KEY', go to state 474
parser: Return. Stack=[create_table LP columnlist COMMA PRIMARY KEY]
parser: Input 'LP' in state 474
parser: Shift 'LP', go to state 20
parser: Return. Stack=[create_table LP columnlist COMMA PRIMARY KEY LP]
parser: Input 'ID' in state 20
parser: Shift 'ID', go to state 419
parser: Return. Stack=[create_table LP columnlist COMMA PRIMARY KEY LP ID]
parser: Input 'RP' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 20.
parser: ... then shift 'expr', go to state 13
parser: Reduce 134 [sortorder ::=].
parser: ... then shift 'sortorder', go to state 353
parser: Reduce 137 [nulls ::=].
parser: ... then shift 'nulls', pending reduce 131
parser: Reduce 131 [sortlist ::= expr sortorder nulls], go to state 20.
parser: ... then shift 'sortlist', go to state 277
parser: Reduce 43 [autoinc ::=].
parser: ... then shift 'autoinc', go to state 473
parser: Shift 'RP', go to state 328
parser: Return. Stack=[create_table LP columnlist COMMA PRIMARY KEY LP sortlist autoinc RP]
parser: Input 'RP' in state 328
parser: Reduce 69 [onconf ::=].
parser: ... then shift 'onconf', pending reduce 64
parser: Reduce 64 [tcons ::= PRIMARY KEY LP sortlist autoinc RP onconf], go to state 34.
parser: ... then shift 'tcons', go to state 278
parser: Reduce 347 [conslist_opt ::= COMMA conslist], go to state 365.
parser: ... then shift 'conslist_opt', go to state 540
parser: Shift 'RP', go to state 364
parser: Return. Stack=[create_table LP columnlist conslist_opt RP]
parser: Input 'WITHOUT' in state 364
parser: Shift 'WITHOUT', go to state 251
parser: Return. Stack=[create_table LP columnlist conslist_opt RP WITHOUT]
parser: Input 'ID' in state 251
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist conslist_opt RP WITHOUT ID]
parser: Input 'SEMI' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 251.
parser: ... then shift 'nm', pending reduce 22
parser: Reduce 22 [table_options ::= WITHOUT nm], go to state 364.
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: ... then shift 'create_table_args', pending reduce 334
parser: Reduce 334 [cmd ::= create_table create_table_args], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
  11 Next             0    5    0               01 
   5 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s5[table](8)
   6 Column           0    1    2               00 r[2]=sqlite_master.name
REG[2] =   s2[ex](8)
   7 Column           0    2    3               00 r[3]=sqlite_master.tbl_name
REG[3] =   s2[ex](8)
   8 Column           0    3    4               00 r[4]=sqlite_master.rootpage
REG[4] =  i:3
   9 Column           0    4    5               00 r[5]=sqlite_master.sql
REG[5] =   s19[CREATE TABLE ex(i1)](8)
  10 ResultRow        1    5    0               00 output=r[1..5]
REG[1] =   s5[table](8)
REG[2] =   s2[ex](8)
REG[3] =   s2[ex](8)
REG[4] =  i:3
REG[5] =   s19[CREATE TABLE ex(i1)](8)
parser: [[[CREATE TABLE ex(i1)]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 390
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 0.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP ID]
parser: Input 'RP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 192
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 379
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 152
parser: Reduce 336 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Reduce 61 [conslist_opt ::=].
parser: ... then shift 'conslist_opt', go to state 540
parser: Shift 'RP', go to state 364
parser: Return. Stack=[create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 364
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: ... then shift 'create_table_args', pending reduce 334
parser: Reduce 334 [cmd ::= create_table create_table_args], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
  11 Next             0    5    0               01 
   5 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s5[index](8)
   6 Column           0    1    2               00 r[2]=sqlite_master.name
REG[2] =   s2[i2](8)
   7 Column           0    2    3               00 r[3]=sqlite_master.tbl_name
REG[3] =   s1[a](8)
   8 Column           0    3    4               00 r[4]=sqlite_master.rootpage
REG[4] =  i:4
   9 Column           0    4    5               00 r[5]=sqlite_master.sql
REG[5] =   s38[CREATE INDEX i2 ON a(b CO](8)
  10 ResultRow        1    5    0               00 output=r[1..5]
REG[1] =   s5[index](8)
REG[2] =   s2[i2](8)
REG[3] =   s1[a](8)
REG[4] =  i:4
REG[5] =   s38[CREATE INDEX i2 ON a(b CO](8)
parser: [[[CREATE INDEX i2 ON a(b COLLATE binary)]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'INDEX' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 225 [uniqueflag ::=].
parser: ... then shift 'uniqueflag', go to state 456
parser: Shift 'INDEX', go to state 315
parser: Return. Stack=[createkw uniqueflag INDEX]
parser: Input 'ID' in state 315
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 225
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists ID]
parser: Input 'ON' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 225.
parser: ... then shift 'nm', go to state 314
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 455
parser: Shift 'ON', go to state 224
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON]
parser: Input 'ID' in state 224
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON ID]
parser: Input 'LP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 224.
parser: ... then shift 'nm', go to state 454
parser: Shift 'LP', go to state 18
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP]
parser: Input 'ID' in state 18
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP ID]
parser: Input 'COLLATE' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 18.
parser: ... then shift 'expr', go to state 13
parser: Shift 'COLLATE', go to state 418
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP expr COLLATE]
parser: Input 'ID' in state 418
parser: Shift 'ID', pending reduce 175
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP expr COLLATE ID]
parser: Input 'RP' with pending reduce 175
parser: Reduce 175 [expr ::= expr COLLATE ID|STRING], go to state 18.
parser: ... then shift 'expr', go to state 13
parser: Reduce 134 [sortorder ::=].
parser: ... then shift 'sortorder', go to state 353
parser: Reduce 137 [nulls ::=].
parser: ... then shift 'nulls', pending reduce 131
parser: Reduce 131 [sortlist ::= expr sortorder nulls], go to state 18.
parser: ... then shift 'sortlist', go to state 402
parser: Shift 'RP', go to state 313
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP]
parser: Input 'SEMI' in state 313
parser: Reduce 147 [where_opt ::=].
parser: ... then shift 'where_opt', pending reduce 223
parser: Reduce 223 [cmd ::= createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP where_opt], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
  11 Next             0    5    0               01 
   5 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s4[view](8)
   6 Column           0    1    2               00 r[2]=sqlite_master.name
REG[2] =   s2[t1](8)
   7 Column           0    2    3               00 r[3]=sqlite_master.tbl_name
REG[3] =   s2[t1](8)
   8 Column           0    3    4               00 r[4]=sqlite_master.rootpage
REG[4] =  i:0
   9 Column           0    4    5               00 r[5]=sqlite_master.sql
REG[5] =   s210[CREATE VIEW t1 AS SELECT ](8)
  10 ResultRow        1    5    0               00 output=r[1..5]
REG[1] =   s4[view](8)
REG[2] =   s2[t1](8)
REG[3] =   s2[t1](8)
REG[4] =  i:0
REG[5] =   s210[CREATE VIEW t1 AS SELECT ](8)
parser: [[[CREATE VIEW t1 AS SELECT 123
    
      WINDOW x AS (
        RANGE BETWEEN UNBOUNDED PRECEDING AND INDEXED() OVER(
          PARTITION BY ( WITH x AS(VALUES(col1)) VALUES(453) )
        )
      FOLLOWING
    )]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'VIEW' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: FALLBACK VIEW => ID
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 390
parser: Shift 'VIEW', go to state 322
parser: Return. Stack=[createkw temp VIEW]
parser: Input 'ID' in state 322
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 228
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw temp VIEW ifnotexists ID]
parser: Input 'AS' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 228.
parser: ... then shift 'nm', go to state 321
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 320
parser: Reduce 226 [eidlist_opt ::=].
parser: ... then shift 'eidlist_opt', go to state 464
parser: Shift 'AS', go to state 37
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS]
parser: Input 'SELECT' in state 37
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT]
parser: Input 'INTEGER' in state 288
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 95 [sclp ::=].
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'INTEGER', pending reduce 173
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt INTEGER]
parser: Input 'WINDOW' with pending reduce 173
parser: Reduce 173 [term ::= INTEGER], go to state 77.
parser: ... then shift 'term', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Reduce 101 [from ::=].
parser: ... then shift 'from', go to state 363
parser: Reduce 147 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 362
parser: Reduce 138 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 361
parser: Reduce 140 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'WINDOW', go to state 136
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW]
parser: Input 'ID' in state 136
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW ID]
parser: Input 'AS' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 136.
parser: ... then shift 'nm', go to state 514
parser: Shift 'AS', go to state 513
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS]
parser: Input 'LP' in state 513
parser: Shift 'LP', go to state 33
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP]
parser: Input 'RANGE' in state 33
parser: Shift 'RANGE', pending reduce 304
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP RANGE]
parser: Input 'BETWEEN' with pending reduce 304
parser: Reduce 304 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 33.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP range_or_rows BETWEEN]
parser: Input 'UNBOUNDED' in state 8
parser: Shift 'UNBOUNDED', go to state 505
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP range_or_rows BETWEEN UNBOUNDED]
parser: Input 'PRECEDING' in state 505
parser: Shift 'PRECEDING', pending reduce 306
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP range_or_rows BETWEEN UNBOUNDED PRECEDING]
parser: Input 'AND' with pending reduce 306
parser: Reduce 306 [frame_bound_s ::= UNBOUNDED PRECEDING], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 508
parser: Shift 'AND', go to state 7
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'INDEXED' in state 7
parser: Shift 'INDEXED', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP range_or_rows BETWEEN frame_bound_s AND INDEXED]
parser: Input 'LP' in state 419
parser: Shift 'LP', go to state 266
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP range_or_rows BETWEEN frame_bound_s AND INDEXED LP]
parser: Input 'RP' in state 266
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Reduce 218 [exprlist ::=].
parser: ... then shift 'exprlist', go to state 484
parser: Shift 'RP', go to state 146
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP range_or_rows BETWEEN frame_bound_s AND INDEXED LP distinct exprlist RP]
parser: Input 'OVER' in state 146
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP range_or_rows BETWEEN frame_bound_s AND INDEXED LP distinct exprlist RP OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP range_or_rows BETWEEN frame_bound_s AND INDEXED LP distinct exprlist RP OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 511
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP range_or_rows BETWEEN frame_bound_s AND INDEXED LP distinct exprlist RP OVER LP PARTITION]
parser: Input 'BY' in state 511
parser: Shift 'BY', go to state 25
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP range_or_rows BETWEEN frame_bound_s AND INDEXED LP distinct exprlist RP OVER LP PARTITION BY]
parser: Input 'LP' in state 25
parser: Shift 'LP', go to state 4
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP range_or_rows BETWEEN frame_bound_s AND INDEXED LP distinct exprlist RP OVER LP PARTITION BY LP]
parser: Input 'WITH' in state 4
parser: Shift 'WITH', go to state 162
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP range_or_rows BETWEEN frame_bound_s AND INDEXED LP distinct exprlist RP OVER LP PARTITION BY LP WITH]
parser: Input 'ID' in state 162
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP range_or_rows BETWEEN frame_bound_s AND INDEXED LP distinct exprlist RP OVER LP PARTITION BY LP WITH ID]
parser: Input 'AS' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 162.
parser: ... then shift 'nm', go to state 338
parser: Reduce 226 [eidlist_opt ::=].
parser: ... then shift 'eidlist_opt', go to state 489
parser: Shift 'AS', go to state 488
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP range_or_rows BETWEEN frame_bound_s AND INDEXED LP distinct exprlist RP OVER LP PARTITION BY LP WITH nm eidlist_opt AS]
parser: Input 'LP' in state 488
parser: Shift 'LP', go to state 39
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP range_or_rows BETWEEN frame_bound_s AND INDEXED LP distinct exprlist RP OVER LP PARTITION BY LP WITH nm eidlist_opt AS LP]
parser: Input 'VALUES' in state 39
parser: Shift 'VALUES', go to state 528
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP range_or_rows BETWEEN frame_bound_s AND INDEXED LP distinct exprlist RP OVER LP PARTITION BY LP WITH nm eidlist_opt AS LP VALUES]
parser: Input 'LP' in state 528
parser: Shift 'LP', go to state 28
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP range_or_rows BETWEEN frame_bound_s AND INDEXED LP distinct exprlist RP OVER LP PARTITION BY LP WITH nm eidlist_opt AS LP VALUES LP]
parser: Input 'ID' in state 28
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP range_or_rows BETWEEN frame_bound_s AND INDEXED LP distinct exprlist RP OVER LP PARTITION BY LP WITH nm eidlist_opt AS LP VALUES LP ID]
parser: Input 'RP' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 28.
parser: ... then shift 'expr', go to state 70
parser: Reduce 220 [nexprlist ::= expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 413
parser: Shift 'RP', pending reduce 90
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP range_or_rows BETWEEN frame_bound_s AND INDEXED LP distinct exprlist RP OVER LP PARTITION BY LP WITH nm eidlist_opt AS LP VALUES LP nexprlist RP]
parser: Input 'RP' with pending reduce 90
parser: Reduce 90 [values ::= VALUES LP nexprlist RP], go to state 39.
parser: ... then shift 'values', go to state 534
parser: Reduce 354 [oneselect ::= values], go to state 39.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 83 [select ::= selectnowith], go to state 39.
parser: ... then shift 'select', go to state 487
parser: Shift 'RP', pending reduce 290
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP range_or_rows BETWEEN frame_bound_s AND INDEXED LP distinct exprlist RP OVER LP PARTITION BY LP WITH nm eidlist_opt AS LP select RP]
parser: Input 'VALUES' with pending reduce 290
parser: Reduce 290 [wqlist ::= nm eidlist_opt AS LP select RP], go to state 162.
parser: ... then shift 'wqlist', go to state 143
parser: Shift 'VALUES', go to state 528
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP range_or_rows BETWEEN frame_bound_s AND INDEXED LP distinct exprlist RP OVER LP PARTITION BY LP WITH wqlist VALUES]
parser: Input 'LP' in state 528
parser: Shift 'LP', go to state 28
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP range_or_rows BETWEEN frame_bound_s AND INDEXED LP distinct exprlist RP OVER LP PARTITION BY LP WITH wqlist VALUES LP]
parser: Input 'INTEGER' in state 28
parser: Shift 'INTEGER', pending reduce 173
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP range_or_rows BETWEEN frame_bound_s AND INDEXED LP distinct exprlist RP OVER LP PARTITION BY LP WITH wqlist VALUES LP INTEGER]
parser: Input 'RP' with pending reduce 173
parser: Reduce 173 [term ::= INTEGER], go to state 28.
parser: ... then shift 'term', go to state 70
parser: Reduce 220 [nexprlist ::= expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 413
parser: Shift 'RP', pending reduce 90
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP range_or_rows BETWEEN frame_bound_s AND INDEXED LP distinct exprlist RP OVER LP PARTITION BY LP WITH wqlist VALUES LP nexprlist RP]
parser: Input 'RP' with pending reduce 90
parser: Reduce 90 [values ::= VALUES LP nexprlist RP], go to state 143.
parser: ... then shift 'values', go to state 534
parser: Reduce 354 [oneselect ::= values], go to state 143.
parser: ... then shift 'oneselect', go to state 265
parser: Reduce 81 [select ::= WITH wqlist selectnowith], go to state 4.
parser: ... then shift 'select', go to state 485
parser: Shift 'RP', pending reduce 207
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP range_or_rows BETWEEN frame_bound_s AND INDEXED LP distinct exprlist RP OVER LP PARTITION BY LP select RP]
parser: Input 'RP' with pending reduce 207
parser: Reduce 207 [expr ::= LP select RP], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 220 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Reduce 128 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 191
parser: Reduce 301 [frame_opt ::=].
parser: ... then shift 'frame_opt', pending reduce 295
parser: Reduce 295 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 483
parser: Shift 'RP', pending reduce 320
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP range_or_rows BETWEEN frame_bound_s AND INDEXED LP distinct exprlist RP OVER LP window RP]
parser: Input 'FOLLOWING' with pending reduce 320
parser: Reduce 320 [over_clause ::= OVER LP window RP], go to state 146.
parser: ... then shift 'over_clause', pending reduce 318
parser: Reduce 318 [filter_over ::= over_clause], go to state 146.
parser: ... then shift 'filter_over', pending reduce 179
parser: Reduce 179 [expr ::= ID|INDEXED LP distinct exprlist RP filter_over], go to state 7.
parser: ... then shift 'expr', go to state 42
parser: Shift 'FOLLOWING', pending reduce 309
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP range_or_rows BETWEEN frame_bound_s AND expr FOLLOWING]
parser: Input 'RP' with pending reduce 309
parser: Reduce 309 [frame_bound ::= expr PRECEDING|FOLLOWING], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 307
parser: Reduce 307 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 351
parser: Reduce 311 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 303
parser: Reduce 303 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 33.
parser: ... then shift 'frame_opt', pending reduce 299
parser: Reduce 299 [window ::= frame_opt], go to state 33.
parser: ... then shift 'window', go to state 512
parser: Shift 'RP', pending reduce 294
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP window RP]
parser: Input 'SEMI' with pending reduce 294
parser: Reduce 294 [windowdefn ::= nm AS LP window RP], go to state 136.
parser: ... then shift 'windowdefn', pending reduce 292
parser: Reduce 292 [windowdefn_list ::= windowdefn], go to state 136.
parser: ... then shift 'windowdefn_list', go to state 515
parser: Reduce 316 [window_clause ::= WINDOW windowdefn_list], go to state 194.
parser: ... then shift 'window_clause', go to state 356
parser: Reduce 128 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 355
parser: Reduce 142 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 89
parser: Reduce 89 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt window_clause orderby_opt limit_opt], go to state 37.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 83 [select ::= selectnowith], go to state 37.
parser: ... then shift 'select', pending reduce 78
parser: Reduce 78 [cmd ::= createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
  11 Next             0    5    0               01 
   5 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s4[view](8)
   6 Column           0    1    2               00 r[2]=sqlite_master.name
REG[2] =   s2[t2](8)
   7 Column           0    2    3               00 r[3]=sqlite_master.tbl_name
REG[3] =   s2[t2](8)
   8 Column           0    3    4               00 r[4]=sqlite_master.rootpage
REG[4] =  i:0
   9 Column           0    4    5               00 r[5]=sqlite_master.sql
REG[5] =   s396[CREATE VIEW t2 AS .  SELE](8)
  10 ResultRow        1    5    0               00 output=r[1..5]
REG[1] =   s4[view](8)
REG[2] =   s2[t2](8)
REG[3] =   s2[t2](8)
REG[4] =  i:0
REG[5] =   s396[CREATE VIEW t2 AS .  SELE](8)
parser: [[[CREATE VIEW t2 AS 
  SELECT sum(b) FILTER( WHERE b>9 ),
         sum(b) FILTER( WHERE b>8 ),
         sum(b) FILTER( WHERE b>7 ),
         sum(b) FILTER( WHERE b>6 ),
         sum(b) FILTER( WHERE b>5 ),
         sum(b) FILTER( WHERE b>4 ),
         sum(b) FILTER( WHERE b>3 ),
         sum(b) FILTER( WHERE b>2 ),
         sum(b) FILTER( WHERE b>1 ),
         sum(b) FILTER( WHERE b>0 )
  FROM a]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'VIEW' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: FALLBACK VIEW => ID
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 390
parser: Shift 'VIEW', go to state 322
parser: Return. Stack=[createkw temp VIEW]
parser: Input 'ID' in state 322
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 228
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw temp VIEW ifnotexists ID]
parser: Input 'AS' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 228.
parser: ... then shift 'nm', go to state 321
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 320
parser: Reduce 226 [eidlist_opt ::=].
parser: ... then shift 'eidlist_opt', go to state 464
parser: Shift 'AS', go to state 37
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS]
parser: Input 'SELECT' in state 37
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT]
parser: Input 'ID' in state 288
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 95 [sclp ::=].
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 419
parser: Shift 'LP', go to state 266
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 220 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 519
parser: Reduce 359 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 484
parser: Shift 'RP', go to state 146
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'FILTER' in state 146
parser: Shift 'FILTER', go to state 482
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER]
parser: Input 'LP' in state 482
parser: Shift 'LP', go to state 481
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP]
parser: Input 'WHERE' in state 481
parser: Shift 'WHERE', go to state 90
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE]
parser: Input 'ID' in state 90
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE ID]
parser: Input 'GT' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'GT', go to state 118
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT]
parser: Input 'INTEGER' in state 118
parser: Shift 'INTEGER', pending reduce 173
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT INTEGER]
parser: Input 'RP' with pending reduce 173
parser: Reduce 173 [term ::= INTEGER], go to state 118.
parser: ... then shift 'term', go to state 130
parser: Reduce 185 [expr ::= expr LT|GT|GE|LE expr], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'RP', pending reduce 322
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr RP]
parser: Input 'COMMA' with pending reduce 322
parser: Reduce 322 [filter_clause ::= FILTER LP WHERE expr RP], go to state 146.
parser: ... then shift 'filter_clause', go to state 337
parser: Reduce 319 [filter_over ::= filter_clause], go to state 146.
parser: ... then shift 'filter_over', pending reduce 179
parser: Reduce 179 [expr ::= ID|INDEXED LP distinct exprlist RP filter_over], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 355
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 355
parser: Reduce 355 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 419
parser: Shift 'LP', go to state 266
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 220 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 519
parser: Reduce 359 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 484
parser: Shift 'RP', go to state 146
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'FILTER' in state 146
parser: Shift 'FILTER', go to state 482
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER]
parser: Input 'LP' in state 482
parser: Shift 'LP', go to state 481
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP]
parser: Input 'WHERE' in state 481
parser: Shift 'WHERE', go to state 90
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE]
parser: Input 'ID' in state 90
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE ID]
parser: Input 'GT' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'GT', go to state 118
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT]
parser: Input 'INTEGER' in state 118
parser: Shift 'INTEGER', pending reduce 173
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT INTEGER]
parser: Input 'RP' with pending reduce 173
parser: Reduce 173 [term ::= INTEGER], go to state 118.
parser: ... then shift 'term', go to state 130
parser: Reduce 185 [expr ::= expr LT|GT|GE|LE expr], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'RP', pending reduce 322
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr RP]
parser: Input 'COMMA' with pending reduce 322
parser: Reduce 322 [filter_clause ::= FILTER LP WHERE expr RP], go to state 146.
parser: ... then shift 'filter_clause', go to state 337
parser: Reduce 319 [filter_over ::= filter_clause], go to state 146.
parser: ... then shift 'filter_over', pending reduce 179
parser: Reduce 179 [expr ::= ID|INDEXED LP distinct exprlist RP filter_over], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 355
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 355
parser: Reduce 355 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 419
parser: Shift 'LP', go to state 266
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 220 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 519
parser: Reduce 359 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 484
parser: Shift 'RP', go to state 146
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'FILTER' in state 146
parser: Shift 'FILTER', go to state 482
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER]
parser: Input 'LP' in state 482
parser: Shift 'LP', go to state 481
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP]
parser: Input 'WHERE' in state 481
parser: Shift 'WHERE', go to state 90
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE]
parser: Input 'ID' in state 90
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE ID]
parser: Input 'GT' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'GT', go to state 118
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT]
parser: Input 'INTEGER' in state 118
parser: Shift 'INTEGER', pending reduce 173
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT INTEGER]
parser: Input 'RP' with pending reduce 173
parser: Reduce 173 [term ::= INTEGER], go to state 118.
parser: ... then shift 'term', go to state 130
parser: Reduce 185 [expr ::= expr LT|GT|GE|LE expr], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'RP', pending reduce 322
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr RP]
parser: Input 'COMMA' with pending reduce 322
parser: Reduce 322 [filter_clause ::= FILTER LP WHERE expr RP], go to state 146.
parser: ... then shift 'filter_clause', go to state 337
parser: Reduce 319 [filter_over ::= filter_clause], go to state 146.
parser: ... then shift 'filter_over', pending reduce 179
parser: Reduce 179 [expr ::= ID|INDEXED LP distinct exprlist RP filter_over], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 355
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 355
parser: Reduce 355 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 419
parser: Shift 'LP', go to state 266
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 220 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 519
parser: Reduce 359 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 484
parser: Shift 'RP', go to state 146
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'FILTER' in state 146
parser: Shift 'FILTER', go to state 482
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER]
parser: Input 'LP' in state 482
parser: Shift 'LP', go to state 481
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP]
parser: Input 'WHERE' in state 481
parser: Shift 'WHERE', go to state 90
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE]
parser: Input 'ID' in state 90
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE ID]
parser: Input 'GT' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'GT', go to state 118
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT]
parser: Input 'INTEGER' in state 118
parser: Shift 'INTEGER', pending reduce 173
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT INTEGER]
parser: Input 'RP' with pending reduce 173
parser: Reduce 173 [term ::= INTEGER], go to state 118.
parser: ... then shift 'term', go to state 130
parser: Reduce 185 [expr ::= expr LT|GT|GE|LE expr], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'RP', pending reduce 322
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr RP]
parser: Input 'COMMA' with pending reduce 322
parser: Reduce 322 [filter_clause ::= FILTER LP WHERE expr RP], go to state 146.
parser: ... then shift 'filter_clause', go to state 337
parser: Reduce 319 [filter_over ::= filter_clause], go to state 146.
parser: ... then shift 'filter_over', pending reduce 179
parser: Reduce 179 [expr ::= ID|INDEXED LP distinct exprlist RP filter_over], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 355
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 355
parser: Reduce 355 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 419
parser: Shift 'LP', go to state 266
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 220 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 519
parser: Reduce 359 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 484
parser: Shift 'RP', go to state 146
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'FILTER' in state 146
parser: Shift 'FILTER', go to state 482
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER]
parser: Input 'LP' in state 482
parser: Shift 'LP', go to state 481
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP]
parser: Input 'WHERE' in state 481
parser: Shift 'WHERE', go to state 90
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE]
parser: Input 'ID' in state 90
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE ID]
parser: Input 'GT' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'GT', go to state 118
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT]
parser: Input 'INTEGER' in state 118
parser: Shift 'INTEGER', pending reduce 173
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT INTEGER]
parser: Input 'RP' with pending reduce 173
parser: Reduce 173 [term ::= INTEGER], go to state 118.
parser: ... then shift 'term', go to state 130
parser: Reduce 185 [expr ::= expr LT|GT|GE|LE expr], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'RP', pending reduce 322
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr RP]
parser: Input 'COMMA' with pending reduce 322
parser: Reduce 322 [filter_clause ::= FILTER LP WHERE expr RP], go to state 146.
parser: ... then shift 'filter_clause', go to state 337
parser: Reduce 319 [filter_over ::= filter_clause], go to state 146.
parser: ... then shift 'filter_over', pending reduce 179
parser: Reduce 179 [expr ::= ID|INDEXED LP distinct exprlist RP filter_over], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 355
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 355
parser: Reduce 355 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 419
parser: Shift 'LP', go to state 266
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 220 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 519
parser: Reduce 359 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 484
parser: Shift 'RP', go to state 146
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'FILTER' in state 146
parser: Shift 'FILTER', go to state 482
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER]
parser: Input 'LP' in state 482
parser: Shift 'LP', go to state 481
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP]
parser: Input 'WHERE' in state 481
parser: Shift 'WHERE', go to state 90
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE]
parser: Input 'ID' in state 90
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE ID]
parser: Input 'GT' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'GT', go to state 118
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT]
parser: Input 'INTEGER' in state 118
parser: Shift 'INTEGER', pending reduce 173
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT INTEGER]
parser: Input 'RP' with pending reduce 173
parser: Reduce 173 [term ::= INTEGER], go to state 118.
parser: ... then shift 'term', go to state 130
parser: Reduce 185 [expr ::= expr LT|GT|GE|LE expr], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'RP', pending reduce 322
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr RP]
parser: Input 'COMMA' with pending reduce 322
parser: Reduce 322 [filter_clause ::= FILTER LP WHERE expr RP], go to state 146.
parser: ... then shift 'filter_clause', go to state 337
parser: Reduce 319 [filter_over ::= filter_clause], go to state 146.
parser: ... then shift 'filter_over', pending reduce 179
parser: Reduce 179 [expr ::= ID|INDEXED LP distinct exprlist RP filter_over], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 355
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 355
parser: Reduce 355 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 419
parser: Shift 'LP', go to state 266
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 220 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 519
parser: Reduce 359 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 484
parser: Shift 'RP', go to state 146
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'FILTER' in state 146
parser: Shift 'FILTER', go to state 482
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER]
parser: Input 'LP' in state 482
parser: Shift 'LP', go to state 481
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP]
parser: Input 'WHERE' in state 481
parser: Shift 'WHERE', go to state 90
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE]
parser: Input 'ID' in state 90
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE ID]
parser: Input 'GT' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'GT', go to state 118
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT]
parser: Input 'INTEGER' in state 118
parser: Shift 'INTEGER', pending reduce 173
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT INTEGER]
parser: Input 'RP' with pending reduce 173
parser: Reduce 173 [term ::= INTEGER], go to state 118.
parser: ... then shift 'term', go to state 130
parser: Reduce 185 [expr ::= expr LT|GT|GE|LE expr], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'RP', pending reduce 322
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr RP]
parser: Input 'COMMA' with pending reduce 322
parser: Reduce 322 [filter_clause ::= FILTER LP WHERE expr RP], go to state 146.
parser: ... then shift 'filter_clause', go to state 337
parser: Reduce 319 [filter_over ::= filter_clause], go to state 146.
parser: ... then shift 'filter_over', pending reduce 179
parser: Reduce 179 [expr ::= ID|INDEXED LP distinct exprlist RP filter_over], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 355
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 355
parser: Reduce 355 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 419
parser: Shift 'LP', go to state 266
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 220 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 519
parser: Reduce 359 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 484
parser: Shift 'RP', go to state 146
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'FILTER' in state 146
parser: Shift 'FILTER', go to state 482
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER]
parser: Input 'LP' in state 482
parser: Shift 'LP', go to state 481
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP]
parser: Input 'WHERE' in state 481
parser: Shift 'WHERE', go to state 90
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE]
parser: Input 'ID' in state 90
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE ID]
parser: Input 'GT' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'GT', go to state 118
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT]
parser: Input 'INTEGER' in state 118
parser: Shift 'INTEGER', pending reduce 173
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT INTEGER]
parser: Input 'RP' with pending reduce 173
parser: Reduce 173 [term ::= INTEGER], go to state 118.
parser: ... then shift 'term', go to state 130
parser: Reduce 185 [expr ::= expr LT|GT|GE|LE expr], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'RP', pending reduce 322
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr RP]
parser: Input 'COMMA' with pending reduce 322
parser: Reduce 322 [filter_clause ::= FILTER LP WHERE expr RP], go to state 146.
parser: ... then shift 'filter_clause', go to state 337
parser: Reduce 319 [filter_over ::= filter_clause], go to state 146.
parser: ... then shift 'filter_over', pending reduce 179
parser: Reduce 179 [expr ::= ID|INDEXED LP distinct exprlist RP filter_over], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 355
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 355
parser: Reduce 355 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 419
parser: Shift 'LP', go to state 266
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 220 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 519
parser: Reduce 359 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 484
parser: Shift 'RP', go to state 146
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'FILTER' in state 146
parser: Shift 'FILTER', go to state 482
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER]
parser: Input 'LP' in state 482
parser: Shift 'LP', go to state 481
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP]
parser: Input 'WHERE' in state 481
parser: Shift 'WHERE', go to state 90
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE]
parser: Input 'ID' in state 90
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE ID]
parser: Input 'GT' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'GT', go to state 118
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT]
parser: Input 'INTEGER' in state 118
parser: Shift 'INTEGER', pending reduce 173
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT INTEGER]
parser: Input 'RP' with pending reduce 173
parser: Reduce 173 [term ::= INTEGER], go to state 118.
parser: ... then shift 'term', go to state 130
parser: Reduce 185 [expr ::= expr LT|GT|GE|LE expr], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'RP', pending reduce 322
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr RP]
parser: Input 'COMMA' with pending reduce 322
parser: Reduce 322 [filter_clause ::= FILTER LP WHERE expr RP], go to state 146.
parser: ... then shift 'filter_clause', go to state 337
parser: Reduce 319 [filter_over ::= filter_clause], go to state 146.
parser: ... then shift 'filter_over', pending reduce 179
parser: Reduce 179 [expr ::= ID|INDEXED LP distinct exprlist RP filter_over], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 355
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 355
parser: Reduce 355 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 419
parser: Shift 'LP', go to state 266
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 220 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 519
parser: Reduce 359 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 484
parser: Shift 'RP', go to state 146
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'FILTER' in state 146
parser: Shift 'FILTER', go to state 482
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER]
parser: Input 'LP' in state 482
parser: Shift 'LP', go to state 481
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP]
parser: Input 'WHERE' in state 481
parser: Shift 'WHERE', go to state 90
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE]
parser: Input 'ID' in state 90
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE ID]
parser: Input 'GT' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'GT', go to state 118
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT]
parser: Input 'INTEGER' in state 118
parser: Shift 'INTEGER', pending reduce 173
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT INTEGER]
parser: Input 'RP' with pending reduce 173
parser: Reduce 173 [term ::= INTEGER], go to state 118.
parser: ... then shift 'term', go to state 130
parser: Reduce 185 [expr ::= expr LT|GT|GE|LE expr], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'RP', pending reduce 322
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr RP]
parser: Input 'FROM' with pending reduce 322
parser: Reduce 322 [filter_clause ::= FILTER LP WHERE expr RP], go to state 146.
parser: ... then shift 'filter_clause', go to state 337
parser: Reduce 319 [filter_over ::= filter_clause], go to state 146.
parser: ... then shift 'filter_over', pending reduce 179
parser: Reduce 179 [expr ::= ID|INDEXED LP distinct exprlist RP filter_over], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 104 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'SEMI' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 350
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 123 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 349
parser: Reduce 122 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 348
parser: Reduce 127 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 105
parser: Reduce 105 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 102 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 363
parser: Reduce 147 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 362
parser: Reduce 138 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 361
parser: Reduce 140 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 128 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 360
parser: Reduce 142 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 88
parser: Reduce 88 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 37.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 83 [select ::= selectnowith], go to state 37.
parser: ... then shift 'select', pending reduce 78
parser: Reduce 78 [cmd ::= createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
  11 Next             0    5    0               01 
   5 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s5[table](8)
   6 Column           0    1    2               00 r[2]=sqlite_master.name
REG[2] =   s1[x](8)
   7 Column           0    2    3               00 r[3]=sqlite_master.tbl_name
REG[3] =   s1[x](8)
   8 Column           0    3    4               00 r[4]=sqlite_master.rootpage
REG[4] =  i:5
   9 Column           0    4    5               00 r[5]=sqlite_master.sql
REG[5] =   s49[CREATE TABLE x(y INTEGER ](8)
  10 ResultRow        1    5    0               00 output=r[1..5]
REG[1] =   s5[table](8)
REG[2] =   s1[x](8)
REG[3] =   s1[x](8)
REG[4] =  i:5
REG[5] =   s49[CREATE TABLE x(y INTEGER ](8)
parser: [[[CREATE TABLE x(y INTEGER PRIMARY KEY, t2i1, t1i1)]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 390
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 0.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP ID]
parser: Input 'ID' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 192
parser: Shift 'ID', pending reduce 341
parser: Return. Stack=[create_table LP nm ID]
parser: Input 'PRIMARY' with pending reduce 341
parser: Reduce 341 [typename ::= ID|STRING], go to state 192.
parser: ... then shift 'typename', go to state 392
parser: Reduce 340 [typetoken ::= typename], go to state 192.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 379
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 152
parser: Shift 'PRIMARY', go to state 478
parser: Return. Stack=[create_table LP columnname carglist PRIMARY]
parser: Input 'KEY' in state 478
parser: Shift 'KEY', go to state 280
parser: Return. Stack=[create_table LP columnname carglist PRIMARY KEY]
parser: Input 'COMMA' in state 280
parser: Reduce 134 [sortorder ::=].
parser: ... then shift 'sortorder', go to state 333
parser: Reduce 69 [onconf ::=].
parser: ... then shift 'onconf', go to state 332
parser: Reduce 43 [autoinc ::=].
parser: ... then shift 'autoinc', pending reduce 37
parser: Reduce 37 [ccons ::= PRIMARY KEY sortorder onconf autoinc], go to state 152.
parser: ... then shift 'ccons', pending reduce 344
parser: Reduce 344 [carglist ::= carglist ccons], go to state 379.
parser: ... then shift 'carglist', go to state 152
parser: Reduce 336 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'COMMA' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'RP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Reduce 61 [conslist_opt ::=].
parser: ... then shift 'conslist_opt', go to state 540
parser: Shift 'RP', go to state 364
parser: Return. Stack=[create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 364
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: ... then shift 'create_table_args', pending reduce 334
parser: Reduce 334 [cmd ::= create_table create_table_args], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
  11 Next             0    5    0               01 
  12 Halt             0    0    0               00 
  35 ParseSchema      1    0    0               00 
parser: [[[CREATE TABLE x(type text,name text,tbl_name text,rootpage int,sql text)]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 390
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 0.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP ID]
parser: Input 'ID' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 192
parser: Shift 'ID', pending reduce 341
parser: Return. Stack=[create_table LP nm ID]
parser: Input 'COMMA' with pending reduce 341
parser: Reduce 341 [typename ::= ID|STRING], go to state 192.
parser: ... then shift 'typename', go to state 392
parser: Reduce 340 [typetoken ::= typename], go to state 192.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 379
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 152
parser: Reduce 336 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'ID' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Shift 'ID', pending reduce 341
parser: Return. Stack=[create_table LP columnlist COMMA nm ID]
parser: Input 'COMMA' with pending reduce 341
parser: Reduce 341 [typename ::= ID|STRING], go to state 192.
parser: ... then shift 'typename', go to state 392
parser: Reduce 340 [typetoken ::= typename], go to state 192.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'ID' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Shift 'ID', pending reduce 341
parser: Return. Stack=[create_table LP columnlist COMMA nm ID]
parser: Input 'COMMA' with pending reduce 341
parser: Reduce 341 [typename ::= ID|STRING], go to state 192.
parser: ... then shift 'typename', go to state 392
parser: Reduce 340 [typetoken ::= typename], go to state 192.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'ID' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Shift 'ID', pending reduce 341
parser: Return. Stack=[create_table LP columnlist COMMA nm ID]
parser: Input 'COMMA' with pending reduce 341
parser: Reduce 341 [typename ::= ID|STRING], go to state 192.
parser: ... then shift 'typename', go to state 392
parser: Reduce 340 [typetoken ::= typename], go to state 192.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'ID' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Shift 'ID', pending reduce 341
parser: Return. Stack=[create_table LP columnlist COMMA nm ID]
parser: Input 'RP' with pending reduce 341
parser: Reduce 341 [typename ::= ID|STRING], go to state 192.
parser: ... then shift 'typename', go to state 392
parser: Reduce 340 [typetoken ::= typename], go to state 192.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Reduce 61 [conslist_opt ::=].
parser: ... then shift 'conslist_opt', go to state 540
parser: Shift 'RP', go to state 364
parser: Return. Stack=[create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 364
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: ... then shift 'create_table_args', pending reduce 334
parser: Reduce 334 [cmd ::= create_table create_table_args], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT*FROM"temp".sqlite_temp_master ORDER BY rowid]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'STAR' in state 288
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 95 [sclp ::=].
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STAR', pending reduce 97
parser: Return. Stack=[SELECT distinct sclp scanpt STAR]
parser: Input 'FROM' with pending reduce 97
parser: Reduce 97 [selcollist ::= sclp scanpt STAR], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 104 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'DOT' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 350
parser: Shift 'DOT', go to state 245
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID' in state 245
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'ORDER' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 245.
parser: ... then shift 'nm', pending reduce 110
parser: Reduce 110 [dbnm ::= DOT nm], go to state 350.
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 123 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 349
parser: Reduce 122 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 348
parser: Reduce 127 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 105
parser: Reduce 105 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 102 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 363
parser: Reduce 147 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 362
parser: Reduce 138 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 361
parser: Reduce 140 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 517
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 517
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 419
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 134 [sortorder ::=].
parser: ... then shift 'sortorder', go to state 353
parser: Reduce 137 [nulls ::=].
parser: ... then shift 'nulls', pending reduce 131
parser: Reduce 131 [sortlist ::= expr sortorder nulls], go to state 26.
parser: ... then shift 'sortlist', go to state 516
parser: Reduce 129 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 360
parser: Reduce 142 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 88
parser: Reduce 88 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 83 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 80
parser: Reduce 80 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
VDBE Trace:
   0 Init             0   13    0               00 Start at 13
  13 Transaction      1    0    0 2             00 usesStmtJournal=0
  14 Goto             0    1    0               00 
   1 Noop             1    7    0               00 
   2 OpenRead         0    1    1 5             00 root=1 iDb=1; sqlite_temp_master
   3 Explain          3    0    0 SCAN TABLE sqlite_temp_master 00 
   4 Rewind           0   12    0               00 
  12 Halt             0    0    0               00 
  36 Halt             0    0    0               00 
parser: [[[;
;SELECT x.RowID id FROM a, x WHERE a.b = x.RowID AND id = 2;SELECT*FROM"temp".sqlite_temp_master ORDER BY rowid
;ALTER TABLE x ADD abc
    
;CREATE INDEX c ON a(b)
;CREATE INDEX v1 ON a(b)
;ALTER TABLE ex ADD v2
    
;CREATE TABLE tr1(t1a, t1b);;SELECT y, v2 FROM x, ex WHERE y>v2;;
;SELECT DISTINCT b FROM a LEFT JOIN ex ON b=v2 ORDER BY +v2;CREATE INDEX x1 ON a(b)
;CREATE INDEX z ON a(b)
;CREATE INDEX example ON ex(v2)
;;SELECT count(*) FROM sqlite_master WHERE tbl_name = 'e' AND type = 'index';;
;CREATE TABLE example_idx_00000042(id PRIMARY KEY, UNIQUE(id) );;BEGIN;;CREATE UNIQUE INDEX IF NOT EXISTS a_id ON a(b==0);;SELECT * FROM ex;]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 326
parser: Return. Stack=[SEMI]
parser: Input 'SEMI' with pending reduce 326
parser: Reduce 326 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Shift 'SEMI', pending reduce 326
parser: Return. Stack=[ecmd SEMI]
parser: Input 'SELECT' with pending reduce 326
parser: Reduce 326 [ecmd ::= SEMI], go to state 1.
parser: ... then shift 'ecmd', pending reduce 324
parser: Reduce 324 [cmdlist ::= cmdlist ecmd], go to state 0.
parser: ... then shift 'cmdlist', go to state 1
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[cmdlist SELECT]
parser: Input 'ID' in state 288
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 95 [sclp ::=].
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 419
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID]
parser: Input 'DOT' in state 419
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 77.
parser: ... then shift 'nm', go to state 493
parser: Shift 'DOT', go to state 205
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt nm DOT]
parser: Input 'ID' in state 205
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt nm DOT ID]
parser: Input 'ID' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 205.
parser: ... then shift 'nm', go to state 536
parser: Reduce 169 [expr ::= nm DOT nm], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Shift 'ID', pending reduce 356
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt expr scanpt ID]
parser: Input 'FROM' with pending reduce 356
parser: Reduce 356 [as ::= ID|STRING], go to state 259.
parser: ... then shift 'as', pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[cmdlist SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 104 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[cmdlist SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'COMMA' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 350
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 123 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 349
parser: Reduce 122 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 348
parser: Reduce 127 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 105
parser: Reduce 105 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Shift 'COMMA', pending reduce 117
parser: Return. Stack=[cmdlist SELECT distinct selcollist FROM seltablist COMMA]
parser: Input 'ID' with pending reduce 117
parser: Reduce 117 [joinop ::= COMMA|JOIN], go to state 263.
parser: ... then shift 'joinop', pending reduce 103
parser: Reduce 103 [stl_prefix ::= seltablist joinop], go to state 197.
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[cmdlist SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'WHERE' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 350
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 123 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 349
parser: Reduce 122 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 348
parser: Reduce 127 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 105
parser: Reduce 105 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 102 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 363
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 419
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE ID]
parser: Input 'DOT' in state 419
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 93.
parser: ... then shift 'nm', go to state 537
parser: Shift 'DOT', go to state 249
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE nm DOT]
parser: Input 'ID' in state 249
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE nm DOT ID]
parser: Input 'EQ' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 249.
parser: ... then shift 'nm', go to state 536
parser: Reduce 169 [expr ::= nm DOT nm], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'ID' in state 117
parser: Shift 'ID', go to state 419
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr EQ ID]
parser: Input 'DOT' in state 419
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 117.
parser: ... then shift 'nm', go to state 537
parser: Shift 'DOT', go to state 249
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr EQ nm DOT]
parser: Input 'ID' in state 249
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr EQ nm DOT ID]
parser: Input 'AND' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 249.
parser: ... then shift 'nm', go to state 536
parser: Reduce 169 [expr ::= nm DOT nm], go to state 117.
parser: ... then shift 'expr', go to state 129
parser: Reduce 186 [expr ::= expr EQ|NE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'AND', go to state 120
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID' in state 120
parser: Shift 'ID', go to state 419
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'EQ' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr AND expr EQ]
parser: Input 'INTEGER' in state 117
parser: Shift 'INTEGER', pending reduce 173
parser: Return. Stack=[cmdlist SELECT distinct selcollist from WHERE expr AND expr EQ INTEGER]
parser: Input 'SEMI' with pending reduce 173
parser: Reduce 173 [term ::= INTEGER], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 186 [expr ::= expr EQ|NE expr], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Reduce 183 [expr ::= expr AND expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 148 [where_opt ::= WHERE expr], go to state 363.
parser: ... then shift 'where_opt', go to state 362
parser: Reduce 138 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 361
parser: Reduce 140 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 128 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 360
parser: Reduce 142 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 88
parser: Reduce 88 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 1.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 83 [select ::= selectnowith], go to state 1.
parser: ... then shift 'select', pending reduce 80
parser: Reduce 80 [cmd ::= select], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdlist cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping cmdlist
SQL: [;
;SELECT x.RowID id FROM a, x WHERE a.b = x.RowID AND id = 2;]
VDBE Trace:
   0 Init             0   19    0               00 Start at 19
  19 Transaction      0    0    8 2             01 usesStmtJournal=0
  20 Integer          2    5    0               00 r[5]=2
REG[5] =  i:2
  21 Goto             0    1    0               00 
   1 OpenRead         2    2    0 k(1,)         02 root=2 iDb=0; sqlite_autoindex_a_1
   2 OpenRead         1    5    0 0             00 root=5 iDb=0; x
   3 Explain          3    0    0 SEARCH TABLE a USING PRIMARY KEY (b=?) 00 
   4 Integer          2    1    0               00 r[1]=2
REG[1] =  i:2
   5 SeekGE           2   18    1 1             00 key=r[1]
REG[1] =  i:2
   7 Column           2    0    2               00 r[2]=a.b
REG[2] =  i:2
   8 Integer          2    3    0               00 r[3]=2
REG[3] =  i:2
   9 Affinity         3    1    0 D             00 affinity(r[3])
REG[3] =  i:2
  10 Ne               3   18    2 (BINARY)      53 if r[2]!=r[3] goto 18
REG[3] =  i:2
REG[2] =  i:2
  11 Explain         11    0    0 SEARCH TABLE x USING INTEGER PRIMARY KEY (rowid=?) 00 
  12 Column           2    0    4               00 r[4]=a.b
REG[4] =  i:2
  13 SeekRowid        1   18    4               00 intkey=r[4]
REG[4] =  i:2
  18 Halt             0    0    0               00 
parser: [[[SELECT*FROM"temp".sqlite_temp_master ORDER BY rowid
;ALTER TABLE x ADD abc
    
;CREATE INDEX c ON a(b)
;CREATE INDEX v1 ON a(b)
;ALTER TABLE ex ADD v2
    
;CREATE TABLE tr1(t1a, t1b);;SELECT y, v2 FROM x, ex WHERE y>v2;;
;SELECT DISTINCT b FROM a LEFT JOIN ex ON b=v2 ORDER BY +v2;CREATE INDEX x1 ON a(b)
;CREATE INDEX z ON a(b)
;CREATE INDEX example ON ex(v2)
;;SELECT count(*) FROM sqlite_master WHERE tbl_name = 'e' AND type = 'index';;
;CREATE TABLE example_idx_00000042(id PRIMARY KEY, UNIQUE(id) );;BEGIN;;CREATE UNIQUE INDEX IF NOT EXISTS a_id ON a(b==0);;SELECT * FROM ex;]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'STAR' in state 288
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 95 [sclp ::=].
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STAR', pending reduce 97
parser: Return. Stack=[SELECT distinct sclp scanpt STAR]
parser: Input 'FROM' with pending reduce 97
parser: Reduce 97 [selcollist ::= sclp scanpt STAR], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 104 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'DOT' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 350
parser: Shift 'DOT', go to state 245
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID' in state 245
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'ORDER' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 245.
parser: ... then shift 'nm', pending reduce 110
parser: Reduce 110 [dbnm ::= DOT nm], go to state 350.
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 123 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 349
parser: Reduce 122 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 348
parser: Reduce 127 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 105
parser: Reduce 105 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 102 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 363
parser: Reduce 147 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 362
parser: Reduce 138 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 361
parser: Reduce 140 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 517
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 517
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 419
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 134 [sortorder ::=].
parser: ... then shift 'sortorder', go to state 353
parser: Reduce 137 [nulls ::=].
parser: ... then shift 'nulls', pending reduce 131
parser: Reduce 131 [sortlist ::= expr sortorder nulls], go to state 26.
parser: ... then shift 'sortlist', go to state 516
parser: Reduce 129 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 360
parser: Reduce 142 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 88
parser: Reduce 88 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 83 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 80
parser: Reduce 80 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
SQL: [SELECT*FROM"temp".sqlite_temp_master ORDER BY rowid
;]
VDBE Trace:
   0 Init             0   13    0               00 Start at 13
  13 Transaction      1    0    0 2             01 usesStmtJournal=0
  14 Goto             0    1    0               00 
   1 Noop             1    7    0               00 
   2 OpenRead         0    1    1 5             00 root=1 iDb=1; sqlite_temp_master
   3 Explain          3    0    0 SCAN TABLE sqlite_temp_master 00 
   4 Rewind           0   12    0               00 
  12 Halt             0    0    0               00 
parser: [[[ALTER TABLE x ADD abc
    
;CREATE INDEX c ON a(b)
;CREATE INDEX v1 ON a(b)
;ALTER TABLE ex ADD v2
    
;CREATE TABLE tr1(t1a, t1b);;SELECT y, v2 FROM x, ex WHERE y>v2;;
;SELECT DISTINCT b FROM a LEFT JOIN ex ON b=v2 ORDER BY +v2;CREATE INDEX x1 ON a(b)
;CREATE INDEX z ON a(b)
;CREATE INDEX example ON ex(v2)
;;SELECT count(*) FROM sqlite_master WHERE tbl_name = 'e' AND type = 'index';;
;CREATE TABLE example_idx_00000042(id PRIMARY KEY, UNIQUE(id) );;BEGIN;;CREATE UNIQUE INDEX IF NOT EXISTS a_id ON a(b==0);;SELECT * FROM ex;]]]
parser: Input 'ALTER' in state 0
parser: Shift 'ALTER', go to state 426
parser: Return. Stack=[ALTER]
parser: Input 'TABLE' in state 426
parser: Shift 'TABLE', go to state 133
parser: Return. Stack=[ALTER TABLE]
parser: Input 'ID' in state 133
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[ALTER TABLE ID]
parser: Input 'ADD' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 133.
parser: ... then shift 'nm', go to state 462
parser: Reduce 111 [fullname ::= nm], go to state 133.
parser: ... then shift 'fullname', go to state 425
parser: Reduce 279 [add_column_fullname ::= fullname], go to state 133.
parser: ... then shift 'add_column_fullname', go to state 423
parser: Shift 'ADD', go to state 290
parser: Return. Stack=[ALTER TABLE add_column_fullname ADD]
parser: Input 'ID' in state 290
parser: Reduce 372 [kwcolumn_opt ::=].
parser: ... then shift 'kwcolumn_opt', go to state 165
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[ALTER TABLE add_column_fullname ADD kwcolumn_opt ID]
parser: Input 'SEMI' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 165.
parser: ... then shift 'nm', go to state 192
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 165.
parser: ... then shift 'columnname', go to state 374
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 151
parser: Reduce 278 [cmd ::= ALTER TABLE add_column_fullname ADD kwcolumn_opt columnname carglist], go to state 0.
parser: [[[UPDATE "main".sqlite_master SET sql = substr(sql,1,48) || ', ' || 'abc' || substr(sql,49) WHERE type = 'table' AND name = 'x']]]
parser: Input 'UPDATE' in state 0
parser: Reduce 380 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'UPDATE', go to state 299
parser: Return. Stack=[with UPDATE]
parser: Input 'ID' in state 299
parser: Reduce 71 [orconf ::=].
parser: ... then shift 'orconf', go to state 167
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[with UPDATE orconf ID]
parser: Input 'DOT' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 167.
parser: ... then shift 'nm', go to state 395
parser: Shift 'DOT', go to state 218
parser: Return. Stack=[with UPDATE orconf nm DOT]
parser: Input 'ID' in state 218
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[with UPDATE orconf nm DOT ID]
parser: Input 'SET' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 218.
parser: ... then shift 'nm', go to state 432
parser: Reduce 114 [xfullname ::= nm DOT nm], go to state 167.
parser: ... then shift 'xfullname', go to state 271
parser: Reduce 123 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 431
parser: Shift 'SET', go to state 155
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET]
parser: Input 'ID' in state 155
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET ID]
parser: Input 'EQ' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 155.
parser: ... then shift 'nm', go to state 445
parser: Shift 'EQ', go to state 84
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ]
parser: Input 'ID' in state 84
parser: Shift 'ID', go to state 419
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ ID]
parser: Input 'LP' in state 419
parser: Shift 'LP', go to state 266
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ ID LP]
parser: Input 'ID' in state 266
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 419
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ ID LP distinct ID]
parser: Input 'COMMA' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 220 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 519
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ ID LP distinct nexprlist COMMA]
parser: Input 'INTEGER' in state 107
parser: Shift 'INTEGER', pending reduce 173
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ ID LP distinct nexprlist COMMA INTEGER]
parser: Input 'COMMA' with pending reduce 173
parser: Reduce 173 [term ::= INTEGER], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 219 [nexprlist ::= nexprlist COMMA expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 519
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ ID LP distinct nexprlist COMMA]
parser: Input 'INTEGER' in state 107
parser: Shift 'INTEGER', pending reduce 173
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ ID LP distinct nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 173
parser: Reduce 173 [term ::= INTEGER], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 219 [nexprlist ::= nexprlist COMMA expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 519
parser: Reduce 359 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 484
parser: Shift 'RP', go to state 146
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ ID LP distinct exprlist RP]
parser: Input 'CONCAT' in state 146
parser: Reduce 177 [expr ::= ID|INDEXED LP distinct exprlist RP], go to state 84.
parser: ... then shift 'expr', go to state 58
parser: Shift 'CONCAT', go to state 113
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ expr CONCAT]
parser: Input 'STRING' in state 113
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ expr CONCAT STRING]
parser: Input 'CONCAT' in state 539
parser: Reduce 172 [term ::= STRING], go to state 113.
parser: ... then shift 'term', go to state 148
parser: Reduce 190 [expr ::= expr CONCAT expr], go to state 84.
parser: ... then shift 'expr', go to state 58
parser: Shift 'CONCAT', go to state 113
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ expr CONCAT]
parser: Input 'STRING' in state 113
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ expr CONCAT STRING]
parser: Input 'CONCAT' in state 539
parser: Reduce 172 [term ::= STRING], go to state 113.
parser: ... then shift 'term', go to state 148
parser: Reduce 190 [expr ::= expr CONCAT expr], go to state 84.
parser: ... then shift 'expr', go to state 58
parser: Shift 'CONCAT', go to state 113
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ expr CONCAT]
parser: Input 'ID' in state 113
parser: Shift 'ID', go to state 419
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ expr CONCAT ID]
parser: Input 'LP' in state 419
parser: Shift 'LP', go to state 266
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ expr CONCAT ID LP]
parser: Input 'ID' in state 266
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 419
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ expr CONCAT ID LP distinct ID]
parser: Input 'COMMA' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 220 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 519
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ expr CONCAT ID LP distinct nexprlist COMMA]
parser: Input 'INTEGER' in state 107
parser: Shift 'INTEGER', pending reduce 173
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ expr CONCAT ID LP distinct nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 173
parser: Reduce 173 [term ::= INTEGER], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 219 [nexprlist ::= nexprlist COMMA expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 519
parser: Reduce 359 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 484
parser: Shift 'RP', go to state 146
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ expr CONCAT ID LP distinct exprlist RP]
parser: Input 'WHERE' in state 146
parser: Reduce 177 [expr ::= ID|INDEXED LP distinct exprlist RP], go to state 113.
parser: ... then shift 'expr', go to state 148
parser: Reduce 190 [expr ::= expr CONCAT expr], go to state 84.
parser: ... then shift 'expr', go to state 58
parser: Reduce 152 [setlist ::= nm EQ expr], go to state 155.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 419
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE ID]
parser: Input 'EQ' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr EQ]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr EQ STRING]
parser: Input 'AND' in state 539
parser: Reduce 172 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 186 [expr ::= expr EQ|NE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'AND', go to state 120
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr AND]
parser: Input 'ID' in state 120
parser: Shift 'ID', go to state 419
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr AND ID]
parser: Input 'EQ' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr AND expr EQ]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr AND expr EQ STRING]
parser: Input 'SEMI' in state 539
parser: Reduce 172 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 186 [expr ::= expr EQ|NE expr], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Reduce 183 [expr ::= expr AND expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 148 [where_opt ::= WHERE expr], go to state 270.
parser: ... then shift 'where_opt', pending reduce 149
parser: Reduce 149 [cmd ::= with UPDATE orconf xfullname indexed_opt SET setlist where_opt], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Input '$' with pending reduce 327
parser: Reduce 327 [ecmd ::= cmdx SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 323 [input ::= cmdlist], go to state 0.
parser: ... then shift 'input', pending reduce -2
parser: Accept!
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
SQL: [ALTER TABLE x ADD abc
    
;]
VDBE Trace:
   0 Init             0   37    0               00 Start at 37
  37 Transaction      0    1    8 2             01 usesStmtJournal=1
  38 String8          0    9    0 table         00 r[9]='table'
REG[9] =   t5[table](8)
  39 String8          0   10    0 x             00 r[10]='x'
REG[10] =   t1[x](8)
  40 Integer          1   15    0               00 r[15]=1
REG[15] =  i:1
  41 Integer         48   16    0               00 r[16]=48
REG[16] =  i:48
  42 String8          0   17    0 ,             00 r[17]=', '
REG[17] =   t2[, ](8)
  43 String8          0   18    0 abc           00 r[18]='abc'
REG[18] =   t3[abc](8)
  44 Integer         49   20    0               00 r[20]=49
REG[20] =  i:49
  45 Goto             0    1    0               00 
   1 Null             0    1    2               00 r[1..2]=NULL
REG[1] =  NULL
   2 OpenRead         0    1    0 2             00 root=1 iDb=0; sqlite_master
   3 Explain          3    0    0 SCAN TABLE sqlite_master 00 
   4 Rewind           0   12    0               00 
   5 Column           0    0    8               00 r[8]=sqlite_master.type
REG[8] =   s5[table](8)
   6 Ne               9   11    8 (BINARY)      52 if r[8]!=r[9] goto 11
REG[9] =   t5[table](8)
REG[8] =   s5[table](8)
   7 Column           0    1    8               00 r[8]=sqlite_master.name
REG[8] =   s1[a](8)
   8 Ne              10   11    8 (BINARY)      52 if r[8]!=r[10] goto 11
REG[10] =   t1[x](8)
REG[8] =   s1[a](8)
  11 Next             0    5    0               01 
   5 Column           0    0    8               00 r[8]=sqlite_master.type
REG[8] =   s5[table](8)
   6 Ne               9   11    8 (BINARY)      52 if r[8]!=r[9] goto 11
REG[9] =   t5[table](8)
REG[8] =   s5[table](8)
   7 Column           0    1    8               00 r[8]=sqlite_master.name
REG[8] =   s2[ex](8)
   8 Ne              10   11    8 (BINARY)      52 if r[8]!=r[10] goto 11
REG[10] =   t1[x](8)
REG[8] =   s2[ex](8)
  11 Next             0    5    0               01 
   5 Column           0    0    8               00 r[8]=sqlite_master.type
REG[8] =   s5[index](8)
   6 Ne               9   11    8 (BINARY)      52 if r[8]!=r[9] goto 11
REG[9] =   t5[table](8)
REG[8] =   s5[index](8)
  11 Next             0    5    0               01 
   5 Column           0    0    8               00 r[8]=sqlite_master.type
REG[8] =   s4[view](8)
   6 Ne               9   11    8 (BINARY)      52 if r[8]!=r[9] goto 11
REG[9] =   t5[table](8)
REG[8] =   s4[view](8)
  11 Next             0    5    0               01 
   5 Column           0    0    8               00 r[8]=sqlite_master.type
REG[8] =   s4[view](8)
   6 Ne               9   11    8 (BINARY)      52 if r[8]!=r[9] goto 11
REG[9] =   t5[table](8)
REG[8] =   s4[view](8)
  11 Next             0    5    0               01 
   5 Column           0    0    8               00 r[8]=sqlite_master.type
REG[8] =   s5[table](8)
   6 Ne               9   11    8 (BINARY)      52 if r[8]!=r[9] goto 11
REG[9] =   t5[table](8)
REG[8] =   s5[table](8)
   7 Column           0    1    8               00 r[8]=sqlite_master.name
REG[8] =   s1[x](8)
   8 Ne              10   11    8 (BINARY)      52 if r[8]!=r[10] goto 11
REG[10] =   t1[x](8)
REG[8] =   s1[x](8)
   9 Rowid            0    2    0               00 r[2]=rowid
REG[2] =  i:6
  10 RowSetAdd        1    2    0               00 rowset(1)=r[2]
REG[1] =  NULL
REG[2] =  i:6
  11 Next             0    5    0               01 
  12 OpenWrite        0    1    0 5             00 root=1 iDb=0; sqlite_master
  13 RowSetRead       1   29    2               00 r[2]=rowset(1)
REG[1] =  (rowset)
REG[2] =  i:6
  14 NotExists        0   13    2               00 intkey=r[2]
REG[2] =  i:6
  15 Column           0    0    3               00 r[3]=sqlite_master.type
REG[3] =   s5[table](8)
  16 Column           0    1    4               00 r[4]=sqlite_master.name
REG[4] =   s1[x](8)
  17 Column           0    2    5               00 r[5]=sqlite_master.tbl_name
REG[5] =   s1[x](8)
  18 Column           0    3    6               00 r[6]=sqlite_master.rootpage
REG[6] =  i:5
  19 Column           0    4   14               00 r[14]=sqlite_master.sql
REG[14] =   s49[CREATE TABLE x(y INTEGER ](8)
  20 Function0        6   14   13 substr(3)     03 r[13]=func(r[14..16])
REG[14] =   s49[CREATE TABLE x(y INTEGER ](8)
REG[15] =  i:1
REG[16] =  i:48
REG[13] =   s48[CREATE TABLE x(y INTEGER ](8)
  21 Concat          17   13   12               00 r[12]=r[13]+r[17]
REG[17] =   t2[, ](8)
REG[13] =   s48[CREATE TABLE x(y INTEGER ](8)
REG[12] =   s50[CREATE TABLE x(y INTEGER ](8)
  22 Concat          18   12    8               00 r[8]=r[12]+r[18]
REG[18] =   t3[abc](8)
REG[12] =   s50[CREATE TABLE x(y INTEGER ](8)
REG[8] =   s53[CREATE TABLE x(y INTEGER ](8)
  23 Column           0    4   19               00 r[19]=sqlite_master.sql
REG[19] =   s49[CREATE TABLE x(y INTEGER ](8)
  24 Function0        2   19   12 substr(2)     02 r[12]=func(r[19..20])
REG[19] =   s49[CREATE TABLE x(y INTEGER ](8)
REG[20] =  i:49
REG[12] =   s1[)](8)
  25 Concat          12    8    7               00 r[7]=r[8]+r[12]
REG[12] =   s1[)](8)
REG[8] =   s53[CREATE TABLE x(y INTEGER ](8)
REG[7] =   s54[CREATE TABLE x(y INTEGER ](8)
  26 MakeRecord       3    5   11 BBBDB         00 r[11]=mkrec(r[3..7])
REG[3] =   s5[table](8)
REG[4] =   s1[x](8)
REG[5] =   s1[x](8)
REG[6] =  i:5
REG[7] =   s54[CREATE TABLE x(y INTEGER ](8)
REG[11] =  sx68[06170F0F01797461626C65787805435245415445205441424C|.....ytablexx.CREATE TABL]
  27 Insert           0   11    2               00 intkey=r[2] data=r[11]
REG[11] =  sx68[06170F0F01797461626C65787805435245415445205441424C|.....ytablexx.CREATE TABL]
REG[2] =  i:6
  28 Goto             0   13    0               00 
  13 RowSetRead       1   29    2               00 r[2]=rowset(1)
REG[1] =  (rowset)
REG[2] =  i:6
  29 ReadCookie       0   12    2               00 
REG[12] =  i:4
  30 AddImm          12   -2    0               00 r[12]=r[12]+-2
REG[12] =  i:4
  31 IfPos           12   33    0               00 if r[12]>0 then r[12]-=0, goto 33
REG[12] =  i:2
  33 SetCookie        0    1    9               00 
  34 ParseSchema      0    0    0               00 
parser: [[[CREATE TABLE x(type text,name text,tbl_name text,rootpage int,sql text)]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 390
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 0.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP ID]
parser: Input 'ID' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 192
parser: Shift 'ID', pending reduce 341
parser: Return. Stack=[create_table LP nm ID]
parser: Input 'COMMA' with pending reduce 341
parser: Reduce 341 [typename ::= ID|STRING], go to state 192.
parser: ... then shift 'typename', go to state 392
parser: Reduce 340 [typetoken ::= typename], go to state 192.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 379
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 152
parser: Reduce 336 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'ID' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Shift 'ID', pending reduce 341
parser: Return. Stack=[create_table LP columnlist COMMA nm ID]
parser: Input 'COMMA' with pending reduce 341
parser: Reduce 341 [typename ::= ID|STRING], go to state 192.
parser: ... then shift 'typename', go to state 392
parser: Reduce 340 [typetoken ::= typename], go to state 192.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'ID' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Shift 'ID', pending reduce 341
parser: Return. Stack=[create_table LP columnlist COMMA nm ID]
parser: Input 'COMMA' with pending reduce 341
parser: Reduce 341 [typename ::= ID|STRING], go to state 192.
parser: ... then shift 'typename', go to state 392
parser: Reduce 340 [typetoken ::= typename], go to state 192.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'ID' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Shift 'ID', pending reduce 341
parser: Return. Stack=[create_table LP columnlist COMMA nm ID]
parser: Input 'COMMA' with pending reduce 341
parser: Reduce 341 [typename ::= ID|STRING], go to state 192.
parser: ... then shift 'typename', go to state 392
parser: Reduce 340 [typetoken ::= typename], go to state 192.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'ID' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Shift 'ID', pending reduce 341
parser: Return. Stack=[create_table LP columnlist COMMA nm ID]
parser: Input 'RP' with pending reduce 341
parser: Reduce 341 [typename ::= ID|STRING], go to state 192.
parser: ... then shift 'typename', go to state 392
parser: Reduce 340 [typetoken ::= typename], go to state 192.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Reduce 61 [conslist_opt ::=].
parser: ... then shift 'conslist_opt', go to state 540
parser: Shift 'RP', go to state 364
parser: Return. Stack=[create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 364
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: ... then shift 'create_table_args', pending reduce 334
parser: Reduce 334 [cmd ::= create_table create_table_args], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT*FROM"main".sqlite_master ORDER BY rowid]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'STAR' in state 288
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 95 [sclp ::=].
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STAR', pending reduce 97
parser: Return. Stack=[SELECT distinct sclp scanpt STAR]
parser: Input 'FROM' with pending reduce 97
parser: Reduce 97 [selcollist ::= sclp scanpt STAR], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 104 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'DOT' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 350
parser: Shift 'DOT', go to state 245
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID' in state 245
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'ORDER' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 245.
parser: ... then shift 'nm', pending reduce 110
parser: Reduce 110 [dbnm ::= DOT nm], go to state 350.
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 123 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 349
parser: Reduce 122 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 348
parser: Reduce 127 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 105
parser: Reduce 105 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 102 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 363
parser: Reduce 147 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 362
parser: Reduce 138 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 361
parser: Reduce 140 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 517
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 517
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 419
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 134 [sortorder ::=].
parser: ... then shift 'sortorder', go to state 353
parser: Reduce 137 [nulls ::=].
parser: ... then shift 'nulls', pending reduce 131
parser: Reduce 131 [sortlist ::= expr sortorder nulls], go to state 26.
parser: ... then shift 'sortlist', go to state 516
parser: Reduce 129 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 360
parser: Reduce 142 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 88
parser: Reduce 88 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 83 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 80
parser: Reduce 80 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
VDBE Trace:
   0 Init             0   13    0               00 Start at 13
  13 Transaction      0    0    9 3             00 usesStmtJournal=0
  14 Goto             0    1    0               00 
   1 Noop             1    7    0               00 
   2 OpenRead         0    1    0 5             00 root=1 iDb=0; sqlite_master
   3 Explain          3    0    0 SCAN TABLE sqlite_master 00 
   4 Rewind           0   12    0               00 
   5 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s5[table](8)
   6 Column           0    1    2               00 r[2]=sqlite_master.name
REG[2] =   s1[a](8)
   7 Column           0    2    3               00 r[3]=sqlite_master.tbl_name
REG[3] =   s1[a](8)
   8 Column           0    3    4               00 r[4]=sqlite_master.rootpage
REG[4] =  i:2
   9 Column           0    4    5               00 r[5]=sqlite_master.sql
REG[5] =   s56[CREATE TABLE a (b INTEGER](8)
  10 ResultRow        1    5    0               00 output=r[1..5]
REG[1] =   s5[table](8)
REG[2] =   s1[a](8)
REG[3] =   s1[a](8)
REG[4] =  i:2
REG[5] =   s56[CREATE TABLE a (b INTEGER](8)
parser: [[[CREATE TABLE a (b INTEGER, PRIMARY KEY(b)) WITHOUT ROWID]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 390
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 0.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP ID]
parser: Input 'ID' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 192
parser: Shift 'ID', pending reduce 341
parser: Return. Stack=[create_table LP nm ID]
parser: Input 'COMMA' with pending reduce 341
parser: Reduce 341 [typename ::= ID|STRING], go to state 192.
parser: ... then shift 'typename', go to state 392
parser: Reduce 340 [typetoken ::= typename], go to state 192.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 379
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 152
parser: Reduce 336 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'PRIMARY' in state 34
parser: Shift 'PRIMARY', go to state 475
parser: Return. Stack=[create_table LP columnlist COMMA PRIMARY]
parser: Input 'KEY' in state 475
parser: Shift 'KEY', go to state 474
parser: Return. Stack=[create_table LP columnlist COMMA PRIMARY KEY]
parser: Input 'LP' in state 474
parser: Shift 'LP', go to state 20
parser: Return. Stack=[create_table LP columnlist COMMA PRIMARY KEY LP]
parser: Input 'ID' in state 20
parser: Shift 'ID', go to state 419
parser: Return. Stack=[create_table LP columnlist COMMA PRIMARY KEY LP ID]
parser: Input 'RP' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 20.
parser: ... then shift 'expr', go to state 13
parser: Reduce 134 [sortorder ::=].
parser: ... then shift 'sortorder', go to state 353
parser: Reduce 137 [nulls ::=].
parser: ... then shift 'nulls', pending reduce 131
parser: Reduce 131 [sortlist ::= expr sortorder nulls], go to state 20.
parser: ... then shift 'sortlist', go to state 277
parser: Reduce 43 [autoinc ::=].
parser: ... then shift 'autoinc', go to state 473
parser: Shift 'RP', go to state 328
parser: Return. Stack=[create_table LP columnlist COMMA PRIMARY KEY LP sortlist autoinc RP]
parser: Input 'RP' in state 328
parser: Reduce 69 [onconf ::=].
parser: ... then shift 'onconf', pending reduce 64
parser: Reduce 64 [tcons ::= PRIMARY KEY LP sortlist autoinc RP onconf], go to state 34.
parser: ... then shift 'tcons', go to state 278
parser: Reduce 347 [conslist_opt ::= COMMA conslist], go to state 365.
parser: ... then shift 'conslist_opt', go to state 540
parser: Shift 'RP', go to state 364
parser: Return. Stack=[create_table LP columnlist conslist_opt RP]
parser: Input 'WITHOUT' in state 364
parser: Shift 'WITHOUT', go to state 251
parser: Return. Stack=[create_table LP columnlist conslist_opt RP WITHOUT]
parser: Input 'ID' in state 251
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist conslist_opt RP WITHOUT ID]
parser: Input 'SEMI' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 251.
parser: ... then shift 'nm', pending reduce 22
parser: Reduce 22 [table_options ::= WITHOUT nm], go to state 364.
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: ... then shift 'create_table_args', pending reduce 334
parser: Reduce 334 [cmd ::= create_table create_table_args], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
  11 Next             0    5    0               01 
   5 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s5[table](8)
   6 Column           0    1    2               00 r[2]=sqlite_master.name
REG[2] =   s2[ex](8)
   7 Column           0    2    3               00 r[3]=sqlite_master.tbl_name
REG[3] =   s2[ex](8)
   8 Column           0    3    4               00 r[4]=sqlite_master.rootpage
REG[4] =  i:3
   9 Column           0    4    5               00 r[5]=sqlite_master.sql
REG[5] =   s19[CREATE TABLE ex(i1)](8)
  10 ResultRow        1    5    0               00 output=r[1..5]
REG[1] =   s5[table](8)
REG[2] =   s2[ex](8)
REG[3] =   s2[ex](8)
REG[4] =  i:3
REG[5] =   s19[CREATE TABLE ex(i1)](8)
parser: [[[CREATE TABLE ex(i1)]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 390
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 0.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP ID]
parser: Input 'RP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 192
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 379
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 152
parser: Reduce 336 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Reduce 61 [conslist_opt ::=].
parser: ... then shift 'conslist_opt', go to state 540
parser: Shift 'RP', go to state 364
parser: Return. Stack=[create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 364
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: ... then shift 'create_table_args', pending reduce 334
parser: Reduce 334 [cmd ::= create_table create_table_args], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
  11 Next             0    5    0               01 
   5 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s5[index](8)
   6 Column           0    1    2               00 r[2]=sqlite_master.name
REG[2] =   s2[i2](8)
   7 Column           0    2    3               00 r[3]=sqlite_master.tbl_name
REG[3] =   s1[a](8)
   8 Column           0    3    4               00 r[4]=sqlite_master.rootpage
REG[4] =  i:4
   9 Column           0    4    5               00 r[5]=sqlite_master.sql
REG[5] =   s38[CREATE INDEX i2 ON a(b CO](8)
  10 ResultRow        1    5    0               00 output=r[1..5]
REG[1] =   s5[index](8)
REG[2] =   s2[i2](8)
REG[3] =   s1[a](8)
REG[4] =  i:4
REG[5] =   s38[CREATE INDEX i2 ON a(b CO](8)
parser: [[[CREATE INDEX i2 ON a(b COLLATE binary)]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'INDEX' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 225 [uniqueflag ::=].
parser: ... then shift 'uniqueflag', go to state 456
parser: Shift 'INDEX', go to state 315
parser: Return. Stack=[createkw uniqueflag INDEX]
parser: Input 'ID' in state 315
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 225
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists ID]
parser: Input 'ON' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 225.
parser: ... then shift 'nm', go to state 314
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 455
parser: Shift 'ON', go to state 224
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON]
parser: Input 'ID' in state 224
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON ID]
parser: Input 'LP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 224.
parser: ... then shift 'nm', go to state 454
parser: Shift 'LP', go to state 18
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP]
parser: Input 'ID' in state 18
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP ID]
parser: Input 'COLLATE' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 18.
parser: ... then shift 'expr', go to state 13
parser: Shift 'COLLATE', go to state 418
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP expr COLLATE]
parser: Input 'ID' in state 418
parser: Shift 'ID', pending reduce 175
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP expr COLLATE ID]
parser: Input 'RP' with pending reduce 175
parser: Reduce 175 [expr ::= expr COLLATE ID|STRING], go to state 18.
parser: ... then shift 'expr', go to state 13
parser: Reduce 134 [sortorder ::=].
parser: ... then shift 'sortorder', go to state 353
parser: Reduce 137 [nulls ::=].
parser: ... then shift 'nulls', pending reduce 131
parser: Reduce 131 [sortlist ::= expr sortorder nulls], go to state 18.
parser: ... then shift 'sortlist', go to state 402
parser: Shift 'RP', go to state 313
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP]
parser: Input 'SEMI' in state 313
parser: Reduce 147 [where_opt ::=].
parser: ... then shift 'where_opt', pending reduce 223
parser: Reduce 223 [cmd ::= createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP where_opt], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
  11 Next             0    5    0               01 
   5 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s4[view](8)
   6 Column           0    1    2               00 r[2]=sqlite_master.name
REG[2] =   s2[t1](8)
   7 Column           0    2    3               00 r[3]=sqlite_master.tbl_name
REG[3] =   s2[t1](8)
   8 Column           0    3    4               00 r[4]=sqlite_master.rootpage
REG[4] =  i:0
   9 Column           0    4    5               00 r[5]=sqlite_master.sql
REG[5] =   s210[CREATE VIEW t1 AS SELECT ](8)
  10 ResultRow        1    5    0               00 output=r[1..5]
REG[1] =   s4[view](8)
REG[2] =   s2[t1](8)
REG[3] =   s2[t1](8)
REG[4] =  i:0
REG[5] =   s210[CREATE VIEW t1 AS SELECT ](8)
parser: [[[CREATE VIEW t1 AS SELECT 123
    
      WINDOW x AS (
        RANGE BETWEEN UNBOUNDED PRECEDING AND INDEXED() OVER(
          PARTITION BY ( WITH x AS(VALUES(col1)) VALUES(453) )
        )
      FOLLOWING
    )]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'VIEW' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: FALLBACK VIEW => ID
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 390
parser: Shift 'VIEW', go to state 322
parser: Return. Stack=[createkw temp VIEW]
parser: Input 'ID' in state 322
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 228
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw temp VIEW ifnotexists ID]
parser: Input 'AS' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 228.
parser: ... then shift 'nm', go to state 321
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 320
parser: Reduce 226 [eidlist_opt ::=].
parser: ... then shift 'eidlist_opt', go to state 464
parser: Shift 'AS', go to state 37
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS]
parser: Input 'SELECT' in state 37
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT]
parser: Input 'INTEGER' in state 288
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 95 [sclp ::=].
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'INTEGER', pending reduce 173
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt INTEGER]
parser: Input 'WINDOW' with pending reduce 173
parser: Reduce 173 [term ::= INTEGER], go to state 77.
parser: ... then shift 'term', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Reduce 101 [from ::=].
parser: ... then shift 'from', go to state 363
parser: Reduce 147 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 362
parser: Reduce 138 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 361
parser: Reduce 140 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'WINDOW', go to state 136
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW]
parser: Input 'ID' in state 136
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW ID]
parser: Input 'AS' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 136.
parser: ... then shift 'nm', go to state 514
parser: Shift 'AS', go to state 513
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS]
parser: Input 'LP' in state 513
parser: Shift 'LP', go to state 33
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP]
parser: Input 'RANGE' in state 33
parser: Shift 'RANGE', pending reduce 304
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP RANGE]
parser: Input 'BETWEEN' with pending reduce 304
parser: Reduce 304 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 33.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP range_or_rows BETWEEN]
parser: Input 'UNBOUNDED' in state 8
parser: Shift 'UNBOUNDED', go to state 505
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP range_or_rows BETWEEN UNBOUNDED]
parser: Input 'PRECEDING' in state 505
parser: Shift 'PRECEDING', pending reduce 306
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP range_or_rows BETWEEN UNBOUNDED PRECEDING]
parser: Input 'AND' with pending reduce 306
parser: Reduce 306 [frame_bound_s ::= UNBOUNDED PRECEDING], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 508
parser: Shift 'AND', go to state 7
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'INDEXED' in state 7
parser: Shift 'INDEXED', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP range_or_rows BETWEEN frame_bound_s AND INDEXED]
parser: Input 'LP' in state 419
parser: Shift 'LP', go to state 266
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP range_or_rows BETWEEN frame_bound_s AND INDEXED LP]
parser: Input 'RP' in state 266
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Reduce 218 [exprlist ::=].
parser: ... then shift 'exprlist', go to state 484
parser: Shift 'RP', go to state 146
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP range_or_rows BETWEEN frame_bound_s AND INDEXED LP distinct exprlist RP]
parser: Input 'OVER' in state 146
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP range_or_rows BETWEEN frame_bound_s AND INDEXED LP distinct exprlist RP OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP range_or_rows BETWEEN frame_bound_s AND INDEXED LP distinct exprlist RP OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 511
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP range_or_rows BETWEEN frame_bound_s AND INDEXED LP distinct exprlist RP OVER LP PARTITION]
parser: Input 'BY' in state 511
parser: Shift 'BY', go to state 25
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP range_or_rows BETWEEN frame_bound_s AND INDEXED LP distinct exprlist RP OVER LP PARTITION BY]
parser: Input 'LP' in state 25
parser: Shift 'LP', go to state 4
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP range_or_rows BETWEEN frame_bound_s AND INDEXED LP distinct exprlist RP OVER LP PARTITION BY LP]
parser: Input 'WITH' in state 4
parser: Shift 'WITH', go to state 162
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP range_or_rows BETWEEN frame_bound_s AND INDEXED LP distinct exprlist RP OVER LP PARTITION BY LP WITH]
parser: Input 'ID' in state 162
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP range_or_rows BETWEEN frame_bound_s AND INDEXED LP distinct exprlist RP OVER LP PARTITION BY LP WITH ID]
parser: Input 'AS' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 162.
parser: ... then shift 'nm', go to state 338
parser: Reduce 226 [eidlist_opt ::=].
parser: ... then shift 'eidlist_opt', go to state 489
parser: Shift 'AS', go to state 488
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP range_or_rows BETWEEN frame_bound_s AND INDEXED LP distinct exprlist RP OVER LP PARTITION BY LP WITH nm eidlist_opt AS]
parser: Input 'LP' in state 488
parser: Shift 'LP', go to state 39
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP range_or_rows BETWEEN frame_bound_s AND INDEXED LP distinct exprlist RP OVER LP PARTITION BY LP WITH nm eidlist_opt AS LP]
parser: Input 'VALUES' in state 39
parser: Shift 'VALUES', go to state 528
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP range_or_rows BETWEEN frame_bound_s AND INDEXED LP distinct exprlist RP OVER LP PARTITION BY LP WITH nm eidlist_opt AS LP VALUES]
parser: Input 'LP' in state 528
parser: Shift 'LP', go to state 28
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP range_or_rows BETWEEN frame_bound_s AND INDEXED LP distinct exprlist RP OVER LP PARTITION BY LP WITH nm eidlist_opt AS LP VALUES LP]
parser: Input 'ID' in state 28
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP range_or_rows BETWEEN frame_bound_s AND INDEXED LP distinct exprlist RP OVER LP PARTITION BY LP WITH nm eidlist_opt AS LP VALUES LP ID]
parser: Input 'RP' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 28.
parser: ... then shift 'expr', go to state 70
parser: Reduce 220 [nexprlist ::= expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 413
parser: Shift 'RP', pending reduce 90
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP range_or_rows BETWEEN frame_bound_s AND INDEXED LP distinct exprlist RP OVER LP PARTITION BY LP WITH nm eidlist_opt AS LP VALUES LP nexprlist RP]
parser: Input 'RP' with pending reduce 90
parser: Reduce 90 [values ::= VALUES LP nexprlist RP], go to state 39.
parser: ... then shift 'values', go to state 534
parser: Reduce 354 [oneselect ::= values], go to state 39.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 83 [select ::= selectnowith], go to state 39.
parser: ... then shift 'select', go to state 487
parser: Shift 'RP', pending reduce 290
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP range_or_rows BETWEEN frame_bound_s AND INDEXED LP distinct exprlist RP OVER LP PARTITION BY LP WITH nm eidlist_opt AS LP select RP]
parser: Input 'VALUES' with pending reduce 290
parser: Reduce 290 [wqlist ::= nm eidlist_opt AS LP select RP], go to state 162.
parser: ... then shift 'wqlist', go to state 143
parser: Shift 'VALUES', go to state 528
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP range_or_rows BETWEEN frame_bound_s AND INDEXED LP distinct exprlist RP OVER LP PARTITION BY LP WITH wqlist VALUES]
parser: Input 'LP' in state 528
parser: Shift 'LP', go to state 28
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP range_or_rows BETWEEN frame_bound_s AND INDEXED LP distinct exprlist RP OVER LP PARTITION BY LP WITH wqlist VALUES LP]
parser: Input 'INTEGER' in state 28
parser: Shift 'INTEGER', pending reduce 173
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP range_or_rows BETWEEN frame_bound_s AND INDEXED LP distinct exprlist RP OVER LP PARTITION BY LP WITH wqlist VALUES LP INTEGER]
parser: Input 'RP' with pending reduce 173
parser: Reduce 173 [term ::= INTEGER], go to state 28.
parser: ... then shift 'term', go to state 70
parser: Reduce 220 [nexprlist ::= expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 413
parser: Shift 'RP', pending reduce 90
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP range_or_rows BETWEEN frame_bound_s AND INDEXED LP distinct exprlist RP OVER LP PARTITION BY LP WITH wqlist VALUES LP nexprlist RP]
parser: Input 'RP' with pending reduce 90
parser: Reduce 90 [values ::= VALUES LP nexprlist RP], go to state 143.
parser: ... then shift 'values', go to state 534
parser: Reduce 354 [oneselect ::= values], go to state 143.
parser: ... then shift 'oneselect', go to state 265
parser: Reduce 81 [select ::= WITH wqlist selectnowith], go to state 4.
parser: ... then shift 'select', go to state 485
parser: Shift 'RP', pending reduce 207
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP range_or_rows BETWEEN frame_bound_s AND INDEXED LP distinct exprlist RP OVER LP PARTITION BY LP select RP]
parser: Input 'RP' with pending reduce 207
parser: Reduce 207 [expr ::= LP select RP], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 220 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Reduce 128 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 191
parser: Reduce 301 [frame_opt ::=].
parser: ... then shift 'frame_opt', pending reduce 295
parser: Reduce 295 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 483
parser: Shift 'RP', pending reduce 320
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP range_or_rows BETWEEN frame_bound_s AND INDEXED LP distinct exprlist RP OVER LP window RP]
parser: Input 'FOLLOWING' with pending reduce 320
parser: Reduce 320 [over_clause ::= OVER LP window RP], go to state 146.
parser: ... then shift 'over_clause', pending reduce 318
parser: Reduce 318 [filter_over ::= over_clause], go to state 146.
parser: ... then shift 'filter_over', pending reduce 179
parser: Reduce 179 [expr ::= ID|INDEXED LP distinct exprlist RP filter_over], go to state 7.
parser: ... then shift 'expr', go to state 42
parser: Shift 'FOLLOWING', pending reduce 309
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP range_or_rows BETWEEN frame_bound_s AND expr FOLLOWING]
parser: Input 'RP' with pending reduce 309
parser: Reduce 309 [frame_bound ::= expr PRECEDING|FOLLOWING], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 307
parser: Reduce 307 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 351
parser: Reduce 311 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 303
parser: Reduce 303 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 33.
parser: ... then shift 'frame_opt', pending reduce 299
parser: Reduce 299 [window ::= frame_opt], go to state 33.
parser: ... then shift 'window', go to state 512
parser: Shift 'RP', pending reduce 294
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP window RP]
parser: Input 'SEMI' with pending reduce 294
parser: Reduce 294 [windowdefn ::= nm AS LP window RP], go to state 136.
parser: ... then shift 'windowdefn', pending reduce 292
parser: Reduce 292 [windowdefn_list ::= windowdefn], go to state 136.
parser: ... then shift 'windowdefn_list', go to state 515
parser: Reduce 316 [window_clause ::= WINDOW windowdefn_list], go to state 194.
parser: ... then shift 'window_clause', go to state 356
parser: Reduce 128 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 355
parser: Reduce 142 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 89
parser: Reduce 89 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt window_clause orderby_opt limit_opt], go to state 37.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 83 [select ::= selectnowith], go to state 37.
parser: ... then shift 'select', pending reduce 78
parser: Reduce 78 [cmd ::= createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
  11 Next             0    5    0               01 
   5 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s4[view](8)
   6 Column           0    1    2               00 r[2]=sqlite_master.name
REG[2] =   s2[t2](8)
   7 Column           0    2    3               00 r[3]=sqlite_master.tbl_name
REG[3] =   s2[t2](8)
   8 Column           0    3    4               00 r[4]=sqlite_master.rootpage
REG[4] =  i:0
   9 Column           0    4    5               00 r[5]=sqlite_master.sql
REG[5] =   s396[CREATE VIEW t2 AS .  SELE](8)
  10 ResultRow        1    5    0               00 output=r[1..5]
REG[1] =   s4[view](8)
REG[2] =   s2[t2](8)
REG[3] =   s2[t2](8)
REG[4] =  i:0
REG[5] =   s396[CREATE VIEW t2 AS .  SELE](8)
parser: [[[CREATE VIEW t2 AS 
  SELECT sum(b) FILTER( WHERE b>9 ),
         sum(b) FILTER( WHERE b>8 ),
         sum(b) FILTER( WHERE b>7 ),
         sum(b) FILTER( WHERE b>6 ),
         sum(b) FILTER( WHERE b>5 ),
         sum(b) FILTER( WHERE b>4 ),
         sum(b) FILTER( WHERE b>3 ),
         sum(b) FILTER( WHERE b>2 ),
         sum(b) FILTER( WHERE b>1 ),
         sum(b) FILTER( WHERE b>0 )
  FROM a]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'VIEW' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: FALLBACK VIEW => ID
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 390
parser: Shift 'VIEW', go to state 322
parser: Return. Stack=[createkw temp VIEW]
parser: Input 'ID' in state 322
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 228
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw temp VIEW ifnotexists ID]
parser: Input 'AS' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 228.
parser: ... then shift 'nm', go to state 321
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 320
parser: Reduce 226 [eidlist_opt ::=].
parser: ... then shift 'eidlist_opt', go to state 464
parser: Shift 'AS', go to state 37
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS]
parser: Input 'SELECT' in state 37
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT]
parser: Input 'ID' in state 288
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 95 [sclp ::=].
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 419
parser: Shift 'LP', go to state 266
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 220 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 519
parser: Reduce 359 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 484
parser: Shift 'RP', go to state 146
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'FILTER' in state 146
parser: Shift 'FILTER', go to state 482
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER]
parser: Input 'LP' in state 482
parser: Shift 'LP', go to state 481
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP]
parser: Input 'WHERE' in state 481
parser: Shift 'WHERE', go to state 90
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE]
parser: Input 'ID' in state 90
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE ID]
parser: Input 'GT' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'GT', go to state 118
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT]
parser: Input 'INTEGER' in state 118
parser: Shift 'INTEGER', pending reduce 173
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT INTEGER]
parser: Input 'RP' with pending reduce 173
parser: Reduce 173 [term ::= INTEGER], go to state 118.
parser: ... then shift 'term', go to state 130
parser: Reduce 185 [expr ::= expr LT|GT|GE|LE expr], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'RP', pending reduce 322
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr RP]
parser: Input 'COMMA' with pending reduce 322
parser: Reduce 322 [filter_clause ::= FILTER LP WHERE expr RP], go to state 146.
parser: ... then shift 'filter_clause', go to state 337
parser: Reduce 319 [filter_over ::= filter_clause], go to state 146.
parser: ... then shift 'filter_over', pending reduce 179
parser: Reduce 179 [expr ::= ID|INDEXED LP distinct exprlist RP filter_over], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 355
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 355
parser: Reduce 355 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 419
parser: Shift 'LP', go to state 266
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 220 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 519
parser: Reduce 359 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 484
parser: Shift 'RP', go to state 146
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'FILTER' in state 146
parser: Shift 'FILTER', go to state 482
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER]
parser: Input 'LP' in state 482
parser: Shift 'LP', go to state 481
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP]
parser: Input 'WHERE' in state 481
parser: Shift 'WHERE', go to state 90
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE]
parser: Input 'ID' in state 90
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE ID]
parser: Input 'GT' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'GT', go to state 118
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT]
parser: Input 'INTEGER' in state 118
parser: Shift 'INTEGER', pending reduce 173
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT INTEGER]
parser: Input 'RP' with pending reduce 173
parser: Reduce 173 [term ::= INTEGER], go to state 118.
parser: ... then shift 'term', go to state 130
parser: Reduce 185 [expr ::= expr LT|GT|GE|LE expr], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'RP', pending reduce 322
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr RP]
parser: Input 'COMMA' with pending reduce 322
parser: Reduce 322 [filter_clause ::= FILTER LP WHERE expr RP], go to state 146.
parser: ... then shift 'filter_clause', go to state 337
parser: Reduce 319 [filter_over ::= filter_clause], go to state 146.
parser: ... then shift 'filter_over', pending reduce 179
parser: Reduce 179 [expr ::= ID|INDEXED LP distinct exprlist RP filter_over], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 355
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 355
parser: Reduce 355 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 419
parser: Shift 'LP', go to state 266
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 220 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 519
parser: Reduce 359 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 484
parser: Shift 'RP', go to state 146
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'FILTER' in state 146
parser: Shift 'FILTER', go to state 482
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER]
parser: Input 'LP' in state 482
parser: Shift 'LP', go to state 481
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP]
parser: Input 'WHERE' in state 481
parser: Shift 'WHERE', go to state 90
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE]
parser: Input 'ID' in state 90
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE ID]
parser: Input 'GT' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'GT', go to state 118
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT]
parser: Input 'INTEGER' in state 118
parser: Shift 'INTEGER', pending reduce 173
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT INTEGER]
parser: Input 'RP' with pending reduce 173
parser: Reduce 173 [term ::= INTEGER], go to state 118.
parser: ... then shift 'term', go to state 130
parser: Reduce 185 [expr ::= expr LT|GT|GE|LE expr], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'RP', pending reduce 322
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr RP]
parser: Input 'COMMA' with pending reduce 322
parser: Reduce 322 [filter_clause ::= FILTER LP WHERE expr RP], go to state 146.
parser: ... then shift 'filter_clause', go to state 337
parser: Reduce 319 [filter_over ::= filter_clause], go to state 146.
parser: ... then shift 'filter_over', pending reduce 179
parser: Reduce 179 [expr ::= ID|INDEXED LP distinct exprlist RP filter_over], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 355
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 355
parser: Reduce 355 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 419
parser: Shift 'LP', go to state 266
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 220 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 519
parser: Reduce 359 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 484
parser: Shift 'RP', go to state 146
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'FILTER' in state 146
parser: Shift 'FILTER', go to state 482
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER]
parser: Input 'LP' in state 482
parser: Shift 'LP', go to state 481
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP]
parser: Input 'WHERE' in state 481
parser: Shift 'WHERE', go to state 90
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE]
parser: Input 'ID' in state 90
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE ID]
parser: Input 'GT' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'GT', go to state 118
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT]
parser: Input 'INTEGER' in state 118
parser: Shift 'INTEGER', pending reduce 173
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT INTEGER]
parser: Input 'RP' with pending reduce 173
parser: Reduce 173 [term ::= INTEGER], go to state 118.
parser: ... then shift 'term', go to state 130
parser: Reduce 185 [expr ::= expr LT|GT|GE|LE expr], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'RP', pending reduce 322
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr RP]
parser: Input 'COMMA' with pending reduce 322
parser: Reduce 322 [filter_clause ::= FILTER LP WHERE expr RP], go to state 146.
parser: ... then shift 'filter_clause', go to state 337
parser: Reduce 319 [filter_over ::= filter_clause], go to state 146.
parser: ... then shift 'filter_over', pending reduce 179
parser: Reduce 179 [expr ::= ID|INDEXED LP distinct exprlist RP filter_over], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 355
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 355
parser: Reduce 355 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 419
parser: Shift 'LP', go to state 266
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 220 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 519
parser: Reduce 359 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 484
parser: Shift 'RP', go to state 146
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'FILTER' in state 146
parser: Shift 'FILTER', go to state 482
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER]
parser: Input 'LP' in state 482
parser: Shift 'LP', go to state 481
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP]
parser: Input 'WHERE' in state 481
parser: Shift 'WHERE', go to state 90
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE]
parser: Input 'ID' in state 90
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE ID]
parser: Input 'GT' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'GT', go to state 118
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT]
parser: Input 'INTEGER' in state 118
parser: Shift 'INTEGER', pending reduce 173
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT INTEGER]
parser: Input 'RP' with pending reduce 173
parser: Reduce 173 [term ::= INTEGER], go to state 118.
parser: ... then shift 'term', go to state 130
parser: Reduce 185 [expr ::= expr LT|GT|GE|LE expr], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'RP', pending reduce 322
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr RP]
parser: Input 'COMMA' with pending reduce 322
parser: Reduce 322 [filter_clause ::= FILTER LP WHERE expr RP], go to state 146.
parser: ... then shift 'filter_clause', go to state 337
parser: Reduce 319 [filter_over ::= filter_clause], go to state 146.
parser: ... then shift 'filter_over', pending reduce 179
parser: Reduce 179 [expr ::= ID|INDEXED LP distinct exprlist RP filter_over], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 355
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 355
parser: Reduce 355 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 419
parser: Shift 'LP', go to state 266
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 220 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 519
parser: Reduce 359 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 484
parser: Shift 'RP', go to state 146
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'FILTER' in state 146
parser: Shift 'FILTER', go to state 482
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER]
parser: Input 'LP' in state 482
parser: Shift 'LP', go to state 481
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP]
parser: Input 'WHERE' in state 481
parser: Shift 'WHERE', go to state 90
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE]
parser: Input 'ID' in state 90
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE ID]
parser: Input 'GT' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'GT', go to state 118
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT]
parser: Input 'INTEGER' in state 118
parser: Shift 'INTEGER', pending reduce 173
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT INTEGER]
parser: Input 'RP' with pending reduce 173
parser: Reduce 173 [term ::= INTEGER], go to state 118.
parser: ... then shift 'term', go to state 130
parser: Reduce 185 [expr ::= expr LT|GT|GE|LE expr], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'RP', pending reduce 322
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr RP]
parser: Input 'COMMA' with pending reduce 322
parser: Reduce 322 [filter_clause ::= FILTER LP WHERE expr RP], go to state 146.
parser: ... then shift 'filter_clause', go to state 337
parser: Reduce 319 [filter_over ::= filter_clause], go to state 146.
parser: ... then shift 'filter_over', pending reduce 179
parser: Reduce 179 [expr ::= ID|INDEXED LP distinct exprlist RP filter_over], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 355
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 355
parser: Reduce 355 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 419
parser: Shift 'LP', go to state 266
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 220 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 519
parser: Reduce 359 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 484
parser: Shift 'RP', go to state 146
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'FILTER' in state 146
parser: Shift 'FILTER', go to state 482
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER]
parser: Input 'LP' in state 482
parser: Shift 'LP', go to state 481
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP]
parser: Input 'WHERE' in state 481
parser: Shift 'WHERE', go to state 90
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE]
parser: Input 'ID' in state 90
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE ID]
parser: Input 'GT' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'GT', go to state 118
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT]
parser: Input 'INTEGER' in state 118
parser: Shift 'INTEGER', pending reduce 173
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT INTEGER]
parser: Input 'RP' with pending reduce 173
parser: Reduce 173 [term ::= INTEGER], go to state 118.
parser: ... then shift 'term', go to state 130
parser: Reduce 185 [expr ::= expr LT|GT|GE|LE expr], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'RP', pending reduce 322
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr RP]
parser: Input 'COMMA' with pending reduce 322
parser: Reduce 322 [filter_clause ::= FILTER LP WHERE expr RP], go to state 146.
parser: ... then shift 'filter_clause', go to state 337
parser: Reduce 319 [filter_over ::= filter_clause], go to state 146.
parser: ... then shift 'filter_over', pending reduce 179
parser: Reduce 179 [expr ::= ID|INDEXED LP distinct exprlist RP filter_over], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 355
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 355
parser: Reduce 355 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 419
parser: Shift 'LP', go to state 266
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 220 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 519
parser: Reduce 359 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 484
parser: Shift 'RP', go to state 146
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'FILTER' in state 146
parser: Shift 'FILTER', go to state 482
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER]
parser: Input 'LP' in state 482
parser: Shift 'LP', go to state 481
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP]
parser: Input 'WHERE' in state 481
parser: Shift 'WHERE', go to state 90
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE]
parser: Input 'ID' in state 90
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE ID]
parser: Input 'GT' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'GT', go to state 118
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT]
parser: Input 'INTEGER' in state 118
parser: Shift 'INTEGER', pending reduce 173
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT INTEGER]
parser: Input 'RP' with pending reduce 173
parser: Reduce 173 [term ::= INTEGER], go to state 118.
parser: ... then shift 'term', go to state 130
parser: Reduce 185 [expr ::= expr LT|GT|GE|LE expr], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'RP', pending reduce 322
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr RP]
parser: Input 'COMMA' with pending reduce 322
parser: Reduce 322 [filter_clause ::= FILTER LP WHERE expr RP], go to state 146.
parser: ... then shift 'filter_clause', go to state 337
parser: Reduce 319 [filter_over ::= filter_clause], go to state 146.
parser: ... then shift 'filter_over', pending reduce 179
parser: Reduce 179 [expr ::= ID|INDEXED LP distinct exprlist RP filter_over], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 355
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 355
parser: Reduce 355 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 419
parser: Shift 'LP', go to state 266
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 220 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 519
parser: Reduce 359 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 484
parser: Shift 'RP', go to state 146
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'FILTER' in state 146
parser: Shift 'FILTER', go to state 482
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER]
parser: Input 'LP' in state 482
parser: Shift 'LP', go to state 481
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP]
parser: Input 'WHERE' in state 481
parser: Shift 'WHERE', go to state 90
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE]
parser: Input 'ID' in state 90
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE ID]
parser: Input 'GT' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'GT', go to state 118
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT]
parser: Input 'INTEGER' in state 118
parser: Shift 'INTEGER', pending reduce 173
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT INTEGER]
parser: Input 'RP' with pending reduce 173
parser: Reduce 173 [term ::= INTEGER], go to state 118.
parser: ... then shift 'term', go to state 130
parser: Reduce 185 [expr ::= expr LT|GT|GE|LE expr], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'RP', pending reduce 322
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr RP]
parser: Input 'COMMA' with pending reduce 322
parser: Reduce 322 [filter_clause ::= FILTER LP WHERE expr RP], go to state 146.
parser: ... then shift 'filter_clause', go to state 337
parser: Reduce 319 [filter_over ::= filter_clause], go to state 146.
parser: ... then shift 'filter_over', pending reduce 179
parser: Reduce 179 [expr ::= ID|INDEXED LP distinct exprlist RP filter_over], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 355
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 355
parser: Reduce 355 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 419
parser: Shift 'LP', go to state 266
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 220 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 519
parser: Reduce 359 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 484
parser: Shift 'RP', go to state 146
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'FILTER' in state 146
parser: Shift 'FILTER', go to state 482
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER]
parser: Input 'LP' in state 482
parser: Shift 'LP', go to state 481
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP]
parser: Input 'WHERE' in state 481
parser: Shift 'WHERE', go to state 90
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE]
parser: Input 'ID' in state 90
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE ID]
parser: Input 'GT' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'GT', go to state 118
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT]
parser: Input 'INTEGER' in state 118
parser: Shift 'INTEGER', pending reduce 173
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT INTEGER]
parser: Input 'RP' with pending reduce 173
parser: Reduce 173 [term ::= INTEGER], go to state 118.
parser: ... then shift 'term', go to state 130
parser: Reduce 185 [expr ::= expr LT|GT|GE|LE expr], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'RP', pending reduce 322
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr RP]
parser: Input 'FROM' with pending reduce 322
parser: Reduce 322 [filter_clause ::= FILTER LP WHERE expr RP], go to state 146.
parser: ... then shift 'filter_clause', go to state 337
parser: Reduce 319 [filter_over ::= filter_clause], go to state 146.
parser: ... then shift 'filter_over', pending reduce 179
parser: Reduce 179 [expr ::= ID|INDEXED LP distinct exprlist RP filter_over], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 104 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'SEMI' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 350
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 123 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 349
parser: Reduce 122 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 348
parser: Reduce 127 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 105
parser: Reduce 105 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 102 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 363
parser: Reduce 147 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 362
parser: Reduce 138 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 361
parser: Reduce 140 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 128 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 360
parser: Reduce 142 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 88
parser: Reduce 88 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 37.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 83 [select ::= selectnowith], go to state 37.
parser: ... then shift 'select', pending reduce 78
parser: Reduce 78 [cmd ::= createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
  11 Next             0    5    0               01 
   5 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s5[table](8)
   6 Column           0    1    2               00 r[2]=sqlite_master.name
REG[2] =   s1[x](8)
   7 Column           0    2    3               00 r[3]=sqlite_master.tbl_name
REG[3] =   s1[x](8)
   8 Column           0    3    4               00 r[4]=sqlite_master.rootpage
REG[4] =  i:5
   9 Column           0    4    5               00 r[5]=sqlite_master.sql
REG[5] =   s54[CREATE TABLE x(y INTEGER ](8)
  10 ResultRow        1    5    0               00 output=r[1..5]
REG[1] =   s5[table](8)
REG[2] =   s1[x](8)
REG[3] =   s1[x](8)
REG[4] =  i:5
REG[5] =   s54[CREATE TABLE x(y INTEGER ](8)
parser: [[[CREATE TABLE x(y INTEGER PRIMARY KEY, t2i1, t1i1, abc)]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 390
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 0.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP ID]
parser: Input 'ID' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 192
parser: Shift 'ID', pending reduce 341
parser: Return. Stack=[create_table LP nm ID]
parser: Input 'PRIMARY' with pending reduce 341
parser: Reduce 341 [typename ::= ID|STRING], go to state 192.
parser: ... then shift 'typename', go to state 392
parser: Reduce 340 [typetoken ::= typename], go to state 192.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 379
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 152
parser: Shift 'PRIMARY', go to state 478
parser: Return. Stack=[create_table LP columnname carglist PRIMARY]
parser: Input 'KEY' in state 478
parser: Shift 'KEY', go to state 280
parser: Return. Stack=[create_table LP columnname carglist PRIMARY KEY]
parser: Input 'COMMA' in state 280
parser: Reduce 134 [sortorder ::=].
parser: ... then shift 'sortorder', go to state 333
parser: Reduce 69 [onconf ::=].
parser: ... then shift 'onconf', go to state 332
parser: Reduce 43 [autoinc ::=].
parser: ... then shift 'autoinc', pending reduce 37
parser: Reduce 37 [ccons ::= PRIMARY KEY sortorder onconf autoinc], go to state 152.
parser: ... then shift 'ccons', pending reduce 344
parser: Reduce 344 [carglist ::= carglist ccons], go to state 379.
parser: ... then shift 'carglist', go to state 152
parser: Reduce 336 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'COMMA' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'COMMA' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'RP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Reduce 61 [conslist_opt ::=].
parser: ... then shift 'conslist_opt', go to state 540
parser: Shift 'RP', go to state 364
parser: Return. Stack=[create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 364
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: ... then shift 'create_table_args', pending reduce 334
parser: Reduce 334 [cmd ::= create_table create_table_args], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
  11 Next             0    5    0               01 
  12 Halt             0    0    0               00 
  35 ParseSchema      1    0    0               00 
parser: [[[CREATE TABLE x(type text,name text,tbl_name text,rootpage int,sql text)]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 390
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 0.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP ID]
parser: Input 'ID' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 192
parser: Shift 'ID', pending reduce 341
parser: Return. Stack=[create_table LP nm ID]
parser: Input 'COMMA' with pending reduce 341
parser: Reduce 341 [typename ::= ID|STRING], go to state 192.
parser: ... then shift 'typename', go to state 392
parser: Reduce 340 [typetoken ::= typename], go to state 192.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 379
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 152
parser: Reduce 336 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'ID' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Shift 'ID', pending reduce 341
parser: Return. Stack=[create_table LP columnlist COMMA nm ID]
parser: Input 'COMMA' with pending reduce 341
parser: Reduce 341 [typename ::= ID|STRING], go to state 192.
parser: ... then shift 'typename', go to state 392
parser: Reduce 340 [typetoken ::= typename], go to state 192.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'ID' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Shift 'ID', pending reduce 341
parser: Return. Stack=[create_table LP columnlist COMMA nm ID]
parser: Input 'COMMA' with pending reduce 341
parser: Reduce 341 [typename ::= ID|STRING], go to state 192.
parser: ... then shift 'typename', go to state 392
parser: Reduce 340 [typetoken ::= typename], go to state 192.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'ID' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Shift 'ID', pending reduce 341
parser: Return. Stack=[create_table LP columnlist COMMA nm ID]
parser: Input 'COMMA' with pending reduce 341
parser: Reduce 341 [typename ::= ID|STRING], go to state 192.
parser: ... then shift 'typename', go to state 392
parser: Reduce 340 [typetoken ::= typename], go to state 192.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'ID' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Shift 'ID', pending reduce 341
parser: Return. Stack=[create_table LP columnlist COMMA nm ID]
parser: Input 'RP' with pending reduce 341
parser: Reduce 341 [typename ::= ID|STRING], go to state 192.
parser: ... then shift 'typename', go to state 392
parser: Reduce 340 [typetoken ::= typename], go to state 192.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Reduce 61 [conslist_opt ::=].
parser: ... then shift 'conslist_opt', go to state 540
parser: Shift 'RP', go to state 364
parser: Return. Stack=[create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 364
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: ... then shift 'create_table_args', pending reduce 334
parser: Reduce 334 [cmd ::= create_table create_table_args], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT*FROM"temp".sqlite_temp_master ORDER BY rowid]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'STAR' in state 288
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 95 [sclp ::=].
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STAR', pending reduce 97
parser: Return. Stack=[SELECT distinct sclp scanpt STAR]
parser: Input 'FROM' with pending reduce 97
parser: Reduce 97 [selcollist ::= sclp scanpt STAR], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 104 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'DOT' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 350
parser: Shift 'DOT', go to state 245
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID' in state 245
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'ORDER' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 245.
parser: ... then shift 'nm', pending reduce 110
parser: Reduce 110 [dbnm ::= DOT nm], go to state 350.
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 123 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 349
parser: Reduce 122 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 348
parser: Reduce 127 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 105
parser: Reduce 105 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 102 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 363
parser: Reduce 147 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 362
parser: Reduce 138 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 361
parser: Reduce 140 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 517
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 517
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 419
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 134 [sortorder ::=].
parser: ... then shift 'sortorder', go to state 353
parser: Reduce 137 [nulls ::=].
parser: ... then shift 'nulls', pending reduce 131
parser: Reduce 131 [sortlist ::= expr sortorder nulls], go to state 26.
parser: ... then shift 'sortlist', go to state 516
parser: Reduce 129 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 360
parser: Reduce 142 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 88
parser: Reduce 88 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 83 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 80
parser: Reduce 80 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
VDBE Trace:
   0 Init             0   13    0               00 Start at 13
  13 Transaction      1    0    0 3             00 usesStmtJournal=0
  14 Goto             0    1    0               00 
   1 Noop             1    7    0               00 
   2 OpenRead         0    1    1 5             00 root=1 iDb=1; sqlite_temp_master
   3 Explain          3    0    0 SCAN TABLE sqlite_temp_master 00 
   4 Rewind           0   12    0               00 
  12 Halt             0    0    0               00 
  36 Halt             0    0    0               00 
parser: [[[CREATE INDEX c ON a(b)
;CREATE INDEX v1 ON a(b)
;ALTER TABLE ex ADD v2
    
;CREATE TABLE tr1(t1a, t1b);;SELECT y, v2 FROM x, ex WHERE y>v2;;
;SELECT DISTINCT b FROM a LEFT JOIN ex ON b=v2 ORDER BY +v2;CREATE INDEX x1 ON a(b)
;CREATE INDEX z ON a(b)
;CREATE INDEX example ON ex(v2)
;;SELECT count(*) FROM sqlite_master WHERE tbl_name = 'e' AND type = 'index';;
;CREATE TABLE example_idx_00000042(id PRIMARY KEY, UNIQUE(id) );;BEGIN;;CREATE UNIQUE INDEX IF NOT EXISTS a_id ON a(b==0);;SELECT * FROM ex;]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'INDEX' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 225 [uniqueflag ::=].
parser: ... then shift 'uniqueflag', go to state 456
parser: Shift 'INDEX', go to state 315
parser: Return. Stack=[createkw uniqueflag INDEX]
parser: Input 'ID' in state 315
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 225
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists ID]
parser: Input 'ON' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 225.
parser: ... then shift 'nm', go to state 314
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 455
parser: Shift 'ON', go to state 224
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON]
parser: Input 'ID' in state 224
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON ID]
parser: Input 'LP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 224.
parser: ... then shift 'nm', go to state 454
parser: Shift 'LP', go to state 18
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP]
parser: Input 'ID' in state 18
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP ID]
parser: Input 'RP' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 18.
parser: ... then shift 'expr', go to state 13
parser: Reduce 134 [sortorder ::=].
parser: ... then shift 'sortorder', go to state 353
parser: Reduce 137 [nulls ::=].
parser: ... then shift 'nulls', pending reduce 131
parser: Reduce 131 [sortlist ::= expr sortorder nulls], go to state 18.
parser: ... then shift 'sortlist', go to state 402
parser: Shift 'RP', go to state 313
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP]
parser: Input 'SEMI' in state 313
parser: Reduce 147 [where_opt ::=].
parser: ... then shift 'where_opt', pending reduce 223
parser: Reduce 223 [cmd ::= createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP where_opt], go to state 0.
parser: [[[INSERT INTO 'main'.sqlite_master VALUES('index','c','a',#1,'CREATE INDEX c ON a(b)
');]]]
parser: Input 'INSERT' in state 0
parser: Reduce 380 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'INSERT', go to state 311
parser: Return. Stack=[with INSERT]
parser: Input 'INTO' in state 311
parser: Reduce 71 [orconf ::=].
parser: ... then shift 'orconf', pending reduce 160
parser: Reduce 160 [insert_cmd ::= INSERT orconf], go to state 219.
parser: ... then shift 'insert_cmd', go to state 430
parser: Shift 'INTO', go to state 166
parser: Return. Stack=[with insert_cmd INTO]
parser: Input 'STRING' in state 166
parser: Shift 'STRING', pending reduce 338
parser: Return. Stack=[with insert_cmd INTO STRING]
parser: Input 'DOT' with pending reduce 338
parser: Reduce 338 [nm ::= STRING], go to state 166.
parser: ... then shift 'nm', go to state 395
parser: Shift 'DOT', go to state 218
parser: Return. Stack=[with insert_cmd INTO nm DOT]
parser: Input 'ID' in state 218
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[with insert_cmd INTO nm DOT ID]
parser: Input 'VALUES' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 218.
parser: ... then shift 'nm', go to state 432
parser: Reduce 114 [xfullname ::= nm DOT nm], go to state 166.
parser: ... then shift 'xfullname', go to state 298
parser: Reduce 162 [idlist_opt ::=].
parser: ... then shift 'idlist_opt', go to state 35
parser: Shift 'VALUES', go to state 528
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES]
parser: Input 'LP' in state 528
parser: Shift 'LP', go to state 28
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP]
parser: Input 'STRING' in state 28
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP STRING]
parser: Input 'COMMA' in state 539
parser: Reduce 172 [term ::= STRING], go to state 28.
parser: ... then shift 'term', go to state 70
parser: Reduce 220 [nexprlist ::= expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 413
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'STRING' in state 107
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA STRING]
parser: Input 'COMMA' in state 539
parser: Reduce 172 [term ::= STRING], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 219 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 413
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'STRING' in state 107
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA STRING]
parser: Input 'COMMA' in state 539
parser: Reduce 172 [term ::= STRING], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 219 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 413
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'VARIABLE' in state 107
parser: Shift 'VARIABLE', pending reduce 174
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA VARIABLE]
parser: Input 'COMMA' with pending reduce 174
parser: Reduce 174 [expr ::= VARIABLE], go to state 107.
parser: ... then shift 'expr', go to state 71
parser: Reduce 219 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 413
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'STRING' in state 107
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA STRING]
parser: Input 'RP' in state 539
parser: Reduce 172 [term ::= STRING], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 219 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 413
parser: Shift 'RP', pending reduce 90
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist RP]
parser: Input 'SEMI' with pending reduce 90
parser: Reduce 90 [values ::= VALUES LP nexprlist RP], go to state 35.
parser: ... then shift 'values', go to state 534
parser: Reduce 354 [oneselect ::= values], go to state 35.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 83 [select ::= selectnowith], go to state 35.
parser: ... then shift 'select', go to state 297
parser: Reduce 156 [upsert ::=].
parser: ... then shift 'upsert', pending reduce 154
parser: Reduce 154 [cmd ::= with insert_cmd INTO xfullname idlist_opt select upsert], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Input '$' with pending reduce 327
parser: Reduce 327 [ecmd ::= cmdx SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 323 [input ::= cmdlist], go to state 0.
parser: ... then shift 'input', pending reduce -2
parser: Accept!
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
SQL: [CREATE INDEX c ON a(b)
;]
VDBE Trace:
   0 Init             0   32    0               00 Start at 32
  32 Transaction      0    1    9 3             01 usesStmtJournal=1
  33 Goto             0    1    0               00 
   1 Noop             0   31    0               00 
   2 CreateBtree      0    1    2               00 r[1]=root iDb=0 flags=2
REG[1] =  i:6
   3 OpenWrite        0    1    0 5             00 root=1 iDb=0; sqlite_master
   4 NewRowid         0    2    0               00 r[2]=rowid
REG[2] =  i:7
   5 String8          0    3    0 index         00 r[3]='index'
REG[3] =   t5[index](8)
   6 String8          0    4    0 c             00 r[4]='c'
REG[4] =   t1[c](8)
   7 String8          0    5    0 a             00 r[5]='a'
REG[5] =   t1[a](8)
   8 Copy             1    6    0               00 r[6]=r[1]
REG[6] =  i:6
   9 String8          0    7    0 CREATE INDEX c ON a(b)
 00 r[7]='CREATE INDEX c ON a(b)
'
REG[7] =   t23[CREATE INDEX c ON a(b).](8)
  10 MakeRecord       3    5    8 BBBDB         00 r[8]=mkrec(r[3..7])
REG[3] =   t5[index](8)
REG[4] =   t1[c](8)
REG[5] =   t1[a](8)
REG[6] =  i:6
REG[7] =   t23[CREATE INDEX c ON a(b).](8)
REG[8] =  sx37[06170F0F013B696E64657863610643524541544520494E4445|.....;indexca.CREATE INDE]
  11 Insert           0    8    2               18 intkey=r[2] data=r[8]
REG[8] =  sx37[06170F0F013B696E64657863610643524541544520494E4445|.....;indexca.CREATE INDE]
REG[2] =  i:7
  12 SorterOpen       3    0    1 k(1,)         00 
  13 OpenRead         1    2    0 k(1,)         00 root=2 iDb=0; a
  14 Rewind           1   19    0               00 
  15 Column           1    0   10               00 r[10]=a.b
REG[10] =  i:1
  16 MakeRecord      10    1    9               00 r[9]=mkrec(r[10])
REG[9] =  sx2[0209|..]
  17 SorterInsert     3    9    0               00 key=r[9]
REG[9] =  sx2[0209|..]
  18 Next             1   15    0               00 
  15 Column           1    0   10               00 r[10]=a.b
REG[10] =  i:2
  16 MakeRecord      10    1    9               00 r[9]=mkrec(r[10])
REG[9] =  sx3[020102|...]
  17 SorterInsert     3    9    0               00 key=r[9]
REG[9] =  sx3[020102|...]
  18 Next             1   15    0               00 
  15 Column           1    0   10               00 r[10]=a.b
REG[10] =  i:3
  16 MakeRecord      10    1    9               00 r[9]=mkrec(r[10])
REG[9] =  sx3[020103|...]
  17 SorterInsert     3    9    0               00 key=r[9]
REG[9] =  sx3[020103|...]
  18 Next             1   15    0               00 
  15 Column           1    0   10               00 r[10]=a.b
REG[10] =  i:4
  16 MakeRecord      10    1    9               00 r[9]=mkrec(r[10])
REG[9] =  sx3[020104|...]
  17 SorterInsert     3    9    0               00 key=r[9]
REG[9] =  sx3[020104|...]
  18 Next             1   15    0               00 
  15 Column           1    0   10               00 r[10]=a.b
REG[10] =  i:5
  16 MakeRecord      10    1    9               00 r[9]=mkrec(r[10])
REG[9] =  sx3[020105|...]
  17 SorterInsert     3    9    0               00 key=r[9]
REG[9] =  sx3[020105|...]
  18 Next             1   15    0               00 
  15 Column           1    0   10               00 r[10]=a.b
REG[10] =  i:6
  16 MakeRecord      10    1    9               00 r[9]=mkrec(r[10])
REG[9] =  sx3[020106|...]
  17 SorterInsert     3    9    0               00 key=r[9]
REG[9] =  sx3[020106|...]
  18 Next             1   15    0               00 
  15 Column           1    0   10               00 r[10]=a.b
REG[10] =  i:7
  16 MakeRecord      10    1    9               00 r[9]=mkrec(r[10])
REG[9] =  sx3[020107|...]
  17 SorterInsert     3    9    0               00 key=r[9]
REG[9] =  sx3[020107|...]
  18 Next             1   15    0               00 
  15 Column           1    0   10               00 r[10]=a.b
REG[10] =  i:8
  16 MakeRecord      10    1    9               00 r[9]=mkrec(r[10])
REG[9] =  sx3[020108|...]
  17 SorterInsert     3    9    0               00 key=r[9]
REG[9] =  sx3[020108|...]
  18 Next             1   15    0               00 
  15 Column           1    0   10               00 r[10]=a.b
REG[10] =  i:9
  16 MakeRecord      10    1    9               00 r[9]=mkrec(r[10])
REG[9] =  sx3[020109|...]
  17 SorterInsert     3    9    0               00 key=r[9]
REG[9] =  sx3[020109|...]
  18 Next             1   15    0               00 
  19 OpenWrite        2    1    0 k(1,)         11 root=1 iDb=0
  20 SorterSort       3   25    0               00 
  21 SorterData       3    9    2               00 r[9]=data
  22 SeekEnd          2    0    0               00 
  23 IdxInsert        2    9    0               10 key=r[9]
REG[9] =  sx2[0209|..]
  24 SorterNext       3   21    0               00 
  21 SorterData       3    9    2               00 r[9]=data
  22 SeekEnd          2    0    0               00 
  23 IdxInsert        2    9    0               10 key=r[9]
REG[9] =  sx3[020102|...]
  24 SorterNext       3   21    0               00 
  21 SorterData       3    9    2               00 r[9]=data
  22 SeekEnd          2    0    0               00 
  23 IdxInsert        2    9    0               10 key=r[9]
REG[9] =  sx3[020103|...]
  24 SorterNext       3   21    0               00 
  21 SorterData       3    9    2               00 r[9]=data
  22 SeekEnd          2    0    0               00 
  23 IdxInsert        2    9    0               10 key=r[9]
REG[9] =  sx3[020104|...]
  24 SorterNext       3   21    0               00 
  21 SorterData       3    9    2               00 r[9]=data
  22 SeekEnd          2    0    0               00 
  23 IdxInsert        2    9    0               10 key=r[9]
REG[9] =  sx3[020105|...]
  24 SorterNext       3   21    0               00 
  21 SorterData       3    9    2               00 r[9]=data
  22 SeekEnd          2    0    0               00 
  23 IdxInsert        2    9    0               10 key=r[9]
REG[9] =  sx3[020106|...]
  24 SorterNext       3   21    0               00 
  21 SorterData       3    9    2               00 r[9]=data
  22 SeekEnd          2    0    0               00 
  23 IdxInsert        2    9    0               10 key=r[9]
REG[9] =  sx3[020107|...]
  24 SorterNext       3   21    0               00 
  21 SorterData       3    9    2               00 r[9]=data
  22 SeekEnd          2    0    0               00 
  23 IdxInsert        2    9    0               10 key=r[9]
REG[9] =  sx3[020108|...]
  24 SorterNext       3   21    0               00 
  21 SorterData       3    9    2               00 r[9]=data
  22 SeekEnd          2    0    0               00 
  23 IdxInsert        2    9    0               10 key=r[9]
REG[9] =  sx3[020109|...]
  24 SorterNext       3   21    0               00 
  25 Close            1    0    0               00 
  26 Close            2    0    0               00 
  27 Close            3    0    0               00 
  28 SetCookie        0    1   10               00 
  29 ParseSchema      0    0    0 name='c' AND type='index' 00 
parser: [[[SELECT*FROM"main".sqlite_master WHERE name='c' AND type='index' ORDER BY rowid]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'STAR' in state 288
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 95 [sclp ::=].
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STAR', pending reduce 97
parser: Return. Stack=[SELECT distinct sclp scanpt STAR]
parser: Input 'FROM' with pending reduce 97
parser: Reduce 97 [selcollist ::= sclp scanpt STAR], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 104 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'DOT' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 350
parser: Shift 'DOT', go to state 245
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID' in state 245
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'WHERE' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 245.
parser: ... then shift 'nm', pending reduce 110
parser: Reduce 110 [dbnm ::= DOT nm], go to state 350.
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 123 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 349
parser: Reduce 122 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 348
parser: Reduce 127 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 105
parser: Reduce 105 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 102 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 363
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[SELECT distinct selcollist from WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 419
parser: Return. Stack=[SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr EQ STRING]
parser: Input 'AND' in state 539
parser: Reduce 172 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 186 [expr ::= expr EQ|NE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'AND', go to state 120
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID' in state 120
parser: Shift 'ID', go to state 419
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'EQ' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr EQ]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr EQ STRING]
parser: Input 'ORDER' in state 539
parser: Reduce 172 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 186 [expr ::= expr EQ|NE expr], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Reduce 183 [expr ::= expr AND expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 148 [where_opt ::= WHERE expr], go to state 363.
parser: ... then shift 'where_opt', go to state 362
parser: Reduce 138 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 361
parser: Reduce 140 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 517
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 517
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 419
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 134 [sortorder ::=].
parser: ... then shift 'sortorder', go to state 353
parser: Reduce 137 [nulls ::=].
parser: ... then shift 'nulls', pending reduce 131
parser: Reduce 131 [sortlist ::= expr sortorder nulls], go to state 26.
parser: ... then shift 'sortlist', go to state 516
parser: Reduce 129 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 360
parser: Reduce 142 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 88
parser: Reduce 88 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 83 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 80
parser: Reduce 80 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
VDBE Trace:
   0 Init             0   17    0               00 Start at 17
  17 Transaction      0    0   10 3             00 usesStmtJournal=0
  18 String8          0    2    0 c             00 r[2]='c'
REG[2] =   t1[c](8)
  19 String8          0    3    0 index         00 r[3]='index'
REG[3] =   t5[index](8)
  20 Goto             0    1    0               00 
   1 Noop             1    7    0               00 
   2 OpenRead         0    1    0 5             00 root=1 iDb=0; sqlite_master
   3 Explain          3    0    0 SCAN TABLE sqlite_master 00 
   4 Rewind           0   16    0               00 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s1[a](8)
   6 Ne               2   15    1 (BINARY)      52 if r[1]!=r[2] goto 15
REG[2] =   t1[c](8)
REG[1] =   s1[a](8)
  15 Next             0    5    0               01 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s2[ex](8)
   6 Ne               2   15    1 (BINARY)      52 if r[1]!=r[2] goto 15
REG[2] =   t1[c](8)
REG[1] =   s2[ex](8)
  15 Next             0    5    0               01 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s2[i2](8)
   6 Ne               2   15    1 (BINARY)      52 if r[1]!=r[2] goto 15
REG[2] =   t1[c](8)
REG[1] =   s2[i2](8)
  15 Next             0    5    0               01 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s2[t1](8)
   6 Ne               2   15    1 (BINARY)      52 if r[1]!=r[2] goto 15
REG[2] =   t1[c](8)
REG[1] =   s2[t1](8)
  15 Next             0    5    0               01 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s2[t2](8)
   6 Ne               2   15    1 (BINARY)      52 if r[1]!=r[2] goto 15
REG[2] =   t1[c](8)
REG[1] =   s2[t2](8)
  15 Next             0    5    0               01 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s1[x](8)
   6 Ne               2   15    1 (BINARY)      52 if r[1]!=r[2] goto 15
REG[2] =   t1[c](8)
REG[1] =   s1[x](8)
  15 Next             0    5    0               01 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s1[c](8)
   6 Ne               2   15    1 (BINARY)      52 if r[1]!=r[2] goto 15
REG[2] =   t1[c](8)
REG[1] =   s1[c](8)
   7 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s5[index](8)
   8 Ne               3   15    1 (BINARY)      52 if r[1]!=r[3] goto 15
REG[3] =   t5[index](8)
REG[1] =   s5[index](8)
   9 Column           0    0    4               00 r[4]=sqlite_master.type
REG[4] =   s5[index](8)
  10 Column           0    1    5               00 r[5]=sqlite_master.name
REG[5] =   s1[c](8)
  11 Column           0    2    6               00 r[6]=sqlite_master.tbl_name
REG[6] =   s1[a](8)
  12 Column           0    3    7               00 r[7]=sqlite_master.rootpage
REG[7] =  i:6
  13 Column           0    4    8               00 r[8]=sqlite_master.sql
REG[8] =   s23[CREATE INDEX c ON a(b).](8)
  14 ResultRow        4    5    0               00 output=r[4..8]
REG[4] =   s5[index](8)
REG[5] =   s1[c](8)
REG[6] =   s1[a](8)
REG[7] =  i:6
REG[8] =   s23[CREATE INDEX c ON a(b).](8)
parser: [[[CREATE INDEX c ON a(b)
]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'INDEX' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 225 [uniqueflag ::=].
parser: ... then shift 'uniqueflag', go to state 456
parser: Shift 'INDEX', go to state 315
parser: Return. Stack=[createkw uniqueflag INDEX]
parser: Input 'ID' in state 315
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 225
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists ID]
parser: Input 'ON' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 225.
parser: ... then shift 'nm', go to state 314
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 455
parser: Shift 'ON', go to state 224
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON]
parser: Input 'ID' in state 224
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON ID]
parser: Input 'LP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 224.
parser: ... then shift 'nm', go to state 454
parser: Shift 'LP', go to state 18
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP]
parser: Input 'ID' in state 18
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP ID]
parser: Input 'RP' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 18.
parser: ... then shift 'expr', go to state 13
parser: Reduce 134 [sortorder ::=].
parser: ... then shift 'sortorder', go to state 353
parser: Reduce 137 [nulls ::=].
parser: ... then shift 'nulls', pending reduce 131
parser: Reduce 131 [sortlist ::= expr sortorder nulls], go to state 18.
parser: ... then shift 'sortlist', go to state 402
parser: Shift 'RP', go to state 313
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP]
parser: Input 'SEMI' in state 313
parser: Reduce 147 [where_opt ::=].
parser: ... then shift 'where_opt', pending reduce 223
parser: Reduce 223 [cmd ::= createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP where_opt], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
  15 Next             0    5    0               01 
  16 Halt             0    0    0               00 
  30 Expire           0    1    0               00 
  31 Halt             0    0    0               00 
parser: [[[CREATE INDEX v1 ON a(b)
;ALTER TABLE ex ADD v2
    
;CREATE TABLE tr1(t1a, t1b);;SELECT y, v2 FROM x, ex WHERE y>v2;;
;SELECT DISTINCT b FROM a LEFT JOIN ex ON b=v2 ORDER BY +v2;CREATE INDEX x1 ON a(b)
;CREATE INDEX z ON a(b)
;CREATE INDEX example ON ex(v2)
;;SELECT count(*) FROM sqlite_master WHERE tbl_name = 'e' AND type = 'index';;
;CREATE TABLE example_idx_00000042(id PRIMARY KEY, UNIQUE(id) );;BEGIN;;CREATE UNIQUE INDEX IF NOT EXISTS a_id ON a(b==0);;SELECT * FROM ex;]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'INDEX' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 225 [uniqueflag ::=].
parser: ... then shift 'uniqueflag', go to state 456
parser: Shift 'INDEX', go to state 315
parser: Return. Stack=[createkw uniqueflag INDEX]
parser: Input 'ID' in state 315
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 225
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists ID]
parser: Input 'ON' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 225.
parser: ... then shift 'nm', go to state 314
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 455
parser: Shift 'ON', go to state 224
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON]
parser: Input 'ID' in state 224
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON ID]
parser: Input 'LP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 224.
parser: ... then shift 'nm', go to state 454
parser: Shift 'LP', go to state 18
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP]
parser: Input 'ID' in state 18
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP ID]
parser: Input 'RP' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 18.
parser: ... then shift 'expr', go to state 13
parser: Reduce 134 [sortorder ::=].
parser: ... then shift 'sortorder', go to state 353
parser: Reduce 137 [nulls ::=].
parser: ... then shift 'nulls', pending reduce 131
parser: Reduce 131 [sortlist ::= expr sortorder nulls], go to state 18.
parser: ... then shift 'sortlist', go to state 402
parser: Shift 'RP', go to state 313
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP]
parser: Input 'SEMI' in state 313
parser: Reduce 147 [where_opt ::=].
parser: ... then shift 'where_opt', pending reduce 223
parser: Reduce 223 [cmd ::= createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP where_opt], go to state 0.
parser: [[[INSERT INTO 'main'.sqlite_master VALUES('index','v1','a',#1,'CREATE INDEX v1 ON a(b)
');]]]
parser: Input 'INSERT' in state 0
parser: Reduce 380 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'INSERT', go to state 311
parser: Return. Stack=[with INSERT]
parser: Input 'INTO' in state 311
parser: Reduce 71 [orconf ::=].
parser: ... then shift 'orconf', pending reduce 160
parser: Reduce 160 [insert_cmd ::= INSERT orconf], go to state 219.
parser: ... then shift 'insert_cmd', go to state 430
parser: Shift 'INTO', go to state 166
parser: Return. Stack=[with insert_cmd INTO]
parser: Input 'STRING' in state 166
parser: Shift 'STRING', pending reduce 338
parser: Return. Stack=[with insert_cmd INTO STRING]
parser: Input 'DOT' with pending reduce 338
parser: Reduce 338 [nm ::= STRING], go to state 166.
parser: ... then shift 'nm', go to state 395
parser: Shift 'DOT', go to state 218
parser: Return. Stack=[with insert_cmd INTO nm DOT]
parser: Input 'ID' in state 218
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[with insert_cmd INTO nm DOT ID]
parser: Input 'VALUES' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 218.
parser: ... then shift 'nm', go to state 432
parser: Reduce 114 [xfullname ::= nm DOT nm], go to state 166.
parser: ... then shift 'xfullname', go to state 298
parser: Reduce 162 [idlist_opt ::=].
parser: ... then shift 'idlist_opt', go to state 35
parser: Shift 'VALUES', go to state 528
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES]
parser: Input 'LP' in state 528
parser: Shift 'LP', go to state 28
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP]
parser: Input 'STRING' in state 28
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP STRING]
parser: Input 'COMMA' in state 539
parser: Reduce 172 [term ::= STRING], go to state 28.
parser: ... then shift 'term', go to state 70
parser: Reduce 220 [nexprlist ::= expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 413
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'STRING' in state 107
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA STRING]
parser: Input 'COMMA' in state 539
parser: Reduce 172 [term ::= STRING], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 219 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 413
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'STRING' in state 107
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA STRING]
parser: Input 'COMMA' in state 539
parser: Reduce 172 [term ::= STRING], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 219 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 413
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'VARIABLE' in state 107
parser: Shift 'VARIABLE', pending reduce 174
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA VARIABLE]
parser: Input 'COMMA' with pending reduce 174
parser: Reduce 174 [expr ::= VARIABLE], go to state 107.
parser: ... then shift 'expr', go to state 71
parser: Reduce 219 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 413
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'STRING' in state 107
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA STRING]
parser: Input 'RP' in state 539
parser: Reduce 172 [term ::= STRING], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 219 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 413
parser: Shift 'RP', pending reduce 90
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist RP]
parser: Input 'SEMI' with pending reduce 90
parser: Reduce 90 [values ::= VALUES LP nexprlist RP], go to state 35.
parser: ... then shift 'values', go to state 534
parser: Reduce 354 [oneselect ::= values], go to state 35.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 83 [select ::= selectnowith], go to state 35.
parser: ... then shift 'select', go to state 297
parser: Reduce 156 [upsert ::=].
parser: ... then shift 'upsert', pending reduce 154
parser: Reduce 154 [cmd ::= with insert_cmd INTO xfullname idlist_opt select upsert], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Input '$' with pending reduce 327
parser: Reduce 327 [ecmd ::= cmdx SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 323 [input ::= cmdlist], go to state 0.
parser: ... then shift 'input', pending reduce -2
parser: Accept!
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
SQL: [CREATE INDEX v1 ON a(b)
;]
VDBE Trace:
   0 Init             0   32    0               00 Start at 32
  32 Transaction      0    1   10 3             01 usesStmtJournal=1
  33 Goto             0    1    0               00 
   1 Noop             0   31    0               00 
   2 CreateBtree      0    1    2               00 r[1]=root iDb=0 flags=2
REG[1] =  i:7
   3 OpenWrite        0    1    0 5             00 root=1 iDb=0; sqlite_master
   4 NewRowid         0    2    0               00 r[2]=rowid
REG[2] =  i:8
   5 String8          0    3    0 index         00 r[3]='index'
REG[3] =   t5[index](8)
   6 String8          0    4    0 v1            00 r[4]='v1'
REG[4] =   t2[v1](8)
   7 String8          0    5    0 a             00 r[5]='a'
REG[5] =   t1[a](8)
   8 Copy             1    6    0               00 r[6]=r[1]
REG[6] =  i:7
   9 String8          0    7    0 CREATE INDEX v1 ON a(b)
 00 r[7]='CREATE INDEX v1 ON a(b)
'
REG[7] =   t24[CREATE INDEX v1 ON a(b).](8)
  10 MakeRecord       3    5    8 BBBDB         00 r[8]=mkrec(r[3..7])
REG[3] =   t5[index](8)
REG[4] =   t2[v1](8)
REG[5] =   t1[a](8)
REG[6] =  i:7
REG[7] =   t24[CREATE INDEX v1 ON a(b).](8)
REG[8] =  sx39[0617110F013D696E6465787631610743524541544520494E44|.....=indexv1a.CREATE IND]
  11 Insert           0    8    2               18 intkey=r[2] data=r[8]
REG[8] =  sx39[0617110F013D696E6465787631610743524541544520494E44|.....=indexv1a.CREATE IND]
REG[2] =  i:8
  12 SorterOpen       3    0    1 k(1,)         00 
  13 OpenRead         1    2    0 k(1,)         00 root=2 iDb=0; a
  14 Rewind           1   19    0               00 
  15 Column           1    0   10               00 r[10]=a.b
REG[10] =  i:1
  16 MakeRecord      10    1    9               00 r[9]=mkrec(r[10])
REG[9] =  sx2[0209|..]
  17 SorterInsert     3    9    0               00 key=r[9]
REG[9] =  sx2[0209|..]
  18 Next             1   15    0               00 
  15 Column           1    0   10               00 r[10]=a.b
REG[10] =  i:2
  16 MakeRecord      10    1    9               00 r[9]=mkrec(r[10])
REG[9] =  sx3[020102|...]
  17 SorterInsert     3    9    0               00 key=r[9]
REG[9] =  sx3[020102|...]
  18 Next             1   15    0               00 
  15 Column           1    0   10               00 r[10]=a.b
REG[10] =  i:3
  16 MakeRecord      10    1    9               00 r[9]=mkrec(r[10])
REG[9] =  sx3[020103|...]
  17 SorterInsert     3    9    0               00 key=r[9]
REG[9] =  sx3[020103|...]
  18 Next             1   15    0               00 
  15 Column           1    0   10               00 r[10]=a.b
REG[10] =  i:4
  16 MakeRecord      10    1    9               00 r[9]=mkrec(r[10])
REG[9] =  sx3[020104|...]
  17 SorterInsert     3    9    0               00 key=r[9]
REG[9] =  sx3[020104|...]
  18 Next             1   15    0               00 
  15 Column           1    0   10               00 r[10]=a.b
REG[10] =  i:5
  16 MakeRecord      10    1    9               00 r[9]=mkrec(r[10])
REG[9] =  sx3[020105|...]
  17 SorterInsert     3    9    0               00 key=r[9]
REG[9] =  sx3[020105|...]
  18 Next             1   15    0               00 
  15 Column           1    0   10               00 r[10]=a.b
REG[10] =  i:6
  16 MakeRecord      10    1    9               00 r[9]=mkrec(r[10])
REG[9] =  sx3[020106|...]
  17 SorterInsert     3    9    0               00 key=r[9]
REG[9] =  sx3[020106|...]
  18 Next             1   15    0               00 
  15 Column           1    0   10               00 r[10]=a.b
REG[10] =  i:7
  16 MakeRecord      10    1    9               00 r[9]=mkrec(r[10])
REG[9] =  sx3[020107|...]
  17 SorterInsert     3    9    0               00 key=r[9]
REG[9] =  sx3[020107|...]
  18 Next             1   15    0               00 
  15 Column           1    0   10               00 r[10]=a.b
REG[10] =  i:8
  16 MakeRecord      10    1    9               00 r[9]=mkrec(r[10])
REG[9] =  sx3[020108|...]
  17 SorterInsert     3    9    0               00 key=r[9]
REG[9] =  sx3[020108|...]
  18 Next             1   15    0               00 
  15 Column           1    0   10               00 r[10]=a.b
REG[10] =  i:9
  16 MakeRecord      10    1    9               00 r[9]=mkrec(r[10])
REG[9] =  sx3[020109|...]
  17 SorterInsert     3    9    0               00 key=r[9]
REG[9] =  sx3[020109|...]
  18 Next             1   15    0               00 
  19 OpenWrite        2    1    0 k(1,)         11 root=1 iDb=0
  20 SorterSort       3   25    0               00 
  21 SorterData       3    9    2               00 r[9]=data
  22 SeekEnd          2    0    0               00 
  23 IdxInsert        2    9    0               10 key=r[9]
REG[9] =  sx2[0209|..]
  24 SorterNext       3   21    0               00 
  21 SorterData       3    9    2               00 r[9]=data
  22 SeekEnd          2    0    0               00 
  23 IdxInsert        2    9    0               10 key=r[9]
REG[9] =  sx3[020102|...]
  24 SorterNext       3   21    0               00 
  21 SorterData       3    9    2               00 r[9]=data
  22 SeekEnd          2    0    0               00 
  23 IdxInsert        2    9    0               10 key=r[9]
REG[9] =  sx3[020103|...]
  24 SorterNext       3   21    0               00 
  21 SorterData       3    9    2               00 r[9]=data
  22 SeekEnd          2    0    0               00 
  23 IdxInsert        2    9    0               10 key=r[9]
REG[9] =  sx3[020104|...]
  24 SorterNext       3   21    0               00 
  21 SorterData       3    9    2               00 r[9]=data
  22 SeekEnd          2    0    0               00 
  23 IdxInsert        2    9    0               10 key=r[9]
REG[9] =  sx3[020105|...]
  24 SorterNext       3   21    0               00 
  21 SorterData       3    9    2               00 r[9]=data
  22 SeekEnd          2    0    0               00 
  23 IdxInsert        2    9    0               10 key=r[9]
REG[9] =  sx3[020106|...]
  24 SorterNext       3   21    0               00 
  21 SorterData       3    9    2               00 r[9]=data
  22 SeekEnd          2    0    0               00 
  23 IdxInsert        2    9    0               10 key=r[9]
REG[9] =  sx3[020107|...]
  24 SorterNext       3   21    0               00 
  21 SorterData       3    9    2               00 r[9]=data
  22 SeekEnd          2    0    0               00 
  23 IdxInsert        2    9    0               10 key=r[9]
REG[9] =  sx3[020108|...]
  24 SorterNext       3   21    0               00 
  21 SorterData       3    9    2               00 r[9]=data
  22 SeekEnd          2    0    0               00 
  23 IdxInsert        2    9    0               10 key=r[9]
REG[9] =  sx3[020109|...]
  24 SorterNext       3   21    0               00 
  25 Close            1    0    0               00 
  26 Close            2    0    0               00 
  27 Close            3    0    0               00 
  28 SetCookie        0    1   11               00 
  29 ParseSchema      0    0    0 name='v1' AND type='index' 00 
parser: [[[SELECT*FROM"main".sqlite_master WHERE name='v1' AND type='index' ORDER BY rowid]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'STAR' in state 288
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 95 [sclp ::=].
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STAR', pending reduce 97
parser: Return. Stack=[SELECT distinct sclp scanpt STAR]
parser: Input 'FROM' with pending reduce 97
parser: Reduce 97 [selcollist ::= sclp scanpt STAR], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 104 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'DOT' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 350
parser: Shift 'DOT', go to state 245
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID' in state 245
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'WHERE' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 245.
parser: ... then shift 'nm', pending reduce 110
parser: Reduce 110 [dbnm ::= DOT nm], go to state 350.
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 123 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 349
parser: Reduce 122 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 348
parser: Reduce 127 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 105
parser: Reduce 105 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 102 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 363
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[SELECT distinct selcollist from WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 419
parser: Return. Stack=[SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr EQ STRING]
parser: Input 'AND' in state 539
parser: Reduce 172 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 186 [expr ::= expr EQ|NE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'AND', go to state 120
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID' in state 120
parser: Shift 'ID', go to state 419
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'EQ' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr EQ]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr EQ STRING]
parser: Input 'ORDER' in state 539
parser: Reduce 172 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 186 [expr ::= expr EQ|NE expr], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Reduce 183 [expr ::= expr AND expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 148 [where_opt ::= WHERE expr], go to state 363.
parser: ... then shift 'where_opt', go to state 362
parser: Reduce 138 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 361
parser: Reduce 140 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 517
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 517
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 419
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 134 [sortorder ::=].
parser: ... then shift 'sortorder', go to state 353
parser: Reduce 137 [nulls ::=].
parser: ... then shift 'nulls', pending reduce 131
parser: Reduce 131 [sortlist ::= expr sortorder nulls], go to state 26.
parser: ... then shift 'sortlist', go to state 516
parser: Reduce 129 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 360
parser: Reduce 142 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 88
parser: Reduce 88 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 83 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 80
parser: Reduce 80 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
VDBE Trace:
   0 Init             0   17    0               00 Start at 17
  17 Transaction      0    0   11 3             00 usesStmtJournal=0
  18 String8          0    2    0 v1            00 r[2]='v1'
REG[2] =   t2[v1](8)
  19 String8          0    3    0 index         00 r[3]='index'
REG[3] =   t5[index](8)
  20 Goto             0    1    0               00 
   1 Noop             1    7    0               00 
   2 OpenRead         0    1    0 5             00 root=1 iDb=0; sqlite_master
   3 Explain          3    0    0 SCAN TABLE sqlite_master 00 
   4 Rewind           0   16    0               00 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s1[a](8)
   6 Ne               2   15    1 (BINARY)      52 if r[1]!=r[2] goto 15
REG[2] =   t2[v1](8)
REG[1] =   s1[a](8)
  15 Next             0    5    0               01 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s2[ex](8)
   6 Ne               2   15    1 (BINARY)      52 if r[1]!=r[2] goto 15
REG[2] =   t2[v1](8)
REG[1] =   s2[ex](8)
  15 Next             0    5    0               01 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s2[i2](8)
   6 Ne               2   15    1 (BINARY)      52 if r[1]!=r[2] goto 15
REG[2] =   t2[v1](8)
REG[1] =   s2[i2](8)
  15 Next             0    5    0               01 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s2[t1](8)
   6 Ne               2   15    1 (BINARY)      52 if r[1]!=r[2] goto 15
REG[2] =   t2[v1](8)
REG[1] =   s2[t1](8)
  15 Next             0    5    0               01 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s2[t2](8)
   6 Ne               2   15    1 (BINARY)      52 if r[1]!=r[2] goto 15
REG[2] =   t2[v1](8)
REG[1] =   s2[t2](8)
  15 Next             0    5    0               01 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s1[x](8)
   6 Ne               2   15    1 (BINARY)      52 if r[1]!=r[2] goto 15
REG[2] =   t2[v1](8)
REG[1] =   s1[x](8)
  15 Next             0    5    0               01 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s1[c](8)
   6 Ne               2   15    1 (BINARY)      52 if r[1]!=r[2] goto 15
REG[2] =   t2[v1](8)
REG[1] =   s1[c](8)
  15 Next             0    5    0               01 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s2[v1](8)
   6 Ne               2   15    1 (BINARY)      52 if r[1]!=r[2] goto 15
REG[2] =   t2[v1](8)
REG[1] =   s2[v1](8)
   7 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s5[index](8)
   8 Ne               3   15    1 (BINARY)      52 if r[1]!=r[3] goto 15
REG[3] =   t5[index](8)
REG[1] =   s5[index](8)
   9 Column           0    0    4               00 r[4]=sqlite_master.type
REG[4] =   s5[index](8)
  10 Column           0    1    5               00 r[5]=sqlite_master.name
REG[5] =   s2[v1](8)
  11 Column           0    2    6               00 r[6]=sqlite_master.tbl_name
REG[6] =   s1[a](8)
  12 Column           0    3    7               00 r[7]=sqlite_master.rootpage
REG[7] =  i:7
  13 Column           0    4    8               00 r[8]=sqlite_master.sql
REG[8] =   s24[CREATE INDEX v1 ON a(b).](8)
  14 ResultRow        4    5    0               00 output=r[4..8]
REG[4] =   s5[index](8)
REG[5] =   s2[v1](8)
REG[6] =   s1[a](8)
REG[7] =  i:7
REG[8] =   s24[CREATE INDEX v1 ON a(b).](8)
parser: [[[CREATE INDEX v1 ON a(b)
]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'INDEX' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 225 [uniqueflag ::=].
parser: ... then shift 'uniqueflag', go to state 456
parser: Shift 'INDEX', go to state 315
parser: Return. Stack=[createkw uniqueflag INDEX]
parser: Input 'ID' in state 315
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 225
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists ID]
parser: Input 'ON' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 225.
parser: ... then shift 'nm', go to state 314
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 455
parser: Shift 'ON', go to state 224
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON]
parser: Input 'ID' in state 224
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON ID]
parser: Input 'LP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 224.
parser: ... then shift 'nm', go to state 454
parser: Shift 'LP', go to state 18
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP]
parser: Input 'ID' in state 18
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP ID]
parser: Input 'RP' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 18.
parser: ... then shift 'expr', go to state 13
parser: Reduce 134 [sortorder ::=].
parser: ... then shift 'sortorder', go to state 353
parser: Reduce 137 [nulls ::=].
parser: ... then shift 'nulls', pending reduce 131
parser: Reduce 131 [sortlist ::= expr sortorder nulls], go to state 18.
parser: ... then shift 'sortlist', go to state 402
parser: Shift 'RP', go to state 313
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP]
parser: Input 'SEMI' in state 313
parser: Reduce 147 [where_opt ::=].
parser: ... then shift 'where_opt', pending reduce 223
parser: Reduce 223 [cmd ::= createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP where_opt], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
  15 Next             0    5    0               01 
  16 Halt             0    0    0               00 
  30 Expire           0    1    0               00 
  31 Halt             0    0    0               00 
parser: [[[ALTER TABLE ex ADD v2
    
;CREATE TABLE tr1(t1a, t1b);;SELECT y, v2 FROM x, ex WHERE y>v2;;
;SELECT DISTINCT b FROM a LEFT JOIN ex ON b=v2 ORDER BY +v2;CREATE INDEX x1 ON a(b)
;CREATE INDEX z ON a(b)
;CREATE INDEX example ON ex(v2)
;;SELECT count(*) FROM sqlite_master WHERE tbl_name = 'e' AND type = 'index';;
;CREATE TABLE example_idx_00000042(id PRIMARY KEY, UNIQUE(id) );;BEGIN;;CREATE UNIQUE INDEX IF NOT EXISTS a_id ON a(b==0);;SELECT * FROM ex;]]]
parser: Input 'ALTER' in state 0
parser: Shift 'ALTER', go to state 426
parser: Return. Stack=[ALTER]
parser: Input 'TABLE' in state 426
parser: Shift 'TABLE', go to state 133
parser: Return. Stack=[ALTER TABLE]
parser: Input 'ID' in state 133
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[ALTER TABLE ID]
parser: Input 'ADD' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 133.
parser: ... then shift 'nm', go to state 462
parser: Reduce 111 [fullname ::= nm], go to state 133.
parser: ... then shift 'fullname', go to state 425
parser: Reduce 279 [add_column_fullname ::= fullname], go to state 133.
parser: ... then shift 'add_column_fullname', go to state 423
parser: Shift 'ADD', go to state 290
parser: Return. Stack=[ALTER TABLE add_column_fullname ADD]
parser: Input 'ID' in state 290
parser: Reduce 372 [kwcolumn_opt ::=].
parser: ... then shift 'kwcolumn_opt', go to state 165
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[ALTER TABLE add_column_fullname ADD kwcolumn_opt ID]
parser: Input 'SEMI' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 165.
parser: ... then shift 'nm', go to state 192
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 165.
parser: ... then shift 'columnname', go to state 374
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 151
parser: Reduce 278 [cmd ::= ALTER TABLE add_column_fullname ADD kwcolumn_opt columnname carglist], go to state 0.
parser: [[[UPDATE "main".sqlite_master SET sql = substr(sql,1,18) || ', ' || 'v2' || substr(sql,19) WHERE type = 'table' AND name = 'ex']]]
parser: Input 'UPDATE' in state 0
parser: Reduce 380 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'UPDATE', go to state 299
parser: Return. Stack=[with UPDATE]
parser: Input 'ID' in state 299
parser: Reduce 71 [orconf ::=].
parser: ... then shift 'orconf', go to state 167
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[with UPDATE orconf ID]
parser: Input 'DOT' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 167.
parser: ... then shift 'nm', go to state 395
parser: Shift 'DOT', go to state 218
parser: Return. Stack=[with UPDATE orconf nm DOT]
parser: Input 'ID' in state 218
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[with UPDATE orconf nm DOT ID]
parser: Input 'SET' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 218.
parser: ... then shift 'nm', go to state 432
parser: Reduce 114 [xfullname ::= nm DOT nm], go to state 167.
parser: ... then shift 'xfullname', go to state 271
parser: Reduce 123 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 431
parser: Shift 'SET', go to state 155
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET]
parser: Input 'ID' in state 155
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET ID]
parser: Input 'EQ' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 155.
parser: ... then shift 'nm', go to state 445
parser: Shift 'EQ', go to state 84
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ]
parser: Input 'ID' in state 84
parser: Shift 'ID', go to state 419
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ ID]
parser: Input 'LP' in state 419
parser: Shift 'LP', go to state 266
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ ID LP]
parser: Input 'ID' in state 266
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 419
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ ID LP distinct ID]
parser: Input 'COMMA' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 220 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 519
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ ID LP distinct nexprlist COMMA]
parser: Input 'INTEGER' in state 107
parser: Shift 'INTEGER', pending reduce 173
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ ID LP distinct nexprlist COMMA INTEGER]
parser: Input 'COMMA' with pending reduce 173
parser: Reduce 173 [term ::= INTEGER], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 219 [nexprlist ::= nexprlist COMMA expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 519
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ ID LP distinct nexprlist COMMA]
parser: Input 'INTEGER' in state 107
parser: Shift 'INTEGER', pending reduce 173
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ ID LP distinct nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 173
parser: Reduce 173 [term ::= INTEGER], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 219 [nexprlist ::= nexprlist COMMA expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 519
parser: Reduce 359 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 484
parser: Shift 'RP', go to state 146
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ ID LP distinct exprlist RP]
parser: Input 'CONCAT' in state 146
parser: Reduce 177 [expr ::= ID|INDEXED LP distinct exprlist RP], go to state 84.
parser: ... then shift 'expr', go to state 58
parser: Shift 'CONCAT', go to state 113
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ expr CONCAT]
parser: Input 'STRING' in state 113
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ expr CONCAT STRING]
parser: Input 'CONCAT' in state 539
parser: Reduce 172 [term ::= STRING], go to state 113.
parser: ... then shift 'term', go to state 148
parser: Reduce 190 [expr ::= expr CONCAT expr], go to state 84.
parser: ... then shift 'expr', go to state 58
parser: Shift 'CONCAT', go to state 113
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ expr CONCAT]
parser: Input 'STRING' in state 113
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ expr CONCAT STRING]
parser: Input 'CONCAT' in state 539
parser: Reduce 172 [term ::= STRING], go to state 113.
parser: ... then shift 'term', go to state 148
parser: Reduce 190 [expr ::= expr CONCAT expr], go to state 84.
parser: ... then shift 'expr', go to state 58
parser: Shift 'CONCAT', go to state 113
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ expr CONCAT]
parser: Input 'ID' in state 113
parser: Shift 'ID', go to state 419
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ expr CONCAT ID]
parser: Input 'LP' in state 419
parser: Shift 'LP', go to state 266
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ expr CONCAT ID LP]
parser: Input 'ID' in state 266
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 419
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ expr CONCAT ID LP distinct ID]
parser: Input 'COMMA' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 220 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 519
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ expr CONCAT ID LP distinct nexprlist COMMA]
parser: Input 'INTEGER' in state 107
parser: Shift 'INTEGER', pending reduce 173
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ expr CONCAT ID LP distinct nexprlist COMMA INTEGER]
parser: Input 'RP' with pending reduce 173
parser: Reduce 173 [term ::= INTEGER], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 219 [nexprlist ::= nexprlist COMMA expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 519
parser: Reduce 359 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 484
parser: Shift 'RP', go to state 146
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ expr CONCAT ID LP distinct exprlist RP]
parser: Input 'WHERE' in state 146
parser: Reduce 177 [expr ::= ID|INDEXED LP distinct exprlist RP], go to state 113.
parser: ... then shift 'expr', go to state 148
parser: Reduce 190 [expr ::= expr CONCAT expr], go to state 84.
parser: ... then shift 'expr', go to state 58
parser: Reduce 152 [setlist ::= nm EQ expr], go to state 155.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 419
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE ID]
parser: Input 'EQ' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr EQ]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr EQ STRING]
parser: Input 'AND' in state 539
parser: Reduce 172 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 186 [expr ::= expr EQ|NE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'AND', go to state 120
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr AND]
parser: Input 'ID' in state 120
parser: Shift 'ID', go to state 419
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr AND ID]
parser: Input 'EQ' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr AND expr EQ]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr AND expr EQ STRING]
parser: Input 'SEMI' in state 539
parser: Reduce 172 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 186 [expr ::= expr EQ|NE expr], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Reduce 183 [expr ::= expr AND expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 148 [where_opt ::= WHERE expr], go to state 270.
parser: ... then shift 'where_opt', pending reduce 149
parser: Reduce 149 [cmd ::= with UPDATE orconf xfullname indexed_opt SET setlist where_opt], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Input '$' with pending reduce 327
parser: Reduce 327 [ecmd ::= cmdx SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 323 [input ::= cmdlist], go to state 0.
parser: ... then shift 'input', pending reduce -2
parser: Accept!
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
SQL: [ALTER TABLE ex ADD v2
    
;]
VDBE Trace:
   0 Init             0   37    0               00 Start at 37
  37 Transaction      0    1   11 3             01 usesStmtJournal=1
  38 String8          0    9    0 table         00 r[9]='table'
REG[9] =   t5[table](8)
  39 String8          0   10    0 ex            00 r[10]='ex'
REG[10] =   t2[ex](8)
  40 Integer          1   15    0               00 r[15]=1
REG[15] =  i:1
  41 Integer         18   16    0               00 r[16]=18
REG[16] =  i:18
  42 String8          0   17    0 ,             00 r[17]=', '
REG[17] =   t2[, ](8)
  43 String8          0   18    0 v2            00 r[18]='v2'
REG[18] =   t2[v2](8)
  44 Integer         19   20    0               00 r[20]=19
REG[20] =  i:19
  45 Goto             0    1    0               00 
   1 Null             0    1    2               00 r[1..2]=NULL
REG[1] =  NULL
   2 OpenRead         0    1    0 2             00 root=1 iDb=0; sqlite_master
   3 Explain          3    0    0 SCAN TABLE sqlite_master 00 
   4 Rewind           0   12    0               00 
   5 Column           0    0    8               00 r[8]=sqlite_master.type
REG[8] =   s5[table](8)
   6 Ne               9   11    8 (BINARY)      52 if r[8]!=r[9] goto 11
REG[9] =   t5[table](8)
REG[8] =   s5[table](8)
   7 Column           0    1    8               00 r[8]=sqlite_master.name
REG[8] =   s1[a](8)
   8 Ne              10   11    8 (BINARY)      52 if r[8]!=r[10] goto 11
REG[10] =   t2[ex](8)
REG[8] =   s1[a](8)
  11 Next             0    5    0               01 
   5 Column           0    0    8               00 r[8]=sqlite_master.type
REG[8] =   s5[table](8)
   6 Ne               9   11    8 (BINARY)      52 if r[8]!=r[9] goto 11
REG[9] =   t5[table](8)
REG[8] =   s5[table](8)
   7 Column           0    1    8               00 r[8]=sqlite_master.name
REG[8] =   s2[ex](8)
   8 Ne              10   11    8 (BINARY)      52 if r[8]!=r[10] goto 11
REG[10] =   t2[ex](8)
REG[8] =   s2[ex](8)
   9 Rowid            0    2    0               00 r[2]=rowid
REG[2] =  i:2
  10 RowSetAdd        1    2    0               00 rowset(1)=r[2]
REG[1] =  NULL
REG[2] =  i:2
  11 Next             0    5    0               01 
   5 Column           0    0    8               00 r[8]=sqlite_master.type
REG[8] =   s5[index](8)
   6 Ne               9   11    8 (BINARY)      52 if r[8]!=r[9] goto 11
REG[9] =   t5[table](8)
REG[8] =   s5[index](8)
  11 Next             0    5    0               01 
   5 Column           0    0    8               00 r[8]=sqlite_master.type
REG[8] =   s4[view](8)
   6 Ne               9   11    8 (BINARY)      52 if r[8]!=r[9] goto 11
REG[9] =   t5[table](8)
REG[8] =   s4[view](8)
  11 Next             0    5    0               01 
   5 Column           0    0    8               00 r[8]=sqlite_master.type
REG[8] =   s4[view](8)
   6 Ne               9   11    8 (BINARY)      52 if r[8]!=r[9] goto 11
REG[9] =   t5[table](8)
REG[8] =   s4[view](8)
  11 Next             0    5    0               01 
   5 Column           0    0    8               00 r[8]=sqlite_master.type
REG[8] =   s5[table](8)
   6 Ne               9   11    8 (BINARY)      52 if r[8]!=r[9] goto 11
REG[9] =   t5[table](8)
REG[8] =   s5[table](8)
   7 Column           0    1    8               00 r[8]=sqlite_master.name
REG[8] =   s1[x](8)
   8 Ne              10   11    8 (BINARY)      52 if r[8]!=r[10] goto 11
REG[10] =   t2[ex](8)
REG[8] =   s1[x](8)
  11 Next             0    5    0               01 
   5 Column           0    0    8               00 r[8]=sqlite_master.type
REG[8] =   s5[index](8)
   6 Ne               9   11    8 (BINARY)      52 if r[8]!=r[9] goto 11
REG[9] =   t5[table](8)
REG[8] =   s5[index](8)
  11 Next             0    5    0               01 
   5 Column           0    0    8               00 r[8]=sqlite_master.type
REG[8] =   s5[index](8)
   6 Ne               9   11    8 (BINARY)      52 if r[8]!=r[9] goto 11
REG[9] =   t5[table](8)
REG[8] =   s5[index](8)
  11 Next             0    5    0               01 
  12 OpenWrite        0    1    0 5             00 root=1 iDb=0; sqlite_master
  13 RowSetRead       1   29    2               00 r[2]=rowset(1)
REG[1] =  (rowset)
REG[2] =  i:2
  14 NotExists        0   13    2               00 intkey=r[2]
REG[2] =  i:2
  15 Column           0    0    3               00 r[3]=sqlite_master.type
REG[3] =   s5[table](8)
  16 Column           0    1    4               00 r[4]=sqlite_master.name
REG[4] =   s2[ex](8)
  17 Column           0    2    5               00 r[5]=sqlite_master.tbl_name
REG[5] =   s2[ex](8)
  18 Column           0    3    6               00 r[6]=sqlite_master.rootpage
REG[6] =  i:3
  19 Column           0    4   14               00 r[14]=sqlite_master.sql
REG[14] =   s19[CREATE TABLE ex(i1)](8)
  20 Function0        6   14   13 substr(3)     03 r[13]=func(r[14..16])
REG[14] =   s19[CREATE TABLE ex(i1)](8)
REG[15] =  i:1
REG[16] =  i:18
REG[13] =   s18[CREATE TABLE ex(i1](8)
  21 Concat          17   13   12               00 r[12]=r[13]+r[17]
REG[17] =   t2[, ](8)
REG[13] =   s18[CREATE TABLE ex(i1](8)
REG[12] =   s20[CREATE TABLE ex(i1, ](8)
  22 Concat          18   12    8               00 r[8]=r[12]+r[18]
REG[18] =   t2[v2](8)
REG[12] =   s20[CREATE TABLE ex(i1, ](8)
REG[8] =   s22[CREATE TABLE ex(i1, v2](8)
  23 Column           0    4   19               00 r[19]=sqlite_master.sql
REG[19] =   s19[CREATE TABLE ex(i1)](8)
  24 Function0        2   19   12 substr(2)     02 r[12]=func(r[19..20])
REG[19] =   s19[CREATE TABLE ex(i1)](8)
REG[20] =  i:19
REG[12] =   s1[)](8)
  25 Concat          12    8    7               00 r[7]=r[8]+r[12]
REG[12] =   s1[)](8)
REG[8] =   s22[CREATE TABLE ex(i1, v2](8)
REG[7] =   s23[CREATE TABLE ex(i1, v2)](8)
  26 MakeRecord       3    5   11 BBBDB         00 r[11]=mkrec(r[3..7])
REG[3] =   s5[table](8)
REG[4] =   s2[ex](8)
REG[5] =   s2[ex](8)
REG[6] =  i:3
REG[7] =   s23[CREATE TABLE ex(i1, v2)](8)
REG[11] =  sx39[06171111013B7461626C656578657803435245415445205441|.....;tableexex.CREATE TA]
  27 Insert           0   11    2               00 intkey=r[2] data=r[11]
REG[11] =  sx39[06171111013B7461626C656578657803435245415445205441|.....;tableexex.CREATE TA]
REG[2] =  i:2
  28 Goto             0   13    0               00 
  13 RowSetRead       1   29    2               00 r[2]=rowset(1)
REG[1] =  (rowset)
REG[2] =  i:2
  29 ReadCookie       0   12    2               00 
REG[12] =  i:4
  30 AddImm          12   -2    0               00 r[12]=r[12]+-2
REG[12] =  i:4
  31 IfPos           12   33    0               00 if r[12]>0 then r[12]-=0, goto 33
REG[12] =  i:2
  33 SetCookie        0    1   12               00 
  34 ParseSchema      0    0    0               00 
parser: [[[CREATE TABLE x(type text,name text,tbl_name text,rootpage int,sql text)]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 390
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 0.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP ID]
parser: Input 'ID' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 192
parser: Shift 'ID', pending reduce 341
parser: Return. Stack=[create_table LP nm ID]
parser: Input 'COMMA' with pending reduce 341
parser: Reduce 341 [typename ::= ID|STRING], go to state 192.
parser: ... then shift 'typename', go to state 392
parser: Reduce 340 [typetoken ::= typename], go to state 192.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 379
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 152
parser: Reduce 336 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'ID' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Shift 'ID', pending reduce 341
parser: Return. Stack=[create_table LP columnlist COMMA nm ID]
parser: Input 'COMMA' with pending reduce 341
parser: Reduce 341 [typename ::= ID|STRING], go to state 192.
parser: ... then shift 'typename', go to state 392
parser: Reduce 340 [typetoken ::= typename], go to state 192.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'ID' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Shift 'ID', pending reduce 341
parser: Return. Stack=[create_table LP columnlist COMMA nm ID]
parser: Input 'COMMA' with pending reduce 341
parser: Reduce 341 [typename ::= ID|STRING], go to state 192.
parser: ... then shift 'typename', go to state 392
parser: Reduce 340 [typetoken ::= typename], go to state 192.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'ID' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Shift 'ID', pending reduce 341
parser: Return. Stack=[create_table LP columnlist COMMA nm ID]
parser: Input 'COMMA' with pending reduce 341
parser: Reduce 341 [typename ::= ID|STRING], go to state 192.
parser: ... then shift 'typename', go to state 392
parser: Reduce 340 [typetoken ::= typename], go to state 192.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'ID' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Shift 'ID', pending reduce 341
parser: Return. Stack=[create_table LP columnlist COMMA nm ID]
parser: Input 'RP' with pending reduce 341
parser: Reduce 341 [typename ::= ID|STRING], go to state 192.
parser: ... then shift 'typename', go to state 392
parser: Reduce 340 [typetoken ::= typename], go to state 192.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Reduce 61 [conslist_opt ::=].
parser: ... then shift 'conslist_opt', go to state 540
parser: Shift 'RP', go to state 364
parser: Return. Stack=[create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 364
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: ... then shift 'create_table_args', pending reduce 334
parser: Reduce 334 [cmd ::= create_table create_table_args], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT*FROM"main".sqlite_master ORDER BY rowid]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'STAR' in state 288
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 95 [sclp ::=].
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STAR', pending reduce 97
parser: Return. Stack=[SELECT distinct sclp scanpt STAR]
parser: Input 'FROM' with pending reduce 97
parser: Reduce 97 [selcollist ::= sclp scanpt STAR], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 104 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'DOT' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 350
parser: Shift 'DOT', go to state 245
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID' in state 245
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'ORDER' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 245.
parser: ... then shift 'nm', pending reduce 110
parser: Reduce 110 [dbnm ::= DOT nm], go to state 350.
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 123 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 349
parser: Reduce 122 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 348
parser: Reduce 127 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 105
parser: Reduce 105 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 102 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 363
parser: Reduce 147 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 362
parser: Reduce 138 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 361
parser: Reduce 140 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 517
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 517
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 419
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 134 [sortorder ::=].
parser: ... then shift 'sortorder', go to state 353
parser: Reduce 137 [nulls ::=].
parser: ... then shift 'nulls', pending reduce 131
parser: Reduce 131 [sortlist ::= expr sortorder nulls], go to state 26.
parser: ... then shift 'sortlist', go to state 516
parser: Reduce 129 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 360
parser: Reduce 142 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 88
parser: Reduce 88 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 83 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 80
parser: Reduce 80 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
VDBE Trace:
   0 Init             0   13    0               00 Start at 13
  13 Transaction      0    0   12 4             00 usesStmtJournal=0
  14 Goto             0    1    0               00 
   1 Noop             1    7    0               00 
   2 OpenRead         0    1    0 5             00 root=1 iDb=0; sqlite_master
   3 Explain          3    0    0 SCAN TABLE sqlite_master 00 
   4 Rewind           0   12    0               00 
   5 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s5[table](8)
   6 Column           0    1    2               00 r[2]=sqlite_master.name
REG[2] =   s1[a](8)
   7 Column           0    2    3               00 r[3]=sqlite_master.tbl_name
REG[3] =   s1[a](8)
   8 Column           0    3    4               00 r[4]=sqlite_master.rootpage
REG[4] =  i:2
   9 Column           0    4    5               00 r[5]=sqlite_master.sql
REG[5] =   s56[CREATE TABLE a (b INTEGER](8)
  10 ResultRow        1    5    0               00 output=r[1..5]
REG[1] =   s5[table](8)
REG[2] =   s1[a](8)
REG[3] =   s1[a](8)
REG[4] =  i:2
REG[5] =   s56[CREATE TABLE a (b INTEGER](8)
parser: [[[CREATE TABLE a (b INTEGER, PRIMARY KEY(b)) WITHOUT ROWID]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 390
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 0.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP ID]
parser: Input 'ID' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 192
parser: Shift 'ID', pending reduce 341
parser: Return. Stack=[create_table LP nm ID]
parser: Input 'COMMA' with pending reduce 341
parser: Reduce 341 [typename ::= ID|STRING], go to state 192.
parser: ... then shift 'typename', go to state 392
parser: Reduce 340 [typetoken ::= typename], go to state 192.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 379
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 152
parser: Reduce 336 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'PRIMARY' in state 34
parser: Shift 'PRIMARY', go to state 475
parser: Return. Stack=[create_table LP columnlist COMMA PRIMARY]
parser: Input 'KEY' in state 475
parser: Shift 'KEY', go to state 474
parser: Return. Stack=[create_table LP columnlist COMMA PRIMARY KEY]
parser: Input 'LP' in state 474
parser: Shift 'LP', go to state 20
parser: Return. Stack=[create_table LP columnlist COMMA PRIMARY KEY LP]
parser: Input 'ID' in state 20
parser: Shift 'ID', go to state 419
parser: Return. Stack=[create_table LP columnlist COMMA PRIMARY KEY LP ID]
parser: Input 'RP' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 20.
parser: ... then shift 'expr', go to state 13
parser: Reduce 134 [sortorder ::=].
parser: ... then shift 'sortorder', go to state 353
parser: Reduce 137 [nulls ::=].
parser: ... then shift 'nulls', pending reduce 131
parser: Reduce 131 [sortlist ::= expr sortorder nulls], go to state 20.
parser: ... then shift 'sortlist', go to state 277
parser: Reduce 43 [autoinc ::=].
parser: ... then shift 'autoinc', go to state 473
parser: Shift 'RP', go to state 328
parser: Return. Stack=[create_table LP columnlist COMMA PRIMARY KEY LP sortlist autoinc RP]
parser: Input 'RP' in state 328
parser: Reduce 69 [onconf ::=].
parser: ... then shift 'onconf', pending reduce 64
parser: Reduce 64 [tcons ::= PRIMARY KEY LP sortlist autoinc RP onconf], go to state 34.
parser: ... then shift 'tcons', go to state 278
parser: Reduce 347 [conslist_opt ::= COMMA conslist], go to state 365.
parser: ... then shift 'conslist_opt', go to state 540
parser: Shift 'RP', go to state 364
parser: Return. Stack=[create_table LP columnlist conslist_opt RP]
parser: Input 'WITHOUT' in state 364
parser: Shift 'WITHOUT', go to state 251
parser: Return. Stack=[create_table LP columnlist conslist_opt RP WITHOUT]
parser: Input 'ID' in state 251
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist conslist_opt RP WITHOUT ID]
parser: Input 'SEMI' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 251.
parser: ... then shift 'nm', pending reduce 22
parser: Reduce 22 [table_options ::= WITHOUT nm], go to state 364.
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: ... then shift 'create_table_args', pending reduce 334
parser: Reduce 334 [cmd ::= create_table create_table_args], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
  11 Next             0    5    0               01 
   5 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s5[table](8)
   6 Column           0    1    2               00 r[2]=sqlite_master.name
REG[2] =   s2[ex](8)
   7 Column           0    2    3               00 r[3]=sqlite_master.tbl_name
REG[3] =   s2[ex](8)
   8 Column           0    3    4               00 r[4]=sqlite_master.rootpage
REG[4] =  i:3
   9 Column           0    4    5               00 r[5]=sqlite_master.sql
REG[5] =   s23[CREATE TABLE ex(i1, v2)](8)
  10 ResultRow        1    5    0               00 output=r[1..5]
REG[1] =   s5[table](8)
REG[2] =   s2[ex](8)
REG[3] =   s2[ex](8)
REG[4] =  i:3
REG[5] =   s23[CREATE TABLE ex(i1, v2)](8)
parser: [[[CREATE TABLE ex(i1, v2)]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 390
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 0.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP ID]
parser: Input 'COMMA' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 192
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 379
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 152
parser: Reduce 336 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'RP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Reduce 61 [conslist_opt ::=].
parser: ... then shift 'conslist_opt', go to state 540
parser: Shift 'RP', go to state 364
parser: Return. Stack=[create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 364
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: ... then shift 'create_table_args', pending reduce 334
parser: Reduce 334 [cmd ::= create_table create_table_args], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
  11 Next             0    5    0               01 
   5 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s5[index](8)
   6 Column           0    1    2               00 r[2]=sqlite_master.name
REG[2] =   s2[i2](8)
   7 Column           0    2    3               00 r[3]=sqlite_master.tbl_name
REG[3] =   s1[a](8)
   8 Column           0    3    4               00 r[4]=sqlite_master.rootpage
REG[4] =  i:4
   9 Column           0    4    5               00 r[5]=sqlite_master.sql
REG[5] =   s38[CREATE INDEX i2 ON a(b CO](8)
  10 ResultRow        1    5    0               00 output=r[1..5]
REG[1] =   s5[index](8)
REG[2] =   s2[i2](8)
REG[3] =   s1[a](8)
REG[4] =  i:4
REG[5] =   s38[CREATE INDEX i2 ON a(b CO](8)
parser: [[[CREATE INDEX i2 ON a(b COLLATE binary)]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'INDEX' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 225 [uniqueflag ::=].
parser: ... then shift 'uniqueflag', go to state 456
parser: Shift 'INDEX', go to state 315
parser: Return. Stack=[createkw uniqueflag INDEX]
parser: Input 'ID' in state 315
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 225
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists ID]
parser: Input 'ON' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 225.
parser: ... then shift 'nm', go to state 314
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 455
parser: Shift 'ON', go to state 224
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON]
parser: Input 'ID' in state 224
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON ID]
parser: Input 'LP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 224.
parser: ... then shift 'nm', go to state 454
parser: Shift 'LP', go to state 18
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP]
parser: Input 'ID' in state 18
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP ID]
parser: Input 'COLLATE' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 18.
parser: ... then shift 'expr', go to state 13
parser: Shift 'COLLATE', go to state 418
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP expr COLLATE]
parser: Input 'ID' in state 418
parser: Shift 'ID', pending reduce 175
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP expr COLLATE ID]
parser: Input 'RP' with pending reduce 175
parser: Reduce 175 [expr ::= expr COLLATE ID|STRING], go to state 18.
parser: ... then shift 'expr', go to state 13
parser: Reduce 134 [sortorder ::=].
parser: ... then shift 'sortorder', go to state 353
parser: Reduce 137 [nulls ::=].
parser: ... then shift 'nulls', pending reduce 131
parser: Reduce 131 [sortlist ::= expr sortorder nulls], go to state 18.
parser: ... then shift 'sortlist', go to state 402
parser: Shift 'RP', go to state 313
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP]
parser: Input 'SEMI' in state 313
parser: Reduce 147 [where_opt ::=].
parser: ... then shift 'where_opt', pending reduce 223
parser: Reduce 223 [cmd ::= createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP where_opt], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
  11 Next             0    5    0               01 
   5 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s4[view](8)
   6 Column           0    1    2               00 r[2]=sqlite_master.name
REG[2] =   s2[t1](8)
   7 Column           0    2    3               00 r[3]=sqlite_master.tbl_name
REG[3] =   s2[t1](8)
   8 Column           0    3    4               00 r[4]=sqlite_master.rootpage
REG[4] =  i:0
   9 Column           0    4    5               00 r[5]=sqlite_master.sql
REG[5] =   s210[CREATE VIEW t1 AS SELECT ](8)
  10 ResultRow        1    5    0               00 output=r[1..5]
REG[1] =   s4[view](8)
REG[2] =   s2[t1](8)
REG[3] =   s2[t1](8)
REG[4] =  i:0
REG[5] =   s210[CREATE VIEW t1 AS SELECT ](8)
parser: [[[CREATE VIEW t1 AS SELECT 123
    
      WINDOW x AS (
        RANGE BETWEEN UNBOUNDED PRECEDING AND INDEXED() OVER(
          PARTITION BY ( WITH x AS(VALUES(col1)) VALUES(453) )
        )
      FOLLOWING
    )]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'VIEW' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: FALLBACK VIEW => ID
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 390
parser: Shift 'VIEW', go to state 322
parser: Return. Stack=[createkw temp VIEW]
parser: Input 'ID' in state 322
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 228
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw temp VIEW ifnotexists ID]
parser: Input 'AS' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 228.
parser: ... then shift 'nm', go to state 321
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 320
parser: Reduce 226 [eidlist_opt ::=].
parser: ... then shift 'eidlist_opt', go to state 464
parser: Shift 'AS', go to state 37
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS]
parser: Input 'SELECT' in state 37
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT]
parser: Input 'INTEGER' in state 288
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 95 [sclp ::=].
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'INTEGER', pending reduce 173
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt INTEGER]
parser: Input 'WINDOW' with pending reduce 173
parser: Reduce 173 [term ::= INTEGER], go to state 77.
parser: ... then shift 'term', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Reduce 101 [from ::=].
parser: ... then shift 'from', go to state 363
parser: Reduce 147 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 362
parser: Reduce 138 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 361
parser: Reduce 140 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'WINDOW', go to state 136
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW]
parser: Input 'ID' in state 136
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW ID]
parser: Input 'AS' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 136.
parser: ... then shift 'nm', go to state 514
parser: Shift 'AS', go to state 513
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS]
parser: Input 'LP' in state 513
parser: Shift 'LP', go to state 33
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP]
parser: Input 'RANGE' in state 33
parser: Shift 'RANGE', pending reduce 304
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP RANGE]
parser: Input 'BETWEEN' with pending reduce 304
parser: Reduce 304 [range_or_rows ::= RANGE|ROWS|GROUPS], go to state 33.
parser: ... then shift 'range_or_rows', go to state 6
parser: Shift 'BETWEEN', go to state 8
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP range_or_rows BETWEEN]
parser: Input 'UNBOUNDED' in state 8
parser: Shift 'UNBOUNDED', go to state 505
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP range_or_rows BETWEEN UNBOUNDED]
parser: Input 'PRECEDING' in state 505
parser: Shift 'PRECEDING', pending reduce 306
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP range_or_rows BETWEEN UNBOUNDED PRECEDING]
parser: Input 'AND' with pending reduce 306
parser: Reduce 306 [frame_bound_s ::= UNBOUNDED PRECEDING], go to state 8.
parser: ... then shift 'frame_bound_s', go to state 508
parser: Shift 'AND', go to state 7
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP range_or_rows BETWEEN frame_bound_s AND]
parser: Input 'INDEXED' in state 7
parser: Shift 'INDEXED', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP range_or_rows BETWEEN frame_bound_s AND INDEXED]
parser: Input 'LP' in state 419
parser: Shift 'LP', go to state 266
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP range_or_rows BETWEEN frame_bound_s AND INDEXED LP]
parser: Input 'RP' in state 266
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Reduce 218 [exprlist ::=].
parser: ... then shift 'exprlist', go to state 484
parser: Shift 'RP', go to state 146
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP range_or_rows BETWEEN frame_bound_s AND INDEXED LP distinct exprlist RP]
parser: Input 'OVER' in state 146
parser: Shift 'OVER', go to state 204
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP range_or_rows BETWEEN frame_bound_s AND INDEXED LP distinct exprlist RP OVER]
parser: Input 'LP' in state 204
parser: Shift 'LP', go to state 32
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP range_or_rows BETWEEN frame_bound_s AND INDEXED LP distinct exprlist RP OVER LP]
parser: Input 'PARTITION' in state 32
parser: Shift 'PARTITION', go to state 511
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP range_or_rows BETWEEN frame_bound_s AND INDEXED LP distinct exprlist RP OVER LP PARTITION]
parser: Input 'BY' in state 511
parser: Shift 'BY', go to state 25
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP range_or_rows BETWEEN frame_bound_s AND INDEXED LP distinct exprlist RP OVER LP PARTITION BY]
parser: Input 'LP' in state 25
parser: Shift 'LP', go to state 4
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP range_or_rows BETWEEN frame_bound_s AND INDEXED LP distinct exprlist RP OVER LP PARTITION BY LP]
parser: Input 'WITH' in state 4
parser: Shift 'WITH', go to state 162
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP range_or_rows BETWEEN frame_bound_s AND INDEXED LP distinct exprlist RP OVER LP PARTITION BY LP WITH]
parser: Input 'ID' in state 162
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP range_or_rows BETWEEN frame_bound_s AND INDEXED LP distinct exprlist RP OVER LP PARTITION BY LP WITH ID]
parser: Input 'AS' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 162.
parser: ... then shift 'nm', go to state 338
parser: Reduce 226 [eidlist_opt ::=].
parser: ... then shift 'eidlist_opt', go to state 489
parser: Shift 'AS', go to state 488
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP range_or_rows BETWEEN frame_bound_s AND INDEXED LP distinct exprlist RP OVER LP PARTITION BY LP WITH nm eidlist_opt AS]
parser: Input 'LP' in state 488
parser: Shift 'LP', go to state 39
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP range_or_rows BETWEEN frame_bound_s AND INDEXED LP distinct exprlist RP OVER LP PARTITION BY LP WITH nm eidlist_opt AS LP]
parser: Input 'VALUES' in state 39
parser: Shift 'VALUES', go to state 528
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP range_or_rows BETWEEN frame_bound_s AND INDEXED LP distinct exprlist RP OVER LP PARTITION BY LP WITH nm eidlist_opt AS LP VALUES]
parser: Input 'LP' in state 528
parser: Shift 'LP', go to state 28
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP range_or_rows BETWEEN frame_bound_s AND INDEXED LP distinct exprlist RP OVER LP PARTITION BY LP WITH nm eidlist_opt AS LP VALUES LP]
parser: Input 'ID' in state 28
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP range_or_rows BETWEEN frame_bound_s AND INDEXED LP distinct exprlist RP OVER LP PARTITION BY LP WITH nm eidlist_opt AS LP VALUES LP ID]
parser: Input 'RP' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 28.
parser: ... then shift 'expr', go to state 70
parser: Reduce 220 [nexprlist ::= expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 413
parser: Shift 'RP', pending reduce 90
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP range_or_rows BETWEEN frame_bound_s AND INDEXED LP distinct exprlist RP OVER LP PARTITION BY LP WITH nm eidlist_opt AS LP VALUES LP nexprlist RP]
parser: Input 'RP' with pending reduce 90
parser: Reduce 90 [values ::= VALUES LP nexprlist RP], go to state 39.
parser: ... then shift 'values', go to state 534
parser: Reduce 354 [oneselect ::= values], go to state 39.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 83 [select ::= selectnowith], go to state 39.
parser: ... then shift 'select', go to state 487
parser: Shift 'RP', pending reduce 290
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP range_or_rows BETWEEN frame_bound_s AND INDEXED LP distinct exprlist RP OVER LP PARTITION BY LP WITH nm eidlist_opt AS LP select RP]
parser: Input 'VALUES' with pending reduce 290
parser: Reduce 290 [wqlist ::= nm eidlist_opt AS LP select RP], go to state 162.
parser: ... then shift 'wqlist', go to state 143
parser: Shift 'VALUES', go to state 528
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP range_or_rows BETWEEN frame_bound_s AND INDEXED LP distinct exprlist RP OVER LP PARTITION BY LP WITH wqlist VALUES]
parser: Input 'LP' in state 528
parser: Shift 'LP', go to state 28
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP range_or_rows BETWEEN frame_bound_s AND INDEXED LP distinct exprlist RP OVER LP PARTITION BY LP WITH wqlist VALUES LP]
parser: Input 'INTEGER' in state 28
parser: Shift 'INTEGER', pending reduce 173
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP range_or_rows BETWEEN frame_bound_s AND INDEXED LP distinct exprlist RP OVER LP PARTITION BY LP WITH wqlist VALUES LP INTEGER]
parser: Input 'RP' with pending reduce 173
parser: Reduce 173 [term ::= INTEGER], go to state 28.
parser: ... then shift 'term', go to state 70
parser: Reduce 220 [nexprlist ::= expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 413
parser: Shift 'RP', pending reduce 90
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP range_or_rows BETWEEN frame_bound_s AND INDEXED LP distinct exprlist RP OVER LP PARTITION BY LP WITH wqlist VALUES LP nexprlist RP]
parser: Input 'RP' with pending reduce 90
parser: Reduce 90 [values ::= VALUES LP nexprlist RP], go to state 143.
parser: ... then shift 'values', go to state 534
parser: Reduce 354 [oneselect ::= values], go to state 143.
parser: ... then shift 'oneselect', go to state 265
parser: Reduce 81 [select ::= WITH wqlist selectnowith], go to state 4.
parser: ... then shift 'select', go to state 485
parser: Shift 'RP', pending reduce 207
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP range_or_rows BETWEEN frame_bound_s AND INDEXED LP distinct exprlist RP OVER LP PARTITION BY LP select RP]
parser: Input 'RP' with pending reduce 207
parser: Reduce 207 [expr ::= LP select RP], go to state 25.
parser: ... then shift 'expr', go to state 70
parser: Reduce 220 [nexprlist ::= expr], go to state 25.
parser: ... then shift 'nexprlist', go to state 285
parser: Reduce 128 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 191
parser: Reduce 301 [frame_opt ::=].
parser: ... then shift 'frame_opt', pending reduce 295
parser: Reduce 295 [window ::= PARTITION BY nexprlist orderby_opt frame_opt], go to state 32.
parser: ... then shift 'window', go to state 483
parser: Shift 'RP', pending reduce 320
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP range_or_rows BETWEEN frame_bound_s AND INDEXED LP distinct exprlist RP OVER LP window RP]
parser: Input 'FOLLOWING' with pending reduce 320
parser: Reduce 320 [over_clause ::= OVER LP window RP], go to state 146.
parser: ... then shift 'over_clause', pending reduce 318
parser: Reduce 318 [filter_over ::= over_clause], go to state 146.
parser: ... then shift 'filter_over', pending reduce 179
parser: Reduce 179 [expr ::= ID|INDEXED LP distinct exprlist RP filter_over], go to state 7.
parser: ... then shift 'expr', go to state 42
parser: Shift 'FOLLOWING', pending reduce 309
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP range_or_rows BETWEEN frame_bound_s AND expr FOLLOWING]
parser: Input 'RP' with pending reduce 309
parser: Reduce 309 [frame_bound ::= expr PRECEDING|FOLLOWING], go to state 7.
parser: ... then shift 'frame_bound', pending reduce 307
parser: Reduce 307 [frame_bound_e ::= frame_bound], go to state 7.
parser: ... then shift 'frame_bound_e', go to state 351
parser: Reduce 311 [frame_exclude_opt ::=].
parser: ... then shift 'frame_exclude_opt', pending reduce 303
parser: Reduce 303 [frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt], go to state 33.
parser: ... then shift 'frame_opt', pending reduce 299
parser: Reduce 299 [window ::= frame_opt], go to state 33.
parser: ... then shift 'window', go to state 512
parser: Shift 'RP', pending reduce 294
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist from where_opt groupby_opt having_opt WINDOW nm AS LP window RP]
parser: Input 'SEMI' with pending reduce 294
parser: Reduce 294 [windowdefn ::= nm AS LP window RP], go to state 136.
parser: ... then shift 'windowdefn', pending reduce 292
parser: Reduce 292 [windowdefn_list ::= windowdefn], go to state 136.
parser: ... then shift 'windowdefn_list', go to state 515
parser: Reduce 316 [window_clause ::= WINDOW windowdefn_list], go to state 194.
parser: ... then shift 'window_clause', go to state 356
parser: Reduce 128 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 355
parser: Reduce 142 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 89
parser: Reduce 89 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt window_clause orderby_opt limit_opt], go to state 37.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 83 [select ::= selectnowith], go to state 37.
parser: ... then shift 'select', pending reduce 78
parser: Reduce 78 [cmd ::= createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
  11 Next             0    5    0               01 
   5 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s4[view](8)
   6 Column           0    1    2               00 r[2]=sqlite_master.name
REG[2] =   s2[t2](8)
   7 Column           0    2    3               00 r[3]=sqlite_master.tbl_name
REG[3] =   s2[t2](8)
   8 Column           0    3    4               00 r[4]=sqlite_master.rootpage
REG[4] =  i:0
   9 Column           0    4    5               00 r[5]=sqlite_master.sql
REG[5] =   s396[CREATE VIEW t2 AS .  SELE](8)
  10 ResultRow        1    5    0               00 output=r[1..5]
REG[1] =   s4[view](8)
REG[2] =   s2[t2](8)
REG[3] =   s2[t2](8)
REG[4] =  i:0
REG[5] =   s396[CREATE VIEW t2 AS .  SELE](8)
parser: [[[CREATE VIEW t2 AS 
  SELECT sum(b) FILTER( WHERE b>9 ),
         sum(b) FILTER( WHERE b>8 ),
         sum(b) FILTER( WHERE b>7 ),
         sum(b) FILTER( WHERE b>6 ),
         sum(b) FILTER( WHERE b>5 ),
         sum(b) FILTER( WHERE b>4 ),
         sum(b) FILTER( WHERE b>3 ),
         sum(b) FILTER( WHERE b>2 ),
         sum(b) FILTER( WHERE b>1 ),
         sum(b) FILTER( WHERE b>0 )
  FROM a]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'VIEW' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: FALLBACK VIEW => ID
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 390
parser: Shift 'VIEW', go to state 322
parser: Return. Stack=[createkw temp VIEW]
parser: Input 'ID' in state 322
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 228
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw temp VIEW ifnotexists ID]
parser: Input 'AS' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 228.
parser: ... then shift 'nm', go to state 321
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 320
parser: Reduce 226 [eidlist_opt ::=].
parser: ... then shift 'eidlist_opt', go to state 464
parser: Shift 'AS', go to state 37
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS]
parser: Input 'SELECT' in state 37
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT]
parser: Input 'ID' in state 288
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 95 [sclp ::=].
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 419
parser: Shift 'LP', go to state 266
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 220 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 519
parser: Reduce 359 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 484
parser: Shift 'RP', go to state 146
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'FILTER' in state 146
parser: Shift 'FILTER', go to state 482
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER]
parser: Input 'LP' in state 482
parser: Shift 'LP', go to state 481
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP]
parser: Input 'WHERE' in state 481
parser: Shift 'WHERE', go to state 90
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE]
parser: Input 'ID' in state 90
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE ID]
parser: Input 'GT' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'GT', go to state 118
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT]
parser: Input 'INTEGER' in state 118
parser: Shift 'INTEGER', pending reduce 173
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT INTEGER]
parser: Input 'RP' with pending reduce 173
parser: Reduce 173 [term ::= INTEGER], go to state 118.
parser: ... then shift 'term', go to state 130
parser: Reduce 185 [expr ::= expr LT|GT|GE|LE expr], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'RP', pending reduce 322
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr RP]
parser: Input 'COMMA' with pending reduce 322
parser: Reduce 322 [filter_clause ::= FILTER LP WHERE expr RP], go to state 146.
parser: ... then shift 'filter_clause', go to state 337
parser: Reduce 319 [filter_over ::= filter_clause], go to state 146.
parser: ... then shift 'filter_over', pending reduce 179
parser: Reduce 179 [expr ::= ID|INDEXED LP distinct exprlist RP filter_over], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 355
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 355
parser: Reduce 355 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 419
parser: Shift 'LP', go to state 266
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 220 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 519
parser: Reduce 359 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 484
parser: Shift 'RP', go to state 146
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'FILTER' in state 146
parser: Shift 'FILTER', go to state 482
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER]
parser: Input 'LP' in state 482
parser: Shift 'LP', go to state 481
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP]
parser: Input 'WHERE' in state 481
parser: Shift 'WHERE', go to state 90
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE]
parser: Input 'ID' in state 90
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE ID]
parser: Input 'GT' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'GT', go to state 118
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT]
parser: Input 'INTEGER' in state 118
parser: Shift 'INTEGER', pending reduce 173
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT INTEGER]
parser: Input 'RP' with pending reduce 173
parser: Reduce 173 [term ::= INTEGER], go to state 118.
parser: ... then shift 'term', go to state 130
parser: Reduce 185 [expr ::= expr LT|GT|GE|LE expr], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'RP', pending reduce 322
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr RP]
parser: Input 'COMMA' with pending reduce 322
parser: Reduce 322 [filter_clause ::= FILTER LP WHERE expr RP], go to state 146.
parser: ... then shift 'filter_clause', go to state 337
parser: Reduce 319 [filter_over ::= filter_clause], go to state 146.
parser: ... then shift 'filter_over', pending reduce 179
parser: Reduce 179 [expr ::= ID|INDEXED LP distinct exprlist RP filter_over], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 355
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 355
parser: Reduce 355 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 419
parser: Shift 'LP', go to state 266
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 220 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 519
parser: Reduce 359 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 484
parser: Shift 'RP', go to state 146
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'FILTER' in state 146
parser: Shift 'FILTER', go to state 482
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER]
parser: Input 'LP' in state 482
parser: Shift 'LP', go to state 481
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP]
parser: Input 'WHERE' in state 481
parser: Shift 'WHERE', go to state 90
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE]
parser: Input 'ID' in state 90
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE ID]
parser: Input 'GT' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'GT', go to state 118
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT]
parser: Input 'INTEGER' in state 118
parser: Shift 'INTEGER', pending reduce 173
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT INTEGER]
parser: Input 'RP' with pending reduce 173
parser: Reduce 173 [term ::= INTEGER], go to state 118.
parser: ... then shift 'term', go to state 130
parser: Reduce 185 [expr ::= expr LT|GT|GE|LE expr], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'RP', pending reduce 322
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr RP]
parser: Input 'COMMA' with pending reduce 322
parser: Reduce 322 [filter_clause ::= FILTER LP WHERE expr RP], go to state 146.
parser: ... then shift 'filter_clause', go to state 337
parser: Reduce 319 [filter_over ::= filter_clause], go to state 146.
parser: ... then shift 'filter_over', pending reduce 179
parser: Reduce 179 [expr ::= ID|INDEXED LP distinct exprlist RP filter_over], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 355
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 355
parser: Reduce 355 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 419
parser: Shift 'LP', go to state 266
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 220 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 519
parser: Reduce 359 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 484
parser: Shift 'RP', go to state 146
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'FILTER' in state 146
parser: Shift 'FILTER', go to state 482
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER]
parser: Input 'LP' in state 482
parser: Shift 'LP', go to state 481
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP]
parser: Input 'WHERE' in state 481
parser: Shift 'WHERE', go to state 90
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE]
parser: Input 'ID' in state 90
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE ID]
parser: Input 'GT' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'GT', go to state 118
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT]
parser: Input 'INTEGER' in state 118
parser: Shift 'INTEGER', pending reduce 173
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT INTEGER]
parser: Input 'RP' with pending reduce 173
parser: Reduce 173 [term ::= INTEGER], go to state 118.
parser: ... then shift 'term', go to state 130
parser: Reduce 185 [expr ::= expr LT|GT|GE|LE expr], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'RP', pending reduce 322
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr RP]
parser: Input 'COMMA' with pending reduce 322
parser: Reduce 322 [filter_clause ::= FILTER LP WHERE expr RP], go to state 146.
parser: ... then shift 'filter_clause', go to state 337
parser: Reduce 319 [filter_over ::= filter_clause], go to state 146.
parser: ... then shift 'filter_over', pending reduce 179
parser: Reduce 179 [expr ::= ID|INDEXED LP distinct exprlist RP filter_over], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 355
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 355
parser: Reduce 355 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 419
parser: Shift 'LP', go to state 266
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 220 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 519
parser: Reduce 359 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 484
parser: Shift 'RP', go to state 146
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'FILTER' in state 146
parser: Shift 'FILTER', go to state 482
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER]
parser: Input 'LP' in state 482
parser: Shift 'LP', go to state 481
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP]
parser: Input 'WHERE' in state 481
parser: Shift 'WHERE', go to state 90
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE]
parser: Input 'ID' in state 90
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE ID]
parser: Input 'GT' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'GT', go to state 118
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT]
parser: Input 'INTEGER' in state 118
parser: Shift 'INTEGER', pending reduce 173
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT INTEGER]
parser: Input 'RP' with pending reduce 173
parser: Reduce 173 [term ::= INTEGER], go to state 118.
parser: ... then shift 'term', go to state 130
parser: Reduce 185 [expr ::= expr LT|GT|GE|LE expr], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'RP', pending reduce 322
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr RP]
parser: Input 'COMMA' with pending reduce 322
parser: Reduce 322 [filter_clause ::= FILTER LP WHERE expr RP], go to state 146.
parser: ... then shift 'filter_clause', go to state 337
parser: Reduce 319 [filter_over ::= filter_clause], go to state 146.
parser: ... then shift 'filter_over', pending reduce 179
parser: Reduce 179 [expr ::= ID|INDEXED LP distinct exprlist RP filter_over], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 355
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 355
parser: Reduce 355 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 419
parser: Shift 'LP', go to state 266
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 220 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 519
parser: Reduce 359 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 484
parser: Shift 'RP', go to state 146
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'FILTER' in state 146
parser: Shift 'FILTER', go to state 482
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER]
parser: Input 'LP' in state 482
parser: Shift 'LP', go to state 481
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP]
parser: Input 'WHERE' in state 481
parser: Shift 'WHERE', go to state 90
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE]
parser: Input 'ID' in state 90
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE ID]
parser: Input 'GT' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'GT', go to state 118
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT]
parser: Input 'INTEGER' in state 118
parser: Shift 'INTEGER', pending reduce 173
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT INTEGER]
parser: Input 'RP' with pending reduce 173
parser: Reduce 173 [term ::= INTEGER], go to state 118.
parser: ... then shift 'term', go to state 130
parser: Reduce 185 [expr ::= expr LT|GT|GE|LE expr], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'RP', pending reduce 322
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr RP]
parser: Input 'COMMA' with pending reduce 322
parser: Reduce 322 [filter_clause ::= FILTER LP WHERE expr RP], go to state 146.
parser: ... then shift 'filter_clause', go to state 337
parser: Reduce 319 [filter_over ::= filter_clause], go to state 146.
parser: ... then shift 'filter_over', pending reduce 179
parser: Reduce 179 [expr ::= ID|INDEXED LP distinct exprlist RP filter_over], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 355
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 355
parser: Reduce 355 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 419
parser: Shift 'LP', go to state 266
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 220 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 519
parser: Reduce 359 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 484
parser: Shift 'RP', go to state 146
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'FILTER' in state 146
parser: Shift 'FILTER', go to state 482
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER]
parser: Input 'LP' in state 482
parser: Shift 'LP', go to state 481
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP]
parser: Input 'WHERE' in state 481
parser: Shift 'WHERE', go to state 90
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE]
parser: Input 'ID' in state 90
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE ID]
parser: Input 'GT' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'GT', go to state 118
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT]
parser: Input 'INTEGER' in state 118
parser: Shift 'INTEGER', pending reduce 173
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT INTEGER]
parser: Input 'RP' with pending reduce 173
parser: Reduce 173 [term ::= INTEGER], go to state 118.
parser: ... then shift 'term', go to state 130
parser: Reduce 185 [expr ::= expr LT|GT|GE|LE expr], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'RP', pending reduce 322
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr RP]
parser: Input 'COMMA' with pending reduce 322
parser: Reduce 322 [filter_clause ::= FILTER LP WHERE expr RP], go to state 146.
parser: ... then shift 'filter_clause', go to state 337
parser: Reduce 319 [filter_over ::= filter_clause], go to state 146.
parser: ... then shift 'filter_over', pending reduce 179
parser: Reduce 179 [expr ::= ID|INDEXED LP distinct exprlist RP filter_over], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 355
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 355
parser: Reduce 355 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 419
parser: Shift 'LP', go to state 266
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 220 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 519
parser: Reduce 359 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 484
parser: Shift 'RP', go to state 146
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'FILTER' in state 146
parser: Shift 'FILTER', go to state 482
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER]
parser: Input 'LP' in state 482
parser: Shift 'LP', go to state 481
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP]
parser: Input 'WHERE' in state 481
parser: Shift 'WHERE', go to state 90
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE]
parser: Input 'ID' in state 90
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE ID]
parser: Input 'GT' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'GT', go to state 118
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT]
parser: Input 'INTEGER' in state 118
parser: Shift 'INTEGER', pending reduce 173
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT INTEGER]
parser: Input 'RP' with pending reduce 173
parser: Reduce 173 [term ::= INTEGER], go to state 118.
parser: ... then shift 'term', go to state 130
parser: Reduce 185 [expr ::= expr LT|GT|GE|LE expr], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'RP', pending reduce 322
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr RP]
parser: Input 'COMMA' with pending reduce 322
parser: Reduce 322 [filter_clause ::= FILTER LP WHERE expr RP], go to state 146.
parser: ... then shift 'filter_clause', go to state 337
parser: Reduce 319 [filter_over ::= filter_clause], go to state 146.
parser: ... then shift 'filter_over', pending reduce 179
parser: Reduce 179 [expr ::= ID|INDEXED LP distinct exprlist RP filter_over], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 355
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 355
parser: Reduce 355 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 419
parser: Shift 'LP', go to state 266
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 220 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 519
parser: Reduce 359 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 484
parser: Shift 'RP', go to state 146
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'FILTER' in state 146
parser: Shift 'FILTER', go to state 482
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER]
parser: Input 'LP' in state 482
parser: Shift 'LP', go to state 481
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP]
parser: Input 'WHERE' in state 481
parser: Shift 'WHERE', go to state 90
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE]
parser: Input 'ID' in state 90
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE ID]
parser: Input 'GT' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'GT', go to state 118
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT]
parser: Input 'INTEGER' in state 118
parser: Shift 'INTEGER', pending reduce 173
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT INTEGER]
parser: Input 'RP' with pending reduce 173
parser: Reduce 173 [term ::= INTEGER], go to state 118.
parser: ... then shift 'term', go to state 130
parser: Reduce 185 [expr ::= expr LT|GT|GE|LE expr], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'RP', pending reduce 322
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr RP]
parser: Input 'COMMA' with pending reduce 322
parser: Reduce 322 [filter_clause ::= FILTER LP WHERE expr RP], go to state 146.
parser: ... then shift 'filter_clause', go to state 337
parser: Reduce 319 [filter_over ::= filter_clause], go to state 146.
parser: ... then shift 'filter_over', pending reduce 179
parser: Reduce 179 [expr ::= ID|INDEXED LP distinct exprlist RP filter_over], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 355
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 355
parser: Reduce 355 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 419
parser: Shift 'LP', go to state 266
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP]
parser: Input 'ID' in state 266
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 11
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct ID]
parser: Input 'RP' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 11.
parser: ... then shift 'expr', go to state 70
parser: Reduce 220 [nexprlist ::= expr], go to state 11.
parser: ... then shift 'nexprlist', go to state 519
parser: Reduce 359 [exprlist ::= nexprlist], go to state 11.
parser: ... then shift 'exprlist', go to state 484
parser: Shift 'RP', go to state 146
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP]
parser: Input 'FILTER' in state 146
parser: Shift 'FILTER', go to state 482
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER]
parser: Input 'LP' in state 482
parser: Shift 'LP', go to state 481
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP]
parser: Input 'WHERE' in state 481
parser: Shift 'WHERE', go to state 90
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE]
parser: Input 'ID' in state 90
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE ID]
parser: Input 'GT' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'GT', go to state 118
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT]
parser: Input 'INTEGER' in state 118
parser: Shift 'INTEGER', pending reduce 173
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr GT INTEGER]
parser: Input 'RP' with pending reduce 173
parser: Reduce 173 [term ::= INTEGER], go to state 118.
parser: ... then shift 'term', go to state 130
parser: Reduce 185 [expr ::= expr LT|GT|GE|LE expr], go to state 90.
parser: ... then shift 'expr', go to state 48
parser: Shift 'RP', pending reduce 322
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct sclp scanpt ID LP distinct exprlist RP FILTER LP WHERE expr RP]
parser: Input 'FROM' with pending reduce 322
parser: Reduce 322 [filter_clause ::= FILTER LP WHERE expr RP], go to state 146.
parser: ... then shift 'filter_clause', go to state 337
parser: Reduce 319 [filter_over ::= filter_clause], go to state 146.
parser: ... then shift 'filter_over', pending reduce 179
parser: Reduce 179 [expr ::= ID|INDEXED LP distinct exprlist RP filter_over], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 104 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'SEMI' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 350
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 123 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 349
parser: Reduce 122 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 348
parser: Reduce 127 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 105
parser: Reduce 105 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 102 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 363
parser: Reduce 147 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 362
parser: Reduce 138 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 361
parser: Reduce 140 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 128 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 360
parser: Reduce 142 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 88
parser: Reduce 88 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 37.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 83 [select ::= selectnowith], go to state 37.
parser: ... then shift 'select', pending reduce 78
parser: Reduce 78 [cmd ::= createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
  11 Next             0    5    0               01 
   5 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s5[table](8)
   6 Column           0    1    2               00 r[2]=sqlite_master.name
REG[2] =   s1[x](8)
   7 Column           0    2    3               00 r[3]=sqlite_master.tbl_name
REG[3] =   s1[x](8)
   8 Column           0    3    4               00 r[4]=sqlite_master.rootpage
REG[4] =  i:5
   9 Column           0    4    5               00 r[5]=sqlite_master.sql
REG[5] =   s54[CREATE TABLE x(y INTEGER ](8)
  10 ResultRow        1    5    0               00 output=r[1..5]
REG[1] =   s5[table](8)
REG[2] =   s1[x](8)
REG[3] =   s1[x](8)
REG[4] =  i:5
REG[5] =   s54[CREATE TABLE x(y INTEGER ](8)
parser: [[[CREATE TABLE x(y INTEGER PRIMARY KEY, t2i1, t1i1, abc)]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 390
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 0.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP ID]
parser: Input 'ID' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 192
parser: Shift 'ID', pending reduce 341
parser: Return. Stack=[create_table LP nm ID]
parser: Input 'PRIMARY' with pending reduce 341
parser: Reduce 341 [typename ::= ID|STRING], go to state 192.
parser: ... then shift 'typename', go to state 392
parser: Reduce 340 [typetoken ::= typename], go to state 192.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 379
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 152
parser: Shift 'PRIMARY', go to state 478
parser: Return. Stack=[create_table LP columnname carglist PRIMARY]
parser: Input 'KEY' in state 478
parser: Shift 'KEY', go to state 280
parser: Return. Stack=[create_table LP columnname carglist PRIMARY KEY]
parser: Input 'COMMA' in state 280
parser: Reduce 134 [sortorder ::=].
parser: ... then shift 'sortorder', go to state 333
parser: Reduce 69 [onconf ::=].
parser: ... then shift 'onconf', go to state 332
parser: Reduce 43 [autoinc ::=].
parser: ... then shift 'autoinc', pending reduce 37
parser: Reduce 37 [ccons ::= PRIMARY KEY sortorder onconf autoinc], go to state 152.
parser: ... then shift 'ccons', pending reduce 344
parser: Reduce 344 [carglist ::= carglist ccons], go to state 379.
parser: ... then shift 'carglist', go to state 152
parser: Reduce 336 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'COMMA' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'COMMA' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'RP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Reduce 61 [conslist_opt ::=].
parser: ... then shift 'conslist_opt', go to state 540
parser: Shift 'RP', go to state 364
parser: Return. Stack=[create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 364
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: ... then shift 'create_table_args', pending reduce 334
parser: Reduce 334 [cmd ::= create_table create_table_args], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
  11 Next             0    5    0               01 
   5 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s5[index](8)
   6 Column           0    1    2               00 r[2]=sqlite_master.name
REG[2] =   s1[c](8)
   7 Column           0    2    3               00 r[3]=sqlite_master.tbl_name
REG[3] =   s1[a](8)
   8 Column           0    3    4               00 r[4]=sqlite_master.rootpage
REG[4] =  i:6
   9 Column           0    4    5               00 r[5]=sqlite_master.sql
REG[5] =   s23[CREATE INDEX c ON a(b).](8)
  10 ResultRow        1    5    0               00 output=r[1..5]
REG[1] =   s5[index](8)
REG[2] =   s1[c](8)
REG[3] =   s1[a](8)
REG[4] =  i:6
REG[5] =   s23[CREATE INDEX c ON a(b).](8)
parser: [[[CREATE INDEX c ON a(b)
]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'INDEX' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 225 [uniqueflag ::=].
parser: ... then shift 'uniqueflag', go to state 456
parser: Shift 'INDEX', go to state 315
parser: Return. Stack=[createkw uniqueflag INDEX]
parser: Input 'ID' in state 315
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 225
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists ID]
parser: Input 'ON' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 225.
parser: ... then shift 'nm', go to state 314
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 455
parser: Shift 'ON', go to state 224
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON]
parser: Input 'ID' in state 224
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON ID]
parser: Input 'LP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 224.
parser: ... then shift 'nm', go to state 454
parser: Shift 'LP', go to state 18
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP]
parser: Input 'ID' in state 18
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP ID]
parser: Input 'RP' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 18.
parser: ... then shift 'expr', go to state 13
parser: Reduce 134 [sortorder ::=].
parser: ... then shift 'sortorder', go to state 353
parser: Reduce 137 [nulls ::=].
parser: ... then shift 'nulls', pending reduce 131
parser: Reduce 131 [sortlist ::= expr sortorder nulls], go to state 18.
parser: ... then shift 'sortlist', go to state 402
parser: Shift 'RP', go to state 313
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP]
parser: Input 'SEMI' in state 313
parser: Reduce 147 [where_opt ::=].
parser: ... then shift 'where_opt', pending reduce 223
parser: Reduce 223 [cmd ::= createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP where_opt], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
  11 Next             0    5    0               01 
   5 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s5[index](8)
   6 Column           0    1    2               00 r[2]=sqlite_master.name
REG[2] =   s2[v1](8)
   7 Column           0    2    3               00 r[3]=sqlite_master.tbl_name
REG[3] =   s1[a](8)
   8 Column           0    3    4               00 r[4]=sqlite_master.rootpage
REG[4] =  i:7
   9 Column           0    4    5               00 r[5]=sqlite_master.sql
REG[5] =   s24[CREATE INDEX v1 ON a(b).](8)
  10 ResultRow        1    5    0               00 output=r[1..5]
REG[1] =   s5[index](8)
REG[2] =   s2[v1](8)
REG[3] =   s1[a](8)
REG[4] =  i:7
REG[5] =   s24[CREATE INDEX v1 ON a(b).](8)
parser: [[[CREATE INDEX v1 ON a(b)
]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'INDEX' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 225 [uniqueflag ::=].
parser: ... then shift 'uniqueflag', go to state 456
parser: Shift 'INDEX', go to state 315
parser: Return. Stack=[createkw uniqueflag INDEX]
parser: Input 'ID' in state 315
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 225
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists ID]
parser: Input 'ON' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 225.
parser: ... then shift 'nm', go to state 314
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 455
parser: Shift 'ON', go to state 224
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON]
parser: Input 'ID' in state 224
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON ID]
parser: Input 'LP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 224.
parser: ... then shift 'nm', go to state 454
parser: Shift 'LP', go to state 18
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP]
parser: Input 'ID' in state 18
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP ID]
parser: Input 'RP' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 18.
parser: ... then shift 'expr', go to state 13
parser: Reduce 134 [sortorder ::=].
parser: ... then shift 'sortorder', go to state 353
parser: Reduce 137 [nulls ::=].
parser: ... then shift 'nulls', pending reduce 131
parser: Reduce 131 [sortlist ::= expr sortorder nulls], go to state 18.
parser: ... then shift 'sortlist', go to state 402
parser: Shift 'RP', go to state 313
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP]
parser: Input 'SEMI' in state 313
parser: Reduce 147 [where_opt ::=].
parser: ... then shift 'where_opt', pending reduce 223
parser: Reduce 223 [cmd ::= createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP where_opt], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
  11 Next             0    5    0               01 
  12 Halt             0    0    0               00 
  35 ParseSchema      1    0    0               00 
parser: [[[CREATE TABLE x(type text,name text,tbl_name text,rootpage int,sql text)]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 390
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 0.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP ID]
parser: Input 'ID' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 192
parser: Shift 'ID', pending reduce 341
parser: Return. Stack=[create_table LP nm ID]
parser: Input 'COMMA' with pending reduce 341
parser: Reduce 341 [typename ::= ID|STRING], go to state 192.
parser: ... then shift 'typename', go to state 392
parser: Reduce 340 [typetoken ::= typename], go to state 192.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 379
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 152
parser: Reduce 336 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'ID' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Shift 'ID', pending reduce 341
parser: Return. Stack=[create_table LP columnlist COMMA nm ID]
parser: Input 'COMMA' with pending reduce 341
parser: Reduce 341 [typename ::= ID|STRING], go to state 192.
parser: ... then shift 'typename', go to state 392
parser: Reduce 340 [typetoken ::= typename], go to state 192.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'ID' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Shift 'ID', pending reduce 341
parser: Return. Stack=[create_table LP columnlist COMMA nm ID]
parser: Input 'COMMA' with pending reduce 341
parser: Reduce 341 [typename ::= ID|STRING], go to state 192.
parser: ... then shift 'typename', go to state 392
parser: Reduce 340 [typetoken ::= typename], go to state 192.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'ID' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Shift 'ID', pending reduce 341
parser: Return. Stack=[create_table LP columnlist COMMA nm ID]
parser: Input 'COMMA' with pending reduce 341
parser: Reduce 341 [typename ::= ID|STRING], go to state 192.
parser: ... then shift 'typename', go to state 392
parser: Reduce 340 [typetoken ::= typename], go to state 192.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'ID' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Shift 'ID', pending reduce 341
parser: Return. Stack=[create_table LP columnlist COMMA nm ID]
parser: Input 'RP' with pending reduce 341
parser: Reduce 341 [typename ::= ID|STRING], go to state 192.
parser: ... then shift 'typename', go to state 392
parser: Reduce 340 [typetoken ::= typename], go to state 192.
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Reduce 61 [conslist_opt ::=].
parser: ... then shift 'conslist_opt', go to state 540
parser: Shift 'RP', go to state 364
parser: Return. Stack=[create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 364
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: ... then shift 'create_table_args', pending reduce 334
parser: Reduce 334 [cmd ::= create_table create_table_args], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: [[[SELECT*FROM"temp".sqlite_temp_master ORDER BY rowid]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'STAR' in state 288
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 95 [sclp ::=].
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STAR', pending reduce 97
parser: Return. Stack=[SELECT distinct sclp scanpt STAR]
parser: Input 'FROM' with pending reduce 97
parser: Reduce 97 [selcollist ::= sclp scanpt STAR], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 104 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'DOT' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 350
parser: Shift 'DOT', go to state 245
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID' in state 245
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'ORDER' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 245.
parser: ... then shift 'nm', pending reduce 110
parser: Reduce 110 [dbnm ::= DOT nm], go to state 350.
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 123 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 349
parser: Reduce 122 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 348
parser: Reduce 127 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 105
parser: Reduce 105 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 102 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 363
parser: Reduce 147 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 362
parser: Reduce 138 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 361
parser: Reduce 140 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 517
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 517
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 419
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 134 [sortorder ::=].
parser: ... then shift 'sortorder', go to state 353
parser: Reduce 137 [nulls ::=].
parser: ... then shift 'nulls', pending reduce 131
parser: Reduce 131 [sortlist ::= expr sortorder nulls], go to state 26.
parser: ... then shift 'sortlist', go to state 516
parser: Reduce 129 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 360
parser: Reduce 142 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 88
parser: Reduce 88 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 83 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 80
parser: Reduce 80 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
VDBE Trace:
   0 Init             0   13    0               00 Start at 13
  13 Transaction      1    0    0 4             00 usesStmtJournal=0
  14 Goto             0    1    0               00 
   1 Noop             1    7    0               00 
   2 OpenRead         0    1    1 5             00 root=1 iDb=1; sqlite_temp_master
   3 Explain          3    0    0 SCAN TABLE sqlite_temp_master 00 
   4 Rewind           0   12    0               00 
  12 Halt             0    0    0               00 
  36 Halt             0    0    0               00 
parser: [[[CREATE TABLE tr1(t1a, t1b);;SELECT y, v2 FROM x, ex WHERE y>v2;;
;SELECT DISTINCT b FROM a LEFT JOIN ex ON b=v2 ORDER BY +v2;CREATE INDEX x1 ON a(b)
;CREATE INDEX z ON a(b)
;CREATE INDEX example ON ex(v2)
;;SELECT count(*) FROM sqlite_master WHERE tbl_name = 'e' AND type = 'index';;
;CREATE TABLE example_idx_00000042(id PRIMARY KEY, UNIQUE(id) );;BEGIN;;CREATE UNIQUE INDEX IF NOT EXISTS a_id ON a(b==0);;SELECT * FROM ex;]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 390
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 0.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP ID]
parser: Input 'COMMA' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 192
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 379
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 152
parser: Reduce 336 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'RP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Reduce 61 [conslist_opt ::=].
parser: ... then shift 'conslist_opt', go to state 540
parser: Shift 'RP', go to state 364
parser: Return. Stack=[create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 364
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: [[[UPDATE 'main'.sqlite_master SET type='table', name='tr1', tbl_name='tr1', rootpage=#2, sql='CREATE TABLE tr1(t1a, t1b)' WHERE rowid=#1]]]
parser: Input 'UPDATE' in state 0
parser: Reduce 380 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'UPDATE', go to state 299
parser: Return. Stack=[with UPDATE]
parser: Input 'STRING' in state 299
parser: Reduce 71 [orconf ::=].
parser: ... then shift 'orconf', go to state 167
parser: Shift 'STRING', pending reduce 338
parser: Return. Stack=[with UPDATE orconf STRING]
parser: Input 'DOT' with pending reduce 338
parser: Reduce 338 [nm ::= STRING], go to state 167.
parser: ... then shift 'nm', go to state 395
parser: Shift 'DOT', go to state 218
parser: Return. Stack=[with UPDATE orconf nm DOT]
parser: Input 'ID' in state 218
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[with UPDATE orconf nm DOT ID]
parser: Input 'SET' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 218.
parser: ... then shift 'nm', go to state 432
parser: Reduce 114 [xfullname ::= nm DOT nm], go to state 167.
parser: ... then shift 'xfullname', go to state 271
parser: Reduce 123 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 431
parser: Shift 'SET', go to state 155
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET]
parser: Input 'ID' in state 155
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET ID]
parser: Input 'EQ' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 155.
parser: ... then shift 'nm', go to state 445
parser: Shift 'EQ', go to state 84
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ]
parser: Input 'STRING' in state 84
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ STRING]
parser: Input 'COMMA' in state 539
parser: Reduce 172 [term ::= STRING], go to state 84.
parser: ... then shift 'term', go to state 58
parser: Reduce 152 [setlist ::= nm EQ expr], go to state 155.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 447
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING' in state 86
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'COMMA' in state 539
parser: Reduce 172 [term ::= STRING], go to state 86.
parser: ... then shift 'term', go to state 60
parser: Reduce 150 [setlist ::= setlist COMMA nm EQ expr], go to state 155.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 447
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING' in state 86
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'COMMA' in state 539
parser: Reduce 172 [term ::= STRING], go to state 86.
parser: ... then shift 'term', go to state 60
parser: Reduce 150 [setlist ::= setlist COMMA nm EQ expr], go to state 155.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 447
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'VARIABLE' in state 86
parser: Shift 'VARIABLE', pending reduce 174
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ VARIABLE]
parser: Input 'COMMA' with pending reduce 174
parser: Reduce 174 [expr ::= VARIABLE], go to state 86.
parser: ... then shift 'expr', go to state 60
parser: Reduce 150 [setlist ::= setlist COMMA nm EQ expr], go to state 155.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 447
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING' in state 86
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'WHERE' in state 539
parser: Reduce 172 [term ::= STRING], go to state 86.
parser: ... then shift 'term', go to state 60
parser: Reduce 150 [setlist ::= setlist COMMA nm EQ expr], go to state 155.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 419
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE ID]
parser: Input 'EQ' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr EQ]
parser: Input 'VARIABLE' in state 117
parser: Shift 'VARIABLE', pending reduce 174
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr EQ VARIABLE]
parser: Input 'SEMI' with pending reduce 174
parser: Reduce 174 [expr ::= VARIABLE], go to state 117.
parser: ... then shift 'expr', go to state 129
parser: Reduce 186 [expr ::= expr EQ|NE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 148 [where_opt ::= WHERE expr], go to state 270.
parser: ... then shift 'where_opt', pending reduce 149
parser: Reduce 149 [cmd ::= with UPDATE orconf xfullname indexed_opt SET setlist where_opt], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Input '$' with pending reduce 327
parser: Reduce 327 [ecmd ::= cmdx SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 323 [input ::= cmdlist], go to state 0.
parser: ... then shift 'input', pending reduce -2
parser: Accept!
parser: ... then shift 'create_table_args', pending reduce 334
parser: Reduce 334 [cmd ::= create_table create_table_args], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
SQL: [CREATE TABLE tr1(t1a, t1b);]
VDBE Trace:
   0 Init             0   28    0               00 Start at 28
  28 Transaction      0    1   12 4             01 usesStmtJournal=0
  29 Goto             0    1    0               00 
   1 ReadCookie       0    3    2               00 
REG[3] =  i:4
   2 If               3    5    0               00 
REG[3] =  i:4
   5 CreateBtree      0    2    1               00 r[2]=root iDb=0 flags=1
REG[2] =  i:8
   6 OpenWrite        0    1    0 5             00 root=1 iDb=0
   7 NewRowid         0    1    0               00 r[1]=rowid
REG[1] =  i:9
   8 Blob             6    3    0              00 r[3]= (len=6)
REG[3] =  tx6[060000000000|......]
   9 Insert           0    3    1               08 intkey=r[1] data=r[3]
REG[3] =  tx6[060000000000|......]
REG[1] =  i:9
  10 Close            0    0    0               00 
  11 Close            0    0    0               00 
  12 Null             0    4    5               00 r[4..5]=NULL
REG[4] =  NULL
  13 OpenWrite        1    1    0 5             00 root=1 iDb=0; sqlite_master
  14 Explain         14    0    0 SEARCH TABLE sqlite_master USING INTEGER PRIMARY KEY (rowid=?) 00 
  15 SeekRowid        1   17    1               00 intkey=r[1]
REG[1] =  i:9
  16 Rowid            1    5    0               00 r[5]=rowid
REG[5] =  i:9
  17 IsNull           5   25    0               00 if r[5]==NULL goto 25
REG[5] =  i:9
  18 String8          0    6    0 table         00 r[6]='table'
REG[6] =   t5[table](8)
  19 String8          0    7    0 tr1           00 r[7]='tr1'
REG[7] =   t3[tr1](8)
  20 String8          0    8    0 tr1           00 r[8]='tr1'
REG[8] =   t3[tr1](8)
  21 Copy             2    9    0               00 r[9]=r[2]
REG[9] =  i:8
  22 String8          0   10    0 CREATE TABLE tr1(t1a, t1b) 00 r[10]='CREATE TABLE tr1(t1a, t1b)'
REG[10] =   t26[CREATE TABLE tr1(t1a, t1b](8)
  23 MakeRecord       6    5    4 BBBDB         00 r[4]=mkrec(r[6..10])
REG[6] =   t5[table](8)
REG[7] =   t3[tr1](8)
REG[8] =   t3[tr1](8)
REG[9] =  i:8
REG[10] =   t26[CREATE TABLE tr1(t1a, t1b](8)
REG[4] =  sx44[0617131301417461626C657472317472310843524541544520|.....Atabletr1tr1.CREATE ]
  24 Insert           1    4    5               00 intkey=r[5] data=r[4]
REG[4] =  sx44[0617131301417461626C657472317472310843524541544520|.....Atabletr1tr1.CREATE ]
REG[5] =  i:9
  25 SetCookie        0    1   13               00 
  26 ParseSchema      0    0    0 tbl_name='tr1' AND type!='trigger' 00 
parser: [[[SELECT*FROM"main".sqlite_master WHERE tbl_name='tr1' AND type!='trigger' ORDER BY rowid]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'STAR' in state 288
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 95 [sclp ::=].
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STAR', pending reduce 97
parser: Return. Stack=[SELECT distinct sclp scanpt STAR]
parser: Input 'FROM' with pending reduce 97
parser: Reduce 97 [selcollist ::= sclp scanpt STAR], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 104 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'DOT' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 350
parser: Shift 'DOT', go to state 245
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID' in state 245
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'WHERE' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 245.
parser: ... then shift 'nm', pending reduce 110
parser: Reduce 110 [dbnm ::= DOT nm], go to state 350.
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 123 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 349
parser: Reduce 122 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 348
parser: Reduce 127 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 105
parser: Reduce 105 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 102 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 363
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[SELECT distinct selcollist from WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 419
parser: Return. Stack=[SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr EQ STRING]
parser: Input 'AND' in state 539
parser: Reduce 172 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 186 [expr ::= expr EQ|NE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'AND', go to state 120
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID' in state 120
parser: Shift 'ID', go to state 419
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'NE' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Shift 'NE', go to state 117
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr NE]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr NE STRING]
parser: Input 'ORDER' in state 539
parser: Reduce 172 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 186 [expr ::= expr EQ|NE expr], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Reduce 183 [expr ::= expr AND expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 148 [where_opt ::= WHERE expr], go to state 363.
parser: ... then shift 'where_opt', go to state 362
parser: Reduce 138 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 361
parser: Reduce 140 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 517
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 517
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 419
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 134 [sortorder ::=].
parser: ... then shift 'sortorder', go to state 353
parser: Reduce 137 [nulls ::=].
parser: ... then shift 'nulls', pending reduce 131
parser: Reduce 131 [sortlist ::= expr sortorder nulls], go to state 26.
parser: ... then shift 'sortlist', go to state 516
parser: Reduce 129 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 360
parser: Reduce 142 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 88
parser: Reduce 88 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 83 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 80
parser: Reduce 80 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
VDBE Trace:
   0 Init             0   17    0               00 Start at 17
  17 Transaction      0    0   13 4             00 usesStmtJournal=0
  18 String8          0    2    0 tr1           00 r[2]='tr1'
REG[2] =   t3[tr1](8)
  19 String8          0    3    0 trigger       00 r[3]='trigger'
REG[3] =   t7[trigger](8)
  20 Goto             0    1    0               00 
   1 Noop             1    7    0               00 
   2 OpenRead         0    1    0 5             00 root=1 iDb=0; sqlite_master
   3 Explain          3    0    0 SCAN TABLE sqlite_master 00 
   4 Rewind           0   16    0               00 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s1[a](8)
   6 Ne               2   15    1 (BINARY)      52 if r[1]!=r[2] goto 15
REG[2] =   t3[tr1](8)
REG[1] =   s1[a](8)
  15 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s2[ex](8)
   6 Ne               2   15    1 (BINARY)      52 if r[1]!=r[2] goto 15
REG[2] =   t3[tr1](8)
REG[1] =   s2[ex](8)
  15 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s1[a](8)
   6 Ne               2   15    1 (BINARY)      52 if r[1]!=r[2] goto 15
REG[2] =   t3[tr1](8)
REG[1] =   s1[a](8)
  15 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s2[t1](8)
   6 Ne               2   15    1 (BINARY)      52 if r[1]!=r[2] goto 15
REG[2] =   t3[tr1](8)
REG[1] =   s2[t1](8)
  15 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s2[t2](8)
   6 Ne               2   15    1 (BINARY)      52 if r[1]!=r[2] goto 15
REG[2] =   t3[tr1](8)
REG[1] =   s2[t2](8)
  15 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s1[x](8)
   6 Ne               2   15    1 (BINARY)      52 if r[1]!=r[2] goto 15
REG[2] =   t3[tr1](8)
REG[1] =   s1[x](8)
  15 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s1[a](8)
   6 Ne               2   15    1 (BINARY)      52 if r[1]!=r[2] goto 15
REG[2] =   t3[tr1](8)
REG[1] =   s1[a](8)
  15 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s1[a](8)
   6 Ne               2   15    1 (BINARY)      52 if r[1]!=r[2] goto 15
REG[2] =   t3[tr1](8)
REG[1] =   s1[a](8)
  15 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s3[tr1](8)
   6 Ne               2   15    1 (BINARY)      52 if r[1]!=r[2] goto 15
REG[2] =   t3[tr1](8)
REG[1] =   s3[tr1](8)
   7 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s5[table](8)
   8 Eq               3   15    1 (BINARY)      52 if r[1]==r[3] goto 15
REG[3] =   t7[trigger](8)
REG[1] =   s5[table](8)
   9 Column           0    0    4               00 r[4]=sqlite_master.type
REG[4] =   s5[table](8)
  10 Column           0    1    5               00 r[5]=sqlite_master.name
REG[5] =   s3[tr1](8)
  11 Column           0    2    6               00 r[6]=sqlite_master.tbl_name
REG[6] =   s3[tr1](8)
  12 Column           0    3    7               00 r[7]=sqlite_master.rootpage
REG[7] =  i:8
  13 Column           0    4    8               00 r[8]=sqlite_master.sql
REG[8] =   s26[CREATE TABLE tr1(t1a, t1b](8)
  14 ResultRow        4    5    0               00 output=r[4..8]
REG[4] =   s5[table](8)
REG[5] =   s3[tr1](8)
REG[6] =   s3[tr1](8)
REG[7] =  i:8
REG[8] =   s26[CREATE TABLE tr1(t1a, t1b](8)
parser: [[[CREATE TABLE tr1(t1a, t1b)]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 390
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 0.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP ID]
parser: Input 'COMMA' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 192
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 379
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 152
parser: Reduce 336 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'ID' in state 34
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP columnlist COMMA ID]
parser: Input 'RP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 34.
parser: ... then shift 'nm', go to state 192
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 34.
parser: ... then shift 'columnname', go to state 385
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 153
parser: Reduce 335 [columnlist ::= columnlist COMMA columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Reduce 61 [conslist_opt ::=].
parser: ... then shift 'conslist_opt', go to state 540
parser: Shift 'RP', go to state 364
parser: Return. Stack=[create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 364
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: ... then shift 'create_table_args', pending reduce 334
parser: Reduce 334 [cmd ::= create_table create_table_args], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
  15 Next             0    5    0               01 
  16 Halt             0    0    0               00 
  27 Halt             0    0    0               00 
parser: [[[;SELECT y, v2 FROM x, ex WHERE y>v2;;
;SELECT DISTINCT b FROM a LEFT JOIN ex ON b=v2 ORDER BY +v2;CREATE INDEX x1 ON a(b)
;CREATE INDEX z ON a(b)
;CREATE INDEX example ON ex(v2)
;;SELECT count(*) FROM sqlite_master WHERE tbl_name = 'e' AND type = 'index';;
;CREATE TABLE example_idx_00000042(id PRIMARY KEY, UNIQUE(id) );;BEGIN;;CREATE UNIQUE INDEX IF NOT EXISTS a_id ON a(b==0);;SELECT * FROM ex;]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 326
parser: Return. Stack=[SEMI]
parser: Input 'SELECT' with pending reduce 326
parser: Reduce 326 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[ecmd SELECT]
parser: Input 'ID' in state 288
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 95 [sclp ::=].
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 419
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt ID]
parser: Input 'COMMA' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'COMMA', pending reduce 355
parser: Return. Stack=[ecmd SELECT distinct selcollist COMMA]
parser: Input 'ID' with pending reduce 355
parser: Reduce 355 [sclp ::= selcollist COMMA], go to state 198.
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 419
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt ID]
parser: Input 'FROM' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[ecmd SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 104 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[ecmd SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'COMMA' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 350
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 123 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 349
parser: Reduce 122 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 348
parser: Reduce 127 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 105
parser: Reduce 105 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Shift 'COMMA', pending reduce 117
parser: Return. Stack=[ecmd SELECT distinct selcollist FROM seltablist COMMA]
parser: Input 'ID' with pending reduce 117
parser: Reduce 117 [joinop ::= COMMA|JOIN], go to state 263.
parser: ... then shift 'joinop', pending reduce 103
parser: Reduce 103 [stl_prefix ::= seltablist joinop], go to state 197.
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[ecmd SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'WHERE' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 350
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 123 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 349
parser: Reduce 122 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 348
parser: Reduce 127 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 105
parser: Reduce 105 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 102 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 363
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 419
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE ID]
parser: Input 'GT' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'GT', go to state 118
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr GT]
parser: Input 'ID' in state 118
parser: Shift 'ID', go to state 419
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr GT ID]
parser: Input 'SEMI' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 118.
parser: ... then shift 'expr', go to state 130
parser: Reduce 185 [expr ::= expr LT|GT|GE|LE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 148 [where_opt ::= WHERE expr], go to state 363.
parser: ... then shift 'where_opt', go to state 362
parser: Reduce 138 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 361
parser: Reduce 140 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 128 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 360
parser: Reduce 142 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 88
parser: Reduce 88 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 1.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 83 [select ::= selectnowith], go to state 1.
parser: ... then shift 'select', pending reduce 80
parser: Reduce 80 [cmd ::= select], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[ecmd cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping ecmd
SQL: [;SELECT y, v2 FROM x, ex WHERE y>v2;]
VDBE Trace:
   0 Init             0   14    0               00 Start at 14
  14 Transaction      0    0   13 4             01 usesStmtJournal=0
  15 Goto             0    1    0               00 
   1 OpenRead         1    3    0 2             00 root=3 iDb=0; ex
   2 OpenRead         0    5    0 0             00 root=5 iDb=0; x
   3 Explain          3    0    0 SCAN TABLE ex 00 
   4 Rewind           1   13    0               00 
  13 Halt             0    0    0               00 
parser: [[[;
;SELECT DISTINCT b FROM a LEFT JOIN ex ON b=v2 ORDER BY +v2;CREATE INDEX x1 ON a(b)
;CREATE INDEX z ON a(b)
;CREATE INDEX example ON ex(v2)
;;SELECT count(*) FROM sqlite_master WHERE tbl_name = 'e' AND type = 'index';;
;CREATE TABLE example_idx_00000042(id PRIMARY KEY, UNIQUE(id) );;BEGIN;;CREATE UNIQUE INDEX IF NOT EXISTS a_id ON a(b==0);;SELECT * FROM ex;]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 326
parser: Return. Stack=[SEMI]
parser: Input 'SEMI' with pending reduce 326
parser: Reduce 326 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Shift 'SEMI', pending reduce 326
parser: Return. Stack=[ecmd SEMI]
parser: Input 'SELECT' with pending reduce 326
parser: Reduce 326 [ecmd ::= SEMI], go to state 1.
parser: ... then shift 'ecmd', pending reduce 324
parser: Reduce 324 [cmdlist ::= cmdlist ecmd], go to state 0.
parser: ... then shift 'cmdlist', go to state 1
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[cmdlist SELECT]
parser: Input 'DISTINCT' in state 288
parser: Shift 'DISTINCT', pending reduce 92
parser: Return. Stack=[cmdlist SELECT DISTINCT]
parser: Input 'ID' with pending reduce 92
parser: Reduce 92 [distinct ::= DISTINCT], go to state 288.
parser: ... then shift 'distinct', go to state 198
parser: Reduce 95 [sclp ::=].
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 419
parser: Return. Stack=[cmdlist SELECT distinct sclp scanpt ID]
parser: Input 'FROM' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[cmdlist SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 104 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[cmdlist SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'JOIN_KW' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 350
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 123 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 349
parser: Reduce 122 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 348
parser: Reduce 127 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 105
parser: Reduce 105 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Shift 'JOIN_KW', go to state 208
parser: Return. Stack=[cmdlist SELECT distinct selcollist FROM seltablist JOIN_KW]
parser: Input 'JOIN' in state 208
parser: Shift 'JOIN', pending reduce 118
parser: Return. Stack=[cmdlist SELECT distinct selcollist FROM seltablist JOIN_KW JOIN]
parser: Input 'ID' with pending reduce 118
parser: Reduce 118 [joinop ::= JOIN_KW JOIN], go to state 263.
parser: ... then shift 'joinop', pending reduce 103
parser: Reduce 103 [stl_prefix ::= seltablist joinop], go to state 197.
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[cmdlist SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'ON' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 350
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 123 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 349
parser: Shift 'ON', go to state 92
parser: Return. Stack=[cmdlist SELECT distinct selcollist FROM stl_prefix nm dbnm as indexed_opt ON]
parser: Input 'ID' in state 92
parser: Shift 'ID', go to state 419
parser: Return. Stack=[cmdlist SELECT distinct selcollist FROM stl_prefix nm dbnm as indexed_opt ON ID]
parser: Input 'EQ' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 92.
parser: ... then shift 'expr', go to state 62
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[cmdlist SELECT distinct selcollist FROM stl_prefix nm dbnm as indexed_opt ON expr EQ]
parser: Input 'ID' in state 117
parser: Shift 'ID', go to state 419
parser: Return. Stack=[cmdlist SELECT distinct selcollist FROM stl_prefix nm dbnm as indexed_opt ON expr EQ ID]
parser: Input 'ORDER' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 117.
parser: ... then shift 'expr', go to state 129
parser: Reduce 186 [expr ::= expr EQ|NE expr], go to state 92.
parser: ... then shift 'expr', go to state 62
parser: Reduce 121 [on_opt ::= ON expr], go to state 349.
parser: ... then shift 'on_opt', go to state 348
parser: Reduce 127 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 105
parser: Reduce 105 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 102 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 363
parser: Reduce 147 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 362
parser: Reduce 138 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 361
parser: Reduce 140 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 517
parser: Return. Stack=[cmdlist SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 517
parser: Shift 'BY', go to state 26
parser: Return. Stack=[cmdlist SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'PLUS' in state 26
parser: Shift 'PLUS', go to state 103
parser: Return. Stack=[cmdlist SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY PLUS]
parser: Input 'ID' in state 103
parser: Shift 'ID', go to state 419
parser: Return. Stack=[cmdlist SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY PLUS ID]
parser: Input 'SEMI' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 103.
parser: ... then shift 'expr', go to state 149
parser: Reduce 200 [expr ::= PLUS|MINUS expr], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 134 [sortorder ::=].
parser: ... then shift 'sortorder', go to state 353
parser: Reduce 137 [nulls ::=].
parser: ... then shift 'nulls', pending reduce 131
parser: Reduce 131 [sortlist ::= expr sortorder nulls], go to state 26.
parser: ... then shift 'sortlist', go to state 516
parser: Reduce 129 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 360
parser: Reduce 142 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 88
parser: Reduce 88 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 1.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 83 [select ::= selectnowith], go to state 1.
parser: ... then shift 'select', pending reduce 80
parser: Reduce 80 [cmd ::= select], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdlist cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping cmdlist
SQL: [;
;SELECT DISTINCT b FROM a LEFT JOIN ex ON b=v2 ORDER BY +v2;]
VDBE Trace:
   0 Init             0   33    0               00 Start at 33
  33 Transaction      0    0   13 4             01 usesStmtJournal=0
  34 Goto             0    1    0               00 
   1 SorterOpen       2    3    0 k(1,B)        00 
   2 Null             1    6    0               08 r[6]=NULL
REG[6] =  NULL
   3 OpenRead         4    7    0 k(1,)         00 root=7 iDb=0; v1
   4 OpenRead         1    3    0 2             00 root=3 iDb=0; ex
   5 Explain          5    0    0 SCAN TABLE a USING COVERING INDEX v1 00 
   6 Rewind           4   25    1 0             00 
   7 Explain          7    0    0 SCAN TABLE ex 00 
   8 Integer          0    1    0               00 r[1]=0; init LEFT JOIN no-match flag
REG[1] =  i:0
   9 Rewind           1   21    0               00 
  21 IfPos            1   24    0               00 if r[1]>0 then r[1]-=0, goto 24
REG[1] =  i:0
  22 NullRow          1    0    0               00 
  23 Goto             0   13    0               00 
  13 Integer          1    1    0               00 r[1]=1; record LEFT JOIN hit
REG[1] =  i:1
  14 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:1
  15 Eq               5   20    6 (BINARY)      80 if r[6]==r[5] goto 20
REG[5] =  i:1
REG[6] =  NULL
  16 Copy             5    6    0               00 r[6]=r[5]
REG[6] =  i:1
  17 Column           1    1    4               00 r[4]=ex.v2
REG[4] =  NULL
  18 MakeRecord       4    2    7               00 r[7]=mkrec(r[4..5])
REG[7] =  sx3[030009|...]
  19 SorterInsert     2    7    4 2             00 key=r[7]
REG[7] =  sx3[030009|...]
  20 Next             1   10    0               01 
  21 IfPos            1   24    0               00 if r[1]>0 then r[1]-=0, goto 24
REG[1] =  i:1
  24 Next             4    7    0               01 
   7 Explain          7    0    0 SCAN TABLE ex 00 
   8 Integer          0    1    0               00 r[1]=0; init LEFT JOIN no-match flag
REG[1] =  i:0
   9 Rewind           1   21    0               00 
  21 IfPos            1   24    0               00 if r[1]>0 then r[1]-=0, goto 24
REG[1] =  i:0
  22 NullRow          1    0    0               00 
  23 Goto             0   13    0               00 
  13 Integer          1    1    0               00 r[1]=1; record LEFT JOIN hit
REG[1] =  i:1
  14 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:2
  15 Eq               5   20    6 (BINARY)      80 if r[6]==r[5] goto 20
REG[5] =  i:2
REG[6] =  i:1
  16 Copy             5    6    0               00 r[6]=r[5]
REG[6] =  i:2
  17 Column           1    1    4               00 r[4]=ex.v2
REG[4] =  NULL
  18 MakeRecord       4    2    7               00 r[7]=mkrec(r[4..5])
REG[7] =  sx4[03000102|....]
  19 SorterInsert     2    7    4 2             00 key=r[7]
REG[7] =  sx4[03000102|....]
  20 Next             1   10    0               01 
  21 IfPos            1   24    0               00 if r[1]>0 then r[1]-=0, goto 24
REG[1] =  i:1
  24 Next             4    7    0               01 
   7 Explain          7    0    0 SCAN TABLE ex 00 
   8 Integer          0    1    0               00 r[1]=0; init LEFT JOIN no-match flag
REG[1] =  i:0
   9 Rewind           1   21    0               00 
  21 IfPos            1   24    0               00 if r[1]>0 then r[1]-=0, goto 24
REG[1] =  i:0
  22 NullRow          1    0    0               00 
  23 Goto             0   13    0               00 
  13 Integer          1    1    0               00 r[1]=1; record LEFT JOIN hit
REG[1] =  i:1
  14 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:3
  15 Eq               5   20    6 (BINARY)      80 if r[6]==r[5] goto 20
REG[5] =  i:3
REG[6] =  i:2
  16 Copy             5    6    0               00 r[6]=r[5]
REG[6] =  i:3
  17 Column           1    1    4               00 r[4]=ex.v2
REG[4] =  NULL
  18 MakeRecord       4    2    7               00 r[7]=mkrec(r[4..5])
REG[7] =  sx4[03000103|....]
  19 SorterInsert     2    7    4 2             00 key=r[7]
REG[7] =  sx4[03000103|....]
  20 Next             1   10    0               01 
  21 IfPos            1   24    0               00 if r[1]>0 then r[1]-=0, goto 24
REG[1] =  i:1
  24 Next             4    7    0               01 
   7 Explain          7    0    0 SCAN TABLE ex 00 
   8 Integer          0    1    0               00 r[1]=0; init LEFT JOIN no-match flag
REG[1] =  i:0
   9 Rewind           1   21    0               00 
  21 IfPos            1   24    0               00 if r[1]>0 then r[1]-=0, goto 24
REG[1] =  i:0
  22 NullRow          1    0    0               00 
  23 Goto             0   13    0               00 
  13 Integer          1    1    0               00 r[1]=1; record LEFT JOIN hit
REG[1] =  i:1
  14 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:4
  15 Eq               5   20    6 (BINARY)      80 if r[6]==r[5] goto 20
REG[5] =  i:4
REG[6] =  i:3
  16 Copy             5    6    0               00 r[6]=r[5]
REG[6] =  i:4
  17 Column           1    1    4               00 r[4]=ex.v2
REG[4] =  NULL
  18 MakeRecord       4    2    7               00 r[7]=mkrec(r[4..5])
REG[7] =  sx4[03000104|....]
  19 SorterInsert     2    7    4 2             00 key=r[7]
REG[7] =  sx4[03000104|....]
  20 Next             1   10    0               01 
  21 IfPos            1   24    0               00 if r[1]>0 then r[1]-=0, goto 24
REG[1] =  i:1
  24 Next             4    7    0               01 
   7 Explain          7    0    0 SCAN TABLE ex 00 
   8 Integer          0    1    0               00 r[1]=0; init LEFT JOIN no-match flag
REG[1] =  i:0
   9 Rewind           1   21    0               00 
  21 IfPos            1   24    0               00 if r[1]>0 then r[1]-=0, goto 24
REG[1] =  i:0
  22 NullRow          1    0    0               00 
  23 Goto             0   13    0               00 
  13 Integer          1    1    0               00 r[1]=1; record LEFT JOIN hit
REG[1] =  i:1
  14 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:5
  15 Eq               5   20    6 (BINARY)      80 if r[6]==r[5] goto 20
REG[5] =  i:5
REG[6] =  i:4
  16 Copy             5    6    0               00 r[6]=r[5]
REG[6] =  i:5
  17 Column           1    1    4               00 r[4]=ex.v2
REG[4] =  NULL
  18 MakeRecord       4    2    7               00 r[7]=mkrec(r[4..5])
REG[7] =  sx4[03000105|....]
  19 SorterInsert     2    7    4 2             00 key=r[7]
REG[7] =  sx4[03000105|....]
  20 Next             1   10    0               01 
  21 IfPos            1   24    0               00 if r[1]>0 then r[1]-=0, goto 24
REG[1] =  i:1
  24 Next             4    7    0               01 
   7 Explain          7    0    0 SCAN TABLE ex 00 
   8 Integer          0    1    0               00 r[1]=0; init LEFT JOIN no-match flag
REG[1] =  i:0
   9 Rewind           1   21    0               00 
  21 IfPos            1   24    0               00 if r[1]>0 then r[1]-=0, goto 24
REG[1] =  i:0
  22 NullRow          1    0    0               00 
  23 Goto             0   13    0               00 
  13 Integer          1    1    0               00 r[1]=1; record LEFT JOIN hit
REG[1] =  i:1
  14 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:6
  15 Eq               5   20    6 (BINARY)      80 if r[6]==r[5] goto 20
REG[5] =  i:6
REG[6] =  i:5
  16 Copy             5    6    0               00 r[6]=r[5]
REG[6] =  i:6
  17 Column           1    1    4               00 r[4]=ex.v2
REG[4] =  NULL
  18 MakeRecord       4    2    7               00 r[7]=mkrec(r[4..5])
REG[7] =  sx4[03000106|....]
  19 SorterInsert     2    7    4 2             00 key=r[7]
REG[7] =  sx4[03000106|....]
  20 Next             1   10    0               01 
  21 IfPos            1   24    0               00 if r[1]>0 then r[1]-=0, goto 24
REG[1] =  i:1
  24 Next             4    7    0               01 
   7 Explain          7    0    0 SCAN TABLE ex 00 
   8 Integer          0    1    0               00 r[1]=0; init LEFT JOIN no-match flag
REG[1] =  i:0
   9 Rewind           1   21    0               00 
  21 IfPos            1   24    0               00 if r[1]>0 then r[1]-=0, goto 24
REG[1] =  i:0
  22 NullRow          1    0    0               00 
  23 Goto             0   13    0               00 
  13 Integer          1    1    0               00 r[1]=1; record LEFT JOIN hit
REG[1] =  i:1
  14 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:7
  15 Eq               5   20    6 (BINARY)      80 if r[6]==r[5] goto 20
REG[5] =  i:7
REG[6] =  i:6
  16 Copy             5    6    0               00 r[6]=r[5]
REG[6] =  i:7
  17 Column           1    1    4               00 r[4]=ex.v2
REG[4] =  NULL
  18 MakeRecord       4    2    7               00 r[7]=mkrec(r[4..5])
REG[7] =  sx4[03000107|....]
  19 SorterInsert     2    7    4 2             00 key=r[7]
REG[7] =  sx4[03000107|....]
  20 Next             1   10    0               01 
  21 IfPos            1   24    0               00 if r[1]>0 then r[1]-=0, goto 24
REG[1] =  i:1
  24 Next             4    7    0               01 
   7 Explain          7    0    0 SCAN TABLE ex 00 
   8 Integer          0    1    0               00 r[1]=0; init LEFT JOIN no-match flag
REG[1] =  i:0
   9 Rewind           1   21    0               00 
  21 IfPos            1   24    0               00 if r[1]>0 then r[1]-=0, goto 24
REG[1] =  i:0
  22 NullRow          1    0    0               00 
  23 Goto             0   13    0               00 
  13 Integer          1    1    0               00 r[1]=1; record LEFT JOIN hit
REG[1] =  i:1
  14 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:8
  15 Eq               5   20    6 (BINARY)      80 if r[6]==r[5] goto 20
REG[5] =  i:8
REG[6] =  i:7
  16 Copy             5    6    0               00 r[6]=r[5]
REG[6] =  i:8
  17 Column           1    1    4               00 r[4]=ex.v2
REG[4] =  NULL
  18 MakeRecord       4    2    7               00 r[7]=mkrec(r[4..5])
REG[7] =  sx4[03000108|....]
  19 SorterInsert     2    7    4 2             00 key=r[7]
REG[7] =  sx4[03000108|....]
  20 Next             1   10    0               01 
  21 IfPos            1   24    0               00 if r[1]>0 then r[1]-=0, goto 24
REG[1] =  i:1
  24 Next             4    7    0               01 
   7 Explain          7    0    0 SCAN TABLE ex 00 
   8 Integer          0    1    0               00 r[1]=0; init LEFT JOIN no-match flag
REG[1] =  i:0
   9 Rewind           1   21    0               00 
  21 IfPos            1   24    0               00 if r[1]>0 then r[1]-=0, goto 24
REG[1] =  i:0
  22 NullRow          1    0    0               00 
  23 Goto             0   13    0               00 
  13 Integer          1    1    0               00 r[1]=1; record LEFT JOIN hit
REG[1] =  i:1
  14 Column           4    0    5               00 r[5]=a.b
REG[5] =  i:9
  15 Eq               5   20    6 (BINARY)      80 if r[6]==r[5] goto 20
REG[5] =  i:9
REG[6] =  i:8
  16 Copy             5    6    0               00 r[6]=r[5]
REG[6] =  i:9
  17 Column           1    1    4               00 r[4]=ex.v2
REG[4] =  NULL
  18 MakeRecord       4    2    7               00 r[7]=mkrec(r[4..5])
REG[7] =  sx4[03000109|....]
  19 SorterInsert     2    7    4 2             00 key=r[7]
REG[7] =  sx4[03000109|....]
  20 Next             1   10    0               01 
  21 IfPos            1   24    0               00 if r[1]>0 then r[1]-=0, goto 24
REG[1] =  i:1
  24 Next             4    7    0               01 
  25 Explain         25    0    0 USE TEMP B-TREE FOR ORDER BY 00 
  26 OpenPseudo       5    8    3               00 3 columns in r[8]
  27 SorterSort       2   32    0               00 
  28 SorterData       2    8    5               00 r[8]=data
  29 Column           5    1    5               00 r[5]=b
REG[5] =  i:1
  30 ResultRow        5    1    0               00 output=r[5]
REG[5] =  i:1
  31 SorterNext       2   28    0               00 
  28 SorterData       2    8    5               00 r[8]=data
  29 Column           5    1    5               00 r[5]=b
REG[5] =  i:2
  30 ResultRow        5    1    0               00 output=r[5]
REG[5] =  i:2
  31 SorterNext       2   28    0               00 
  28 SorterData       2    8    5               00 r[8]=data
  29 Column           5    1    5               00 r[5]=b
REG[5] =  i:3
  30 ResultRow        5    1    0               00 output=r[5]
REG[5] =  i:3
  31 SorterNext       2   28    0               00 
  28 SorterData       2    8    5               00 r[8]=data
  29 Column           5    1    5               00 r[5]=b
REG[5] =  i:4
  30 ResultRow        5    1    0               00 output=r[5]
REG[5] =  i:4
  31 SorterNext       2   28    0               00 
  28 SorterData       2    8    5               00 r[8]=data
  29 Column           5    1    5               00 r[5]=b
REG[5] =  i:5
  30 ResultRow        5    1    0               00 output=r[5]
REG[5] =  i:5
  31 SorterNext       2   28    0               00 
  28 SorterData       2    8    5               00 r[8]=data
  29 Column           5    1    5               00 r[5]=b
REG[5] =  i:6
  30 ResultRow        5    1    0               00 output=r[5]
REG[5] =  i:6
  31 SorterNext       2   28    0               00 
  28 SorterData       2    8    5               00 r[8]=data
  29 Column           5    1    5               00 r[5]=b
REG[5] =  i:7
  30 ResultRow        5    1    0               00 output=r[5]
REG[5] =  i:7
  31 SorterNext       2   28    0               00 
  28 SorterData       2    8    5               00 r[8]=data
  29 Column           5    1    5               00 r[5]=b
REG[5] =  i:8
  30 ResultRow        5    1    0               00 output=r[5]
REG[5] =  i:8
  31 SorterNext       2   28    0               00 
  28 SorterData       2    8    5               00 r[8]=data
  29 Column           5    1    5               00 r[5]=b
REG[5] =  i:9
  30 ResultRow        5    1    0               00 output=r[5]
REG[5] =  i:9
  31 SorterNext       2   28    0               00 
  32 Halt             0    0    0               00 
parser: [[[CREATE INDEX x1 ON a(b)
;CREATE INDEX z ON a(b)
;CREATE INDEX example ON ex(v2)
;;SELECT count(*) FROM sqlite_master WHERE tbl_name = 'e' AND type = 'index';;
;CREATE TABLE example_idx_00000042(id PRIMARY KEY, UNIQUE(id) );;BEGIN;;CREATE UNIQUE INDEX IF NOT EXISTS a_id ON a(b==0);;SELECT * FROM ex;]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'INDEX' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 225 [uniqueflag ::=].
parser: ... then shift 'uniqueflag', go to state 456
parser: Shift 'INDEX', go to state 315
parser: Return. Stack=[createkw uniqueflag INDEX]
parser: Input 'ID' in state 315
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 225
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists ID]
parser: Input 'ON' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 225.
parser: ... then shift 'nm', go to state 314
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 455
parser: Shift 'ON', go to state 224
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON]
parser: Input 'ID' in state 224
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON ID]
parser: Input 'LP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 224.
parser: ... then shift 'nm', go to state 454
parser: Shift 'LP', go to state 18
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP]
parser: Input 'ID' in state 18
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP ID]
parser: Input 'RP' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 18.
parser: ... then shift 'expr', go to state 13
parser: Reduce 134 [sortorder ::=].
parser: ... then shift 'sortorder', go to state 353
parser: Reduce 137 [nulls ::=].
parser: ... then shift 'nulls', pending reduce 131
parser: Reduce 131 [sortlist ::= expr sortorder nulls], go to state 18.
parser: ... then shift 'sortlist', go to state 402
parser: Shift 'RP', go to state 313
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP]
parser: Input 'SEMI' in state 313
parser: Reduce 147 [where_opt ::=].
parser: ... then shift 'where_opt', pending reduce 223
parser: Reduce 223 [cmd ::= createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP where_opt], go to state 0.
parser: [[[INSERT INTO 'main'.sqlite_master VALUES('index','x1','a',#1,'CREATE INDEX x1 ON a(b)
');]]]
parser: Input 'INSERT' in state 0
parser: Reduce 380 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'INSERT', go to state 311
parser: Return. Stack=[with INSERT]
parser: Input 'INTO' in state 311
parser: Reduce 71 [orconf ::=].
parser: ... then shift 'orconf', pending reduce 160
parser: Reduce 160 [insert_cmd ::= INSERT orconf], go to state 219.
parser: ... then shift 'insert_cmd', go to state 430
parser: Shift 'INTO', go to state 166
parser: Return. Stack=[with insert_cmd INTO]
parser: Input 'STRING' in state 166
parser: Shift 'STRING', pending reduce 338
parser: Return. Stack=[with insert_cmd INTO STRING]
parser: Input 'DOT' with pending reduce 338
parser: Reduce 338 [nm ::= STRING], go to state 166.
parser: ... then shift 'nm', go to state 395
parser: Shift 'DOT', go to state 218
parser: Return. Stack=[with insert_cmd INTO nm DOT]
parser: Input 'ID' in state 218
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[with insert_cmd INTO nm DOT ID]
parser: Input 'VALUES' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 218.
parser: ... then shift 'nm', go to state 432
parser: Reduce 114 [xfullname ::= nm DOT nm], go to state 166.
parser: ... then shift 'xfullname', go to state 298
parser: Reduce 162 [idlist_opt ::=].
parser: ... then shift 'idlist_opt', go to state 35
parser: Shift 'VALUES', go to state 528
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES]
parser: Input 'LP' in state 528
parser: Shift 'LP', go to state 28
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP]
parser: Input 'STRING' in state 28
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP STRING]
parser: Input 'COMMA' in state 539
parser: Reduce 172 [term ::= STRING], go to state 28.
parser: ... then shift 'term', go to state 70
parser: Reduce 220 [nexprlist ::= expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 413
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'STRING' in state 107
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA STRING]
parser: Input 'COMMA' in state 539
parser: Reduce 172 [term ::= STRING], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 219 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 413
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'STRING' in state 107
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA STRING]
parser: Input 'COMMA' in state 539
parser: Reduce 172 [term ::= STRING], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 219 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 413
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'VARIABLE' in state 107
parser: Shift 'VARIABLE', pending reduce 174
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA VARIABLE]
parser: Input 'COMMA' with pending reduce 174
parser: Reduce 174 [expr ::= VARIABLE], go to state 107.
parser: ... then shift 'expr', go to state 71
parser: Reduce 219 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 413
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'STRING' in state 107
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA STRING]
parser: Input 'RP' in state 539
parser: Reduce 172 [term ::= STRING], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 219 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 413
parser: Shift 'RP', pending reduce 90
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist RP]
parser: Input 'SEMI' with pending reduce 90
parser: Reduce 90 [values ::= VALUES LP nexprlist RP], go to state 35.
parser: ... then shift 'values', go to state 534
parser: Reduce 354 [oneselect ::= values], go to state 35.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 83 [select ::= selectnowith], go to state 35.
parser: ... then shift 'select', go to state 297
parser: Reduce 156 [upsert ::=].
parser: ... then shift 'upsert', pending reduce 154
parser: Reduce 154 [cmd ::= with insert_cmd INTO xfullname idlist_opt select upsert], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Input '$' with pending reduce 327
parser: Reduce 327 [ecmd ::= cmdx SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 323 [input ::= cmdlist], go to state 0.
parser: ... then shift 'input', pending reduce -2
parser: Accept!
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
SQL: [CREATE INDEX x1 ON a(b)
;]
VDBE Trace:
   0 Init             0   32    0               00 Start at 32
  32 Transaction      0    1   13 4             01 usesStmtJournal=1
  33 Goto             0    1    0               00 
   1 Noop             0   31    0               00 
   2 CreateBtree      0    1    2               00 r[1]=root iDb=0 flags=2
REG[1] =  i:9
   3 OpenWrite        0    1    0 5             00 root=1 iDb=0; sqlite_master
   4 NewRowid         0    2    0               00 r[2]=rowid
REG[2] =  i:10
   5 String8          0    3    0 index         00 r[3]='index'
REG[3] =   t5[index](8)
   6 String8          0    4    0 x1            00 r[4]='x1'
REG[4] =   t2[x1](8)
   7 String8          0    5    0 a             00 r[5]='a'
REG[5] =   t1[a](8)
   8 Copy             1    6    0               00 r[6]=r[1]
REG[6] =  i:9
   9 String8          0    7    0 CREATE INDEX x1 ON a(b)
 00 r[7]='CREATE INDEX x1 ON a(b)
'
REG[7] =   t24[CREATE INDEX x1 ON a(b).](8)
  10 MakeRecord       3    5    8 BBBDB         00 r[8]=mkrec(r[3..7])
REG[3] =   t5[index](8)
REG[4] =   t2[x1](8)
REG[5] =   t1[a](8)
REG[6] =  i:9
REG[7] =   t24[CREATE INDEX x1 ON a(b).](8)
REG[8] =  sx39[0617110F013D696E6465787831610943524541544520494E44|.....=indexx1a.CREATE IND]
  11 Insert           0    8    2               18 intkey=r[2] data=r[8]
REG[8] =  sx39[0617110F013D696E6465787831610943524541544520494E44|.....=indexx1a.CREATE IND]
REG[2] =  i:10
  12 SorterOpen       3    0    1 k(1,)         00 
  13 OpenRead         1    2    0 k(1,)         00 root=2 iDb=0; a
  14 Rewind           1   19    0               00 
  15 Column           1    0   10               00 r[10]=a.b
REG[10] =  i:1
  16 MakeRecord      10    1    9               00 r[9]=mkrec(r[10])
REG[9] =  sx2[0209|..]
  17 SorterInsert     3    9    0               00 key=r[9]
REG[9] =  sx2[0209|..]
  18 Next             1   15    0               00 
  15 Column           1    0   10               00 r[10]=a.b
REG[10] =  i:2
  16 MakeRecord      10    1    9               00 r[9]=mkrec(r[10])
REG[9] =  sx3[020102|...]
  17 SorterInsert     3    9    0               00 key=r[9]
REG[9] =  sx3[020102|...]
  18 Next             1   15    0               00 
  15 Column           1    0   10               00 r[10]=a.b
REG[10] =  i:3
  16 MakeRecord      10    1    9               00 r[9]=mkrec(r[10])
REG[9] =  sx3[020103|...]
  17 SorterInsert     3    9    0               00 key=r[9]
REG[9] =  sx3[020103|...]
  18 Next             1   15    0               00 
  15 Column           1    0   10               00 r[10]=a.b
REG[10] =  i:4
  16 MakeRecord      10    1    9               00 r[9]=mkrec(r[10])
REG[9] =  sx3[020104|...]
  17 SorterInsert     3    9    0               00 key=r[9]
REG[9] =  sx3[020104|...]
  18 Next             1   15    0               00 
  15 Column           1    0   10               00 r[10]=a.b
REG[10] =  i:5
  16 MakeRecord      10    1    9               00 r[9]=mkrec(r[10])
REG[9] =  sx3[020105|...]
  17 SorterInsert     3    9    0               00 key=r[9]
REG[9] =  sx3[020105|...]
  18 Next             1   15    0               00 
  15 Column           1    0   10               00 r[10]=a.b
REG[10] =  i:6
  16 MakeRecord      10    1    9               00 r[9]=mkrec(r[10])
REG[9] =  sx3[020106|...]
  17 SorterInsert     3    9    0               00 key=r[9]
REG[9] =  sx3[020106|...]
  18 Next             1   15    0               00 
  15 Column           1    0   10               00 r[10]=a.b
REG[10] =  i:7
  16 MakeRecord      10    1    9               00 r[9]=mkrec(r[10])
REG[9] =  sx3[020107|...]
  17 SorterInsert     3    9    0               00 key=r[9]
REG[9] =  sx3[020107|...]
  18 Next             1   15    0               00 
  15 Column           1    0   10               00 r[10]=a.b
REG[10] =  i:8
  16 MakeRecord      10    1    9               00 r[9]=mkrec(r[10])
REG[9] =  sx3[020108|...]
  17 SorterInsert     3    9    0               00 key=r[9]
REG[9] =  sx3[020108|...]
  18 Next             1   15    0               00 
  15 Column           1    0   10               00 r[10]=a.b
REG[10] =  i:9
  16 MakeRecord      10    1    9               00 r[9]=mkrec(r[10])
REG[9] =  sx3[020109|...]
  17 SorterInsert     3    9    0               00 key=r[9]
REG[9] =  sx3[020109|...]
  18 Next             1   15    0               00 
  19 OpenWrite        2    1    0 k(1,)         11 root=1 iDb=0
  20 SorterSort       3   25    0               00 
  21 SorterData       3    9    2               00 r[9]=data
  22 SeekEnd          2    0    0               00 
  23 IdxInsert        2    9    0               10 key=r[9]
REG[9] =  sx2[0209|..]
  24 SorterNext       3   21    0               00 
  21 SorterData       3    9    2               00 r[9]=data
  22 SeekEnd          2    0    0               00 
  23 IdxInsert        2    9    0               10 key=r[9]
REG[9] =  sx3[020102|...]
  24 SorterNext       3   21    0               00 
  21 SorterData       3    9    2               00 r[9]=data
  22 SeekEnd          2    0    0               00 
  23 IdxInsert        2    9    0               10 key=r[9]
REG[9] =  sx3[020103|...]
  24 SorterNext       3   21    0               00 
  21 SorterData       3    9    2               00 r[9]=data
  22 SeekEnd          2    0    0               00 
  23 IdxInsert        2    9    0               10 key=r[9]
REG[9] =  sx3[020104|...]
  24 SorterNext       3   21    0               00 
  21 SorterData       3    9    2               00 r[9]=data
  22 SeekEnd          2    0    0               00 
  23 IdxInsert        2    9    0               10 key=r[9]
REG[9] =  sx3[020105|...]
  24 SorterNext       3   21    0               00 
  21 SorterData       3    9    2               00 r[9]=data
  22 SeekEnd          2    0    0               00 
  23 IdxInsert        2    9    0               10 key=r[9]
REG[9] =  sx3[020106|...]
  24 SorterNext       3   21    0               00 
  21 SorterData       3    9    2               00 r[9]=data
  22 SeekEnd          2    0    0               00 
  23 IdxInsert        2    9    0               10 key=r[9]
REG[9] =  sx3[020107|...]
  24 SorterNext       3   21    0               00 
  21 SorterData       3    9    2               00 r[9]=data
  22 SeekEnd          2    0    0               00 
  23 IdxInsert        2    9    0               10 key=r[9]
REG[9] =  sx3[020108|...]
  24 SorterNext       3   21    0               00 
  21 SorterData       3    9    2               00 r[9]=data
  22 SeekEnd          2    0    0               00 
  23 IdxInsert        2    9    0               10 key=r[9]
REG[9] =  sx3[020109|...]
  24 SorterNext       3   21    0               00 
  25 Close            1    0    0               00 
  26 Close            2    0    0               00 
  27 Close            3    0    0               00 
  28 SetCookie        0    1   14               00 
  29 ParseSchema      0    0    0 name='x1' AND type='index' 00 
parser: [[[SELECT*FROM"main".sqlite_master WHERE name='x1' AND type='index' ORDER BY rowid]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'STAR' in state 288
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 95 [sclp ::=].
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STAR', pending reduce 97
parser: Return. Stack=[SELECT distinct sclp scanpt STAR]
parser: Input 'FROM' with pending reduce 97
parser: Reduce 97 [selcollist ::= sclp scanpt STAR], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 104 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'DOT' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 350
parser: Shift 'DOT', go to state 245
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID' in state 245
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'WHERE' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 245.
parser: ... then shift 'nm', pending reduce 110
parser: Reduce 110 [dbnm ::= DOT nm], go to state 350.
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 123 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 349
parser: Reduce 122 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 348
parser: Reduce 127 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 105
parser: Reduce 105 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 102 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 363
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[SELECT distinct selcollist from WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 419
parser: Return. Stack=[SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr EQ STRING]
parser: Input 'AND' in state 539
parser: Reduce 172 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 186 [expr ::= expr EQ|NE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'AND', go to state 120
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID' in state 120
parser: Shift 'ID', go to state 419
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'EQ' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr EQ]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr EQ STRING]
parser: Input 'ORDER' in state 539
parser: Reduce 172 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 186 [expr ::= expr EQ|NE expr], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Reduce 183 [expr ::= expr AND expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 148 [where_opt ::= WHERE expr], go to state 363.
parser: ... then shift 'where_opt', go to state 362
parser: Reduce 138 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 361
parser: Reduce 140 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 517
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 517
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 419
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 134 [sortorder ::=].
parser: ... then shift 'sortorder', go to state 353
parser: Reduce 137 [nulls ::=].
parser: ... then shift 'nulls', pending reduce 131
parser: Reduce 131 [sortlist ::= expr sortorder nulls], go to state 26.
parser: ... then shift 'sortlist', go to state 516
parser: Reduce 129 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 360
parser: Reduce 142 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 88
parser: Reduce 88 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 83 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 80
parser: Reduce 80 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
VDBE Trace:
   0 Init             0   17    0               00 Start at 17
  17 Transaction      0    0   14 4             00 usesStmtJournal=0
  18 String8          0    2    0 x1            00 r[2]='x1'
REG[2] =   t2[x1](8)
  19 String8          0    3    0 index         00 r[3]='index'
REG[3] =   t5[index](8)
  20 Goto             0    1    0               00 
   1 Noop             1    7    0               00 
   2 OpenRead         0    1    0 5             00 root=1 iDb=0; sqlite_master
   3 Explain          3    0    0 SCAN TABLE sqlite_master 00 
   4 Rewind           0   16    0               00 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s1[a](8)
   6 Ne               2   15    1 (BINARY)      52 if r[1]!=r[2] goto 15
REG[2] =   t2[x1](8)
REG[1] =   s1[a](8)
  15 Next             0    5    0               01 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s2[ex](8)
   6 Ne               2   15    1 (BINARY)      52 if r[1]!=r[2] goto 15
REG[2] =   t2[x1](8)
REG[1] =   s2[ex](8)
  15 Next             0    5    0               01 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s2[i2](8)
   6 Ne               2   15    1 (BINARY)      52 if r[1]!=r[2] goto 15
REG[2] =   t2[x1](8)
REG[1] =   s2[i2](8)
  15 Next             0    5    0               01 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s2[t1](8)
   6 Ne               2   15    1 (BINARY)      52 if r[1]!=r[2] goto 15
REG[2] =   t2[x1](8)
REG[1] =   s2[t1](8)
  15 Next             0    5    0               01 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s2[t2](8)
   6 Ne               2   15    1 (BINARY)      52 if r[1]!=r[2] goto 15
REG[2] =   t2[x1](8)
REG[1] =   s2[t2](8)
  15 Next             0    5    0               01 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s1[x](8)
   6 Ne               2   15    1 (BINARY)      52 if r[1]!=r[2] goto 15
REG[2] =   t2[x1](8)
REG[1] =   s1[x](8)
  15 Next             0    5    0               01 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s1[c](8)
   6 Ne               2   15    1 (BINARY)      52 if r[1]!=r[2] goto 15
REG[2] =   t2[x1](8)
REG[1] =   s1[c](8)
  15 Next             0    5    0               01 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s2[v1](8)
   6 Ne               2   15    1 (BINARY)      52 if r[1]!=r[2] goto 15
REG[2] =   t2[x1](8)
REG[1] =   s2[v1](8)
  15 Next             0    5    0               01 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s3[tr1](8)
   6 Ne               2   15    1 (BINARY)      52 if r[1]!=r[2] goto 15
REG[2] =   t2[x1](8)
REG[1] =   s3[tr1](8)
  15 Next             0    5    0               01 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s2[x1](8)
   6 Ne               2   15    1 (BINARY)      52 if r[1]!=r[2] goto 15
REG[2] =   t2[x1](8)
REG[1] =   s2[x1](8)
   7 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s5[index](8)
   8 Ne               3   15    1 (BINARY)      52 if r[1]!=r[3] goto 15
REG[3] =   t5[index](8)
REG[1] =   s5[index](8)
   9 Column           0    0    4               00 r[4]=sqlite_master.type
REG[4] =   s5[index](8)
  10 Column           0    1    5               00 r[5]=sqlite_master.name
REG[5] =   s2[x1](8)
  11 Column           0    2    6               00 r[6]=sqlite_master.tbl_name
REG[6] =   s1[a](8)
  12 Column           0    3    7               00 r[7]=sqlite_master.rootpage
REG[7] =  i:9
  13 Column           0    4    8               00 r[8]=sqlite_master.sql
REG[8] =   s24[CREATE INDEX x1 ON a(b).](8)
  14 ResultRow        4    5    0               00 output=r[4..8]
REG[4] =   s5[index](8)
REG[5] =   s2[x1](8)
REG[6] =   s1[a](8)
REG[7] =  i:9
REG[8] =   s24[CREATE INDEX x1 ON a(b).](8)
parser: [[[CREATE INDEX x1 ON a(b)
]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'INDEX' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 225 [uniqueflag ::=].
parser: ... then shift 'uniqueflag', go to state 456
parser: Shift 'INDEX', go to state 315
parser: Return. Stack=[createkw uniqueflag INDEX]
parser: Input 'ID' in state 315
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 225
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists ID]
parser: Input 'ON' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 225.
parser: ... then shift 'nm', go to state 314
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 455
parser: Shift 'ON', go to state 224
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON]
parser: Input 'ID' in state 224
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON ID]
parser: Input 'LP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 224.
parser: ... then shift 'nm', go to state 454
parser: Shift 'LP', go to state 18
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP]
parser: Input 'ID' in state 18
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP ID]
parser: Input 'RP' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 18.
parser: ... then shift 'expr', go to state 13
parser: Reduce 134 [sortorder ::=].
parser: ... then shift 'sortorder', go to state 353
parser: Reduce 137 [nulls ::=].
parser: ... then shift 'nulls', pending reduce 131
parser: Reduce 131 [sortlist ::= expr sortorder nulls], go to state 18.
parser: ... then shift 'sortlist', go to state 402
parser: Shift 'RP', go to state 313
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP]
parser: Input 'SEMI' in state 313
parser: Reduce 147 [where_opt ::=].
parser: ... then shift 'where_opt', pending reduce 223
parser: Reduce 223 [cmd ::= createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP where_opt], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
  15 Next             0    5    0               01 
  16 Halt             0    0    0               00 
  30 Expire           0    1    0               00 
  31 Halt             0    0    0               00 
parser: [[[CREATE INDEX z ON a(b)
;CREATE INDEX example ON ex(v2)
;;SELECT count(*) FROM sqlite_master WHERE tbl_name = 'e' AND type = 'index';;
;CREATE TABLE example_idx_00000042(id PRIMARY KEY, UNIQUE(id) );;BEGIN;;CREATE UNIQUE INDEX IF NOT EXISTS a_id ON a(b==0);;SELECT * FROM ex;]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'INDEX' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 225 [uniqueflag ::=].
parser: ... then shift 'uniqueflag', go to state 456
parser: Shift 'INDEX', go to state 315
parser: Return. Stack=[createkw uniqueflag INDEX]
parser: Input 'ID' in state 315
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 225
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists ID]
parser: Input 'ON' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 225.
parser: ... then shift 'nm', go to state 314
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 455
parser: Shift 'ON', go to state 224
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON]
parser: Input 'ID' in state 224
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON ID]
parser: Input 'LP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 224.
parser: ... then shift 'nm', go to state 454
parser: Shift 'LP', go to state 18
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP]
parser: Input 'ID' in state 18
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP ID]
parser: Input 'RP' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 18.
parser: ... then shift 'expr', go to state 13
parser: Reduce 134 [sortorder ::=].
parser: ... then shift 'sortorder', go to state 353
parser: Reduce 137 [nulls ::=].
parser: ... then shift 'nulls', pending reduce 131
parser: Reduce 131 [sortlist ::= expr sortorder nulls], go to state 18.
parser: ... then shift 'sortlist', go to state 402
parser: Shift 'RP', go to state 313
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP]
parser: Input 'SEMI' in state 313
parser: Reduce 147 [where_opt ::=].
parser: ... then shift 'where_opt', pending reduce 223
parser: Reduce 223 [cmd ::= createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP where_opt], go to state 0.
parser: [[[INSERT INTO 'main'.sqlite_master VALUES('index','z','a',#1,'CREATE INDEX z ON a(b)
');]]]
parser: Input 'INSERT' in state 0
parser: Reduce 380 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'INSERT', go to state 311
parser: Return. Stack=[with INSERT]
parser: Input 'INTO' in state 311
parser: Reduce 71 [orconf ::=].
parser: ... then shift 'orconf', pending reduce 160
parser: Reduce 160 [insert_cmd ::= INSERT orconf], go to state 219.
parser: ... then shift 'insert_cmd', go to state 430
parser: Shift 'INTO', go to state 166
parser: Return. Stack=[with insert_cmd INTO]
parser: Input 'STRING' in state 166
parser: Shift 'STRING', pending reduce 338
parser: Return. Stack=[with insert_cmd INTO STRING]
parser: Input 'DOT' with pending reduce 338
parser: Reduce 338 [nm ::= STRING], go to state 166.
parser: ... then shift 'nm', go to state 395
parser: Shift 'DOT', go to state 218
parser: Return. Stack=[with insert_cmd INTO nm DOT]
parser: Input 'ID' in state 218
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[with insert_cmd INTO nm DOT ID]
parser: Input 'VALUES' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 218.
parser: ... then shift 'nm', go to state 432
parser: Reduce 114 [xfullname ::= nm DOT nm], go to state 166.
parser: ... then shift 'xfullname', go to state 298
parser: Reduce 162 [idlist_opt ::=].
parser: ... then shift 'idlist_opt', go to state 35
parser: Shift 'VALUES', go to state 528
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES]
parser: Input 'LP' in state 528
parser: Shift 'LP', go to state 28
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP]
parser: Input 'STRING' in state 28
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP STRING]
parser: Input 'COMMA' in state 539
parser: Reduce 172 [term ::= STRING], go to state 28.
parser: ... then shift 'term', go to state 70
parser: Reduce 220 [nexprlist ::= expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 413
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'STRING' in state 107
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA STRING]
parser: Input 'COMMA' in state 539
parser: Reduce 172 [term ::= STRING], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 219 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 413
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'STRING' in state 107
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA STRING]
parser: Input 'COMMA' in state 539
parser: Reduce 172 [term ::= STRING], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 219 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 413
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'VARIABLE' in state 107
parser: Shift 'VARIABLE', pending reduce 174
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA VARIABLE]
parser: Input 'COMMA' with pending reduce 174
parser: Reduce 174 [expr ::= VARIABLE], go to state 107.
parser: ... then shift 'expr', go to state 71
parser: Reduce 219 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 413
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'STRING' in state 107
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA STRING]
parser: Input 'RP' in state 539
parser: Reduce 172 [term ::= STRING], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 219 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 413
parser: Shift 'RP', pending reduce 90
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist RP]
parser: Input 'SEMI' with pending reduce 90
parser: Reduce 90 [values ::= VALUES LP nexprlist RP], go to state 35.
parser: ... then shift 'values', go to state 534
parser: Reduce 354 [oneselect ::= values], go to state 35.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 83 [select ::= selectnowith], go to state 35.
parser: ... then shift 'select', go to state 297
parser: Reduce 156 [upsert ::=].
parser: ... then shift 'upsert', pending reduce 154
parser: Reduce 154 [cmd ::= with insert_cmd INTO xfullname idlist_opt select upsert], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Input '$' with pending reduce 327
parser: Reduce 327 [ecmd ::= cmdx SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 323 [input ::= cmdlist], go to state 0.
parser: ... then shift 'input', pending reduce -2
parser: Accept!
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
SQL: [CREATE INDEX z ON a(b)
;]
VDBE Trace:
   0 Init             0   32    0               00 Start at 32
  32 Transaction      0    1   14 4             01 usesStmtJournal=1
  33 Goto             0    1    0               00 
   1 Noop             0   31    0               00 
   2 CreateBtree      0    1    2               00 r[1]=root iDb=0 flags=2
REG[1] =  i:10
   3 OpenWrite        0    1    0 5             00 root=1 iDb=0; sqlite_master
   4 NewRowid         0    2    0               00 r[2]=rowid
REG[2] =  i:11
   5 String8          0    3    0 index         00 r[3]='index'
REG[3] =   t5[index](8)
   6 String8          0    4    0 z             00 r[4]='z'
REG[4] =   t1[z](8)
   7 String8          0    5    0 a             00 r[5]='a'
REG[5] =   t1[a](8)
   8 Copy             1    6    0               00 r[6]=r[1]
REG[6] =  i:10
   9 String8          0    7    0 CREATE INDEX z ON a(b)
 00 r[7]='CREATE INDEX z ON a(b)
'
REG[7] =   t23[CREATE INDEX z ON a(b).](8)
  10 MakeRecord       3    5    8 BBBDB         00 r[8]=mkrec(r[3..7])
REG[3] =   t5[index](8)
REG[4] =   t1[z](8)
REG[5] =   t1[a](8)
REG[6] =  i:10
REG[7] =   t23[CREATE INDEX z ON a(b).](8)
REG[8] =  sx37[06170F0F013B696E6465787A610A43524541544520494E4445|.....;indexza.CREATE INDE]
  11 Insert           0    8    2               18 intkey=r[2] data=r[8]
REG[8] =  sx37[06170F0F013B696E6465787A610A43524541544520494E4445|.....;indexza.CREATE INDE]
REG[2] =  i:11
  12 SorterOpen       3    0    1 k(1,)         00 
  13 OpenRead         1    2    0 k(1,)         00 root=2 iDb=0; a
  14 Rewind           1   19    0               00 
  15 Column           1    0   10               00 r[10]=a.b
REG[10] =  i:1
  16 MakeRecord      10    1    9               00 r[9]=mkrec(r[10])
REG[9] =  sx2[0209|..]
  17 SorterInsert     3    9    0               00 key=r[9]
REG[9] =  sx2[0209|..]
  18 Next             1   15    0               00 
  15 Column           1    0   10               00 r[10]=a.b
REG[10] =  i:2
  16 MakeRecord      10    1    9               00 r[9]=mkrec(r[10])
REG[9] =  sx3[020102|...]
  17 SorterInsert     3    9    0               00 key=r[9]
REG[9] =  sx3[020102|...]
  18 Next             1   15    0               00 
  15 Column           1    0   10               00 r[10]=a.b
REG[10] =  i:3
  16 MakeRecord      10    1    9               00 r[9]=mkrec(r[10])
REG[9] =  sx3[020103|...]
  17 SorterInsert     3    9    0               00 key=r[9]
REG[9] =  sx3[020103|...]
  18 Next             1   15    0               00 
  15 Column           1    0   10               00 r[10]=a.b
REG[10] =  i:4
  16 MakeRecord      10    1    9               00 r[9]=mkrec(r[10])
REG[9] =  sx3[020104|...]
  17 SorterInsert     3    9    0               00 key=r[9]
REG[9] =  sx3[020104|...]
  18 Next             1   15    0               00 
  15 Column           1    0   10               00 r[10]=a.b
REG[10] =  i:5
  16 MakeRecord      10    1    9               00 r[9]=mkrec(r[10])
REG[9] =  sx3[020105|...]
  17 SorterInsert     3    9    0               00 key=r[9]
REG[9] =  sx3[020105|...]
  18 Next             1   15    0               00 
  15 Column           1    0   10               00 r[10]=a.b
REG[10] =  i:6
  16 MakeRecord      10    1    9               00 r[9]=mkrec(r[10])
REG[9] =  sx3[020106|...]
  17 SorterInsert     3    9    0               00 key=r[9]
REG[9] =  sx3[020106|...]
  18 Next             1   15    0               00 
  15 Column           1    0   10               00 r[10]=a.b
REG[10] =  i:7
  16 MakeRecord      10    1    9               00 r[9]=mkrec(r[10])
REG[9] =  sx3[020107|...]
  17 SorterInsert     3    9    0               00 key=r[9]
REG[9] =  sx3[020107|...]
  18 Next             1   15    0               00 
  15 Column           1    0   10               00 r[10]=a.b
REG[10] =  i:8
  16 MakeRecord      10    1    9               00 r[9]=mkrec(r[10])
REG[9] =  sx3[020108|...]
  17 SorterInsert     3    9    0               00 key=r[9]
REG[9] =  sx3[020108|...]
  18 Next             1   15    0               00 
  15 Column           1    0   10               00 r[10]=a.b
REG[10] =  i:9
  16 MakeRecord      10    1    9               00 r[9]=mkrec(r[10])
REG[9] =  sx3[020109|...]
  17 SorterInsert     3    9    0               00 key=r[9]
REG[9] =  sx3[020109|...]
  18 Next             1   15    0               00 
  19 OpenWrite        2    1    0 k(1,)         11 root=1 iDb=0
  20 SorterSort       3   25    0               00 
  21 SorterData       3    9    2               00 r[9]=data
  22 SeekEnd          2    0    0               00 
  23 IdxInsert        2    9    0               10 key=r[9]
REG[9] =  sx2[0209|..]
  24 SorterNext       3   21    0               00 
  21 SorterData       3    9    2               00 r[9]=data
  22 SeekEnd          2    0    0               00 
  23 IdxInsert        2    9    0               10 key=r[9]
REG[9] =  sx3[020102|...]
  24 SorterNext       3   21    0               00 
  21 SorterData       3    9    2               00 r[9]=data
  22 SeekEnd          2    0    0               00 
  23 IdxInsert        2    9    0               10 key=r[9]
REG[9] =  sx3[020103|...]
  24 SorterNext       3   21    0               00 
  21 SorterData       3    9    2               00 r[9]=data
  22 SeekEnd          2    0    0               00 
  23 IdxInsert        2    9    0               10 key=r[9]
REG[9] =  sx3[020104|...]
  24 SorterNext       3   21    0               00 
  21 SorterData       3    9    2               00 r[9]=data
  22 SeekEnd          2    0    0               00 
  23 IdxInsert        2    9    0               10 key=r[9]
REG[9] =  sx3[020105|...]
  24 SorterNext       3   21    0               00 
  21 SorterData       3    9    2               00 r[9]=data
  22 SeekEnd          2    0    0               00 
  23 IdxInsert        2    9    0               10 key=r[9]
REG[9] =  sx3[020106|...]
  24 SorterNext       3   21    0               00 
  21 SorterData       3    9    2               00 r[9]=data
  22 SeekEnd          2    0    0               00 
  23 IdxInsert        2    9    0               10 key=r[9]
REG[9] =  sx3[020107|...]
  24 SorterNext       3   21    0               00 
  21 SorterData       3    9    2               00 r[9]=data
  22 SeekEnd          2    0    0               00 
  23 IdxInsert        2    9    0               10 key=r[9]
REG[9] =  sx3[020108|...]
  24 SorterNext       3   21    0               00 
  21 SorterData       3    9    2               00 r[9]=data
  22 SeekEnd          2    0    0               00 
  23 IdxInsert        2    9    0               10 key=r[9]
REG[9] =  sx3[020109|...]
  24 SorterNext       3   21    0               00 
  25 Close            1    0    0               00 
  26 Close            2    0    0               00 
  27 Close            3    0    0               00 
  28 SetCookie        0    1   15               00 
  29 ParseSchema      0    0    0 name='z' AND type='index' 00 
parser: [[[SELECT*FROM"main".sqlite_master WHERE name='z' AND type='index' ORDER BY rowid]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'STAR' in state 288
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 95 [sclp ::=].
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STAR', pending reduce 97
parser: Return. Stack=[SELECT distinct sclp scanpt STAR]
parser: Input 'FROM' with pending reduce 97
parser: Reduce 97 [selcollist ::= sclp scanpt STAR], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 104 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'DOT' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 350
parser: Shift 'DOT', go to state 245
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID' in state 245
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'WHERE' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 245.
parser: ... then shift 'nm', pending reduce 110
parser: Reduce 110 [dbnm ::= DOT nm], go to state 350.
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 123 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 349
parser: Reduce 122 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 348
parser: Reduce 127 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 105
parser: Reduce 105 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 102 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 363
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[SELECT distinct selcollist from WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 419
parser: Return. Stack=[SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr EQ STRING]
parser: Input 'AND' in state 539
parser: Reduce 172 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 186 [expr ::= expr EQ|NE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'AND', go to state 120
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID' in state 120
parser: Shift 'ID', go to state 419
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'EQ' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr EQ]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr EQ STRING]
parser: Input 'ORDER' in state 539
parser: Reduce 172 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 186 [expr ::= expr EQ|NE expr], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Reduce 183 [expr ::= expr AND expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 148 [where_opt ::= WHERE expr], go to state 363.
parser: ... then shift 'where_opt', go to state 362
parser: Reduce 138 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 361
parser: Reduce 140 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 517
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 517
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 419
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 134 [sortorder ::=].
parser: ... then shift 'sortorder', go to state 353
parser: Reduce 137 [nulls ::=].
parser: ... then shift 'nulls', pending reduce 131
parser: Reduce 131 [sortlist ::= expr sortorder nulls], go to state 26.
parser: ... then shift 'sortlist', go to state 516
parser: Reduce 129 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 360
parser: Reduce 142 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 88
parser: Reduce 88 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 83 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 80
parser: Reduce 80 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
VDBE Trace:
   0 Init             0   17    0               00 Start at 17
  17 Transaction      0    0   15 4             00 usesStmtJournal=0
  18 String8          0    2    0 z             00 r[2]='z'
REG[2] =   t1[z](8)
  19 String8          0    3    0 index         00 r[3]='index'
REG[3] =   t5[index](8)
  20 Goto             0    1    0               00 
   1 Noop             1    7    0               00 
   2 OpenRead         0    1    0 5             00 root=1 iDb=0; sqlite_master
   3 Explain          3    0    0 SCAN TABLE sqlite_master 00 
   4 Rewind           0   16    0               00 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s1[a](8)
   6 Ne               2   15    1 (BINARY)      52 if r[1]!=r[2] goto 15
REG[2] =   t1[z](8)
REG[1] =   s1[a](8)
  15 Next             0    5    0               01 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s2[ex](8)
   6 Ne               2   15    1 (BINARY)      52 if r[1]!=r[2] goto 15
REG[2] =   t1[z](8)
REG[1] =   s2[ex](8)
  15 Next             0    5    0               01 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s2[i2](8)
   6 Ne               2   15    1 (BINARY)      52 if r[1]!=r[2] goto 15
REG[2] =   t1[z](8)
REG[1] =   s2[i2](8)
  15 Next             0    5    0               01 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s2[t1](8)
   6 Ne               2   15    1 (BINARY)      52 if r[1]!=r[2] goto 15
REG[2] =   t1[z](8)
REG[1] =   s2[t1](8)
  15 Next             0    5    0               01 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s2[t2](8)
   6 Ne               2   15    1 (BINARY)      52 if r[1]!=r[2] goto 15
REG[2] =   t1[z](8)
REG[1] =   s2[t2](8)
  15 Next             0    5    0               01 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s1[x](8)
   6 Ne               2   15    1 (BINARY)      52 if r[1]!=r[2] goto 15
REG[2] =   t1[z](8)
REG[1] =   s1[x](8)
  15 Next             0    5    0               01 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s1[c](8)
   6 Ne               2   15    1 (BINARY)      52 if r[1]!=r[2] goto 15
REG[2] =   t1[z](8)
REG[1] =   s1[c](8)
  15 Next             0    5    0               01 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s2[v1](8)
   6 Ne               2   15    1 (BINARY)      52 if r[1]!=r[2] goto 15
REG[2] =   t1[z](8)
REG[1] =   s2[v1](8)
  15 Next             0    5    0               01 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s3[tr1](8)
   6 Ne               2   15    1 (BINARY)      52 if r[1]!=r[2] goto 15
REG[2] =   t1[z](8)
REG[1] =   s3[tr1](8)
  15 Next             0    5    0               01 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s2[x1](8)
   6 Ne               2   15    1 (BINARY)      52 if r[1]!=r[2] goto 15
REG[2] =   t1[z](8)
REG[1] =   s2[x1](8)
  15 Next             0    5    0               01 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s1[z](8)
   6 Ne               2   15    1 (BINARY)      52 if r[1]!=r[2] goto 15
REG[2] =   t1[z](8)
REG[1] =   s1[z](8)
   7 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s5[index](8)
   8 Ne               3   15    1 (BINARY)      52 if r[1]!=r[3] goto 15
REG[3] =   t5[index](8)
REG[1] =   s5[index](8)
   9 Column           0    0    4               00 r[4]=sqlite_master.type
REG[4] =   s5[index](8)
  10 Column           0    1    5               00 r[5]=sqlite_master.name
REG[5] =   s1[z](8)
  11 Column           0    2    6               00 r[6]=sqlite_master.tbl_name
REG[6] =   s1[a](8)
  12 Column           0    3    7               00 r[7]=sqlite_master.rootpage
REG[7] =  i:10
  13 Column           0    4    8               00 r[8]=sqlite_master.sql
REG[8] =   s23[CREATE INDEX z ON a(b).](8)
  14 ResultRow        4    5    0               00 output=r[4..8]
REG[4] =   s5[index](8)
REG[5] =   s1[z](8)
REG[6] =   s1[a](8)
REG[7] =  i:10
REG[8] =   s23[CREATE INDEX z ON a(b).](8)
parser: [[[CREATE INDEX z ON a(b)
]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'INDEX' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 225 [uniqueflag ::=].
parser: ... then shift 'uniqueflag', go to state 456
parser: Shift 'INDEX', go to state 315
parser: Return. Stack=[createkw uniqueflag INDEX]
parser: Input 'ID' in state 315
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 225
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists ID]
parser: Input 'ON' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 225.
parser: ... then shift 'nm', go to state 314
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 455
parser: Shift 'ON', go to state 224
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON]
parser: Input 'ID' in state 224
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON ID]
parser: Input 'LP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 224.
parser: ... then shift 'nm', go to state 454
parser: Shift 'LP', go to state 18
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP]
parser: Input 'ID' in state 18
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP ID]
parser: Input 'RP' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 18.
parser: ... then shift 'expr', go to state 13
parser: Reduce 134 [sortorder ::=].
parser: ... then shift 'sortorder', go to state 353
parser: Reduce 137 [nulls ::=].
parser: ... then shift 'nulls', pending reduce 131
parser: Reduce 131 [sortlist ::= expr sortorder nulls], go to state 18.
parser: ... then shift 'sortlist', go to state 402
parser: Shift 'RP', go to state 313
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP]
parser: Input 'SEMI' in state 313
parser: Reduce 147 [where_opt ::=].
parser: ... then shift 'where_opt', pending reduce 223
parser: Reduce 223 [cmd ::= createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP where_opt], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
  15 Next             0    5    0               01 
  16 Halt             0    0    0               00 
  30 Expire           0    1    0               00 
  31 Halt             0    0    0               00 
parser: [[[CREATE INDEX example ON ex(v2)
;;SELECT count(*) FROM sqlite_master WHERE tbl_name = 'e' AND type = 'index';;
;CREATE TABLE example_idx_00000042(id PRIMARY KEY, UNIQUE(id) );;BEGIN;;CREATE UNIQUE INDEX IF NOT EXISTS a_id ON a(b==0);;SELECT * FROM ex;]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'INDEX' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 225 [uniqueflag ::=].
parser: ... then shift 'uniqueflag', go to state 456
parser: Shift 'INDEX', go to state 315
parser: Return. Stack=[createkw uniqueflag INDEX]
parser: Input 'ID' in state 315
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 225
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists ID]
parser: Input 'ON' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 225.
parser: ... then shift 'nm', go to state 314
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 455
parser: Shift 'ON', go to state 224
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON]
parser: Input 'ID' in state 224
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON ID]
parser: Input 'LP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 224.
parser: ... then shift 'nm', go to state 454
parser: Shift 'LP', go to state 18
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP]
parser: Input 'ID' in state 18
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP ID]
parser: Input 'RP' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 18.
parser: ... then shift 'expr', go to state 13
parser: Reduce 134 [sortorder ::=].
parser: ... then shift 'sortorder', go to state 353
parser: Reduce 137 [nulls ::=].
parser: ... then shift 'nulls', pending reduce 131
parser: Reduce 131 [sortlist ::= expr sortorder nulls], go to state 18.
parser: ... then shift 'sortlist', go to state 402
parser: Shift 'RP', go to state 313
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP]
parser: Input 'SEMI' in state 313
parser: Reduce 147 [where_opt ::=].
parser: ... then shift 'where_opt', pending reduce 223
parser: Reduce 223 [cmd ::= createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP where_opt], go to state 0.
parser: [[[INSERT INTO 'main'.sqlite_master VALUES('index','example','ex',#1,'CREATE INDEX example ON ex(v2)
');]]]
parser: Input 'INSERT' in state 0
parser: Reduce 380 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'INSERT', go to state 311
parser: Return. Stack=[with INSERT]
parser: Input 'INTO' in state 311
parser: Reduce 71 [orconf ::=].
parser: ... then shift 'orconf', pending reduce 160
parser: Reduce 160 [insert_cmd ::= INSERT orconf], go to state 219.
parser: ... then shift 'insert_cmd', go to state 430
parser: Shift 'INTO', go to state 166
parser: Return. Stack=[with insert_cmd INTO]
parser: Input 'STRING' in state 166
parser: Shift 'STRING', pending reduce 338
parser: Return. Stack=[with insert_cmd INTO STRING]
parser: Input 'DOT' with pending reduce 338
parser: Reduce 338 [nm ::= STRING], go to state 166.
parser: ... then shift 'nm', go to state 395
parser: Shift 'DOT', go to state 218
parser: Return. Stack=[with insert_cmd INTO nm DOT]
parser: Input 'ID' in state 218
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[with insert_cmd INTO nm DOT ID]
parser: Input 'VALUES' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 218.
parser: ... then shift 'nm', go to state 432
parser: Reduce 114 [xfullname ::= nm DOT nm], go to state 166.
parser: ... then shift 'xfullname', go to state 298
parser: Reduce 162 [idlist_opt ::=].
parser: ... then shift 'idlist_opt', go to state 35
parser: Shift 'VALUES', go to state 528
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES]
parser: Input 'LP' in state 528
parser: Shift 'LP', go to state 28
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP]
parser: Input 'STRING' in state 28
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP STRING]
parser: Input 'COMMA' in state 539
parser: Reduce 172 [term ::= STRING], go to state 28.
parser: ... then shift 'term', go to state 70
parser: Reduce 220 [nexprlist ::= expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 413
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'STRING' in state 107
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA STRING]
parser: Input 'COMMA' in state 539
parser: Reduce 172 [term ::= STRING], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 219 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 413
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'STRING' in state 107
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA STRING]
parser: Input 'COMMA' in state 539
parser: Reduce 172 [term ::= STRING], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 219 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 413
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'VARIABLE' in state 107
parser: Shift 'VARIABLE', pending reduce 174
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA VARIABLE]
parser: Input 'COMMA' with pending reduce 174
parser: Reduce 174 [expr ::= VARIABLE], go to state 107.
parser: ... then shift 'expr', go to state 71
parser: Reduce 219 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 413
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'STRING' in state 107
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA STRING]
parser: Input 'RP' in state 539
parser: Reduce 172 [term ::= STRING], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 219 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 413
parser: Shift 'RP', pending reduce 90
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist RP]
parser: Input 'SEMI' with pending reduce 90
parser: Reduce 90 [values ::= VALUES LP nexprlist RP], go to state 35.
parser: ... then shift 'values', go to state 534
parser: Reduce 354 [oneselect ::= values], go to state 35.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 83 [select ::= selectnowith], go to state 35.
parser: ... then shift 'select', go to state 297
parser: Reduce 156 [upsert ::=].
parser: ... then shift 'upsert', pending reduce 154
parser: Reduce 154 [cmd ::= with insert_cmd INTO xfullname idlist_opt select upsert], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Input '$' with pending reduce 327
parser: Reduce 327 [ecmd ::= cmdx SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 323 [input ::= cmdlist], go to state 0.
parser: ... then shift 'input', pending reduce -2
parser: Accept!
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
SQL: [CREATE INDEX example ON ex(v2)
;]
VDBE Trace:
   0 Init             0   33    0               00 Start at 33
  33 Transaction      0    1   15 4             01 usesStmtJournal=1
  34 Goto             0    1    0               00 
   1 Noop             0   32    0               00 
   2 CreateBtree      0    1    2               00 r[1]=root iDb=0 flags=2
REG[1] =  i:11
   3 OpenWrite        0    1    0 5             00 root=1 iDb=0; sqlite_master
   4 NewRowid         0    2    0               00 r[2]=rowid
REG[2] =  i:12
   5 String8          0    3    0 index         00 r[3]='index'
REG[3] =   t5[index](8)
   6 String8          0    4    0 example       00 r[4]='example'
REG[4] =   t7[example](8)
   7 String8          0    5    0 ex            00 r[5]='ex'
REG[5] =   t2[ex](8)
   8 Copy             1    6    0               00 r[6]=r[1]
REG[6] =  i:11
   9 String8          0    7    0 CREATE INDEX example ON ex(v2)
 00 r[7]='CREATE INDEX example ON ex(v2)
'
REG[7] =   t31[CREATE INDEX example ON e](8)
  10 MakeRecord       3    5    8 BBBDB         00 r[8]=mkrec(r[3..7])
REG[3] =   t5[index](8)
REG[4] =   t7[example](8)
REG[5] =   t2[ex](8)
REG[6] =  i:11
REG[7] =   t31[CREATE INDEX example ON e](8)
REG[8] =  sx52[06171B11014B696E6465786578616D706C6565780B43524541|.....Kindexexampleex.CREA]
  11 Insert           0    8    2               18 intkey=r[2] data=r[8]
REG[8] =  sx52[06171B11014B696E6465786578616D706C6565780B43524541|.....Kindexexampleex.CREA]
REG[2] =  i:12
  12 SorterOpen       3    0    1 k(2,,)        00 
  13 OpenRead         1    3    0 2             00 root=3 iDb=0; ex
  14 Rewind           1   20    0               00 
  20 OpenWrite        2    1    0 k(2,,)        11 root=1 iDb=0
  21 SorterSort       3   26    0               00 
  26 Close            1    0    0               00 
  27 Close            2    0    0               00 
  28 Close            3    0    0               00 
  29 SetCookie        0    1   16               00 
  30 ParseSchema      0    0    0 name='example' AND type='index' 00 
parser: [[[SELECT*FROM"main".sqlite_master WHERE name='example' AND type='index' ORDER BY rowid]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'STAR' in state 288
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 95 [sclp ::=].
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STAR', pending reduce 97
parser: Return. Stack=[SELECT distinct sclp scanpt STAR]
parser: Input 'FROM' with pending reduce 97
parser: Reduce 97 [selcollist ::= sclp scanpt STAR], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 104 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'DOT' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 350
parser: Shift 'DOT', go to state 245
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID' in state 245
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'WHERE' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 245.
parser: ... then shift 'nm', pending reduce 110
parser: Reduce 110 [dbnm ::= DOT nm], go to state 350.
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 123 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 349
parser: Reduce 122 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 348
parser: Reduce 127 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 105
parser: Reduce 105 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 102 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 363
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[SELECT distinct selcollist from WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 419
parser: Return. Stack=[SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr EQ STRING]
parser: Input 'AND' in state 539
parser: Reduce 172 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 186 [expr ::= expr EQ|NE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'AND', go to state 120
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID' in state 120
parser: Shift 'ID', go to state 419
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'EQ' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr EQ]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr EQ STRING]
parser: Input 'ORDER' in state 539
parser: Reduce 172 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 186 [expr ::= expr EQ|NE expr], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Reduce 183 [expr ::= expr AND expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 148 [where_opt ::= WHERE expr], go to state 363.
parser: ... then shift 'where_opt', go to state 362
parser: Reduce 138 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 361
parser: Reduce 140 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 517
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 517
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 419
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 134 [sortorder ::=].
parser: ... then shift 'sortorder', go to state 353
parser: Reduce 137 [nulls ::=].
parser: ... then shift 'nulls', pending reduce 131
parser: Reduce 131 [sortlist ::= expr sortorder nulls], go to state 26.
parser: ... then shift 'sortlist', go to state 516
parser: Reduce 129 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 360
parser: Reduce 142 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 88
parser: Reduce 88 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 83 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 80
parser: Reduce 80 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
VDBE Trace:
   0 Init             0   17    0               00 Start at 17
  17 Transaction      0    0   16 4             00 usesStmtJournal=0
  18 String8          0    2    0 example       00 r[2]='example'
REG[2] =   t7[example](8)
  19 String8          0    3    0 index         00 r[3]='index'
REG[3] =   t5[index](8)
  20 Goto             0    1    0               00 
   1 Noop             1    7    0               00 
   2 OpenRead         0    1    0 5             00 root=1 iDb=0; sqlite_master
   3 Explain          3    0    0 SCAN TABLE sqlite_master 00 
   4 Rewind           0   16    0               00 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s1[a](8)
   6 Ne               2   15    1 (BINARY)      52 if r[1]!=r[2] goto 15
REG[2] =   t7[example](8)
REG[1] =   s1[a](8)
  15 Next             0    5    0               01 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s2[ex](8)
   6 Ne               2   15    1 (BINARY)      52 if r[1]!=r[2] goto 15
REG[2] =   t7[example](8)
REG[1] =   s2[ex](8)
  15 Next             0    5    0               01 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s2[i2](8)
   6 Ne               2   15    1 (BINARY)      52 if r[1]!=r[2] goto 15
REG[2] =   t7[example](8)
REG[1] =   s2[i2](8)
  15 Next             0    5    0               01 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s2[t1](8)
   6 Ne               2   15    1 (BINARY)      52 if r[1]!=r[2] goto 15
REG[2] =   t7[example](8)
REG[1] =   s2[t1](8)
  15 Next             0    5    0               01 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s2[t2](8)
   6 Ne               2   15    1 (BINARY)      52 if r[1]!=r[2] goto 15
REG[2] =   t7[example](8)
REG[1] =   s2[t2](8)
  15 Next             0    5    0               01 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s1[x](8)
   6 Ne               2   15    1 (BINARY)      52 if r[1]!=r[2] goto 15
REG[2] =   t7[example](8)
REG[1] =   s1[x](8)
  15 Next             0    5    0               01 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s1[c](8)
   6 Ne               2   15    1 (BINARY)      52 if r[1]!=r[2] goto 15
REG[2] =   t7[example](8)
REG[1] =   s1[c](8)
  15 Next             0    5    0               01 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s2[v1](8)
   6 Ne               2   15    1 (BINARY)      52 if r[1]!=r[2] goto 15
REG[2] =   t7[example](8)
REG[1] =   s2[v1](8)
  15 Next             0    5    0               01 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s3[tr1](8)
   6 Ne               2   15    1 (BINARY)      52 if r[1]!=r[2] goto 15
REG[2] =   t7[example](8)
REG[1] =   s3[tr1](8)
  15 Next             0    5    0               01 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s2[x1](8)
   6 Ne               2   15    1 (BINARY)      52 if r[1]!=r[2] goto 15
REG[2] =   t7[example](8)
REG[1] =   s2[x1](8)
  15 Next             0    5    0               01 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s1[z](8)
   6 Ne               2   15    1 (BINARY)      52 if r[1]!=r[2] goto 15
REG[2] =   t7[example](8)
REG[1] =   s1[z](8)
  15 Next             0    5    0               01 
   5 Column           0    1    1               00 r[1]=sqlite_master.name
REG[1] =   s7[example](8)
   6 Ne               2   15    1 (BINARY)      52 if r[1]!=r[2] goto 15
REG[2] =   t7[example](8)
REG[1] =   s7[example](8)
   7 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s5[index](8)
   8 Ne               3   15    1 (BINARY)      52 if r[1]!=r[3] goto 15
REG[3] =   t5[index](8)
REG[1] =   s5[index](8)
   9 Column           0    0    4               00 r[4]=sqlite_master.type
REG[4] =   s5[index](8)
  10 Column           0    1    5               00 r[5]=sqlite_master.name
REG[5] =   s7[example](8)
  11 Column           0    2    6               00 r[6]=sqlite_master.tbl_name
REG[6] =   s2[ex](8)
  12 Column           0    3    7               00 r[7]=sqlite_master.rootpage
REG[7] =  i:11
  13 Column           0    4    8               00 r[8]=sqlite_master.sql
REG[8] =   s31[CREATE INDEX example ON e](8)
  14 ResultRow        4    5    0               00 output=r[4..8]
REG[4] =   s5[index](8)
REG[5] =   s7[example](8)
REG[6] =   s2[ex](8)
REG[7] =  i:11
REG[8] =   s31[CREATE INDEX example ON e](8)
parser: [[[CREATE INDEX example ON ex(v2)
]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'INDEX' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 225 [uniqueflag ::=].
parser: ... then shift 'uniqueflag', go to state 456
parser: Shift 'INDEX', go to state 315
parser: Return. Stack=[createkw uniqueflag INDEX]
parser: Input 'ID' in state 315
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 225
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists ID]
parser: Input 'ON' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 225.
parser: ... then shift 'nm', go to state 314
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 455
parser: Shift 'ON', go to state 224
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON]
parser: Input 'ID' in state 224
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON ID]
parser: Input 'LP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 224.
parser: ... then shift 'nm', go to state 454
parser: Shift 'LP', go to state 18
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP]
parser: Input 'ID' in state 18
parser: Shift 'ID', go to state 419
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP ID]
parser: Input 'RP' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 18.
parser: ... then shift 'expr', go to state 13
parser: Reduce 134 [sortorder ::=].
parser: ... then shift 'sortorder', go to state 353
parser: Reduce 137 [nulls ::=].
parser: ... then shift 'nulls', pending reduce 131
parser: Reduce 131 [sortlist ::= expr sortorder nulls], go to state 18.
parser: ... then shift 'sortlist', go to state 402
parser: Shift 'RP', go to state 313
parser: Return. Stack=[createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP]
parser: Input 'SEMI' in state 313
parser: Reduce 147 [where_opt ::=].
parser: ... then shift 'where_opt', pending reduce 223
parser: Reduce 223 [cmd ::= createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP where_opt], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
  15 Next             0    5    0               01 
  16 Halt             0    0    0               00 
  31 Expire           0    1    0               00 
  32 Halt             0    0    0               00 
parser: [[[;SELECT count(*) FROM sqlite_master WHERE tbl_name = 'e' AND type = 'index';;
;CREATE TABLE example_idx_00000042(id PRIMARY KEY, UNIQUE(id) );;BEGIN;;CREATE UNIQUE INDEX IF NOT EXISTS a_id ON a(b==0);;SELECT * FROM ex;]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 326
parser: Return. Stack=[SEMI]
parser: Input 'SELECT' with pending reduce 326
parser: Reduce 326 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[ecmd SELECT]
parser: Input 'ID' in state 288
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 95 [sclp ::=].
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'ID', go to state 419
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt ID]
parser: Input 'LP' in state 419
parser: Shift 'LP', go to state 266
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt ID LP]
parser: Input 'STAR' in state 266
parser: Shift 'STAR', go to state 480
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt ID LP STAR]
parser: Input 'RP' in state 480
parser: Shift 'RP', go to state 145
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt ID LP STAR RP]
parser: Input 'FROM' in state 145
parser: Reduce 178 [expr ::= ID|INDEXED LP STAR RP], go to state 77.
parser: ... then shift 'expr', go to state 16
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 259
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', pending reduce 96
parser: Reduce 96 [selcollist ::= sclp scanpt expr scanpt as], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[ecmd SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 104 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[ecmd SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'WHERE' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 350
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 123 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 349
parser: Reduce 122 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 348
parser: Reduce 127 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 105
parser: Reduce 105 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 102 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 363
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 419
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr EQ STRING]
parser: Input 'AND' in state 539
parser: Reduce 172 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 186 [expr ::= expr EQ|NE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'AND', go to state 120
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID' in state 120
parser: Shift 'ID', go to state 419
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'EQ' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr AND expr EQ]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[ecmd SELECT distinct selcollist from WHERE expr AND expr EQ STRING]
parser: Input 'SEMI' in state 539
parser: Reduce 172 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 186 [expr ::= expr EQ|NE expr], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Reduce 183 [expr ::= expr AND expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 148 [where_opt ::= WHERE expr], go to state 363.
parser: ... then shift 'where_opt', go to state 362
parser: Reduce 138 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 361
parser: Reduce 140 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 128 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 360
parser: Reduce 142 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 88
parser: Reduce 88 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 1.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 83 [select ::= selectnowith], go to state 1.
parser: ... then shift 'select', pending reduce 80
parser: Reduce 80 [cmd ::= select], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[ecmd cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping ecmd
SQL: [;SELECT count(*) FROM sqlite_master WHERE tbl_name = 'e' AND type = 'index';]
VDBE Trace:
   0 Init             0   15    0               00 Start at 15
  15 Transaction      0    0   16 4             01 usesStmtJournal=0
  16 String8          0    3    0 e             00 r[3]='e'
REG[3] =   t1[e](8)
  17 String8          0    4    0 index         00 r[4]='index'
REG[4] =   t5[index](8)
  18 Goto             0    1    0               00 
   1 Null             0    1    1               00 r[1..1]=NULL
REG[1] =  NULL
   2 OpenRead         0    1    0 3             00 root=1 iDb=0; sqlite_master
   3 Explain          3    0    0 SCAN TABLE sqlite_master 00 
   4 Rewind           0   11    0               00 
   5 Column           0    2    2               00 r[2]=sqlite_master.tbl_name
REG[2] =   s1[a](8)
   6 Ne               3   10    2 (BINARY)      52 if r[2]!=r[3] goto 10
REG[3] =   t1[e](8)
REG[2] =   s1[a](8)
  10 Next             0    5    0               01 
   5 Column           0    2    2               00 r[2]=sqlite_master.tbl_name
REG[2] =   s2[ex](8)
   6 Ne               3   10    2 (BINARY)      52 if r[2]!=r[3] goto 10
REG[3] =   t1[e](8)
REG[2] =   s2[ex](8)
  10 Next             0    5    0               01 
   5 Column           0    2    2               00 r[2]=sqlite_master.tbl_name
REG[2] =   s1[a](8)
   6 Ne               3   10    2 (BINARY)      52 if r[2]!=r[3] goto 10
REG[3] =   t1[e](8)
REG[2] =   s1[a](8)
  10 Next             0    5    0               01 
   5 Column           0    2    2               00 r[2]=sqlite_master.tbl_name
REG[2] =   s2[t1](8)
   6 Ne               3   10    2 (BINARY)      52 if r[2]!=r[3] goto 10
REG[3] =   t1[e](8)
REG[2] =   s2[t1](8)
  10 Next             0    5    0               01 
   5 Column           0    2    2               00 r[2]=sqlite_master.tbl_name
REG[2] =   s2[t2](8)
   6 Ne               3   10    2 (BINARY)      52 if r[2]!=r[3] goto 10
REG[3] =   t1[e](8)
REG[2] =   s2[t2](8)
  10 Next             0    5    0               01 
   5 Column           0    2    2               00 r[2]=sqlite_master.tbl_name
REG[2] =   s1[x](8)
   6 Ne               3   10    2 (BINARY)      52 if r[2]!=r[3] goto 10
REG[3] =   t1[e](8)
REG[2] =   s1[x](8)
  10 Next             0    5    0               01 
   5 Column           0    2    2               00 r[2]=sqlite_master.tbl_name
REG[2] =   s1[a](8)
   6 Ne               3   10    2 (BINARY)      52 if r[2]!=r[3] goto 10
REG[3] =   t1[e](8)
REG[2] =   s1[a](8)
  10 Next             0    5    0               01 
   5 Column           0    2    2               00 r[2]=sqlite_master.tbl_name
REG[2] =   s1[a](8)
   6 Ne               3   10    2 (BINARY)      52 if r[2]!=r[3] goto 10
REG[3] =   t1[e](8)
REG[2] =   s1[a](8)
  10 Next             0    5    0               01 
   5 Column           0    2    2               00 r[2]=sqlite_master.tbl_name
REG[2] =   s3[tr1](8)
   6 Ne               3   10    2 (BINARY)      52 if r[2]!=r[3] goto 10
REG[3] =   t1[e](8)
REG[2] =   s3[tr1](8)
  10 Next             0    5    0               01 
   5 Column           0    2    2               00 r[2]=sqlite_master.tbl_name
REG[2] =   s1[a](8)
   6 Ne               3   10    2 (BINARY)      52 if r[2]!=r[3] goto 10
REG[3] =   t1[e](8)
REG[2] =   s1[a](8)
  10 Next             0    5    0               01 
   5 Column           0    2    2               00 r[2]=sqlite_master.tbl_name
REG[2] =   s1[a](8)
   6 Ne               3   10    2 (BINARY)      52 if r[2]!=r[3] goto 10
REG[3] =   t1[e](8)
REG[2] =   s1[a](8)
  10 Next             0    5    0               01 
   5 Column           0    2    2               00 r[2]=sqlite_master.tbl_name
REG[2] =   s2[ex](8)
   6 Ne               3   10    2 (BINARY)      52 if r[2]!=r[3] goto 10
REG[3] =   t1[e](8)
REG[2] =   s2[ex](8)
  10 Next             0    5    0               01 
  11 AggFinal         1    0    0 count(0)      00 accum=r[1] N=0
  12 Copy             1    5    0               00 r[5]=r[1]
REG[5] =  i:0
  13 ResultRow        5    1    0               00 output=r[5]
REG[5] =  i:0
  14 Halt             0    0    0               00 
parser: [[[;
;CREATE TABLE example_idx_00000042(id PRIMARY KEY, UNIQUE(id) );;BEGIN;;CREATE UNIQUE INDEX IF NOT EXISTS a_id ON a(b==0);;SELECT * FROM ex;]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 326
parser: Return. Stack=[SEMI]
parser: Input 'SEMI' with pending reduce 326
parser: Reduce 326 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Shift 'SEMI', pending reduce 326
parser: Return. Stack=[ecmd SEMI]
parser: Input 'CREATE' with pending reduce 326
parser: Reduce 326 [ecmd ::= SEMI], go to state 1.
parser: ... then shift 'ecmd', pending reduce 324
parser: Reduce 324 [cmdlist ::= cmdlist ecmd], go to state 0.
parser: ... then shift 'cmdlist', go to state 1
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[cmdlist CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 1.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 390
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[cmdlist createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[cmdlist createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 1.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[cmdlist create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[cmdlist create_table LP ID]
parser: Input 'PRIMARY' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 192
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 379
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 152
parser: Shift 'PRIMARY', go to state 478
parser: Return. Stack=[cmdlist create_table LP columnname carglist PRIMARY]
parser: Input 'KEY' in state 478
parser: Shift 'KEY', go to state 280
parser: Return. Stack=[cmdlist create_table LP columnname carglist PRIMARY KEY]
parser: Input 'COMMA' in state 280
parser: Reduce 134 [sortorder ::=].
parser: ... then shift 'sortorder', go to state 333
parser: Reduce 69 [onconf ::=].
parser: ... then shift 'onconf', go to state 332
parser: Reduce 43 [autoinc ::=].
parser: ... then shift 'autoinc', pending reduce 37
parser: Reduce 37 [ccons ::= PRIMARY KEY sortorder onconf autoinc], go to state 152.
parser: [[[INSERT INTO 'main'.sqlite_master VALUES('index','sqlite_autoindex_example_idx_00000042_1','example_idx_00000042',#4,NULL);]]]
parser: Input 'INSERT' in state 0
parser: Reduce 380 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'INSERT', go to state 311
parser: Return. Stack=[with INSERT]
parser: Input 'INTO' in state 311
parser: Reduce 71 [orconf ::=].
parser: ... then shift 'orconf', pending reduce 160
parser: Reduce 160 [insert_cmd ::= INSERT orconf], go to state 219.
parser: ... then shift 'insert_cmd', go to state 430
parser: Shift 'INTO', go to state 166
parser: Return. Stack=[with insert_cmd INTO]
parser: Input 'STRING' in state 166
parser: Shift 'STRING', pending reduce 338
parser: Return. Stack=[with insert_cmd INTO STRING]
parser: Input 'DOT' with pending reduce 338
parser: Reduce 338 [nm ::= STRING], go to state 166.
parser: ... then shift 'nm', go to state 395
parser: Shift 'DOT', go to state 218
parser: Return. Stack=[with insert_cmd INTO nm DOT]
parser: Input 'ID' in state 218
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[with insert_cmd INTO nm DOT ID]
parser: Input 'VALUES' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 218.
parser: ... then shift 'nm', go to state 432
parser: Reduce 114 [xfullname ::= nm DOT nm], go to state 166.
parser: ... then shift 'xfullname', go to state 298
parser: Reduce 162 [idlist_opt ::=].
parser: ... then shift 'idlist_opt', go to state 35
parser: Shift 'VALUES', go to state 528
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES]
parser: Input 'LP' in state 528
parser: Shift 'LP', go to state 28
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP]
parser: Input 'STRING' in state 28
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP STRING]
parser: Input 'COMMA' in state 539
parser: Reduce 172 [term ::= STRING], go to state 28.
parser: ... then shift 'term', go to state 70
parser: Reduce 220 [nexprlist ::= expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 413
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'STRING' in state 107
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA STRING]
parser: Input 'COMMA' in state 539
parser: Reduce 172 [term ::= STRING], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 219 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 413
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'STRING' in state 107
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA STRING]
parser: Input 'COMMA' in state 539
parser: Reduce 172 [term ::= STRING], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 219 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 413
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'VARIABLE' in state 107
parser: Shift 'VARIABLE', pending reduce 174
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA VARIABLE]
parser: Input 'COMMA' with pending reduce 174
parser: Reduce 174 [expr ::= VARIABLE], go to state 107.
parser: ... then shift 'expr', go to state 71
parser: Reduce 219 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 413
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'NULL' in state 107
parser: Shift 'NULL', pending reduce 171
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA NULL]
parser: Input 'RP' with pending reduce 171
parser: Reduce 171 [term ::= NULL|FLOAT|BLOB], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 219 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 413
parser: Shift 'RP', pending reduce 90
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist RP]
parser: Input 'SEMI' with pending reduce 90
parser: Reduce 90 [values ::= VALUES LP nexprlist RP], go to state 35.
parser: ... then shift 'values', go to state 534
parser: Reduce 354 [oneselect ::= values], go to state 35.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 83 [select ::= selectnowith], go to state 35.
parser: ... then shift 'select', go to state 297
parser: Reduce 156 [upsert ::=].
parser: ... then shift 'upsert', pending reduce 154
parser: Reduce 154 [cmd ::= with insert_cmd INTO xfullname idlist_opt select upsert], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Input '$' with pending reduce 327
parser: Reduce 327 [ecmd ::= cmdx SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 323 [input ::= cmdlist], go to state 0.
parser: ... then shift 'input', pending reduce -2
parser: Accept!
parser: ... then shift 'ccons', pending reduce 344
parser: Reduce 344 [carglist ::= carglist ccons], go to state 379.
parser: ... then shift 'carglist', go to state 152
parser: Reduce 336 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[cmdlist create_table LP columnlist COMMA]
parser: Input 'UNIQUE' in state 34
parser: Shift 'UNIQUE', go to state 472
parser: Return. Stack=[cmdlist create_table LP columnlist COMMA UNIQUE]
parser: Input 'LP' in state 472
parser: Shift 'LP', go to state 19
parser: Return. Stack=[cmdlist create_table LP columnlist COMMA UNIQUE LP]
parser: Input 'ID' in state 19
parser: Shift 'ID', go to state 419
parser: Return. Stack=[cmdlist create_table LP columnlist COMMA UNIQUE LP ID]
parser: Input 'RP' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 19.
parser: ... then shift 'expr', go to state 13
parser: Reduce 134 [sortorder ::=].
parser: ... then shift 'sortorder', go to state 353
parser: Reduce 137 [nulls ::=].
parser: ... then shift 'nulls', pending reduce 131
parser: Reduce 131 [sortlist ::= expr sortorder nulls], go to state 19.
parser: ... then shift 'sortlist', go to state 404
parser: Shift 'RP', go to state 327
parser: Return. Stack=[cmdlist create_table LP columnlist COMMA UNIQUE LP sortlist RP]
parser: Input 'RP' in state 327
parser: Reduce 69 [onconf ::=].
parser: ... then shift 'onconf', pending reduce 65
parser: Reduce 65 [tcons ::= UNIQUE LP sortlist RP onconf], go to state 34.
parser: ... then shift 'tcons', go to state 278
parser: Reduce 347 [conslist_opt ::= COMMA conslist], go to state 365.
parser: ... then shift 'conslist_opt', go to state 540
parser: Shift 'RP', go to state 364
parser: Return. Stack=[cmdlist create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 364
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: [[[UPDATE 'main'.sqlite_master SET type='table', name='example_idx_00000042', tbl_name='example_idx_00000042', rootpage=#2, sql='CREATE TABLE example_idx_00000042(id PRIMARY KEY, UNIQUE(id) )' WHERE rowid=#1]]]
parser: Input 'UPDATE' in state 0
parser: Reduce 380 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'UPDATE', go to state 299
parser: Return. Stack=[with UPDATE]
parser: Input 'STRING' in state 299
parser: Reduce 71 [orconf ::=].
parser: ... then shift 'orconf', go to state 167
parser: Shift 'STRING', pending reduce 338
parser: Return. Stack=[with UPDATE orconf STRING]
parser: Input 'DOT' with pending reduce 338
parser: Reduce 338 [nm ::= STRING], go to state 167.
parser: ... then shift 'nm', go to state 395
parser: Shift 'DOT', go to state 218
parser: Return. Stack=[with UPDATE orconf nm DOT]
parser: Input 'ID' in state 218
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[with UPDATE orconf nm DOT ID]
parser: Input 'SET' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 218.
parser: ... then shift 'nm', go to state 432
parser: Reduce 114 [xfullname ::= nm DOT nm], go to state 167.
parser: ... then shift 'xfullname', go to state 271
parser: Reduce 123 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 431
parser: Shift 'SET', go to state 155
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET]
parser: Input 'ID' in state 155
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET ID]
parser: Input 'EQ' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 155.
parser: ... then shift 'nm', go to state 445
parser: Shift 'EQ', go to state 84
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ]
parser: Input 'STRING' in state 84
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET nm EQ STRING]
parser: Input 'COMMA' in state 539
parser: Reduce 172 [term ::= STRING], go to state 84.
parser: ... then shift 'term', go to state 58
parser: Reduce 152 [setlist ::= nm EQ expr], go to state 155.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 447
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING' in state 86
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'COMMA' in state 539
parser: Reduce 172 [term ::= STRING], go to state 86.
parser: ... then shift 'term', go to state 60
parser: Reduce 150 [setlist ::= setlist COMMA nm EQ expr], go to state 155.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 447
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING' in state 86
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'COMMA' in state 539
parser: Reduce 172 [term ::= STRING], go to state 86.
parser: ... then shift 'term', go to state 60
parser: Reduce 150 [setlist ::= setlist COMMA nm EQ expr], go to state 155.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 447
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'VARIABLE' in state 86
parser: Shift 'VARIABLE', pending reduce 174
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ VARIABLE]
parser: Input 'COMMA' with pending reduce 174
parser: Reduce 174 [expr ::= VARIABLE], go to state 86.
parser: ... then shift 'expr', go to state 60
parser: Reduce 150 [setlist ::= setlist COMMA nm EQ expr], go to state 155.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'COMMA', go to state 202
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA]
parser: Input 'ID' in state 202
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA ID]
parser: Input 'EQ' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 202.
parser: ... then shift 'nm', go to state 447
parser: Shift 'EQ', go to state 86
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ]
parser: Input 'STRING' in state 86
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist COMMA nm EQ STRING]
parser: Input 'WHERE' in state 539
parser: Reduce 172 [term ::= STRING], go to state 86.
parser: ... then shift 'term', go to state 60
parser: Reduce 150 [setlist ::= setlist COMMA nm EQ expr], go to state 155.
parser: ... then shift 'setlist', go to state 270
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 419
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE ID]
parser: Input 'EQ' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr EQ]
parser: Input 'VARIABLE' in state 117
parser: Shift 'VARIABLE', pending reduce 174
parser: Return. Stack=[with UPDATE orconf xfullname indexed_opt SET setlist WHERE expr EQ VARIABLE]
parser: Input 'SEMI' with pending reduce 174
parser: Reduce 174 [expr ::= VARIABLE], go to state 117.
parser: ... then shift 'expr', go to state 129
parser: Reduce 186 [expr ::= expr EQ|NE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 148 [where_opt ::= WHERE expr], go to state 270.
parser: ... then shift 'where_opt', pending reduce 149
parser: Reduce 149 [cmd ::= with UPDATE orconf xfullname indexed_opt SET setlist where_opt], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Input '$' with pending reduce 327
parser: Reduce 327 [ecmd ::= cmdx SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 323 [input ::= cmdlist], go to state 0.
parser: ... then shift 'input', pending reduce -2
parser: Accept!
parser: ... then shift 'create_table_args', pending reduce 334
parser: Reduce 334 [cmd ::= create_table create_table_args], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdlist cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping cmdlist
SQL: [;
;CREATE TABLE example_idx_00000042(id PRIMARY KEY, UNIQUE(id) );]
VDBE Trace:
   0 Init             0   39    0               00 Start at 39
  39 Transaction      0    1   16 4             01 usesStmtJournal=0
  40 Goto             0    1    0               00 
   1 ReadCookie       0    3    2               00 
REG[3] =  i:4
   2 If               3    5    0               00 
REG[3] =  i:4
   5 CreateBtree      0    2    1               00 r[2]=root iDb=0 flags=1
REG[2] =  i:12
   6 OpenWrite        0    1    0 5             00 root=1 iDb=0
   7 NewRowid         0    1    0               00 r[1]=rowid
REG[1] =  i:13
   8 Blob             6    3    0              00 r[3]= (len=6)
REG[3] =  tx6[060000000000|......]
   9 Insert           0    3    1               08 intkey=r[1] data=r[3]
REG[3] =  tx6[060000000000|......]
REG[1] =  i:13
  10 Close            0    0    0               00 
  11 Noop             0   22    0               00 
  12 CreateBtree      0    4    2               00 r[4]=root iDb=0 flags=2
REG[4] =  i:13
  13 OpenWrite        1    1    0 5             00 root=1 iDb=0; sqlite_master
  14 NewRowid         1    5    0               00 r[5]=rowid
REG[5] =  i:14
  15 String8          0    6    0 index         00 r[6]='index'
REG[6] =   t5[index](8)
  16 String8          0    7    0 sqlite_autoindex_example_idx_00000042_1 00 r[7]='sqlite_autoindex_example_idx_00000042_1'
REG[7] =   t39[sqlite_autoindex_example_](8)
  17 String8          0    8    0 example_idx_00000042 00 r[8]='example_idx_00000042'
REG[8] =   t20[example_idx_00000042](8)
  18 Copy             4    9    0               00 r[9]=r[4]
REG[9] =  i:13
  19 Null             0   10    0               00 r[10]=NULL
REG[10] =  NULL
  20 MakeRecord       6    5   11 BBBDB         00 r[11]=mkrec(r[6..10])
REG[6] =   t5[index](8)
REG[7] =   t39[sqlite_autoindex_example_](8)
REG[8] =   t20[example_idx_00000042](8)
REG[9] =  i:13
REG[10] =  NULL
REG[11] =  sx71[06175B350100696E64657873716C6974655F6175746F696E64|..[5..indexsqlite_autoind]
  21 Insert           1   11    5               18 intkey=r[5] data=r[11]
REG[11] =  sx71[06175B350100696E64657873716C6974655F6175746F696E64|..[5..indexsqlite_autoind]
REG[5] =  i:14
  22 Close            0    0    0               00 
  23 Null             0   12   13               00 r[12..13]=NULL
REG[12] =  NULL
  24 OpenWrite        2    1    0 5             00 root=1 iDb=0; sqlite_master
  25 Explain         25    0    0 SEARCH TABLE sqlite_master USING INTEGER PRIMARY KEY (rowid=?) 00 
  26 SeekRowid        2   28    1               00 intkey=r[1]
REG[1] =  i:13
  27 Rowid            2   13    0               00 r[13]=rowid
REG[13] =  i:13
  28 IsNull          13   36    0               00 if r[13]==NULL goto 36
REG[13] =  i:13
  29 String8          0   14    0 table         00 r[14]='table'
REG[14] =   t5[table](8)
  30 String8          0   15    0 example_idx_00000042 00 r[15]='example_idx_00000042'
REG[15] =   t20[example_idx_00000042](8)
  31 String8          0   16    0 example_idx_00000042 00 r[16]='example_idx_00000042'
REG[16] =   t20[example_idx_00000042](8)
  32 Copy             2   17    0               00 r[17]=r[2]
REG[17] =  i:12
  33 String8          0   18    0 CREATE TABLE example_idx_00000042(id PRIMARY KEY, UNIQUE(id) ) 00 r[18]='CREATE TABLE example_idx_00000042(id PRIMARY KEY, UNIQUE(id) )'
REG[18] =   t62[CREATE TABLE example_idx_](8)
  34 MakeRecord      14    5   12 BBBDB         00 r[12]=mkrec(r[14..18])
REG[14] =   t5[table](8)
REG[15] =   t20[example_idx_00000042](8)
REG[16] =   t20[example_idx_00000042](8)
REG[17] =  i:12
REG[18] =   t62[CREATE TABLE example_idx_](8)
REG[12] =  sx115[071735350181097461626C656578616D706C655F6964785F30|..55...tableexample_idx_0]
  35 Insert           2   12   13               00 intkey=r[13] data=r[12]
REG[12] =  sx115[071735350181097461626C656578616D706C655F6964785F30|..55...tableexample_idx_0]
REG[13] =  i:13
  36 SetCookie        0    1   17               00 
  37 ParseSchema      0    0    0 tbl_name='example_idx_00000042' AND type!='trigger' 00 
parser: [[[SELECT*FROM"main".sqlite_master WHERE tbl_name='example_idx_00000042' AND type!='trigger' ORDER BY rowid]]]
parser: Input 'SELECT' in state 0
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[SELECT]
parser: Input 'STAR' in state 288
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 95 [sclp ::=].
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STAR', pending reduce 97
parser: Return. Stack=[SELECT distinct sclp scanpt STAR]
parser: Input 'FROM' with pending reduce 97
parser: Reduce 97 [selcollist ::= sclp scanpt STAR], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 104 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'DOT' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 350
parser: Shift 'DOT', go to state 245
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT]
parser: Input 'ID' in state 245
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[SELECT distinct selcollist FROM stl_prefix nm DOT ID]
parser: Input 'WHERE' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 245.
parser: ... then shift 'nm', pending reduce 110
parser: Reduce 110 [dbnm ::= DOT nm], go to state 350.
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 123 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 349
parser: Reduce 122 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 348
parser: Reduce 127 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 105
parser: Reduce 105 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 102 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 363
parser: Shift 'WHERE', go to state 93
parser: Return. Stack=[SELECT distinct selcollist from WHERE]
parser: Input 'ID' in state 93
parser: Shift 'ID', go to state 419
parser: Return. Stack=[SELECT distinct selcollist from WHERE ID]
parser: Input 'EQ' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr EQ]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr EQ STRING]
parser: Input 'AND' in state 539
parser: Reduce 172 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 186 [expr ::= expr EQ|NE expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Shift 'AND', go to state 120
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND]
parser: Input 'ID' in state 120
parser: Shift 'ID', go to state 419
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND ID]
parser: Input 'NE' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Shift 'NE', go to state 117
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr NE]
parser: Input 'STRING' in state 117
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[SELECT distinct selcollist from WHERE expr AND expr NE STRING]
parser: Input 'ORDER' in state 539
parser: Reduce 172 [term ::= STRING], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 186 [expr ::= expr EQ|NE expr], go to state 120.
parser: ... then shift 'expr', go to state 76
parser: Reduce 183 [expr ::= expr AND expr], go to state 93.
parser: ... then shift 'expr', go to state 63
parser: Reduce 148 [where_opt ::= WHERE expr], go to state 363.
parser: ... then shift 'where_opt', go to state 362
parser: Reduce 138 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 361
parser: Reduce 140 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Shift 'ORDER', go to state 517
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER]
parser: Input 'BY' in state 517
parser: Shift 'BY', go to state 26
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY]
parser: Input 'ID' in state 26
parser: Shift 'ID', go to state 419
parser: Return. Stack=[SELECT distinct selcollist from where_opt groupby_opt having_opt ORDER BY ID]
parser: Input 'SEMI' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 26.
parser: ... then shift 'expr', go to state 13
parser: Reduce 134 [sortorder ::=].
parser: ... then shift 'sortorder', go to state 353
parser: Reduce 137 [nulls ::=].
parser: ... then shift 'nulls', pending reduce 131
parser: Reduce 131 [sortlist ::= expr sortorder nulls], go to state 26.
parser: ... then shift 'sortlist', go to state 516
parser: Reduce 129 [orderby_opt ::= ORDER BY sortlist], go to state 194.
parser: ... then shift 'orderby_opt', go to state 360
parser: Reduce 142 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 88
parser: Reduce 88 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 0.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 83 [select ::= selectnowith], go to state 0.
parser: ... then shift 'select', pending reduce 80
parser: Reduce 80 [cmd ::= select], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
VDBE Trace:
   0 Init             0   17    0               00 Start at 17
  17 Transaction      0    0   17 4             00 usesStmtJournal=0
  18 String8          0    2    0 example_idx_00000042 00 r[2]='example_idx_00000042'
REG[2] =   t20[example_idx_00000042](8)
  19 String8          0    3    0 trigger       00 r[3]='trigger'
REG[3] =   t7[trigger](8)
  20 Goto             0    1    0               00 
   1 Noop             1    7    0               00 
   2 OpenRead         0    1    0 5             00 root=1 iDb=0; sqlite_master
   3 Explain          3    0    0 SCAN TABLE sqlite_master 00 
   4 Rewind           0   16    0               00 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s1[a](8)
   6 Ne               2   15    1 (BINARY)      52 if r[1]!=r[2] goto 15
REG[2] =   t20[example_idx_00000042](8)
REG[1] =   s1[a](8)
  15 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s2[ex](8)
   6 Ne               2   15    1 (BINARY)      52 if r[1]!=r[2] goto 15
REG[2] =   t20[example_idx_00000042](8)
REG[1] =   s2[ex](8)
  15 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s1[a](8)
   6 Ne               2   15    1 (BINARY)      52 if r[1]!=r[2] goto 15
REG[2] =   t20[example_idx_00000042](8)
REG[1] =   s1[a](8)
  15 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s2[t1](8)
   6 Ne               2   15    1 (BINARY)      52 if r[1]!=r[2] goto 15
REG[2] =   t20[example_idx_00000042](8)
REG[1] =   s2[t1](8)
  15 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s2[t2](8)
   6 Ne               2   15    1 (BINARY)      52 if r[1]!=r[2] goto 15
REG[2] =   t20[example_idx_00000042](8)
REG[1] =   s2[t2](8)
  15 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s1[x](8)
   6 Ne               2   15    1 (BINARY)      52 if r[1]!=r[2] goto 15
REG[2] =   t20[example_idx_00000042](8)
REG[1] =   s1[x](8)
  15 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s1[a](8)
   6 Ne               2   15    1 (BINARY)      52 if r[1]!=r[2] goto 15
REG[2] =   t20[example_idx_00000042](8)
REG[1] =   s1[a](8)
  15 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s1[a](8)
   6 Ne               2   15    1 (BINARY)      52 if r[1]!=r[2] goto 15
REG[2] =   t20[example_idx_00000042](8)
REG[1] =   s1[a](8)
  15 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s3[tr1](8)
   6 Ne               2   15    1 (BINARY)      52 if r[1]!=r[2] goto 15
REG[2] =   t20[example_idx_00000042](8)
REG[1] =   s3[tr1](8)
  15 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s1[a](8)
   6 Ne               2   15    1 (BINARY)      52 if r[1]!=r[2] goto 15
REG[2] =   t20[example_idx_00000042](8)
REG[1] =   s1[a](8)
  15 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s1[a](8)
   6 Ne               2   15    1 (BINARY)      52 if r[1]!=r[2] goto 15
REG[2] =   t20[example_idx_00000042](8)
REG[1] =   s1[a](8)
  15 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s2[ex](8)
   6 Ne               2   15    1 (BINARY)      52 if r[1]!=r[2] goto 15
REG[2] =   t20[example_idx_00000042](8)
REG[1] =   s2[ex](8)
  15 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s20[example_idx_00000042](8)
   6 Ne               2   15    1 (BINARY)      52 if r[1]!=r[2] goto 15
REG[2] =   t20[example_idx_00000042](8)
REG[1] =   s20[example_idx_00000042](8)
   7 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s5[table](8)
   8 Eq               3   15    1 (BINARY)      52 if r[1]==r[3] goto 15
REG[3] =   t7[trigger](8)
REG[1] =   s5[table](8)
   9 Column           0    0    4               00 r[4]=sqlite_master.type
REG[4] =   s5[table](8)
  10 Column           0    1    5               00 r[5]=sqlite_master.name
REG[5] =   s20[example_idx_00000042](8)
  11 Column           0    2    6               00 r[6]=sqlite_master.tbl_name
REG[6] =   s20[example_idx_00000042](8)
  12 Column           0    3    7               00 r[7]=sqlite_master.rootpage
REG[7] =  i:12
  13 Column           0    4    8               00 r[8]=sqlite_master.sql
REG[8] =   s62[CREATE TABLE example_idx_](8)
  14 ResultRow        4    5    0               00 output=r[4..8]
REG[4] =   s5[table](8)
REG[5] =   s20[example_idx_00000042](8)
REG[6] =   s20[example_idx_00000042](8)
REG[7] =  i:12
REG[8] =   s62[CREATE TABLE example_idx_](8)
parser: [[[CREATE TABLE example_idx_00000042(id PRIMARY KEY, UNIQUE(id) )]]]
parser: Input 'CREATE' in state 0
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[CREATE]
parser: Input 'TABLE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 0.
parser: ... then shift 'createkw', go to state 134
parser: Reduce 18 [temp ::=].
parser: ... then shift 'temp', go to state 390
parser: Shift 'TABLE', go to state 324
parser: Return. Stack=[createkw temp TABLE]
parser: Input 'ID' in state 324
parser: Reduce 15 [ifnotexists ::=].
parser: ... then shift 'ifnotexists', go to state 229
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[createkw temp TABLE ifnotexists ID]
parser: Input 'LP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 229.
parser: ... then shift 'nm', go to state 323
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', pending reduce 13
parser: Reduce 13 [create_table ::= createkw temp TABLE ifnotexists nm dbnm], go to state 0.
parser: ... then shift 'create_table', go to state 289
parser: Shift 'LP', go to state 139
parser: Return. Stack=[create_table LP]
parser: Input 'ID' in state 139
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[create_table LP ID]
parser: Input 'PRIMARY' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 139.
parser: ... then shift 'nm', go to state 192
parser: Reduce 24 [typetoken ::=].
parser: ... then shift 'typetoken', pending reduce 23
parser: Reduce 23 [columnname ::= nm typetoken], go to state 139.
parser: ... then shift 'columnname', go to state 379
parser: Reduce 345 [carglist ::=].
parser: ... then shift 'carglist', go to state 152
parser: Shift 'PRIMARY', go to state 478
parser: Return. Stack=[create_table LP columnname carglist PRIMARY]
parser: Input 'KEY' in state 478
parser: Shift 'KEY', go to state 280
parser: Return. Stack=[create_table LP columnname carglist PRIMARY KEY]
parser: Input 'COMMA' in state 280
parser: Reduce 134 [sortorder ::=].
parser: ... then shift 'sortorder', go to state 333
parser: Reduce 69 [onconf ::=].
parser: ... then shift 'onconf', go to state 332
parser: Reduce 43 [autoinc ::=].
parser: ... then shift 'autoinc', pending reduce 37
parser: Reduce 37 [ccons ::= PRIMARY KEY sortorder onconf autoinc], go to state 152.
parser: ... then shift 'ccons', pending reduce 344
parser: Reduce 344 [carglist ::= carglist ccons], go to state 379.
parser: ... then shift 'carglist', go to state 152
parser: Reduce 336 [columnlist ::= columnname carglist], go to state 139.
parser: ... then shift 'columnlist', go to state 365
parser: Shift 'COMMA', go to state 34
parser: Return. Stack=[create_table LP columnlist COMMA]
parser: Input 'UNIQUE' in state 34
parser: Shift 'UNIQUE', go to state 472
parser: Return. Stack=[create_table LP columnlist COMMA UNIQUE]
parser: Input 'LP' in state 472
parser: Shift 'LP', go to state 19
parser: Return. Stack=[create_table LP columnlist COMMA UNIQUE LP]
parser: Input 'ID' in state 19
parser: Shift 'ID', go to state 419
parser: Return. Stack=[create_table LP columnlist COMMA UNIQUE LP ID]
parser: Input 'RP' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 19.
parser: ... then shift 'expr', go to state 13
parser: Reduce 134 [sortorder ::=].
parser: ... then shift 'sortorder', go to state 353
parser: Reduce 137 [nulls ::=].
parser: ... then shift 'nulls', pending reduce 131
parser: Reduce 131 [sortlist ::= expr sortorder nulls], go to state 19.
parser: ... then shift 'sortlist', go to state 404
parser: Shift 'RP', go to state 327
parser: Return. Stack=[create_table LP columnlist COMMA UNIQUE LP sortlist RP]
parser: Input 'RP' in state 327
parser: Reduce 69 [onconf ::=].
parser: ... then shift 'onconf', pending reduce 65
parser: Reduce 65 [tcons ::= UNIQUE LP sortlist RP onconf], go to state 34.
parser: ... then shift 'tcons', go to state 278
parser: Reduce 347 [conslist_opt ::= COMMA conslist], go to state 365.
parser: ... then shift 'conslist_opt', go to state 540
parser: Shift 'RP', go to state 364
parser: Return. Stack=[create_table LP columnlist conslist_opt RP]
parser: Input 'SEMI' in state 364
parser: Reduce 21 [table_options ::=].
parser: ... then shift 'table_options', pending reduce 19
parser: Reduce 19 [create_table_args ::= LP columnlist conslist_opt RP table_options], go to state 289.
parser: ... then shift 'create_table_args', pending reduce 334
parser: Reduce 334 [cmd ::= create_table create_table_args], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
  15 Next             0    5    0               01 
   5 Column           0    2    1               00 r[1]=sqlite_master.tbl_name
REG[1] =   s20[example_idx_00000042](8)
   6 Ne               2   15    1 (BINARY)      52 if r[1]!=r[2] goto 15
REG[2] =   t20[example_idx_00000042](8)
REG[1] =   s20[example_idx_00000042](8)
   7 Column           0    0    1               00 r[1]=sqlite_master.type
REG[1] =   s5[index](8)
   8 Eq               3   15    1 (BINARY)      52 if r[1]==r[3] goto 15
REG[3] =   t7[trigger](8)
REG[1] =   s5[index](8)
   9 Column           0    0    4               00 r[4]=sqlite_master.type
REG[4] =   s5[index](8)
  10 Column           0    1    5               00 r[5]=sqlite_master.name
REG[5] =   s39[sqlite_autoindex_example_](8)
  11 Column           0    2    6               00 r[6]=sqlite_master.tbl_name
REG[6] =   s20[example_idx_00000042](8)
  12 Column           0    3    7               00 r[7]=sqlite_master.rootpage
REG[7] =  i:13
  13 Column           0    4    8               00 r[8]=sqlite_master.sql
REG[8] =  NULL
  14 ResultRow        4    5    0               00 output=r[4..8]
REG[4] =   s5[index](8)
REG[5] =   s39[sqlite_autoindex_example_](8)
REG[6] =   s20[example_idx_00000042](8)
REG[7] =  i:13
REG[8] =  NULL
  15 Next             0    5    0               01 
  16 Halt             0    0    0               00 
  38 Halt             0    0    0               00 
parser: [[[;BEGIN;;CREATE UNIQUE INDEX IF NOT EXISTS a_id ON a(b==0);;SELECT * FROM ex;]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 326
parser: Return. Stack=[SEMI]
parser: Input 'BEGIN' with pending reduce 326
parser: Reduce 326 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Shift 'BEGIN', go to state 268
parser: Return. Stack=[ecmd BEGIN]
parser: Input 'SEMI' in state 268
parser: Reduce 4 [transtype ::=].
parser: ... then shift 'transtype', go to state 370
parser: Reduce 329 [trans_opt ::=].
parser: ... then shift 'trans_opt', pending reduce 3
parser: Reduce 3 [cmd ::= BEGIN transtype trans_opt], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[ecmd cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping ecmd
SQL: [;BEGIN;]
VDBE Trace:
   0 Init             0    1    0               00 Start at 1
   1 AutoCommit       0    0    0               00 
parser: [[[;CREATE UNIQUE INDEX IF NOT EXISTS a_id ON a(b==0);;SELECT * FROM ex;]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 326
parser: Return. Stack=[SEMI]
parser: Input 'CREATE' with pending reduce 326
parser: Reduce 326 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Shift 'CREATE', pending reduce 14
parser: Return. Stack=[ecmd CREATE]
parser: Input 'UNIQUE' with pending reduce 14
parser: Reduce 14 [createkw ::= CREATE], go to state 1.
parser: ... then shift 'createkw', go to state 134
parser: Shift 'UNIQUE', pending reduce 224
parser: Return. Stack=[ecmd createkw UNIQUE]
parser: Input 'INDEX' with pending reduce 224
parser: Reduce 224 [uniqueflag ::= UNIQUE], go to state 134.
parser: ... then shift 'uniqueflag', go to state 456
parser: Shift 'INDEX', go to state 315
parser: Return. Stack=[ecmd createkw uniqueflag INDEX]
parser: Input 'IF' in state 315
parser: Shift 'IF', go to state 466
parser: Return. Stack=[ecmd createkw uniqueflag INDEX IF]
parser: Input 'NOT' in state 466
parser: Shift 'NOT', go to state 465
parser: Return. Stack=[ecmd createkw uniqueflag INDEX IF NOT]
parser: Input 'EXISTS' in state 465
parser: Shift 'EXISTS', pending reduce 16
parser: Return. Stack=[ecmd createkw uniqueflag INDEX IF NOT EXISTS]
parser: Input 'ID' with pending reduce 16
parser: Reduce 16 [ifnotexists ::= IF NOT EXISTS], go to state 315.
parser: ... then shift 'ifnotexists', go to state 225
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[ecmd createkw uniqueflag INDEX ifnotexists ID]
parser: Input 'ON' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 225.
parser: ... then shift 'nm', go to state 314
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 455
parser: Shift 'ON', go to state 224
parser: Return. Stack=[ecmd createkw uniqueflag INDEX ifnotexists nm dbnm ON]
parser: Input 'ID' in state 224
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[ecmd createkw uniqueflag INDEX ifnotexists nm dbnm ON ID]
parser: Input 'LP' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 224.
parser: ... then shift 'nm', go to state 454
parser: Shift 'LP', go to state 18
parser: Return. Stack=[ecmd createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP]
parser: Input 'ID' in state 18
parser: Shift 'ID', go to state 419
parser: Return. Stack=[ecmd createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP ID]
parser: Input 'EQ' in state 419
parser: Reduce 167 [expr ::= ID|INDEXED], go to state 18.
parser: ... then shift 'expr', go to state 13
parser: Shift 'EQ', go to state 117
parser: Return. Stack=[ecmd createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP expr EQ]
parser: Input 'INTEGER' in state 117
parser: Shift 'INTEGER', pending reduce 173
parser: Return. Stack=[ecmd createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP expr EQ INTEGER]
parser: Input 'RP' with pending reduce 173
parser: Reduce 173 [term ::= INTEGER], go to state 117.
parser: ... then shift 'term', go to state 129
parser: Reduce 186 [expr ::= expr EQ|NE expr], go to state 18.
parser: ... then shift 'expr', go to state 13
parser: Reduce 134 [sortorder ::=].
parser: ... then shift 'sortorder', go to state 353
parser: Reduce 137 [nulls ::=].
parser: ... then shift 'nulls', pending reduce 131
parser: Reduce 131 [sortlist ::= expr sortorder nulls], go to state 18.
parser: ... then shift 'sortlist', go to state 402
parser: Shift 'RP', go to state 313
parser: Return. Stack=[ecmd createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP]
parser: Input 'SEMI' in state 313
parser: Reduce 147 [where_opt ::=].
parser: ... then shift 'where_opt', pending reduce 223
parser: Reduce 223 [cmd ::= createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP where_opt], go to state 1.
parser: [[[INSERT INTO 'main'.sqlite_master VALUES('index','a_id','a',#1,'CREATE UNIQUE INDEX a_id ON a(b==0)');]]]
parser: Input 'INSERT' in state 0
parser: Reduce 380 [with ::=].
parser: ... then shift 'with', go to state 219
parser: Shift 'INSERT', go to state 311
parser: Return. Stack=[with INSERT]
parser: Input 'INTO' in state 311
parser: Reduce 71 [orconf ::=].
parser: ... then shift 'orconf', pending reduce 160
parser: Reduce 160 [insert_cmd ::= INSERT orconf], go to state 219.
parser: ... then shift 'insert_cmd', go to state 430
parser: Shift 'INTO', go to state 166
parser: Return. Stack=[with insert_cmd INTO]
parser: Input 'STRING' in state 166
parser: Shift 'STRING', pending reduce 338
parser: Return. Stack=[with insert_cmd INTO STRING]
parser: Input 'DOT' with pending reduce 338
parser: Reduce 338 [nm ::= STRING], go to state 166.
parser: ... then shift 'nm', go to state 395
parser: Shift 'DOT', go to state 218
parser: Return. Stack=[with insert_cmd INTO nm DOT]
parser: Input 'ID' in state 218
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[with insert_cmd INTO nm DOT ID]
parser: Input 'VALUES' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 218.
parser: ... then shift 'nm', go to state 432
parser: Reduce 114 [xfullname ::= nm DOT nm], go to state 166.
parser: ... then shift 'xfullname', go to state 298
parser: Reduce 162 [idlist_opt ::=].
parser: ... then shift 'idlist_opt', go to state 35
parser: Shift 'VALUES', go to state 528
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES]
parser: Input 'LP' in state 528
parser: Shift 'LP', go to state 28
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP]
parser: Input 'STRING' in state 28
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP STRING]
parser: Input 'COMMA' in state 539
parser: Reduce 172 [term ::= STRING], go to state 28.
parser: ... then shift 'term', go to state 70
parser: Reduce 220 [nexprlist ::= expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 413
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'STRING' in state 107
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA STRING]
parser: Input 'COMMA' in state 539
parser: Reduce 172 [term ::= STRING], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 219 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 413
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'STRING' in state 107
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA STRING]
parser: Input 'COMMA' in state 539
parser: Reduce 172 [term ::= STRING], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 219 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 413
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'VARIABLE' in state 107
parser: Shift 'VARIABLE', pending reduce 174
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA VARIABLE]
parser: Input 'COMMA' with pending reduce 174
parser: Reduce 174 [expr ::= VARIABLE], go to state 107.
parser: ... then shift 'expr', go to state 71
parser: Reduce 219 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 413
parser: Shift 'COMMA', go to state 107
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA]
parser: Input 'STRING' in state 107
parser: Shift 'STRING', go to state 539
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist COMMA STRING]
parser: Input 'RP' in state 539
parser: Reduce 172 [term ::= STRING], go to state 107.
parser: ... then shift 'term', go to state 71
parser: Reduce 219 [nexprlist ::= nexprlist COMMA expr], go to state 28.
parser: ... then shift 'nexprlist', go to state 413
parser: Shift 'RP', pending reduce 90
parser: Return. Stack=[with insert_cmd INTO xfullname idlist_opt VALUES LP nexprlist RP]
parser: Input 'SEMI' with pending reduce 90
parser: Reduce 90 [values ::= VALUES LP nexprlist RP], go to state 35.
parser: ... then shift 'values', go to state 534
parser: Reduce 354 [oneselect ::= values], go to state 35.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 83 [select ::= selectnowith], go to state 35.
parser: ... then shift 'select', go to state 297
parser: Reduce 156 [upsert ::=].
parser: ... then shift 'upsert', pending reduce 154
parser: Reduce 154 [cmd ::= with insert_cmd INTO xfullname idlist_opt select upsert], go to state 0.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 0.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[cmdx SEMI]
parser: Input '$' with pending reduce 327
parser: Reduce 327 [ecmd ::= cmdx SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 323 [input ::= cmdlist], go to state 0.
parser: ... then shift 'input', pending reduce -2
parser: Accept!
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[ecmd cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping ecmd
SQL: [;CREATE UNIQUE INDEX IF NOT EXISTS a_id ON a(b==0);]
VDBE Trace:
   0 Init             0   38    0               00 Start at 38
  38 Transaction      0    1   17 4             01 usesStmtJournal=1
  39 Integer          0   13    0               00 r[13]=0
REG[13] =  i:0
  40 Goto             0    1    0               00 
   1 Noop             0   37    0               00 
   2 CreateBtree      0    1    2               00 r[1]=root iDb=0 flags=2
REG[1] =  i:14
   3 OpenWrite        0    1    0 5             00 root=1 iDb=0; sqlite_master
   4 NewRowid         0    2    0               00 r[2]=rowid
REG[2] =  i:15
   5 String8          0    3    0 index         00 r[3]='index'
REG[3] =   t5[index](8)
   6 String8          0    4    0 a_id          00 r[4]='a_id'
REG[4] =   t4[a_id](8)
   7 String8          0    5    0 a             00 r[5]='a'
REG[5] =   t1[a](8)
   8 Copy             1    6    0               00 r[6]=r[1]
REG[6] =  i:14
   9 String8          0    7    0 CREATE UNIQUE INDEX a_id ON a(b==0) 00 r[7]='CREATE UNIQUE INDEX a_id ON a(b==0)'
REG[7] =   t35[CREATE UNIQUE INDEX a_id ](8)
  10 MakeRecord       3    5    8 BBBDB         00 r[8]=mkrec(r[3..7])
REG[3] =   t5[index](8)
REG[4] =   t4[a_id](8)
REG[5] =   t1[a](8)
REG[6] =  i:14
REG[7] =   t35[CREATE UNIQUE INDEX a_id ](8)
REG[8] =  sx52[0617150F0153696E646578615F6964610E4352454154452055|.....Sindexa_ida.CREATE U]
  11 Insert           0    8    2               18 intkey=r[2] data=r[8]
REG[8] =  sx52[0617150F0153696E646578615F6964610E4352454154452055|.....Sindexa_ida.CREATE U]
REG[2] =  i:15
  12 SorterOpen       3    0    1 k(2,,)        00 
  13 OpenRead         1    2    0 k(1,)         00 root=2 iDb=0; a
  14 Rewind           1   21    0               00 
  15 Column           1    0   12               00 r[12]=a.b
REG[12] =  i:1
  16 Eq              13   10   12 (BINARY)      64 r[10] = (r[12]==r[13])
REG[13] =  i:0
REG[12] =  i:1
REG[10] =  i:0
  17 Column           1    0   11               00 r[11]=a.b
REG[11] =  i:1
  18 MakeRecord      10    2    9               00 r[9]=mkrec(r[10..11])
REG[9] =  sx3[030809|...]
  19 SorterInsert     3    9    0               00 key=r[9]
REG[9] =  sx3[030809|...]
  20 Next             1   15    0               00 
  15 Column           1    0   12               00 r[12]=a.b
REG[12] =  i:2
  16 Eq              13   10   12 (BINARY)      64 r[10] = (r[12]==r[13])
REG[13] =  i:0
REG[12] =  i:2
REG[10] =  i:0
  17 Column           1    0   11               00 r[11]=a.b
REG[11] =  i:2
  18 MakeRecord      10    2    9               00 r[9]=mkrec(r[10..11])
REG[9] =  sx4[03080102|....]
  19 SorterInsert     3    9    0               00 key=r[9]
REG[9] =  sx4[03080102|....]
  20 Next             1   15    0               00 
  15 Column           1    0   12               00 r[12]=a.b
REG[12] =  i:3
  16 Eq              13   10   12 (BINARY)      64 r[10] = (r[12]==r[13])
REG[13] =  i:0
REG[12] =  i:3
REG[10] =  i:0
  17 Column           1    0   11               00 r[11]=a.b
REG[11] =  i:3
  18 MakeRecord      10    2    9               00 r[9]=mkrec(r[10..11])
REG[9] =  sx4[03080103|....]
  19 SorterInsert     3    9    0               00 key=r[9]
REG[9] =  sx4[03080103|....]
  20 Next             1   15    0               00 
  15 Column           1    0   12               00 r[12]=a.b
REG[12] =  i:4
  16 Eq              13   10   12 (BINARY)      64 r[10] = (r[12]==r[13])
REG[13] =  i:0
REG[12] =  i:4
REG[10] =  i:0
  17 Column           1    0   11               00 r[11]=a.b
REG[11] =  i:4
  18 MakeRecord      10    2    9               00 r[9]=mkrec(r[10..11])
REG[9] =  sx4[03080104|....]
  19 SorterInsert     3    9    0               00 key=r[9]
REG[9] =  sx4[03080104|....]
  20 Next             1   15    0               00 
  15 Column           1    0   12               00 r[12]=a.b
REG[12] =  i:5
  16 Eq              13   10   12 (BINARY)      64 r[10] = (r[12]==r[13])
REG[13] =  i:0
REG[12] =  i:5
REG[10] =  i:0
  17 Column           1    0   11               00 r[11]=a.b
REG[11] =  i:5
  18 MakeRecord      10    2    9               00 r[9]=mkrec(r[10..11])
REG[9] =  sx4[03080105|....]
  19 SorterInsert     3    9    0               00 key=r[9]
REG[9] =  sx4[03080105|....]
  20 Next             1   15    0               00 
  15 Column           1    0   12               00 r[12]=a.b
REG[12] =  i:6
  16 Eq              13   10   12 (BINARY)      64 r[10] = (r[12]==r[13])
REG[13] =  i:0
REG[12] =  i:6
REG[10] =  i:0
  17 Column           1    0   11               00 r[11]=a.b
REG[11] =  i:6
  18 MakeRecord      10    2    9               00 r[9]=mkrec(r[10..11])
REG[9] =  sx4[03080106|....]
  19 SorterInsert     3    9    0               00 key=r[9]
REG[9] =  sx4[03080106|....]
  20 Next             1   15    0               00 
  15 Column           1    0   12               00 r[12]=a.b
REG[12] =  i:7
  16 Eq              13   10   12 (BINARY)      64 r[10] = (r[12]==r[13])
REG[13] =  i:0
REG[12] =  i:7
REG[10] =  i:0
  17 Column           1    0   11               00 r[11]=a.b
REG[11] =  i:7
  18 MakeRecord      10    2    9               00 r[9]=mkrec(r[10..11])
REG[9] =  sx4[03080107|....]
  19 SorterInsert     3    9    0               00 key=r[9]
REG[9] =  sx4[03080107|....]
  20 Next             1   15    0               00 
  15 Column           1    0   12               00 r[12]=a.b
REG[12] =  i:8
  16 Eq              13   10   12 (BINARY)      64 r[10] = (r[12]==r[13])
REG[13] =  i:0
REG[12] =  i:8
REG[10] =  i:0
  17 Column           1    0   11               00 r[11]=a.b
REG[11] =  i:8
  18 MakeRecord      10    2    9               00 r[9]=mkrec(r[10..11])
REG[9] =  sx4[03080108|....]
  19 SorterInsert     3    9    0               00 key=r[9]
REG[9] =  sx4[03080108|....]
  20 Next             1   15    0               00 
  15 Column           1    0   12               00 r[12]=a.b
REG[12] =  i:9
  16 Eq              13   10   12 (BINARY)      64 r[10] = (r[12]==r[13])
REG[13] =  i:0
REG[12] =  i:9
REG[10] =  i:0
  17 Column           1    0   11               00 r[11]=a.b
REG[11] =  i:9
  18 MakeRecord      10    2    9               00 r[9]=mkrec(r[10..11])
REG[9] =  sx4[03080109|....]
  19 SorterInsert     3    9    0               00 key=r[9]
REG[9] =  sx4[03080109|....]
  20 Next             1   15    0               00 
  21 OpenWrite        2    1    0 k(2,,)        11 root=1 iDb=0
  22 SorterSort       3   31    0               00 
  23 Goto             0   27    0               00 
  27 SorterData       3    9    2               00 r[9]=data
  28 SeekEnd          2    0    0               00 
  29 IdxInsert        2    9    0               10 key=r[9]
REG[9] =  sx3[030809|...]
  30 SorterNext       3   24    0               00 
  24 Abortable        0    0    0               00 
  25 SorterCompare    3   23    9 1             00 if key(3)!=trim(r[9],1) goto 23
  26 Halt          2067    2    0 index 'a_id'  02 
parser: [[[;SELECT * FROM ex;]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 326
parser: Return. Stack=[SEMI]
parser: Input 'SELECT' with pending reduce 326
parser: Reduce 326 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Shift 'SELECT', go to state 288
parser: Return. Stack=[ecmd SELECT]
parser: Input 'STAR' in state 288
parser: Reduce 94 [distinct ::=].
parser: ... then shift 'distinct', go to state 198
parser: Reduce 95 [sclp ::=].
parser: ... then shift 'sclp', go to state 384
parser: Reduce 28 [scanpt ::=].
parser: ... then shift 'scanpt', go to state 77
parser: Shift 'STAR', pending reduce 97
parser: Return. Stack=[ecmd SELECT distinct sclp scanpt STAR]
parser: Input 'FROM' with pending reduce 97
parser: Reduce 97 [selcollist ::= sclp scanpt STAR], go to state 198.
parser: ... then shift 'selcollist', go to state 287
parser: Shift 'FROM', go to state 197
parser: Return. Stack=[ecmd SELECT distinct selcollist FROM]
parser: Input 'ID' in state 197
parser: Reduce 104 [stl_prefix ::=].
parser: ... then shift 'stl_prefix', go to state 206
parser: Shift 'ID', pending reduce 337
parser: Return. Stack=[ecmd SELECT distinct selcollist FROM stl_prefix ID]
parser: Input 'SEMI' with pending reduce 337
parser: Reduce 337 [nm ::= ID|INDEXED], go to state 206.
parser: ... then shift 'nm', go to state 350
parser: Reduce 109 [dbnm ::=].
parser: ... then shift 'dbnm', go to state 243
parser: Reduce 100 [as ::=].
parser: ... then shift 'as', go to state 283
parser: Reduce 123 [indexed_opt ::=].
parser: ... then shift 'indexed_opt', go to state 349
parser: Reduce 122 [on_opt ::=].
parser: ... then shift 'on_opt', go to state 348
parser: Reduce 127 [using_opt ::=].
parser: ... then shift 'using_opt', pending reduce 105
parser: Reduce 105 [seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt], go to state 197.
parser: ... then shift 'seltablist', go to state 263
parser: Reduce 102 [from ::= FROM seltablist], go to state 287.
parser: ... then shift 'from', go to state 363
parser: Reduce 147 [where_opt ::=].
parser: ... then shift 'where_opt', go to state 362
parser: Reduce 138 [groupby_opt ::=].
parser: ... then shift 'groupby_opt', go to state 361
parser: Reduce 140 [having_opt ::=].
parser: ... then shift 'having_opt', go to state 194
parser: Reduce 128 [orderby_opt ::=].
parser: ... then shift 'orderby_opt', go to state 360
parser: Reduce 142 [limit_opt ::=].
parser: ... then shift 'limit_opt', pending reduce 88
parser: Reduce 88 [oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt], go to state 1.
parser: ... then shift 'oneselect', go to state 264
parser: Reduce 83 [select ::= selectnowith], go to state 1.
parser: ... then shift 'select', pending reduce 80
parser: Reduce 80 [cmd ::= select], go to state 1.
parser: ... then shift 'cmd', pending reduce 2
parser: Reduce 2 [cmdx ::= cmd], go to state 1.
parser: ... then shift 'cmdx', go to state 542
parser: Shift 'SEMI', pending reduce 327
parser: Return. Stack=[ecmd cmdx SEMI]
parser: Popping SEMI
parser: Popping cmdx
parser: Popping ecmd
SQL: [;SELECT * FROM ex;]
VDBE Trace:
   0 Init             0    9    0               00 Start at 9
   9 Transaction      0    0   17 4             01 usesStmtJournal=0
  10 Goto             0    1    0               00 
   1 OpenRead         0    3    0 2             00 root=3 iDb=0; ex
   2 Explain          2    0    0 SCAN TABLE ex 00 
   3 Rewind           0    8    0               00 
   8 Halt             0    0    0               00 
parser: [[[]]]
parser: Input 'SEMI' in state 0
parser: Shift 'SEMI', pending reduce 326
parser: Return. Stack=[SEMI]
parser: Input '$' with pending reduce 326
parser: Reduce 326 [ecmd ::= SEMI], go to state 0.
parser: ... then shift 'ecmd', go to state 1
parser: Reduce 323 [input ::= cmdlist], go to state 0.
parser: ... then shift 'input', pending reduce -2
parser: Accept!
[Inferior 1 (process 62412) exited normally]
(gdb) (gdb) quit
