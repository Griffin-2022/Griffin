parse_option_list: enter: struct: 0x0 list: 0x0 rules: 0x0 suppress_warning: 1 root: 0x61b00113cbb0
parse_option_list: enter: struct: 0x0 list: 0x0 rules: 0x0 suppress_warning: 1 root: 0x61b00113cbb0
parse_option_list: enter: struct: 0x0 list: 0x0 rules: 0x0 suppress_warning: 1 root: 0x61b00113cbb0
alloc_root: enter: root: 0x61b00113cbb0
alloc_root: exit: ptr: 0x61a000574cc8
my_free: my: ptr: 0x61600740ec08
my_free: info: thd memory_used: 54600  size: -504
tdc_acquire_share: mutex: element->LOCK_table_share (0x61b00000b1c0) locking
tdc_acquire_share: mutex: element->LOCK_table_share (0x61b00000b1c0) locked
tdc_acquire_share: mutex: element->LOCK_table_share (0x61b00000b1c0) unlocking
tdc_acquire_share: exit: share: 0x61b00113cb28  ref_count: 1
my_malloc: my: size: 920 flags: 16
my_malloc: info: global thd memory_used: -30168  size: 944
my_malloc: exit: ptr: 0x6190001a0508
open_table_from_share: enter: name: 'btswegqu.bug13510739'  form: 0x6190001a0508
init_alloc_root: enter: root: 0x6190001a07a0  prealloc: 0
alloc_root: enter: root: 0x6190001a07a0
my_malloc: my: size: 1016 flags: 4112
my_malloc: info: global thd memory_used: -29224  size: 1040
my_malloc: exit: ptr: 0x61a00054fd08
alloc_root: exit: ptr: 0x61a00054fd28
get_new_handler: enter: alloc: 0x6190001a07a0
alloc_root: enter: root: 0x6190001a07a0
my_malloc: my: size: 1992 flags: 4112
my_malloc: info: global thd memory_used: -28184  size: 2016
my_malloc: exit: ptr: 0x61d001393f08
alloc_root: exit: ptr: 0x61d001393f28
get_new_handler: info: handler created F_UNLCK 2 F_RDLCK 0 F_WRLCK 1
alloc_root: enter: root: 0x6190001a07a0
alloc_root: exit: ptr: 0x61a00054fd40
alloc_root: enter: root: 0x6190001a07a0
alloc_root: exit: ptr: 0x61a00054fd68
alloc_root: enter: root: 0x6190001a07a0
alloc_root: exit: ptr: 0x61a00054fd90
alloc_root: enter: root: 0x6190001a07a0
alloc_root: exit: ptr: 0x61a00054fd98
alloc_root: enter: root: 0x6190001a07a0
alloc_root: exit: ptr: 0x61a00054fe70
alloc_root: enter: root: 0x6190001a07a0
alloc_root: exit: ptr: 0x61a00054ff48
alloc_root: enter: root: 0x6190001a07a0
alloc_root: exit: ptr: 0x61a000550020
handler::ha_open: enter: name: ./btswegqu/bug13510739  db_type: 12  db_stat: 33  mode: 2  lock_test: 18
handler::ha_open: info: old m_lock_type: 2 F_UNLCK 2
dict_table_open_on_name: dict_table_open_on_name: table: 'btswegqu/bug13510739'
ha_innobase::update_thd: ha_innobase::update_thd: user_thd: 0x0 -> 0x62b00015e288
info: mutex: mutex (0x611000001480) locking
info: mutex: mutex (0x611000001480) locked
info: mutex: mutex (0x611000001480) unlocking
info: mutex: mutex (0x6120000012a0) locking
info: mutex: mutex (0x6120000012a0) locked
info: mutex: mutex (0x6120000012a0) unlocking
info: trx: Create: 0x7f2a84c9db80
info: mutex: mutex (0x52b5200) locking
info: mutex: mutex (0x52b5200) locked
info: mutex: mutex (0x52b5200) unlocking
que_eval_sql: que_eval_sql: query: PROCEDURE FETCH_STATS () IS
found INT;
DECLARE FUNCTION fetch_table_stats_step;
DECLARE FUNCTION fetch_index_stats_step;
DECLARE CURSOR table_stats_cur IS
  SELECT
  n_rows,
  clustered_index_size,
  sum_of_other_index_sizes
  FROM "mysql/innodb_table_stats"
  WHERE
  database_name = :database_name AND
  table_name = :table_name;
DECLARE CURSOR index_stats_cur IS
  SELECT
  index_name,
  stat_name,
  stat_value,
  sample_size
  FROM "mysql/innodb_index_stats"
  WHERE
  database_name = :database_name AND
  table_name = :table_name;
BEGIN
OPEN table_stats_cur;
FETCH table_stats_cur INTO
  fetch_table_stats_step();
IF (SQL % NOTFOUND) THEN
  CLOSE table_stats_cur;
  RETURN;
END IF;
CLOSE table_stats_cur;
OPEN index_stats_cur;
found := 1;
WHILE found = 1 LOOP
  FETCH index_stats_cur INTO
    fetch_index_stats_step();
  IF (SQL % NOTFOUND) THEN
    found := 0;
  END IF;
END LOOP;
CLOSE index_stats_cur;
END;
dict_table_open_on_name: dict_table_open_on_name: table: 'mysql/innodb_table_stats'
