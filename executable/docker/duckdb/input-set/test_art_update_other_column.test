# name: test/sql/index/art/test_art_update_other_column.test
# description: Test ART index on table with updates to other columns
# group: [art]

;
CREATE TABLE integers(i BIGINT, j INTEGER, k VARCHAR)

;
CREATE INDEX i_index ON integers using art(j)

;
INSERT INTO integers VALUES (10, 1, 'hello'), (11, 2, 'world')

# condition on "j"
;
SELECT * FROM integers WHERE j=1
;
10	1	hello

# now update the column
;
BEGIN TRANSACTION

;
UPDATE integers SET i=100, k='update' WHERE j=1

# con sees the old state, con2 sees the new state
;
SELECT * FROM integers WHERE j=1
;
10	1	hello

;
SELECT * FROM integers WHERE j=1
;
100	1	update

# after a commit, both see the new state
;
COMMIT

;
SELECT * FROM integers WHERE j=1
;
100	1	update

;
SELECT * FROM integers WHERE j=1
;
100	1	update

# now do the same but with two outstanding updates
;
BEGIN TRANSACTION

;
BEGIN TRANSACTION

;
UPDATE integers SET i=20, k='t1' WHERE j=1

;
UPDATE integers SET i=21, k='t2' WHERE j=2

# con1 sees the updated state for the first tuple, but the old state for the new tuple
;
SELECT * FROM integers WHERE j=1
;
20	1	t1

;
SELECT * FROM integers WHERE j=2
;
11	2	world

;
SELECT * FROM integers ORDER BY j
;
20	1	t1
11	2	world

# con2 sees the updated state for the second tuple, but the old state for the new tuple
;
SELECT * FROM integers WHERE j=1
;
100	1	update

;
SELECT * FROM integers WHERE j=2
;
21	2	t2

;
SELECT * FROM integers ORDER BY j
;
100	1	update
21	2	t2

# after commit, both see the updated state
;
COMMIT

;
COMMIT

;
SELECT * FROM integers WHERE j=1
;
20	1	t1

;
SELECT * FROM integers WHERE j=2
;
21	2	t2

;
SELECT * FROM integers ORDER BY j
;
20	1	t1
21	2	t2

;
SELECT * FROM integers ORDER BY j
;
20	1	t1
21	2	t2

