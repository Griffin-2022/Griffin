# name: test/optimizer/statistics/statistics_between.test
# description: Statistics propagation test with between expression
# group: [statistics]

;
CREATE TABLE integers AS SELECT * FROM (VALUES (1), (2), (3)) tbl(i);

;
PRAGMA enable_verification;

;
PRAGMA explain_output = OPTIMIZED_ONLY;

# filter is out of range: no need to execute it
;
EXPLAIN SELECT i=3 FROM integers WHERE i BETWEEN 0 AND 2
;
logical_opt	<!REGEX>:.*i = 3.*

# filter is in range: need to execute it
;
EXPLAIN SELECT i=1 FROM integers WHERE i BETWEEN 0 AND 2
;
logical_opt	<REGEX>:.*i = 1.*

# between where lhs is bigger than rhs: we can prune this entirely
;
EXPLAIN SELECT * FROM integers WHERE i BETWEEN 3 AND 2
;
logical_opt	<REGEX>:.*EMPTY_RESULT.*

# now verify all of the results
;
SELECT i=3 FROM integers WHERE i BETWEEN 0 AND 2;
;
0
0

;
SELECT i=1 FROM integers WHERE i BETWEEN 0 AND 2;
;
1
0

;
SELECT * FROM integers WHERE i BETWEEN 3 AND 2;
;

# now test the same with a subquery, where we don't have filter pushdown into the scan
;
EXPLAIN SELECT i=3 FROM (SELECT * FROM integers LIMIT 10) integers(i) WHERE i BETWEEN 0 AND 2
;
logical_opt	<!REGEX>:.*i = 3.*

;
EXPLAIN SELECT i=1 FROM (SELECT * FROM integers LIMIT 10) integers(i) WHERE i BETWEEN 0 AND 2
;
logical_opt	<REGEX>:.*i = 1.*

;
EXPLAIN SELECT * FROM (SELECT * FROM integers LIMIT 10) integers(i) WHERE i BETWEEN 3 AND 2
;
logical_opt	<REGEX>:.*EMPTY_RESULT.*

# wide between: both are always true, entire filter can be pruned
;
EXPLAIN SELECT * FROM (SELECT * FROM integers LIMIT 10) integers(i) WHERE i BETWEEN 0 AND 10;
;
logical_opt	<!REGEX>:.*FILTER.*

# lower clause is always true: between should be converted into i <= 2
;
EXPLAIN SELECT * FROM (SELECT * FROM integers LIMIT 10) integers(i) WHERE i BETWEEN 0 AND 2;
;
logical_opt	<REGEX>:.*i <= 2.*

# upper clause is always true: between should be converted into i >= 2
;
EXPLAIN SELECT * FROM (SELECT * FROM integers LIMIT 10) integers(i) WHERE i BETWEEN 2 AND 10;
;
logical_opt	<REGEX>:.*i >= 2.*

# between is always false
;
EXPLAIN SELECT * FROM (SELECT * FROM integers LIMIT 10) integers(i) WHERE i BETWEEN -1 AND 0;
;
logical_opt	<REGEX>:.*EMPTY_RESULT.*

;
EXPLAIN SELECT i BETWEEN -1 AND 0 FROM (SELECT * FROM integers LIMIT 10) integers(i);
;
logical_opt	<REGEX>:.*False.*

# verify the results
;
SELECT i=3 FROM (SELECT * FROM integers LIMIT 10) integers(i) WHERE i BETWEEN 0 AND 2;
;
0
0

;
SELECT i=1 FROM (SELECT * FROM integers LIMIT 10) integers(i) WHERE i BETWEEN 0 AND 2;
;
1
0

;
SELECT * FROM (SELECT * FROM integers LIMIT 10) integers(i) WHERE i BETWEEN 3 AND 2;
;

;
SELECT * FROM (SELECT * FROM integers LIMIT 10) integers(i) WHERE i BETWEEN 0 AND 10;
;
1
2
3

;
SELECT * FROM (SELECT * FROM integers LIMIT 10) integers(i) WHERE i BETWEEN 0 AND 2;
;
1
2

;
SELECT * FROM (SELECT * FROM integers LIMIT 10) integers(i) WHERE i BETWEEN 2 AND 10;
;
2
3

;
SELECT * FROM (SELECT * FROM integers LIMIT 10) integers(i) WHERE i BETWEEN -1 AND 0;
;

;
SELECT i BETWEEN -1 AND 0 FROM (SELECT * FROM integers LIMIT 10) integers(i);
;
0
0
0

# now insert a null value
;
INSERT INTO integers VALUES (NULL)

# between is always false or null: we can still prune the entire filter
;
EXPLAIN SELECT * FROM (SELECT * FROM integers LIMIT 10) integers(i) WHERE i BETWEEN -1 AND 0;
;
logical_opt	<REGEX>:.*EMPTY_RESULT.*

# however, if used in a select clause, we can only replace it with a constant_or_null clause
;
EXPLAIN SELECT i BETWEEN -1 AND 0 FROM (SELECT * FROM integers LIMIT 10) integers(i);
;
logical_opt	<REGEX>:.*constant_or_null.*

# in the case of null values we cannot prune the filter here
;
EXPLAIN SELECT * FROM (SELECT * FROM integers LIMIT 10) integers(i) WHERE i BETWEEN 0 AND 10;
;
logical_opt	<REGEX>:.*FILTER.*

;
SELECT * FROM (SELECT * FROM integers LIMIT 10) integers(i) WHERE i BETWEEN -1 AND 0;
;

;
SELECT i BETWEEN -1 AND 0 FROM (SELECT * FROM integers LIMIT 10) integers(i);
;
0
0
0
NULL

;
SELECT * FROM (SELECT * FROM integers LIMIT 10) integers(i) WHERE i BETWEEN 0 AND 10;
;
1
2
3
