# name: test/sql/join/left_outer/test_left_outer.test
# description: Test LEFT OUTER JOIN
# group: [left_outer]

;
PRAGMA enable_verification

;
CREATE TABLE integers(i INTEGER, j INTEGER)

;
INSERT INTO integers VALUES (1, 2), (2, 3), (3, 4)

;
CREATE TABLE integers2(k INTEGER, l INTEGER)

;
INSERT INTO integers2 VALUES (1, 10), (2, 20)

;
SELECT * FROM integers LEFT OUTER JOIN integers2 ON integers.i=integers2.k ORDER BY i
;
1	2	1	10
2	3	2	20
3	4	NULL	NULL

# RIGHT OUTER JOIN is just LEFT OUTER JOIN but with arguments reversed
# with one caveat: SELECT * will project the columns of the LHS first!
;
SELECT * FROM integers2 RIGHT OUTER JOIN integers ON integers.i=integers2.k ORDER BY i
;
1	10	1	2
2	20	2	3
NULL	NULL	3	4

# WHERE happens AFTER the join, thus [where k IS NOT NULL] filters out any tuples with generated NULL values from
# the LEFT OUTER JOIN. Because of this, this join is equivalent to an inner join.
;
SELECT * FROM integers LEFT OUTER JOIN integers2 ON integers.i=integers2.k  WHERE k IS NOT NULL ORDER BY i
;
1	2	1	10
2	3	2	20

# however, any conditions in the ON clause happen BEFORE the join, thus the condition [integers2.k IS NOT NULL]
# happens BEFORE any NULL values are generated by the LEFT OUTER JOIN.
;
SELECT * FROM integers LEFT OUTER JOIN integers2 ON integers.i=integers2.k AND integers2.k IS NOT NULL ORDER BY i
;
1	2	1	10
2	3	2	20
3	4	NULL	NULL

# filter on LHS
;
SELECT * FROM integers LEFT OUTER JOIN integers2 ON i=1 ORDER BY i, k;
;
1	2	1	10
1	2	2	20
2	3	NULL	NULL
3	4	NULL	NULL

# left outer join on "true" is cross product
;
SELECT * FROM integers LEFT OUTER JOIN integers2 ON 1=1 ORDER BY i, k;
;
1	2	1	10
1	2	2	20
2	3	1	10
2	3	2	20
3	4	1	10
3	4	2	20

# except if RHS is empty; then it is the LHS with NULl values appended
;
SELECT * FROM integers LEFT OUTER JOIN (SELECT * FROM integers2 WHERE 1<>1) tbl2 ON 1=2 ORDER BY i;
;
1	2	NULL	NULL
2	3	NULL	NULL
3	4	NULL	NULL

# left outer join on "false" gives the LHS with the RHS filled as NULL
;
SELECT * FROM integers LEFT OUTER JOIN integers2 ON 1=2 ORDER BY i;
;
1	2	NULL	NULL
2	3	NULL	NULL
3	4	NULL	NULL

# left outer join on NULL constant gives the LHS with the RHS filled as null as well
;
SELECT * FROM integers LEFT OUTER JOIN integers2 ON NULL<>NULL ORDER BY i;
;
1	2	NULL	NULL
2	3	NULL	NULL
3	4	NULL	NULL

# left outer join on condition that only concerns the LHS
;
SELECT * FROM integers LEFT OUTER JOIN integers2 ON i=1 ORDER BY i, k;
;
1	2	1	10
1	2	2	20
2	3	NULL	NULL
3	4	NULL	NULL

#  left outer join on condition that only concerns the RHS
;
SELECT * FROM integers LEFT OUTER JOIN integers2 ON l=20 ORDER BY i, k;
;
1	2	2	20
2	3	2	20
3	4	2	20

;
SELECT * FROM integers LEFT OUTER JOIN integers2 ON l>0 ORDER BY i, k;
;
1	2	1	10
1	2	2	20
2	3	1	10
2	3	2	20
3	4	1	10
3	4	2	20

#  left outer join on condition that affects both, but is not a simple comparison
;
SELECT * FROM integers LEFT OUTER JOIN integers2 ON i=1 OR l=20 ORDER BY i, k;
;
1	2	1	10
1	2	2	20
2	3	2	20
3	4	2	20

;
SELECT * FROM integers LEFT OUTER JOIN integers2 ON i=4 OR l=17 ORDER BY i;
;
1	2	NULL	NULL
2	3	NULL	NULL
3	4	NULL	NULL

;
SELECT * FROM integers LEFT OUTER JOIN integers2 ON i+l=21 ORDER BY i;
;
1	2	2	20
2	3	NULL	NULL
3	4	NULL	NULL

;
SELECT * FROM integers LEFT OUTER JOIN integers2 ON i+l>12 ORDER BY i, k;
;
1	2	2	20
2	3	2	20
3	4	1	10
3	4	2	20

# range join
;
SELECT * FROM integers LEFT OUTER JOIN integers2 ON integers.i<integers2.k WHERE integers.i <= 2 ORDER BY i
;
1	2	2	20
2	3	NULL	NULL

# multiple conditions
;
SELECT * FROM integers LEFT OUTER JOIN integers2 ON integers.i<integers2.k AND integers.i<integers2.l WHERE integers.i <= 2 ORDER BY i
;
1	2	2	20
2	3	NULL	NULL

;
SELECT * FROM integers LEFT OUTER JOIN (SELECT * FROM integers2 WHERE k=100) integers2 ON integers.i<integers2.k ORDER BY i
;
1	2	NULL	NULL
2	3	NULL	NULL
3	4	NULL	NULL

;
select * from (values(1), (2)) t1(i) left join (values (2), (3)) t2(i) on t1.i=t2.i AND t1.i+t2.i=4 ORDER BY 1, 2;
;
1	NULL
2	2
