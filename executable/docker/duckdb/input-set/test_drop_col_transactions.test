# name: test/sql/alter/drop_col/test_drop_col_transactions.test
# description: Test ALTER TABLE DROP COLUMN with multiple transactions
# group: [drop_col]

;
CREATE TABLE test(i INTEGER, j INTEGER)

;
INSERT INTO test VALUES (1, 1), (2, 2)

# Only one pending table alter can be active at a time
;
BEGIN TRANSACTION

# con removes a column to test
;
ALTER TABLE test DROP COLUMN j

# con2 cannot add a new column now!
;
ALTER TABLE test ADD COLUMN k INTEGER

;
COMMIT

# we can add the column after the commit
;
ALTER TABLE test ADD COLUMN k INTEGER

;
DROP TABLE test

;
CREATE TABLE test(i INTEGER, j INTEGER)

;
INSERT INTO test VALUES (1, 1), (2, 2)

# Can only append to newest table
;
BEGIN TRANSACTION

# con removes a column from test
;
ALTER TABLE test DROP COLUMN i

# con2 cannot append now!
;
INSERT INTO test (i, j) VALUES (3, 3)

# but we can delete rows!
;
DELETE FROM test WHERE i=1

;
SELECT * FROM test
;
1
2

;
SELECT * FROM test
;
2	2

# we can't update on tables that have been altered
;
UPDATE test SET j=100

;
SELECT * FROM test
;
1
2

;
UPDATE test SET j=100

;
COMMIT

;
SELECT * FROM test
;
100

;
DROP TABLE test

;
CREATE TABLE test(i INTEGER, j INTEGER)

;
INSERT INTO test VALUES (1, 1), (2, 2)

# Alter table while other transaction still has pending appends
;
BEGIN TRANSACTION

;
INSERT INTO test VALUES (3, 3)

# now con adds a column
;
ALTER TABLE test DROP COLUMN i

# cannot commit con2! conflict on append
;
COMMIT

;
DROP TABLE test

;
CREATE TABLE test(i INTEGER, j INTEGER)

;
INSERT INTO test VALUES (1, 1), (2, 2)

# Create index on column that has been removed by other transaction
# con2 removes a column
;
BEGIN TRANSACTION

;
ALTER TABLE test DROP COLUMN j

# now con tries to add an index to that column: this should fail
;
CREATE INDEX i_index ON test(j

