CREATE TABLE PKTABLE ( ptest1 int PRIMARY KEY, ptest2 text );
;CREATE TABLE FKTABLE ( ftest1 int REFERENCES PKTABLE MATCH FULL ON DELETE CASCADE ON UPDATE CASCADE, ftest2 int );
;INSERT INTO PKTABLE VALUES (1, 'Test1');
;INSERT INTO PKTABLE VALUES (2, 'Test2');
;INSERT INTO PKTABLE VALUES (3, 'Test3');
;INSERT INTO PKTABLE VALUES (4, 'Test4');
;INSERT INTO PKTABLE VALUES (5, 'Test5');
;INSERT INTO FKTABLE VALUES (1, 2);
;INSERT INTO FKTABLE VALUES (2, 3);
;INSERT INTO FKTABLE VALUES (3, 4);
;INSERT INTO FKTABLE VALUES (NULL, 1);
;INSERT INTO FKTABLE VALUES (100, 2);
;SELECT * FROM FKTABLE;
;DELETE FROM PKTABLE WHERE ptest1=1;
;SELECT * FROM FKTABLE;
;UPDATE PKTABLE SET ptest1=1 WHERE ptest1=2;
;SELECT * FROM FKTABLE;
;DROP TABLE FKTABLE;
;DROP TABLE PKTABLE;
;CREATE TABLE PKTABLE ( ptest1 int, ptest2 int, ptest3 text, PRIMARY KEY(ptest1, ptest2) );
;CREATE TABLE FKTABLE ( ftest1 int, ftest2 int, ftest3 int, CONSTRAINT constrname FOREIGN KEY(ftest1, ftest2)
                       REFERENCES PKTABLE MATCH FULL ON DELETE SET NULL ON UPDATE SET NULL);
;COMMENT ON CONSTRAINT constrname_wrong ON FKTABLE IS 'fk constraint comment';
;COMMENT ON CONSTRAINT constrname ON FKTABLE IS 'fk constraint comment';
;COMMENT ON CONSTRAINT constrname ON FKTABLE IS NULL;
;INSERT INTO PKTABLE VALUES (1, 2, 'Test1');
;INSERT INTO PKTABLE VALUES (1, 3, 'Test1-2');
;INSERT INTO PKTABLE VALUES (2, 4, 'Test2');
;INSERT INTO PKTABLE VALUES (3, 6, 'Test3');
;INSERT INTO PKTABLE VALUES (4, 8, 'Test4');
;INSERT INTO PKTABLE VALUES (5, 10, 'Test5');
;INSERT INTO FKTABLE VALUES (1, 2, 4);
;INSERT INTO FKTABLE VALUES (1, 3, 5);
;INSERT INTO FKTABLE VALUES (2, 4, 8);
;INSERT INTO FKTABLE VALUES (3, 6, 12);
;INSERT INTO FKTABLE VALUES (NULL, NULL, 0);
;INSERT INTO FKTABLE VALUES (100, 2, 4);
;INSERT INTO FKTABLE VALUES (2, 2, 4);
;INSERT INTO FKTABLE VALUES (NULL, 2, 4);
;INSERT INTO FKTABLE VALUES (1, NULL, 4);
;SELECT * FROM FKTABLE;
;DELETE FROM PKTABLE WHERE ptest1=1 and ptest2=2;
;SELECT * FROM FKTABLE;
;DELETE FROM PKTABLE WHERE ptest1=5 and ptest2=10;
;SELECT * FROM FKTABLE;
;UPDATE PKTABLE SET ptest1=1 WHERE ptest1=2;
;SELECT * FROM FKTABLE;
;UPDATE FKTABLE SET ftest1 = NULL WHERE ftest1 = 1;
;UPDATE FKTABLE SET ftest1 = 1 WHERE ftest1 = 1;
;ALTER TABLE PKTABLE ALTER COLUMN ptest1 TYPE bigint;
;ALTER TABLE FKTABLE ALTER COLUMN ftest1 TYPE bigint;
;SELECT * FROM PKTABLE;
;SELECT * FROM FKTABLE;
;DROP TABLE PKTABLE CASCADE;
;DROP TABLE FKTABLE;
;CREATE TABLE PKTABLE ( ptest1 int, ptest2 int, ptest3 text, PRIMARY KEY(ptest1, ptest2) );
;CREATE TABLE FKTABLE ( ftest1 int DEFAULT -1, ftest2 int DEFAULT -2, ftest3 int, CONSTRAINT constrname2 FOREIGN KEY(ftest1, ftest2)
                       REFERENCES PKTABLE MATCH FULL ON DELETE SET DEFAULT ON UPDATE SET DEFAULT);
;INSERT INTO PKTABLE VALUES (-1, -2, 'The Default!');
;INSERT INTO PKTABLE VALUES (1, 2, 'Test1');
;INSERT INTO PKTABLE VALUES (1, 3, 'Test1-2');
;INSERT INTO PKTABLE VALUES (2, 4, 'Test2');
;INSERT INTO PKTABLE VALUES (3, 6, 'Test3');
;INSERT INTO PKTABLE VALUES (4, 8, 'Test4');
;INSERT INTO PKTABLE VALUES (5, 10, 'Test5');
;INSERT INTO FKTABLE VALUES (1, 2, 4);
;INSERT INTO FKTABLE VALUES (1, 3, 5);
;INSERT INTO FKTABLE VALUES (2, 4, 8);
;INSERT INTO FKTABLE VALUES (3, 6, 12);
;INSERT INTO FKTABLE VALUES (NULL, NULL, 0);
;INSERT INTO FKTABLE VALUES (100, 2, 4);
;INSERT INTO FKTABLE VALUES (2, 2, 4);
;INSERT INTO FKTABLE VALUES (NULL, 2, 4);
;INSERT INTO FKTABLE VALUES (1, NULL, 4);
;SELECT * FROM FKTABLE;
;DELETE FROM PKTABLE WHERE ptest1=1 and ptest2=2;
;SELECT * FROM FKTABLE;
;DELETE FROM PKTABLE WHERE ptest1=5 and ptest2=10;
;SELECT * FROM FKTABLE;
;UPDATE PKTABLE SET ptest1=1 WHERE ptest1=2;
;SELECT * FROM FKTABLE;
;DROP TABLE PKTABLE;
;DROP TABLE PKTABLE CASCADE;
;DROP TABLE FKTABLE;
;CREATE TABLE PKTABLE ( ptest1 int PRIMARY KEY, ptest2 text );
;CREATE TABLE FKTABLE ( ftest1 int REFERENCES PKTABLE MATCH FULL, ftest2 int );
;INSERT INTO PKTABLE VALUES (1, 'Test1');
;INSERT INTO PKTABLE VALUES (2, 'Test2');
;INSERT INTO PKTABLE VALUES (3, 'Test3');
;INSERT INTO PKTABLE VALUES (4, 'Test4');
;INSERT INTO PKTABLE VALUES (5, 'Test5');
;INSERT INTO FKTABLE VALUES (1, 2);
;INSERT INTO FKTABLE VALUES (2, 3);
;INSERT INTO FKTABLE VALUES (3, 4);
;INSERT INTO FKTABLE VALUES (NULL, 1);
;INSERT INTO FKTABLE VALUES (100, 2);
;SELECT * FROM FKTABLE;
;SELECT * FROM PKTABLE;
;DELETE FROM PKTABLE WHERE ptest1=1;
;DELETE FROM PKTABLE WHERE ptest1=5;
;SELECT * FROM PKTABLE;
;UPDATE PKTABLE SET ptest1=0 WHERE ptest1=2;
;UPDATE PKTABLE SET ptest1=0 WHERE ptest1=4;
;SELECT * FROM PKTABLE;
;DROP TABLE FKTABLE;
;DROP TABLE PKTABLE;
;CREATE TABLE PKTABLE ( ptest1 int, ptest2 int, PRIMARY KEY(ptest1, ptest2) );
;CREATE TABLE FKTABLE ( ftest1 int, ftest2 int );
;INSERT INTO PKTABLE VALUES (1, 2);
;INSERT INTO FKTABLE VALUES (1, NULL);
;ALTER TABLE FKTABLE ADD FOREIGN KEY(ftest1, ftest2) REFERENCES PKTABLE MATCH FULL;
;DROP TABLE FKTABLE;
;DROP TABLE PKTABLE;
;CREATE TABLE PKTABLE ( ptest1 int, ptest2 int, ptest3 int, ptest4 text, PRIMARY KEY(ptest1, ptest2, ptest3) );
;CREATE TABLE FKTABLE ( ftest1 int, ftest2 int, ftest3 int, ftest4 int,  CONSTRAINT constrname3
			FOREIGN KEY(ftest1, ftest2, ftest3) REFERENCES PKTABLE);
;INSERT INTO PKTABLE VALUES (1, 2, 3, 'test1');
;INSERT INTO PKTABLE VALUES (1, 3, 3, 'test2');
;INSERT INTO PKTABLE VALUES (2, 3, 4, 'test3');
;INSERT INTO PKTABLE VALUES (2, 4, 5, 'test4');
;INSERT INTO FKTABLE VALUES (1, 2, 3, 1);
;INSERT INTO FKTABLE VALUES (NULL, 2, 3, 2);
;INSERT INTO FKTABLE VALUES (2, NULL, 3, 3);
;INSERT INTO FKTABLE VALUES (NULL, 2, 7, 4);
;INSERT INTO FKTABLE VALUES (NULL, 3, 4, 5);
;INSERT INTO FKTABLE VALUES (1, 2, 7, 6);
;SELECT * from FKTABLE;
;UPDATE PKTABLE set ptest2=5 where ptest2=2;
;UPDATE PKTABLE set ptest1=1 WHERE ptest2=3;
;DELETE FROM PKTABLE where ptest1=1 and ptest2=2 and ptest3=3;
;DELETE FROM PKTABLE where ptest1=2;
;SELECT * from PKTABLE;
;SELECT * from FKTABLE;
;DROP TABLE FKTABLE;
;DROP TABLE PKTABLE;
;CREATE TABLE PKTABLE ( ptest1 int, ptest2 int, ptest3 int, ptest4 text, UNIQUE(ptest1, ptest2, ptest3) );
;CREATE TABLE FKTABLE ( ftest1 int, ftest2 int, ftest3 int, ftest4 int,  CONSTRAINT constrname3
			FOREIGN KEY(ftest1, ftest2, ftest3) REFERENCES PKTABLE (ptest1, ptest2, ptest3));
;INSERT INTO PKTABLE VALUES (1, 2, 3, 'test1');
;INSERT INTO PKTABLE VALUES (1, 3, NULL, 'test2');
;INSERT INTO PKTABLE VALUES (2, NULL, 4, 'test3');
;INSERT INTO FKTABLE VALUES (1, 2, 3, 1);
;DELETE FROM PKTABLE WHERE ptest1 = 2;
;SELECT * FROM PKTABLE;
;SELECT * FROM FKTABLE;
;DROP TABLE FKTABLE;
;DROP TABLE PKTABLE;
;CREATE TABLE PKTABLE ( ptest1 int, ptest2 int, ptest3 int, ptest4 text, PRIMARY KEY(ptest1, ptest2, ptest3) );
;CREATE TABLE FKTABLE ( ftest1 int, ftest2 int, ftest3 int, ftest4 int,  CONSTRAINT constrname3
			FOREIGN KEY(ftest1, ftest2, ftest3) REFERENCES PKTABLE
			ON DELETE CASCADE ON UPDATE CASCADE);
;INSERT INTO PKTABLE VALUES (1, 2, 3, 'test1');
;INSERT INTO PKTABLE VALUES (1, 3, 3, 'test2');
;INSERT INTO PKTABLE VALUES (2, 3, 4, 'test3');
;INSERT INTO PKTABLE VALUES (2, 4, 5, 'test4');
;INSERT INTO FKTABLE VALUES (1, 2, 3, 1);
;INSERT INTO FKTABLE VALUES (NULL, 2, 3, 2);
;INSERT INTO FKTABLE VALUES (2, NULL, 3, 3);
;INSERT INTO FKTABLE VALUES (NULL, 2, 7, 4);
;INSERT INTO FKTABLE VALUES (NULL, 3, 4, 5);
;INSERT INTO FKTABLE VALUES (1, 2, 7, 6);
;SELECT * from FKTABLE;
;UPDATE PKTABLE set ptest2=5 where ptest2=2;
;UPDATE PKTABLE set ptest1=1 WHERE ptest2=3;
;SELECT * from PKTABLE;
;SELECT * from FKTABLE;
;DELETE FROM PKTABLE where ptest1=1 and ptest2=5 and ptest3=3;
;SELECT * from PKTABLE;
;SELECT * from FKTABLE;
;DELETE FROM PKTABLE where ptest1=2;
;SELECT * from PKTABLE;
;SELECT * from FKTABLE;
;DROP TABLE FKTABLE;
;DROP TABLE PKTABLE;
;CREATE TABLE PKTABLE ( ptest1 int, ptest2 int, ptest3 int, ptest4 text, PRIMARY KEY(ptest1, ptest2, ptest3) );
;CREATE TABLE FKTABLE ( ftest1 int DEFAULT 0, ftest2 int, ftest3 int, ftest4 int,  CONSTRAINT constrname3
			FOREIGN KEY(ftest1, ftest2, ftest3) REFERENCES PKTABLE
			ON DELETE SET DEFAULT ON UPDATE SET NULL);
;INSERT INTO PKTABLE VALUES (1, 2, 3, 'test1');
;INSERT INTO PKTABLE VALUES (1, 3, 3, 'test2');
;INSERT INTO PKTABLE VALUES (2, 3, 4, 'test3');
;INSERT INTO PKTABLE VALUES (2, 4, 5, 'test4');
;INSERT INTO FKTABLE VALUES (1, 2, 3, 1);
;INSERT INTO FKTABLE VALUES (2, 3, 4, 1);
;INSERT INTO FKTABLE VALUES (NULL, 2, 3, 2);
;INSERT INTO FKTABLE VALUES (2, NULL, 3, 3);
;INSERT INTO FKTABLE VALUES (NULL, 2, 7, 4);
;INSERT INTO FKTABLE VALUES (NULL, 3, 4, 5);
;INSERT INTO FKTABLE VALUES (1, 2, 7, 6);
;SELECT * from FKTABLE;
;UPDATE PKTABLE set ptest2=5 where ptest2=2;
;UPDATE PKTABLE set ptest2=2 WHERE ptest2=3 and ptest1=1;
;SELECT * from PKTABLE;
;SELECT * from FKTABLE;
;DELETE FROM PKTABLE where ptest1=2 and ptest2=3 and ptest3=4;
;SELECT * from PKTABLE;
;SELECT * from FKTABLE;
;DELETE FROM PKTABLE where ptest2=5;
;SELECT * from PKTABLE;
;SELECT * from FKTABLE;
;DROP TABLE FKTABLE;
;DROP TABLE PKTABLE;
;CREATE TABLE PKTABLE ( ptest1 int, ptest2 int, ptest3 int, ptest4 text, PRIMARY KEY(ptest1, ptest2, ptest3) );
;CREATE TABLE FKTABLE ( ftest1 int DEFAULT 0, ftest2 int DEFAULT -1, ftest3 int DEFAULT -2, ftest4 int, CONSTRAINT constrname3
			FOREIGN KEY(ftest1, ftest2, ftest3) REFERENCES PKTABLE
			ON DELETE SET NULL ON UPDATE SET DEFAULT);
;INSERT INTO PKTABLE VALUES (1, 2, 3, 'test1');
;INSERT INTO PKTABLE VALUES (1, 3, 3, 'test2');
;INSERT INTO PKTABLE VALUES (2, 3, 4, 'test3');
;INSERT INTO PKTABLE VALUES (2, 4, 5, 'test4');
;INSERT INTO PKTABLE VALUES (2, -1, 5, 'test5');
;INSERT INTO FKTABLE VALUES (1, 2, 3, 1);
;INSERT INTO FKTABLE VALUES (2, 3, 4, 1);
;INSERT INTO FKTABLE VALUES (2, 4, 5, 1);
;INSERT INTO FKTABLE VALUES (NULL, 2, 3, 2);
;INSERT INTO FKTABLE VALUES (2, NULL, 3, 3);
;INSERT INTO FKTABLE VALUES (NULL, 2, 7, 4);
;INSERT INTO FKTABLE VALUES (NULL, 3, 4, 5);
;INSERT INTO FKTABLE VALUES (1, 2, 7, 6);
;SELECT * from FKTABLE;
;UPDATE PKTABLE set ptest2=5 where ptest2=2;
;UPDATE PKTABLE set ptest1=0, ptest2=-1, ptest3=-2 where ptest2=2;
;UPDATE PKTABLE set ptest2=10 where ptest2=4;
;UPDATE PKTABLE set ptest2=2 WHERE ptest2=3 and ptest1=1;
;SELECT * from PKTABLE;
;SELECT * from FKTABLE;
;DELETE FROM PKTABLE where ptest1=2 and ptest2=3 and ptest3=4;
;SELECT * from PKTABLE;
;SELECT * from FKTABLE;
;DELETE FROM PKTABLE where ptest2=-1 and ptest3=5;
;SELECT * from PKTABLE;
;SELECT * from FKTABLE;
;DROP TABLE FKTABLE;
;DROP TABLE PKTABLE;
;CREATE TABLE PKTABLE (tid int, id int, PRIMARY KEY (tid, id));
;CREATE TABLE FKTABLE (tid int, id int, foo int, FOREIGN KEY (tid, id) REFERENCES PKTABLE ON DELETE SET NULL (bar));
;CREATE TABLE FKTABLE (tid int, id int, foo int, FOREIGN KEY (tid, id) REFERENCES PKTABLE ON DELETE SET NULL (foo));
;CREATE TABLE FKTABLE (tid int, id int, foo int, FOREIGN KEY (tid, foo) REFERENCES PKTABLE ON UPDATE SET NULL (foo));
;CREATE TABLE FKTABLE (
  tid int, id int,
  fk_id_del_set_null int,
  fk_id_del_set_default int DEFAULT 0,
  FOREIGN KEY (tid, fk_id_del_set_null) REFERENCES PKTABLE ON DELETE SET NULL (fk_id_del_set_null),
  FOREIGN KEY (tid, fk_id_del_set_default) REFERENCES PKTABLE ON DELETE SET DEFAULT (fk_id_del_set_default)
);
;SELECT pg_get_constraintdef(oid) FROM pg_constraint WHERE conrelid = 'fktable'::regclass::oid ORDER BY oid;
;INSERT INTO PKTABLE VALUES (1, 0), (1, 1), (1, 2);
;INSERT INTO FKTABLE VALUES
  (1, 1, 1, NULL),
  (1, 2, NULL, 2);
;DELETE FROM PKTABLE WHERE id = 1 OR id = 2;
;SELECT * FROM FKTABLE ORDER BY id;
;DROP TABLE FKTABLE;
;DROP TABLE PKTABLE;
;CREATE TABLE PKTABLE (ptest1 int PRIMARY KEY);
;CREATE TABLE FKTABLE_FAIL1 ( ftest1 int, CONSTRAINT fkfail1 FOREIGN KEY (ftest2) REFERENCES PKTABLE);
;CREATE TABLE FKTABLE_FAIL2 ( ftest1 int, CONSTRAINT fkfail1 FOREIGN KEY (ftest1) REFERENCES PKTABLE(ptest2));
;DROP TABLE FKTABLE_FAIL1;
;DROP TABLE FKTABLE_FAIL2;
;DROP TABLE PKTABLE;
;CREATE TABLE PKTABLE (ptest1 int, ptest2 int, UNIQUE(ptest1, ptest2));
;CREATE TABLE FKTABLE_FAIL1 (ftest1 int REFERENCES pktable(ptest1));
;DROP TABLE FKTABLE_FAIL1;
;DROP TABLE PKTABLE;
;CREATE TABLE PKTABLE (ptest1 int PRIMARY KEY);
;INSERT INTO PKTABLE VALUES(42);
;CREATE TABLE FKTABLE (ftest1 inet REFERENCES pktable);
;CREATE TABLE FKTABLE (ftest1 inet REFERENCES pktable(ptest1));
;CREATE TABLE FKTABLE (ftest1 int8 REFERENCES pktable);
;INSERT INTO FKTABLE VALUES(42);
;INSERT INTO FKTABLE VALUES(43);
;UPDATE FKTABLE SET ftest1 = ftest1;
;UPDATE FKTABLE SET ftest1 = ftest1 + 1;
;DROP TABLE FKTABLE;
;CREATE TABLE FKTABLE (ftest1 numeric REFERENCES pktable);
;DROP TABLE PKTABLE;
;CREATE TABLE PKTABLE (ptest1 numeric PRIMARY KEY);
;INSERT INTO PKTABLE VALUES(42);
;CREATE TABLE FKTABLE (ftest1 int REFERENCES pktable);
;INSERT INTO FKTABLE VALUES(42);
;INSERT INTO FKTABLE VALUES(43);
;UPDATE FKTABLE SET ftest1 = ftest1;
;UPDATE FKTABLE SET ftest1 = ftest1 + 1;
;DROP TABLE FKTABLE;
;DROP TABLE PKTABLE;
;CREATE TABLE PKTABLE (ptest1 int, ptest2 inet, PRIMARY KEY(ptest1, ptest2));
;CREATE TABLE FKTABLE (ftest1 cidr, ftest2 timestamp, FOREIGN KEY(ftest1, ftest2) REFERENCES pktable);
;CREATE TABLE FKTABLE (ftest1 cidr, ftest2 timestamp, FOREIGN KEY(ftest1, ftest2) REFERENCES pktable(ptest1, ptest2));
;CREATE TABLE FKTABLE (ftest1 int, ftest2 inet, FOREIGN KEY(ftest2, ftest1) REFERENCES pktable);
;CREATE TABLE FKTABLE (ftest1 int, ftest2 inet, FOREIGN KEY(ftest2, ftest1) REFERENCES pktable(ptest1, ptest2));
;CREATE TABLE FKTABLE (ftest1 int, ftest2 inet, FOREIGN KEY(ftest1, ftest2) REFERENCES pktable(ptest2, ptest1));
;CREATE TABLE FKTABLE (ftest1 int, ftest2 inet, FOREIGN KEY(ftest2, ftest1) REFERENCES pktable(ptest2, ptest1));
;DROP TABLE FKTABLE;
;CREATE TABLE FKTABLE (ftest1 int, ftest2 inet, FOREIGN KEY(ftest1, ftest2) REFERENCES pktable(ptest1, ptest2));
;DROP TABLE FKTABLE;
;DROP TABLE PKTABLE;
;CREATE TABLE PKTABLE (ptest1 int, ptest2 inet, ptest3 int, ptest4 inet, PRIMARY KEY(ptest1, ptest2), FOREIGN KEY(ptest3,
ptest4) REFERENCES pktable(ptest1, ptest2));
;DROP TABLE PKTABLE;
;CREATE TABLE PKTABLE (ptest1 int, ptest2 inet, ptest3 int, ptest4 inet, PRIMARY KEY(ptest1, ptest2), FOREIGN KEY(ptest3,
ptest4) REFERENCES pktable);
;DROP TABLE PKTABLE;
;CREATE TABLE PKTABLE (ptest1 int, ptest2 inet, ptest3 int, ptest4 inet, PRIMARY KEY(ptest1, ptest2), FOREIGN KEY(ptest3,
ptest4) REFERENCES pktable(ptest2, ptest1));
;CREATE TABLE PKTABLE (ptest1 int, ptest2 inet, ptest3 int, ptest4 inet, PRIMARY KEY(ptest1, ptest2), FOREIGN KEY(ptest4,
ptest3) REFERENCES pktable(ptest1, ptest2));
;CREATE TABLE PKTABLE (ptest1 int, ptest2 inet, ptest3 int, ptest4 inet, PRIMARY KEY(ptest1, ptest2), FOREIGN KEY(ptest4,
ptest3) REFERENCES pktable);
;create table pktable_base (base1 int not null);
;create table pktable (ptest1 int, primary key(base1), unique(base1, ptest1)) inherits (pktable_base);
;create table fktable (ftest1 int references pktable(base1));
;insert into pktable(base1) values (1);
;insert into pktable(base1) values (2);
;insert into fktable(ftest1) values (3);
;insert into pktable(base1) values (3);
;insert into fktable(ftest1) values (3);
;delete from pktable where base1>2;
;update pktable set base1=base1*4;
;update pktable set base1=base1*4 where base1<3;
;delete from pktable where base1>3;
;drop table fktable;
;delete from pktable;
;create table fktable (ftest1 int, ftest2 int, foreign key(ftest1, ftest2) references pktable(base1, ptest1));
;insert into pktable(base1, ptest1) values (1, 1);
;insert into pktable(base1, ptest1) values (2, 2);
;insert into fktable(ftest1, ftest2) values (3, 1);
;insert into pktable(base1,ptest1) values (3, 1);
;insert into fktable(ftest1, ftest2) values (3, 1);
;delete from pktable where base1>2;
;update pktable set base1=base1*4;
;update pktable set base1=base1*4 where base1<3;
;delete from pktable where base1>3;
;drop table fktable;
;drop table pktable;
;drop table pktable_base;
;create table pktable_base(base1 int not null, base2 int);
;create table pktable(ptest1 int, ptest2 int, primary key(base1, ptest1), foreign key(base2, ptest2) references
                                             pktable(base1, ptest1)) inherits (pktable_base);
;insert into pktable (base1, ptest1, base2, ptest2) values (1, 1, 1, 1);
;insert into pktable (base1, ptest1, base2, ptest2) values (2, 1, 1, 1);
;insert into pktable (base1, ptest1, base2, ptest2) values (2, 2, 2, 1);
;insert into pktable (base1, ptest1, base2, ptest2) values (1, 3, 2, 2);
;insert into pktable (base1, ptest1, base2, ptest2) values (2, 3, 3, 2);
;delete from pktable where base1=2;
;update pktable set base1=3 where base1=1;
;delete from pktable where base2=2;
;delete from pktable where base1=2;
;drop table pktable;
;drop table pktable_base;
;create table pktable_base(base1 int not null);
;create table pktable(ptest1 inet, primary key(base1, ptest1)) inherits (pktable_base);
;create table fktable(ftest1 cidr, ftest2 int[], foreign key (ftest1, ftest2) references pktable);
;create table fktable(ftest1 cidr, ftest2 int[], foreign key (ftest1, ftest2) references pktable(base1, ptest1));
;create table fktable(ftest1 int, ftest2 inet, foreign key(ftest2, ftest1) references pktable);
;create table fktable(ftest1 int, ftest2 inet, foreign key(ftest2, ftest1) references pktable(base1, ptest1));
;create table fktable(ftest1 int, ftest2 inet, foreign key(ftest1, ftest2) references pktable(ptest1, base1));
;drop table pktable;
;drop table pktable_base;
;create table pktable_base(base1 int not null, base2 int);
;create table pktable(ptest1 inet, ptest2 inet[], primary key(base1, ptest1), foreign key(base2, ptest2) references
                                             pktable(base1, ptest1)) inherits (pktable_base);
;create table pktable(ptest1 inet, ptest2 inet, primary key(base1, ptest1), foreign key(base2, ptest2) references
                                             pktable(ptest1, base1)) inherits (pktable_base);
;create table pktable(ptest1 inet, ptest2 inet, primary key(base1, ptest1), foreign key(ptest2, base2) references
                                             pktable(base1, ptest1)) inherits (pktable_base);
;create table pktable(ptest1 inet, ptest2 inet, primary key(base1, ptest1), foreign key(ptest2, base2) references
                                             pktable(base1, ptest1)) inherits (pktable_base);
;drop table pktable;
;drop table pktable_base;
;CREATE TABLE pktable (
	id		INT4 PRIMARY KEY,
	other	INT4
);
;CREATE TABLE fktable (
	id		INT4 PRIMARY KEY,
	fk		INT4 REFERENCES pktable DEFERRABLE
);
;INSERT INTO fktable VALUES (5, 10);
;BEGIN;
;SET CONSTRAINTS ALL DEFERRED;
;INSERT INTO fktable VALUES (10, 15);
;INSERT INTO pktable VALUES (15, 0);
;COMMIT;
;DROP TABLE fktable, pktable;
;CREATE TABLE pktable (
	id		INT4 PRIMARY KEY,
	other	INT4
);
;CREATE TABLE fktable (
	id		INT4 PRIMARY KEY,
	fk		INT4 REFERENCES pktable DEFERRABLE INITIALLY DEFERRED
);
;BEGIN;
;INSERT INTO fktable VALUES (100, 200);
;INSERT INTO pktable VALUES (200, 500);
;COMMIT;
;BEGIN;
;SET CONSTRAINTS ALL IMMEDIATE;
;INSERT INTO fktable VALUES (500, 1000);
;COMMIT;
;DROP TABLE fktable, pktable;
;CREATE TABLE pktable (
	id		INT4 PRIMARY KEY,
	other	INT4
);
;CREATE TABLE fktable (
	id		INT4 PRIMARY KEY,
	fk		INT4 REFERENCES pktable DEFERRABLE
);
;BEGIN;
;SET CONSTRAINTS ALL DEFERRED;
;INSERT INTO fktable VALUES (1000, 2000);
;SET CONSTRAINTS ALL IMMEDIATE;
;INSERT INTO pktable VALUES (2000, 3);
;COMMIT;
;DROP TABLE fktable, pktable;
;CREATE TABLE pktable (
	id		INT4 PRIMARY KEY,
	other	INT4
);
;CREATE TABLE fktable (
	id		INT4 PRIMARY KEY,
	fk		INT4 REFERENCES pktable DEFERRABLE INITIALLY DEFERRED
);
;BEGIN;
;INSERT INTO fktable VALUES (100, 200);
;COMMIT;
;DROP TABLE pktable, fktable;
;CREATE TEMP TABLE pktable (
        id1     INT4 PRIMARY KEY,
        id2     VARCHAR(4) UNIQUE,
        id3     REAL UNIQUE,
        UNIQUE(id1, id2, id3)
);
;CREATE TEMP TABLE fktable (
        x1      INT4 REFERENCES pktable(id1),
        x2      VARCHAR(4) REFERENCES pktable(id2),
        x3      REAL REFERENCES pktable(id3),
        x4      TEXT,
        x5      INT2
);
;ALTER TABLE fktable ADD CONSTRAINT fk_2_3
FOREIGN KEY (x2) REFERENCES pktable(id3);
;ALTER TABLE fktable ADD CONSTRAINT fk_2_1
FOREIGN KEY (x2) REFERENCES pktable(id1);
;ALTER TABLE fktable ADD CONSTRAINT fk_3_1
FOREIGN KEY (x3) REFERENCES pktable(id1);
;ALTER TABLE fktable ADD CONSTRAINT fk_1_2
FOREIGN KEY (x1) REFERENCES pktable(id2);
;ALTER TABLE fktable ADD CONSTRAINT fk_1_3
FOREIGN KEY (x1) REFERENCES pktable(id3);
;ALTER TABLE fktable ADD CONSTRAINT fk_4_2
FOREIGN KEY (x4) REFERENCES pktable(id2);
;ALTER TABLE fktable ADD CONSTRAINT fk_5_1
FOREIGN KEY (x5) REFERENCES pktable(id1);
;ALTER TABLE fktable ADD CONSTRAINT fk_123_123
FOREIGN KEY (x1,x2,x3) REFERENCES pktable(id1,id2,id3);
;ALTER TABLE fktable ADD CONSTRAINT fk_213_213
FOREIGN KEY (x2,x1,x3) REFERENCES pktable(id2,id1,id3);
;ALTER TABLE fktable ADD CONSTRAINT fk_253_213
FOREIGN KEY (x2,x5,x3) REFERENCES pktable(id2,id1,id3);
;ALTER TABLE fktable ADD CONSTRAINT fk_123_231
FOREIGN KEY (x1,x2,x3) REFERENCES pktable(id2,id3,id1);
;ALTER TABLE fktable ADD CONSTRAINT fk_241_132
FOREIGN KEY (x2,x4,x1) REFERENCES pktable(id1,id3,id2);
;DROP TABLE pktable, fktable;
;CREATE TEMP TABLE pktable (
    id int primary key,
    other int
);
;CREATE TEMP TABLE fktable (
    id int primary key,
    fk int references pktable deferrable initially deferred
);
;INSERT INTO pktable VALUES (5, 10);
;BEGIN;
;INSERT INTO fktable VALUES (0, 20);
;UPDATE fktable SET id = id + 1;
;COMMIT;
;BEGIN;
;INSERT INTO fktable VALUES (0, 20);
;SAVEPOINT savept1;
;UPDATE fktable SET id = id + 1;
;COMMIT;
;BEGIN;
;SAVEPOINT savept1;
;INSERT INTO fktable VALUES (0, 20);
;RELEASE SAVEPOINT savept1;
;UPDATE fktable SET id = id + 1;
;COMMIT;
;BEGIN;
;INSERT INTO fktable VALUES (0, 20);
;SAVEPOINT savept1;
;UPDATE fktable SET id = id + 1;
;ROLLBACK TO savept1;
;COMMIT;
;INSERT INTO fktable VALUES (1, 5);
;ALTER TABLE fktable ALTER CONSTRAINT fktable_fk_fkey DEFERRABLE INITIALLY IMMEDIATE;
;BEGIN;
;UPDATE pktable SET id = 10 WHERE id = 5;
;COMMIT;
;BEGIN;
;INSERT INTO fktable VALUES (0, 20);
;COMMIT;
;ALTER TABLE fktable ALTER CONSTRAINT fktable_fk_fkey NOT DEFERRABLE;
;ALTER TABLE fktable ALTER CONSTRAINT fktable_fk_fkey NOT DEFERRABLE INITIALLY DEFERRED;
;CREATE TEMP TABLE users (
  id INT PRIMARY KEY,
  name VARCHAR NOT NULL
);
;INSERT INTO users VALUES (1, 'Jozko');
;INSERT INTO users VALUES (2, 'Ferko');
;INSERT INTO users VALUES (3, 'Samko');
;CREATE TEMP TABLE tasks (
  id INT PRIMARY KEY,
  owner INT REFERENCES users ON UPDATE CASCADE ON DELETE SET NULL,
  worker INT REFERENCES users ON UPDATE CASCADE ON DELETE SET NULL,
  checked_by INT REFERENCES users ON UPDATE CASCADE ON DELETE SET NULL
);
;INSERT INTO tasks VALUES (1,1,NULL,NULL);
;INSERT INTO tasks VALUES (2,2,2,NULL);
;INSERT INTO tasks VALUES (3,3,3,3);
;SELECT * FROM tasks;
;UPDATE users SET id = 4 WHERE id = 3;
;SELECT * FROM tasks;
;DELETE FROM users WHERE id = 4;
;SELECT * FROM tasks;
;BEGIN;
;UPDATE tasks set id=id WHERE id=2;
;SELECT * FROM tasks;
;DELETE FROM users WHERE id = 2;
;SELECT * FROM tasks;
;COMMIT;
;create temp table selfref (
    a int primary key,
    b int,
    foreign key (b) references selfref (a)
        on update cascade on delete cascade
);
;insert into selfref (a, b)
values
    (0, 0),
    (1, 1);
;begin;
;update selfref set a = 123 where a = 0;
;select a, b from selfref;
;update selfref set a = 456 where a = 123;
;select a, b from selfref;
;commit;
;create temp table defp (f1 int primary key);
;create temp table defc (f1 int default 0
                        references defp on delete set default);
;insert into defp values (0), (1), (2);
;insert into defc values (2);
;select * from defc;
;delete from defp where f1 = 2;
;select * from defc;
;delete from defp where f1 = 0;
;alter table defc alter column f1 set default 1;
;delete from defp where f1 = 0;
;select * from defc;
;delete from defp where f1 = 1;
;create temp table pp (f1 int primary key);
;create temp table cc (f1 int references pp on update no action on delete no action);
;insert into pp values(12);
;insert into pp values(11);
;update pp set f1=f1+1;
;insert into cc values(13);
;update pp set f1=f1+1;
;update pp set f1=f1+1;
;delete from pp where f1 = 13;
;drop table pp, cc;
;create temp table pp (f1 int primary key);
;create temp table cc (f1 int references pp on update restrict on delete restrict);
;insert into pp values(12);
;insert into pp values(11);
;update pp set f1=f1+1;
;insert into cc values(13);
;update pp set f1=f1+1;
;delete from pp where f1 = 13;
;drop table pp, cc;
;create temp table t1 (a integer primary key, b text);
;create temp table t2 (a integer primary key, b integer references t1);
;create rule r1 as on delete to t1 do delete from t2 where t2.b = old.a;
;explain (costs off) delete from t1 where a = 1;
;delete from t1 where a = 1;
;create table pktable2 (a int, b int, c int, d int, e int, primary key (d, e));
;create table fktable2 (d int, e int, foreign key (d, e) references pktable2);
;insert into pktable2 values (1, 2, 3, 4, 5);
;insert into fktable2 values (4, 5);
;delete from pktable2;
;update pktable2 set d = 5;
;drop table pktable2, fktable2;
;create table pktable1 (a int primary key);
;create table pktable2 (a int, b int, primary key (a, b));
;create table fktable2 (
  a int,
  b int,
  very_very_long_column_name_to_exceed_63_characters int,
  foreign key (very_very_long_column_name_to_exceed_63_characters) references pktable1,
  foreign key (a, very_very_long_column_name_to_exceed_63_characters) references pktable2,
  foreign key (a, very_very_long_column_name_to_exceed_63_characters) references pktable2
);
;select conname from pg_constraint where conrelid = 'fktable2'::regclass order by conname;
;drop table pktable1, pktable2, fktable2;
;create table pktable2(f1 int primary key);
;create table fktable2(f1 int references pktable2 deferrable initially deferred);
;insert into pktable2 values(1);
;begin;
;insert into fktable2 values(1);
;savepoint x;
;delete from fktable2;
;rollback to x;
;commit;
;begin;
;insert into fktable2 values(2);
;savepoint x;
;delete from fktable2;
;rollback to x;
;commit;
;begin;
;insert into fktable2 values(2);
;alter table fktable2 drop constraint fktable2_f1_fkey;
;commit;
;begin;
;delete from pktable2 where f1 = 1;
;alter table fktable2 drop constraint fktable2_f1_fkey;
;commit;
;drop table pktable2, fktable2;
;create table pktable2 (a float8, b float8, primary key (a, b));
;create table fktable2 (x float8, y float8, foreign key (x, y) references pktable2 (a, b) on update cascade);
;insert into pktable2 values ('-0', '-0');
;insert into fktable2 values ('-0', '-0');
;select * from pktable2;
;select * from fktable2;
;update pktable2 set a = '0' where a = '-0';
;select * from pktable2;
;select * from fktable2;
;drop table pktable2, fktable2;
;CREATE TABLE fk_notpartitioned_pk (fdrop1 int, a int, fdrop2 int, b int,
  PRIMARY KEY (a, b));
;ALTER TABLE fk_notpartitioned_pk DROP COLUMN fdrop1, DROP COLUMN fdrop2;
;CREATE TABLE fk_partitioned_fk (b int, fdrop1 int, a int) PARTITION BY RANGE (a, b);
;ALTER TABLE fk_partitioned_fk DROP COLUMN fdrop1;
;CREATE TABLE fk_partitioned_fk_1 (fdrop1 int, fdrop2 int, a int, fdrop3 int, b int);
;ALTER TABLE fk_partitioned_fk_1 DROP COLUMN fdrop1, DROP COLUMN fdrop2, DROP COLUMN fdrop3;
;ALTER TABLE fk_partitioned_fk ATTACH PARTITION fk_partitioned_fk_1 FOR VALUES FROM (0,0) TO (1000,1000);
;ALTER TABLE fk_partitioned_fk ADD FOREIGN KEY (a, b) REFERENCES fk_notpartitioned_pk;
;CREATE TABLE fk_partitioned_fk_2 (b int, fdrop1 int, fdrop2 int, a int);
;ALTER TABLE fk_partitioned_fk_2 DROP COLUMN fdrop1, DROP COLUMN fdrop2;
;ALTER TABLE fk_partitioned_fk ATTACH PARTITION fk_partitioned_fk_2 FOR VALUES FROM (1000,1000) TO (2000,2000);
;CREATE TABLE fk_partitioned_fk_3 (fdrop1 int, fdrop2 int, fdrop3 int, fdrop4 int, b int, a int)
  PARTITION BY HASH (a);
;ALTER TABLE fk_partitioned_fk_3 DROP COLUMN fdrop1, DROP COLUMN fdrop2,
	DROP COLUMN fdrop3, DROP COLUMN fdrop4;
;CREATE TABLE fk_partitioned_fk_3_0 PARTITION OF fk_partitioned_fk_3 FOR VALUES WITH (MODULUS 5, REMAINDER 0);
;CREATE TABLE fk_partitioned_fk_3_1 PARTITION OF fk_partitioned_fk_3 FOR VALUES WITH (MODULUS 5, REMAINDER 1);
;ALTER TABLE fk_partitioned_fk ATTACH PARTITION fk_partitioned_fk_3
  FOR VALUES FROM (2000,2000) TO (3000,3000);
;ALTER TABLE ONLY fk_partitioned_fk ADD FOREIGN KEY (a, b)
  REFERENCES fk_notpartitioned_pk;
;ALTER TABLE fk_partitioned_fk ADD FOREIGN KEY (a, b)
  REFERENCES fk_notpartitioned_pk NOT VALID;
;INSERT INTO fk_partitioned_fk (a,b) VALUES (500, 501);
;INSERT INTO fk_partitioned_fk_1 (a,b) VALUES (500, 501);
;INSERT INTO fk_partitioned_fk (a,b) VALUES (1500, 1501);
;INSERT INTO fk_partitioned_fk_2 (a,b) VALUES (1500, 1501);
;INSERT INTO fk_partitioned_fk (a,b) VALUES (2500, 2502);
;INSERT INTO fk_partitioned_fk_3 (a,b) VALUES (2500, 2502);
;INSERT INTO fk_partitioned_fk (a,b) VALUES (2501, 2503);
;INSERT INTO fk_partitioned_fk_3 (a,b) VALUES (2501, 2503);
;INSERT INTO fk_notpartitioned_pk VALUES (500, 501), (1500, 1501),
  (2500, 2502), (2501, 2503);
;INSERT INTO fk_partitioned_fk (a,b) VALUES (500, 501);
;INSERT INTO fk_partitioned_fk (a,b) VALUES (1500, 1501);
;INSERT INTO fk_partitioned_fk (a,b) VALUES (2500, 2502);
;INSERT INTO fk_partitioned_fk (a,b) VALUES (2501, 2503);
;UPDATE fk_partitioned_fk SET a = a + 1 WHERE a = 2501;
;INSERT INTO fk_notpartitioned_pk (a,b) VALUES (2502, 2503);
;UPDATE fk_partitioned_fk SET a = a + 1 WHERE a = 2501;
;UPDATE fk_notpartitioned_pk SET b = 502 WHERE a = 500;
;UPDATE fk_notpartitioned_pk SET b = 1502 WHERE a = 1500;
;UPDATE fk_notpartitioned_pk SET b = 2504 WHERE a = 2500;
;SELECT c.oid,
  n.nspname,
  c.relname
FROM pg_catalog.pg_class c
     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
WHERE c.relname OPERATOR(pg_catalog.~) '^(fk_notpartitioned_pk)$' COLLATE pg_catalog.default
  AND pg_catalog.pg_table_is_visible(c.oid)
ORDER BY 2, 3;
;SELECT c.relchecks, c.relkind, c.relhasindex, c.relhasrules, c.relhastriggers, c.relrowsecurity, c.relforcerowsecurity, false AS relhasoids, c.relispartition, '', c.reltablespace, CASE WHEN c.reloftype = 0 THEN '' ELSE c.reloftype::pg_catalog.regtype::pg_catalog.text END, c.relpersistence, c.relreplident, am.amname
FROM pg_catalog.pg_class c
 LEFT JOIN pg_catalog.pg_class tc ON (c.reltoastrelid = tc.oid)
LEFT JOIN pg_catalog.pg_am am ON (c.relam = am.oid)
WHERE c.oid = '30185';
;SELECT a.attname,
  pg_catalog.format_type(a.atttypid, a.atttypmod),
  (SELECT pg_catalog.pg_get_expr(d.adbin, d.adrelid, true)
   FROM pg_catalog.pg_attrdef d
   WHERE d.adrelid = a.attrelid AND d.adnum = a.attnum AND a.atthasdef),
  a.attnotnull,
  (SELECT c.collname FROM pg_catalog.pg_collation c, pg_catalog.pg_type t
   WHERE c.oid = a.attcollation AND t.oid = a.atttypid AND a.attcollation <> t.typcollation) AS attcollation,
  a.attidentity,
  a.attgenerated
FROM pg_catalog.pg_attribute a
WHERE a.attrelid = '30185' AND a.attnum > 0 AND NOT a.attisdropped
ORDER BY a.attnum;
;SELECT c2.relname, i.indisprimary, i.indisunique, i.indisclustered, i.indisvalid, pg_catalog.pg_get_indexdef(i.indexrelid, 0, true),
  pg_catalog.pg_get_constraintdef(con.oid, true), contype, condeferrable, condeferred, i.indisreplident, c2.reltablespace
FROM pg_catalog.pg_class c, pg_catalog.pg_class c2, pg_catalog.pg_index i
  LEFT JOIN pg_catalog.pg_constraint con ON (conrelid = i.indrelid AND conindid = i.indexrelid AND contype IN ('p','u','x'))
WHERE c.oid = '30185' AND c.oid = i.indrelid AND i.indexrelid = c2.oid
ORDER BY i.indisprimary DESC, c2.relname;
;SELECT true as sametable, conname,
  pg_catalog.pg_get_constraintdef(r.oid, true) as condef,
  conrelid::pg_catalog.regclass AS ontable
FROM pg_catalog.pg_constraint r
WHERE r.conrelid = '30185' AND r.contype = 'f'
     AND conparentid = 0
ORDER BY conname
;SELECT conname, conrelid::pg_catalog.regclass AS ontable,
       pg_catalog.pg_get_constraintdef(oid, true) AS condef
  FROM pg_catalog.pg_constraint c
 WHERE confrelid IN (SELECT pg_catalog.pg_partition_ancestors('30185')
                     UNION ALL VALUES ('30185'::pg_catalog.regclass))
       AND contype = 'f' AND conparentid = 0
ORDER BY conname;
;SELECT pol.polname, pol.polpermissive,
  CASE WHEN pol.polroles = '{0}' THEN NULL ELSE pg_catalog.array_to_string(array(select rolname from pg_catalog.pg_roles where oid = any (pol.polroles) order by 1),',') END,
  pg_catalog.pg_get_expr(pol.polqual, pol.polrelid),
  pg_catalog.pg_get_expr(pol.polwithcheck, pol.polrelid),
  CASE pol.polcmd
    WHEN 'r' THEN 'SELECT'
    WHEN 'a' THEN 'INSERT'
    WHEN 'w' THEN 'UPDATE'
    WHEN 'd' THEN 'DELETE'
    END AS cmd
FROM pg_catalog.pg_policy pol
WHERE pol.polrelid = '30185' ORDER BY 1;
;SELECT oid, stxrelid::pg_catalog.regclass, stxnamespace::pg_catalog.regnamespace::pg_catalog.text AS nsp, stxname,
pg_catalog.pg_get_statisticsobjdef_columns(oid) AS columns,
  'd' = any(stxkind) AS ndist_enabled,
  'f' = any(stxkind) AS deps_enabled,
  'm' = any(stxkind) AS mcv_enabled,
stxstattarget
FROM pg_catalog.pg_statistic_ext
WHERE stxrelid = '30185'
ORDER BY nsp, stxname;
;SELECT pubname
FROM pg_catalog.pg_publication p
		JOIN pg_catalog.pg_publication_namespace pn ON p.oid = pn.pnpubid
		JOIN pg_catalog.pg_class pc ON pc.relnamespace = pn.pnnspid
WHERE pc.oid ='30185' and pg_catalog.pg_relation_is_publishable('30185')
UNION
SELECT pubname
FROM pg_catalog.pg_publication p
		JOIN pg_catalog.pg_publication_rel pr ON p.oid = pr.prpubid
WHERE pr.prrelid = '30185'
UNION
SELECT pubname
FROM pg_catalog.pg_publication p
WHERE p.puballtables AND pg_catalog.pg_relation_is_publishable('30185')
ORDER BY 1;
;SELECT t.tgname, pg_catalog.pg_get_triggerdef(t.oid, true), t.tgenabled, t.tgisinternal,
  CASE WHEN t.tgparentid != 0 THEN
    (SELECT u.tgrelid::pg_catalog.regclass
     FROM pg_catalog.pg_trigger AS u,
          pg_catalog.pg_partition_ancestors(t.tgrelid) WITH ORDINALITY AS a(relid, depth)
     WHERE u.tgname = t.tgname AND u.tgrelid = a.relid
           AND u.tgparentid = 0
     ORDER BY a.depth LIMIT 1)
  END AS parent
FROM pg_catalog.pg_trigger t
WHERE t.tgrelid = '30185' AND (NOT t.tgisinternal OR (t.tgisinternal AND t.tgenabled = 'D'))
ORDER BY 1;
;SELECT c.oid::pg_catalog.regclass
FROM pg_catalog.pg_class c, pg_catalog.pg_inherits i
WHERE c.oid = i.inhparent AND i.inhrelid = '30185'
  AND c.relkind != 'p' AND c.relkind != 'I'
ORDER BY inhseqno;
;SELECT c.oid::pg_catalog.regclass, c.relkind, inhdetachpending, pg_catalog.pg_get_expr(c.relpartbound, c.oid)
FROM pg_catalog.pg_class c, pg_catalog.pg_inherits i
WHERE c.oid = i.inhrelid AND i.inhparent = '30185'
ORDER BY pg_catalog.pg_get_expr(c.relpartbound, c.oid) = 'DEFAULT', c.oid::pg_catalog.regclass::pg_catalog.text;
;ALTER TABLE fk_partitioned_fk DROP CONSTRAINT fk_partitioned_fk_a_b_fkey;
;DROP TABLE fk_notpartitioned_pk, fk_partitioned_fk;
;CREATE TABLE fk_notpartitioned_pk (a INT, PRIMARY KEY(a), CHECK (a > 0));
;CREATE TABLE fk_partitioned_fk (a INT REFERENCES fk_notpartitioned_pk(a) PRIMARY KEY) PARTITION BY RANGE(a);
;CREATE TABLE fk_partitioned_fk_1 PARTITION OF fk_partitioned_fk FOR VALUES FROM (MINVALUE) TO (MAXVALUE);
;INSERT INTO fk_notpartitioned_pk VALUES (1);
;INSERT INTO fk_partitioned_fk VALUES (1);
;ALTER TABLE fk_notpartitioned_pk ALTER COLUMN a TYPE bigint;
;DELETE FROM fk_notpartitioned_pk WHERE a = 1;
;DROP TABLE fk_notpartitioned_pk, fk_partitioned_fk;
;CREATE TABLE fk_notpartitioned_pk (a int, b int, primary key (a, b));
;CREATE TABLE fk_partitioned_fk (a int default 2501, b int default 142857) PARTITION BY LIST (a);
;CREATE TABLE fk_partitioned_fk_1 PARTITION OF fk_partitioned_fk FOR VALUES IN (NULL,500,501,502);
;ALTER TABLE fk_partitioned_fk ADD FOREIGN KEY (a, b)
  REFERENCES fk_notpartitioned_pk MATCH SIMPLE
  ON DELETE SET NULL ON UPDATE SET NULL;
;CREATE TABLE fk_partitioned_fk_2 PARTITION OF fk_partitioned_fk FOR VALUES IN (1500,1502);
;CREATE TABLE fk_partitioned_fk_3 (a int, b int);
;ALTER TABLE fk_partitioned_fk ATTACH PARTITION fk_partitioned_fk_3 FOR VALUES IN (2500,2501,2502,2503);
;INSERT INTO fk_partitioned_fk (a, b) VALUES (2502, 2503);
;INSERT INTO fk_partitioned_fk_3 (a, b) VALUES (2502, 2503);
;INSERT INTO fk_partitioned_fk_3 (a, b) VALUES (2502, NULL);
;INSERT INTO fk_notpartitioned_pk VALUES (2502, 2503);
;INSERT INTO fk_partitioned_fk_3 (a, b) VALUES (2502, 2503);
;INSERT INTO fk_partitioned_fk (a,b) VALUES (NULL, NULL);
;INSERT INTO fk_notpartitioned_pk VALUES (1, 2);
;CREATE TABLE fk_partitioned_fk_full (x int, y int) PARTITION BY RANGE (x);
;CREATE TABLE fk_partitioned_fk_full_1 PARTITION OF fk_partitioned_fk_full DEFAULT;
;INSERT INTO fk_partitioned_fk_full VALUES (1, NULL);
;ALTER TABLE fk_partitioned_fk_full ADD FOREIGN KEY (x, y) REFERENCES fk_notpartitioned_pk MATCH FULL;
;TRUNCATE fk_partitioned_fk_full;
;ALTER TABLE fk_partitioned_fk_full ADD FOREIGN KEY (x, y) REFERENCES fk_notpartitioned_pk MATCH FULL;
;INSERT INTO fk_partitioned_fk_full VALUES (1, NULL);
;DROP TABLE fk_partitioned_fk_full;
;SELECT tableoid::regclass, a, b FROM fk_partitioned_fk WHERE b IS NULL ORDER BY a;
;UPDATE fk_notpartitioned_pk SET a = a + 1 WHERE a = 2502;
;SELECT tableoid::regclass, a, b FROM fk_partitioned_fk WHERE b IS NULL ORDER BY a;
;INSERT INTO fk_partitioned_fk VALUES (2503, 2503);
;SELECT count(*) FROM fk_partitioned_fk WHERE a IS NULL;
;DELETE FROM fk_notpartitioned_pk;
;SELECT count(*) FROM fk_partitioned_fk WHERE a IS NULL;
;ALTER TABLE fk_partitioned_fk DROP CONSTRAINT fk_partitioned_fk_a_b_fkey;
;ALTER TABLE fk_partitioned_fk ADD FOREIGN KEY (a, b)
  REFERENCES fk_notpartitioned_pk
  ON DELETE SET DEFAULT ON UPDATE SET DEFAULT;
;INSERT INTO fk_notpartitioned_pk VALUES (2502, 2503);
;INSERT INTO fk_partitioned_fk_3 (a, b) VALUES (2502, 2503);
;UPDATE fk_notpartitioned_pk SET a = 1500 WHERE a = 2502;
;INSERT INTO fk_notpartitioned_pk VALUES (2501, 142857);
;UPDATE fk_notpartitioned_pk SET a = 1500 WHERE a = 2502;
;SELECT * FROM fk_partitioned_fk WHERE b = 142857;
;ALTER TABLE fk_partitioned_fk DROP CONSTRAINT fk_partitioned_fk_a_b_fkey;
;ALTER TABLE fk_partitioned_fk ADD FOREIGN KEY (a, b)
  REFERENCES fk_notpartitioned_pk
  ON DELETE SET NULL (a);
;BEGIN;
;DELETE FROM fk_notpartitioned_pk WHERE b = 142857;
;SELECT * FROM fk_partitioned_fk WHERE a IS NOT NULL OR b IS NOT NULL ORDER BY a NULLS LAST;
;ROLLBACK;
;ALTER TABLE fk_partitioned_fk DROP CONSTRAINT fk_partitioned_fk_a_b_fkey;
;ALTER TABLE fk_partitioned_fk ADD FOREIGN KEY (a, b)
  REFERENCES fk_notpartitioned_pk
  ON DELETE SET DEFAULT (a);
;BEGIN;
;DELETE FROM fk_partitioned_fk;
;DELETE FROM fk_notpartitioned_pk;
;INSERT INTO fk_notpartitioned_pk VALUES (500, 100000), (2501, 100000);
;INSERT INTO fk_partitioned_fk VALUES (500, 100000);
;DELETE FROM fk_notpartitioned_pk WHERE a = 500;
;SELECT * FROM fk_partitioned_fk ORDER BY a;
;ROLLBACK;
;ALTER TABLE fk_partitioned_fk DROP CONSTRAINT fk_partitioned_fk_a_b_fkey;
;ALTER TABLE fk_partitioned_fk ADD FOREIGN KEY (a, b)
  REFERENCES fk_notpartitioned_pk
  ON DELETE CASCADE ON UPDATE CASCADE;
;UPDATE fk_notpartitioned_pk SET a = 2502 WHERE a = 2501;
;SELECT * FROM fk_partitioned_fk WHERE b = 142857;
;SELECT * FROM fk_partitioned_fk WHERE b = 142857;
;DELETE FROM fk_notpartitioned_pk WHERE b = 142857;
;SELECT * FROM fk_partitioned_fk WHERE a = 142857;
;DROP TABLE fk_partitioned_fk_2;
;CREATE TABLE fk_partitioned_fk_2 PARTITION OF fk_partitioned_fk FOR VALUES IN (1500,1502);
;ALTER TABLE fk_partitioned_fk DETACH PARTITION fk_partitioned_fk_2;
;BEGIN;
;DROP TABLE fk_partitioned_fk;
;SELECT c.oid,
  n.nspname,
  c.relname
FROM pg_catalog.pg_class c
     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
WHERE c.relname OPERATOR(pg_catalog.~) '^(fk_partitioned_fk_2)$' COLLATE pg_catalog.default
  AND pg_catalog.pg_table_is_visible(c.oid)
ORDER BY 2, 3;
;SELECT c.relchecks, c.relkind, c.relhasindex, c.relhasrules, c.relhastriggers, c.relrowsecurity, c.relforcerowsecurity, false AS relhasoids, c.relispartition, '', c.reltablespace, CASE WHEN c.reloftype = 0 THEN '' ELSE c.reloftype::pg_catalog.regtype::pg_catalog.text END, c.relpersistence, c.relreplident, am.amname
FROM pg_catalog.pg_class c
 LEFT JOIN pg_catalog.pg_class tc ON (c.reltoastrelid = tc.oid)
LEFT JOIN pg_catalog.pg_am am ON (c.relam = am.oid)
WHERE c.oid = '30383';
;SELECT a.attname,
  pg_catalog.format_type(a.atttypid, a.atttypmod),
  (SELECT pg_catalog.pg_get_expr(d.adbin, d.adrelid, true)
   FROM pg_catalog.pg_attrdef d
   WHERE d.adrelid = a.attrelid AND d.adnum = a.attnum AND a.atthasdef),
  a.attnotnull,
  (SELECT c.collname FROM pg_catalog.pg_collation c, pg_catalog.pg_type t
   WHERE c.oid = a.attcollation AND t.oid = a.atttypid AND a.attcollation <> t.typcollation) AS attcollation,
  a.attidentity,
  a.attgenerated
FROM pg_catalog.pg_attribute a
WHERE a.attrelid = '30383' AND a.attnum > 0 AND NOT a.attisdropped
ORDER BY a.attnum;
;SELECT true as sametable, conname,
  pg_catalog.pg_get_constraintdef(r.oid, true) as condef,
  conrelid::pg_catalog.regclass AS ontable
FROM pg_catalog.pg_constraint r
WHERE r.conrelid = '30383' AND r.contype = 'f'
     AND conparentid = 0
ORDER BY conname
;SELECT conname, conrelid::pg_catalog.regclass AS ontable,
       pg_catalog.pg_get_constraintdef(oid, true) AS condef
  FROM pg_catalog.pg_constraint c
 WHERE confrelid IN (SELECT pg_catalog.pg_partition_ancestors('30383')
                     UNION ALL VALUES ('30383'::pg_catalog.regclass))
       AND contype = 'f' AND conparentid = 0
ORDER BY conname;
;SELECT pol.polname, pol.polpermissive,
  CASE WHEN pol.polroles = '{0}' THEN NULL ELSE pg_catalog.array_to_string(array(select rolname from pg_catalog.pg_roles where oid = any (pol.polroles) order by 1),',') END,
  pg_catalog.pg_get_expr(pol.polqual, pol.polrelid),
  pg_catalog.pg_get_expr(pol.polwithcheck, pol.polrelid),
  CASE pol.polcmd
    WHEN 'r' THEN 'SELECT'
    WHEN 'a' THEN 'INSERT'
    WHEN 'w' THEN 'UPDATE'
    WHEN 'd' THEN 'DELETE'
    END AS cmd
FROM pg_catalog.pg_policy pol
WHERE pol.polrelid = '30383' ORDER BY 1;
;SELECT oid, stxrelid::pg_catalog.regclass, stxnamespace::pg_catalog.regnamespace::pg_catalog.text AS nsp, stxname,
pg_catalog.pg_get_statisticsobjdef_columns(oid) AS columns,
  'd' = any(stxkind) AS ndist_enabled,
  'f' = any(stxkind) AS deps_enabled,
  'm' = any(stxkind) AS mcv_enabled,
stxstattarget
FROM pg_catalog.pg_statistic_ext
WHERE stxrelid = '30383'
ORDER BY nsp, stxname;
;SELECT pubname
FROM pg_catalog.pg_publication p
		JOIN pg_catalog.pg_publication_namespace pn ON p.oid = pn.pnpubid
		JOIN pg_catalog.pg_class pc ON pc.relnamespace = pn.pnnspid
WHERE pc.oid ='30383' and pg_catalog.pg_relation_is_publishable('30383')
UNION
SELECT pubname
FROM pg_catalog.pg_publication p
		JOIN pg_catalog.pg_publication_rel pr ON p.oid = pr.prpubid
WHERE pr.prrelid = '30383'
UNION
SELECT pubname
FROM pg_catalog.pg_publication p
WHERE p.puballtables AND pg_catalog.pg_relation_is_publishable('30383')
ORDER BY 1;
;SELECT t.tgname, pg_catalog.pg_get_triggerdef(t.oid, true), t.tgenabled, t.tgisinternal,
  CASE WHEN t.tgparentid != 0 THEN
    (SELECT u.tgrelid::pg_catalog.regclass
     FROM pg_catalog.pg_trigger AS u,
          pg_catalog.pg_partition_ancestors(t.tgrelid) WITH ORDINALITY AS a(relid, depth)
     WHERE u.tgname = t.tgname AND u.tgrelid = a.relid
           AND u.tgparentid = 0
     ORDER BY a.depth LIMIT 1)
  END AS parent
FROM pg_catalog.pg_trigger t
WHERE t.tgrelid = '30383' AND (NOT t.tgisinternal OR (t.tgisinternal AND t.tgenabled = 'D'))
ORDER BY 1;
;SELECT c.oid::pg_catalog.regclass
FROM pg_catalog.pg_class c, pg_catalog.pg_inherits i
WHERE c.oid = i.inhparent AND i.inhrelid = '30383'
  AND c.relkind != 'p' AND c.relkind != 'I'
ORDER BY inhseqno;
;SELECT c.oid::pg_catalog.regclass, c.relkind, inhdetachpending, pg_catalog.pg_get_expr(c.relpartbound, c.oid)
FROM pg_catalog.pg_class c, pg_catalog.pg_inherits i
WHERE c.oid = i.inhrelid AND i.inhparent = '30383'
ORDER BY pg_catalog.pg_get_expr(c.relpartbound, c.oid) = 'DEFAULT', c.oid::pg_catalog.regclass::pg_catalog.text;
;ROLLBACK;
;ALTER TABLE fk_partitioned_fk ATTACH PARTITION fk_partitioned_fk_2 FOR VALUES IN (1500,1502);
;DROP TABLE fk_partitioned_fk_2;
;CREATE TABLE fk_partitioned_fk_2 (b int, c text, a int,
	FOREIGN KEY (a, b) REFERENCES fk_notpartitioned_pk ON UPDATE CASCADE ON DELETE CASCADE);
;ALTER TABLE fk_partitioned_fk_2 DROP COLUMN c;
;ALTER TABLE fk_partitioned_fk ATTACH PARTITION fk_partitioned_fk_2 FOR VALUES IN (1500,1502);
;SELECT c.oid,
  n.nspname,
  c.relname
FROM pg_catalog.pg_class c
     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
WHERE c.relname OPERATOR(pg_catalog.~) '^(fk_partitioned_fk_2)$' COLLATE pg_catalog.default
  AND pg_catalog.pg_table_is_visible(c.oid)
ORDER BY 2, 3;
;SELECT c.relchecks, c.relkind, c.relhasindex, c.relhasrules, c.relhastriggers, c.relrowsecurity, c.relforcerowsecurity, false AS relhasoids, c.relispartition, '', c.reltablespace, CASE WHEN c.reloftype = 0 THEN '' ELSE c.reloftype::pg_catalog.regtype::pg_catalog.text END, c.relpersistence, c.relreplident, am.amname
FROM pg_catalog.pg_class c
 LEFT JOIN pg_catalog.pg_class tc ON (c.reltoastrelid = tc.oid)
LEFT JOIN pg_catalog.pg_am am ON (c.relam = am.oid)
WHERE c.oid = '30393';
;SELECT a.attname,
  pg_catalog.format_type(a.atttypid, a.atttypmod),
  (SELECT pg_catalog.pg_get_expr(d.adbin, d.adrelid, true)
   FROM pg_catalog.pg_attrdef d
   WHERE d.adrelid = a.attrelid AND d.adnum = a.attnum AND a.atthasdef),
  a.attnotnull,
  (SELECT c.collname FROM pg_catalog.pg_collation c, pg_catalog.pg_type t
   WHERE c.oid = a.attcollation AND t.oid = a.atttypid AND a.attcollation <> t.typcollation) AS attcollation,
  a.attidentity,
  a.attgenerated
FROM pg_catalog.pg_attribute a
WHERE a.attrelid = '30393' AND a.attnum > 0 AND NOT a.attisdropped
ORDER BY a.attnum;
;SELECT inhparent::pg_catalog.regclass,
  pg_catalog.pg_get_expr(c.relpartbound, c.oid),
  inhdetachpending
FROM pg_catalog.pg_class c JOIN pg_catalog.pg_inherits i ON c.oid = inhrelid
WHERE c.oid = '30393';
;SELECT conrelid = '30393'::pg_catalog.regclass AS sametable,
       conname,
       pg_catalog.pg_get_constraintdef(oid, true) AS condef,
       conrelid::pg_catalog.regclass AS ontable
  FROM pg_catalog.pg_constraint,
       pg_catalog.pg_partition_ancestors('30393')
 WHERE conrelid = relid AND contype = 'f' AND conparentid = 0
ORDER BY sametable DESC, conname;
;SELECT conname, conrelid::pg_catalog.regclass AS ontable,
       pg_catalog.pg_get_constraintdef(oid, true) AS condef
  FROM pg_catalog.pg_constraint c
 WHERE confrelid IN (SELECT pg_catalog.pg_partition_ancestors('30393')
                     UNION ALL VALUES ('30393'::pg_catalog.regclass))
       AND contype = 'f' AND conparentid = 0
ORDER BY conname;
;SELECT pol.polname, pol.polpermissive,
  CASE WHEN pol.polroles = '{0}' THEN NULL ELSE pg_catalog.array_to_string(array(select rolname from pg_catalog.pg_roles where oid = any (pol.polroles) order by 1),',') END,
  pg_catalog.pg_get_expr(pol.polqual, pol.polrelid),
  pg_catalog.pg_get_expr(pol.polwithcheck, pol.polrelid),
  CASE pol.polcmd
    WHEN 'r' THEN 'SELECT'
    WHEN 'a' THEN 'INSERT'
    WHEN 'w' THEN 'UPDATE'
    WHEN 'd' THEN 'DELETE'
    END AS cmd
FROM pg_catalog.pg_policy pol
WHERE pol.polrelid = '30393' ORDER BY 1;
;SELECT oid, stxrelid::pg_catalog.regclass, stxnamespace::pg_catalog.regnamespace::pg_catalog.text AS nsp, stxname,
pg_catalog.pg_get_statisticsobjdef_columns(oid) AS columns,
  'd' = any(stxkind) AS ndist_enabled,
  'f' = any(stxkind) AS deps_enabled,
  'm' = any(stxkind) AS mcv_enabled,
stxstattarget
FROM pg_catalog.pg_statistic_ext
WHERE stxrelid = '30393'
ORDER BY nsp, stxname;
;SELECT pubname
FROM pg_catalog.pg_publication p
		JOIN pg_catalog.pg_publication_namespace pn ON p.oid = pn.pnpubid
		JOIN pg_catalog.pg_class pc ON pc.relnamespace = pn.pnnspid
WHERE pc.oid ='30393' and pg_catalog.pg_relation_is_publishable('30393')
UNION
SELECT pubname
FROM pg_catalog.pg_publication p
		JOIN pg_catalog.pg_publication_rel pr ON p.oid = pr.prpubid
WHERE pr.prrelid = '30393'
UNION
SELECT pubname
FROM pg_catalog.pg_publication p
WHERE p.puballtables AND pg_catalog.pg_relation_is_publishable('30393')
ORDER BY 1;
;SELECT t.tgname, pg_catalog.pg_get_triggerdef(t.oid, true), t.tgenabled, t.tgisinternal,
  CASE WHEN t.tgparentid != 0 THEN
    (SELECT u.tgrelid::pg_catalog.regclass
     FROM pg_catalog.pg_trigger AS u,
          pg_catalog.pg_partition_ancestors(t.tgrelid) WITH ORDINALITY AS a(relid, depth)
     WHERE u.tgname = t.tgname AND u.tgrelid = a.relid
           AND u.tgparentid = 0
     ORDER BY a.depth LIMIT 1)
  END AS parent
FROM pg_catalog.pg_trigger t
WHERE t.tgrelid = '30393' AND (NOT t.tgisinternal OR (t.tgisinternal AND t.tgenabled = 'D'))
ORDER BY 1;
;SELECT c.oid::pg_catalog.regclass
FROM pg_catalog.pg_class c, pg_catalog.pg_inherits i
WHERE c.oid = i.inhparent AND i.inhrelid = '30393'
  AND c.relkind != 'p' AND c.relkind != 'I'
ORDER BY inhseqno;
;SELECT c.oid::pg_catalog.regclass, c.relkind, inhdetachpending, pg_catalog.pg_get_expr(c.relpartbound, c.oid)
FROM pg_catalog.pg_class c, pg_catalog.pg_inherits i
WHERE c.oid = i.inhrelid AND i.inhparent = '30393'
ORDER BY pg_catalog.pg_get_expr(c.relpartbound, c.oid) = 'DEFAULT', c.oid::pg_catalog.regclass::pg_catalog.text;
;DROP TABLE fk_partitioned_fk_2;
;CREATE TABLE fk_partitioned_fk_4 (a int, b int, FOREIGN KEY (a, b) REFERENCES fk_notpartitioned_pk(a, b) ON UPDATE CASCADE ON DELETE CASCADE) PARTITION BY RANGE (b, a);
;CREATE TABLE fk_partitioned_fk_4_1 PARTITION OF fk_partitioned_fk_4 FOR VALUES FROM (1,1) TO (100,100);
;CREATE TABLE fk_partitioned_fk_4_2 (a int, b int, FOREIGN KEY (a, b) REFERENCES fk_notpartitioned_pk(a, b) ON UPDATE SET NULL);
;ALTER TABLE fk_partitioned_fk_4 ATTACH PARTITION fk_partitioned_fk_4_2 FOR VALUES FROM (100,100) TO (1000,1000);
;ALTER TABLE fk_partitioned_fk ATTACH PARTITION fk_partitioned_fk_4 FOR VALUES IN (3500,3502);
;ALTER TABLE fk_partitioned_fk DETACH PARTITION fk_partitioned_fk_4;
;ALTER TABLE fk_partitioned_fk ATTACH PARTITION fk_partitioned_fk_4 FOR VALUES IN (3500,3502);
;SELECT c.oid,
  n.nspname,
  c.relname
FROM pg_catalog.pg_class c
     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
WHERE c.relname OPERATOR(pg_catalog.~) '^(fk_partitioned_fk_4)$' COLLATE pg_catalog.default
  AND pg_catalog.pg_table_is_visible(c.oid)
ORDER BY 2, 3;
;SELECT c.relchecks, c.relkind, c.relhasindex, c.relhasrules, c.relhastriggers, c.relrowsecurity, c.relforcerowsecurity, false AS relhasoids, c.relispartition, '', c.reltablespace, CASE WHEN c.reloftype = 0 THEN '' ELSE c.reloftype::pg_catalog.regtype::pg_catalog.text END, c.relpersistence, c.relreplident, am.amname
FROM pg_catalog.pg_class c
 LEFT JOIN pg_catalog.pg_class tc ON (c.reltoastrelid = tc.oid)
LEFT JOIN pg_catalog.pg_am am ON (c.relam = am.oid)
WHERE c.oid = '30403';
;SELECT a.attname,
  pg_catalog.format_type(a.atttypid, a.atttypmod),
  (SELECT pg_catalog.pg_get_expr(d.adbin, d.adrelid, true)
   FROM pg_catalog.pg_attrdef d
   WHERE d.adrelid = a.attrelid AND d.adnum = a.attnum AND a.atthasdef),
  a.attnotnull,
  (SELECT c.collname FROM pg_catalog.pg_collation c, pg_catalog.pg_type t
   WHERE c.oid = a.attcollation AND t.oid = a.atttypid AND a.attcollation <> t.typcollation) AS attcollation,
  a.attidentity,
  a.attgenerated
FROM pg_catalog.pg_attribute a
WHERE a.attrelid = '30403' AND a.attnum > 0 AND NOT a.attisdropped
ORDER BY a.attnum;
;SELECT inhparent::pg_catalog.regclass,
  pg_catalog.pg_get_expr(c.relpartbound, c.oid),
  inhdetachpending
FROM pg_catalog.pg_class c JOIN pg_catalog.pg_inherits i ON c.oid = inhrelid
WHERE c.oid = '30403';
;SELECT pg_catalog.pg_get_partkeydef('30403'::pg_catalog.oid);
;SELECT conrelid = '30403'::pg_catalog.regclass AS sametable,
       conname,
       pg_catalog.pg_get_constraintdef(oid, true) AS condef,
       conrelid::pg_catalog.regclass AS ontable
  FROM pg_catalog.pg_constraint,
       pg_catalog.pg_partition_ancestors('30403')
 WHERE conrelid = relid AND contype = 'f' AND conparentid = 0
ORDER BY sametable DESC, conname;
;SELECT conname, conrelid::pg_catalog.regclass AS ontable,
       pg_catalog.pg_get_constraintdef(oid, true) AS condef
  FROM pg_catalog.pg_constraint c
 WHERE confrelid IN (SELECT pg_catalog.pg_partition_ancestors('30403')
                     UNION ALL VALUES ('30403'::pg_catalog.regclass))
       AND contype = 'f' AND conparentid = 0
ORDER BY conname;
;SELECT pol.polname, pol.polpermissive,
  CASE WHEN pol.polroles = '{0}' THEN NULL ELSE pg_catalog.array_to_string(array(select rolname from pg_catalog.pg_roles where oid = any (pol.polroles) order by 1),',') END,
  pg_catalog.pg_get_expr(pol.polqual, pol.polrelid),
  pg_catalog.pg_get_expr(pol.polwithcheck, pol.polrelid),
  CASE pol.polcmd
    WHEN 'r' THEN 'SELECT'
    WHEN 'a' THEN 'INSERT'
    WHEN 'w' THEN 'UPDATE'
    WHEN 'd' THEN 'DELETE'
    END AS cmd
FROM pg_catalog.pg_policy pol
WHERE pol.polrelid = '30403' ORDER BY 1;
;SELECT oid, stxrelid::pg_catalog.regclass, stxnamespace::pg_catalog.regnamespace::pg_catalog.text AS nsp, stxname,
pg_catalog.pg_get_statisticsobjdef_columns(oid) AS columns,
  'd' = any(stxkind) AS ndist_enabled,
  'f' = any(stxkind) AS deps_enabled,
  'm' = any(stxkind) AS mcv_enabled,
stxstattarget
FROM pg_catalog.pg_statistic_ext
WHERE stxrelid = '30403'
ORDER BY nsp, stxname;
;SELECT pubname
FROM pg_catalog.pg_publication p
		JOIN pg_catalog.pg_publication_namespace pn ON p.oid = pn.pnpubid
		JOIN pg_catalog.pg_class pc ON pc.relnamespace = pn.pnnspid
WHERE pc.oid ='30403' and pg_catalog.pg_relation_is_publishable('30403')
UNION
SELECT pubname
FROM pg_catalog.pg_publication p
		JOIN pg_catalog.pg_publication_rel pr ON p.oid = pr.prpubid
WHERE pr.prrelid = '30403'
UNION
SELECT pubname
FROM pg_catalog.pg_publication p
WHERE p.puballtables AND pg_catalog.pg_relation_is_publishable('30403')
ORDER BY 1;
;SELECT t.tgname, pg_catalog.pg_get_triggerdef(t.oid, true), t.tgenabled, t.tgisinternal,
  CASE WHEN t.tgparentid != 0 THEN
    (SELECT u.tgrelid::pg_catalog.regclass
     FROM pg_catalog.pg_trigger AS u,
          pg_catalog.pg_partition_ancestors(t.tgrelid) WITH ORDINALITY AS a(relid, depth)
     WHERE u.tgname = t.tgname AND u.tgrelid = a.relid
           AND u.tgparentid = 0
     ORDER BY a.depth LIMIT 1)
  END AS parent
FROM pg_catalog.pg_trigger t
WHERE t.tgrelid = '30403' AND (NOT t.tgisinternal OR (t.tgisinternal AND t.tgenabled = 'D'))
ORDER BY 1;
;SELECT c.oid::pg_catalog.regclass
FROM pg_catalog.pg_class c, pg_catalog.pg_inherits i
WHERE c.oid = i.inhparent AND i.inhrelid = '30403'
  AND c.relkind != 'p' AND c.relkind != 'I'
ORDER BY inhseqno;
;SELECT c.oid::pg_catalog.regclass, c.relkind, inhdetachpending, pg_catalog.pg_get_expr(c.relpartbound, c.oid)
FROM pg_catalog.pg_class c, pg_catalog.pg_inherits i
WHERE c.oid = i.inhrelid AND i.inhparent = '30403'
ORDER BY pg_catalog.pg_get_expr(c.relpartbound, c.oid) = 'DEFAULT', c.oid::pg_catalog.regclass::pg_catalog.text;
;SELECT c.oid,
  n.nspname,
  c.relname
FROM pg_catalog.pg_class c
     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
WHERE c.relname OPERATOR(pg_catalog.~) '^(fk_partitioned_fk_4_1)$' COLLATE pg_catalog.default
  AND pg_catalog.pg_table_is_visible(c.oid)
ORDER BY 2, 3;
;SELECT c.relchecks, c.relkind, c.relhasindex, c.relhasrules, c.relhastriggers, c.relrowsecurity, c.relforcerowsecurity, false AS relhasoids, c.relispartition, '', c.reltablespace, CASE WHEN c.reloftype = 0 THEN '' ELSE c.reloftype::pg_catalog.regtype::pg_catalog.text END, c.relpersistence, c.relreplident, am.amname
FROM pg_catalog.pg_class c
 LEFT JOIN pg_catalog.pg_class tc ON (c.reltoastrelid = tc.oid)
LEFT JOIN pg_catalog.pg_am am ON (c.relam = am.oid)
WHERE c.oid = '30411';
;SELECT a.attname,
  pg_catalog.format_type(a.atttypid, a.atttypmod),
  (SELECT pg_catalog.pg_get_expr(d.adbin, d.adrelid, true)
   FROM pg_catalog.pg_attrdef d
   WHERE d.adrelid = a.attrelid AND d.adnum = a.attnum AND a.atthasdef),
  a.attnotnull,
  (SELECT c.collname FROM pg_catalog.pg_collation c, pg_catalog.pg_type t
   WHERE c.oid = a.attcollation AND t.oid = a.atttypid AND a.attcollation <> t.typcollation) AS attcollation,
  a.attidentity,
  a.attgenerated
FROM pg_catalog.pg_attribute a
WHERE a.attrelid = '30411' AND a.attnum > 0 AND NOT a.attisdropped
ORDER BY a.attnum;
;SELECT inhparent::pg_catalog.regclass,
  pg_catalog.pg_get_expr(c.relpartbound, c.oid),
  inhdetachpending
FROM pg_catalog.pg_class c JOIN pg_catalog.pg_inherits i ON c.oid = inhrelid
WHERE c.oid = '30411';
;SELECT conrelid = '30411'::pg_catalog.regclass AS sametable,
       conname,
       pg_catalog.pg_get_constraintdef(oid, true) AS condef,
       conrelid::pg_catalog.regclass AS ontable
  FROM pg_catalog.pg_constraint,
       pg_catalog.pg_partition_ancestors('30411')
 WHERE conrelid = relid AND contype = 'f' AND conparentid = 0
ORDER BY sametable DESC, conname;
;SELECT conname, conrelid::pg_catalog.regclass AS ontable,
       pg_catalog.pg_get_constraintdef(oid, true) AS condef
  FROM pg_catalog.pg_constraint c
 WHERE confrelid IN (SELECT pg_catalog.pg_partition_ancestors('30411')
                     UNION ALL VALUES ('30411'::pg_catalog.regclass))
       AND contype = 'f' AND conparentid = 0
ORDER BY conname;
;SELECT pol.polname, pol.polpermissive,
  CASE WHEN pol.polroles = '{0}' THEN NULL ELSE pg_catalog.array_to_string(array(select rolname from pg_catalog.pg_roles where oid = any (pol.polroles) order by 1),',') END,
  pg_catalog.pg_get_expr(pol.polqual, pol.polrelid),
  pg_catalog.pg_get_expr(pol.polwithcheck, pol.polrelid),
  CASE pol.polcmd
    WHEN 'r' THEN 'SELECT'
    WHEN 'a' THEN 'INSERT'
    WHEN 'w' THEN 'UPDATE'
    WHEN 'd' THEN 'DELETE'
    END AS cmd
FROM pg_catalog.pg_policy pol
WHERE pol.polrelid = '30411' ORDER BY 1;
;SELECT oid, stxrelid::pg_catalog.regclass, stxnamespace::pg_catalog.regnamespace::pg_catalog.text AS nsp, stxname,
pg_catalog.pg_get_statisticsobjdef_columns(oid) AS columns,
  'd' = any(stxkind) AS ndist_enabled,
  'f' = any(stxkind) AS deps_enabled,
  'm' = any(stxkind) AS mcv_enabled,
stxstattarget
FROM pg_catalog.pg_statistic_ext
WHERE stxrelid = '30411'
ORDER BY nsp, stxname;
;SELECT pubname
FROM pg_catalog.pg_publication p
		JOIN pg_catalog.pg_publication_namespace pn ON p.oid = pn.pnpubid
		JOIN pg_catalog.pg_class pc ON pc.relnamespace = pn.pnnspid
WHERE pc.oid ='30411' and pg_catalog.pg_relation_is_publishable('30411')
UNION
SELECT pubname
FROM pg_catalog.pg_publication p
		JOIN pg_catalog.pg_publication_rel pr ON p.oid = pr.prpubid
WHERE pr.prrelid = '30411'
UNION
SELECT pubname
FROM pg_catalog.pg_publication p
WHERE p.puballtables AND pg_catalog.pg_relation_is_publishable('30411')
ORDER BY 1;
;SELECT t.tgname, pg_catalog.pg_get_triggerdef(t.oid, true), t.tgenabled, t.tgisinternal,
  CASE WHEN t.tgparentid != 0 THEN
    (SELECT u.tgrelid::pg_catalog.regclass
     FROM pg_catalog.pg_trigger AS u,
          pg_catalog.pg_partition_ancestors(t.tgrelid) WITH ORDINALITY AS a(relid, depth)
     WHERE u.tgname = t.tgname AND u.tgrelid = a.relid
           AND u.tgparentid = 0
     ORDER BY a.depth LIMIT 1)
  END AS parent
FROM pg_catalog.pg_trigger t
WHERE t.tgrelid = '30411' AND (NOT t.tgisinternal OR (t.tgisinternal AND t.tgenabled = 'D'))
ORDER BY 1;
;SELECT c.oid::pg_catalog.regclass
FROM pg_catalog.pg_class c, pg_catalog.pg_inherits i
WHERE c.oid = i.inhparent AND i.inhrelid = '30411'
  AND c.relkind != 'p' AND c.relkind != 'I'
ORDER BY inhseqno;
;SELECT c.oid::pg_catalog.regclass, c.relkind, inhdetachpending, pg_catalog.pg_get_expr(c.relpartbound, c.oid)
FROM pg_catalog.pg_class c, pg_catalog.pg_inherits i
WHERE c.oid = i.inhrelid AND i.inhparent = '30411'
ORDER BY pg_catalog.pg_get_expr(c.relpartbound, c.oid) = 'DEFAULT', c.oid::pg_catalog.regclass::pg_catalog.text;
;SELECT c.oid,
  n.nspname,
  c.relname
FROM pg_catalog.pg_class c
     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
WHERE c.relname OPERATOR(pg_catalog.~) '^(fk_partitioned_fk_4_2)$' COLLATE pg_catalog.default
  AND pg_catalog.pg_table_is_visible(c.oid)
ORDER BY 2, 3;
;SELECT c.relchecks, c.relkind, c.relhasindex, c.relhasrules, c.relhastriggers, c.relrowsecurity, c.relforcerowsecurity, false AS relhasoids, c.relispartition, '', c.reltablespace, CASE WHEN c.reloftype = 0 THEN '' ELSE c.reloftype::pg_catalog.regtype::pg_catalog.text END, c.relpersistence, c.relreplident, am.amname
FROM pg_catalog.pg_class c
 LEFT JOIN pg_catalog.pg_class tc ON (c.reltoastrelid = tc.oid)
LEFT JOIN pg_catalog.pg_am am ON (c.relam = am.oid)
WHERE c.oid = '30417';
;SELECT a.attname,
  pg_catalog.format_type(a.atttypid, a.atttypmod),
  (SELECT pg_catalog.pg_get_expr(d.adbin, d.adrelid, true)
   FROM pg_catalog.pg_attrdef d
   WHERE d.adrelid = a.attrelid AND d.adnum = a.attnum AND a.atthasdef),
  a.attnotnull,
  (SELECT c.collname FROM pg_catalog.pg_collation c, pg_catalog.pg_type t
   WHERE c.oid = a.attcollation AND t.oid = a.atttypid AND a.attcollation <> t.typcollation) AS attcollation,
  a.attidentity,
  a.attgenerated
FROM pg_catalog.pg_attribute a
WHERE a.attrelid = '30417' AND a.attnum > 0 AND NOT a.attisdropped
ORDER BY a.attnum;
;SELECT inhparent::pg_catalog.regclass,
  pg_catalog.pg_get_expr(c.relpartbound, c.oid),
  inhdetachpending
FROM pg_catalog.pg_class c JOIN pg_catalog.pg_inherits i ON c.oid = inhrelid
WHERE c.oid = '30417';
;SELECT conrelid = '30417'::pg_catalog.regclass AS sametable,
       conname,
       pg_catalog.pg_get_constraintdef(oid, true) AS condef,
       conrelid::pg_catalog.regclass AS ontable
  FROM pg_catalog.pg_constraint,
       pg_catalog.pg_partition_ancestors('30417')
 WHERE conrelid = relid AND contype = 'f' AND conparentid = 0
ORDER BY sametable DESC, conname;
;SELECT conname, conrelid::pg_catalog.regclass AS ontable,
       pg_catalog.pg_get_constraintdef(oid, true) AS condef
  FROM pg_catalog.pg_constraint c
 WHERE confrelid IN (SELECT pg_catalog.pg_partition_ancestors('30417')
                     UNION ALL VALUES ('30417'::pg_catalog.regclass))
       AND contype = 'f' AND conparentid = 0
ORDER BY conname;
;SELECT pol.polname, pol.polpermissive,
  CASE WHEN pol.polroles = '{0}' THEN NULL ELSE pg_catalog.array_to_string(array(select rolname from pg_catalog.pg_roles where oid = any (pol.polroles) order by 1),',') END,
  pg_catalog.pg_get_expr(pol.polqual, pol.polrelid),
  pg_catalog.pg_get_expr(pol.polwithcheck, pol.polrelid),
  CASE pol.polcmd
    WHEN 'r' THEN 'SELECT'
    WHEN 'a' THEN 'INSERT'
    WHEN 'w' THEN 'UPDATE'
    WHEN 'd' THEN 'DELETE'
    END AS cmd
FROM pg_catalog.pg_policy pol
WHERE pol.polrelid = '30417' ORDER BY 1;
;SELECT oid, stxrelid::pg_catalog.regclass, stxnamespace::pg_catalog.regnamespace::pg_catalog.text AS nsp, stxname,
pg_catalog.pg_get_statisticsobjdef_columns(oid) AS columns,
  'd' = any(stxkind) AS ndist_enabled,
  'f' = any(stxkind) AS deps_enabled,
  'm' = any(stxkind) AS mcv_enabled,
stxstattarget
FROM pg_catalog.pg_statistic_ext
WHERE stxrelid = '30417'
ORDER BY nsp, stxname;
;SELECT pubname
FROM pg_catalog.pg_publication p
		JOIN pg_catalog.pg_publication_namespace pn ON p.oid = pn.pnpubid
		JOIN pg_catalog.pg_class pc ON pc.relnamespace = pn.pnnspid
WHERE pc.oid ='30417' and pg_catalog.pg_relation_is_publishable('30417')
UNION
SELECT pubname
FROM pg_catalog.pg_publication p
		JOIN pg_catalog.pg_publication_rel pr ON p.oid = pr.prpubid
WHERE pr.prrelid = '30417'
UNION
SELECT pubname
FROM pg_catalog.pg_publication p
WHERE p.puballtables AND pg_catalog.pg_relation_is_publishable('30417')
ORDER BY 1;
;SELECT t.tgname, pg_catalog.pg_get_triggerdef(t.oid, true), t.tgenabled, t.tgisinternal,
  CASE WHEN t.tgparentid != 0 THEN
    (SELECT u.tgrelid::pg_catalog.regclass
     FROM pg_catalog.pg_trigger AS u,
          pg_catalog.pg_partition_ancestors(t.tgrelid) WITH ORDINALITY AS a(relid, depth)
     WHERE u.tgname = t.tgname AND u.tgrelid = a.relid
           AND u.tgparentid = 0
     ORDER BY a.depth LIMIT 1)
  END AS parent
FROM pg_catalog.pg_trigger t
WHERE t.tgrelid = '30417' AND (NOT t.tgisinternal OR (t.tgisinternal AND t.tgenabled = 'D'))
ORDER BY 1;
;SELECT c.oid::pg_catalog.regclass
FROM pg_catalog.pg_class c, pg_catalog.pg_inherits i
WHERE c.oid = i.inhparent AND i.inhrelid = '30417'
  AND c.relkind != 'p' AND c.relkind != 'I'
ORDER BY inhseqno;
;SELECT c.oid::pg_catalog.regclass, c.relkind, inhdetachpending, pg_catalog.pg_get_expr(c.relpartbound, c.oid)
FROM pg_catalog.pg_class c, pg_catalog.pg_inherits i
WHERE c.oid = i.inhrelid AND i.inhparent = '30417'
ORDER BY pg_catalog.pg_get_expr(c.relpartbound, c.oid) = 'DEFAULT', c.oid::pg_catalog.regclass::pg_catalog.text;
;CREATE TABLE fk_partitioned_fk_5 (a int, b int,
	FOREIGN KEY (a, b) REFERENCES fk_notpartitioned_pk(a, b) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE,
	FOREIGN KEY (a, b) REFERENCES fk_notpartitioned_pk(a, b) MATCH FULL ON UPDATE CASCADE ON DELETE CASCADE)
  PARTITION BY RANGE (a);
;CREATE TABLE fk_partitioned_fk_5_1 (a int, b int, FOREIGN KEY (a, b) REFERENCES fk_notpartitioned_pk);
;ALTER TABLE fk_partitioned_fk ATTACH PARTITION fk_partitioned_fk_5 FOR VALUES IN (4500);
;ALTER TABLE fk_partitioned_fk_5 ATTACH PARTITION fk_partitioned_fk_5_1 FOR VALUES FROM (0) TO (10);
;ALTER TABLE fk_partitioned_fk DETACH PARTITION fk_partitioned_fk_5;
;ALTER TABLE fk_partitioned_fk ATTACH PARTITION fk_partitioned_fk_5 FOR VALUES IN (4500);
;SELECT c.oid,
  n.nspname,
  c.relname
FROM pg_catalog.pg_class c
     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
WHERE c.relname OPERATOR(pg_catalog.~) '^(fk_partitioned_fk_5)$' COLLATE pg_catalog.default
  AND pg_catalog.pg_table_is_visible(c.oid)
ORDER BY 2, 3;
;SELECT c.relchecks, c.relkind, c.relhasindex, c.relhasrules, c.relhastriggers, c.relrowsecurity, c.relforcerowsecurity, false AS relhasoids, c.relispartition, '', c.reltablespace, CASE WHEN c.reloftype = 0 THEN '' ELSE c.reloftype::pg_catalog.regtype::pg_catalog.text END, c.relpersistence, c.relreplident, am.amname
FROM pg_catalog.pg_class c
 LEFT JOIN pg_catalog.pg_class tc ON (c.reltoastrelid = tc.oid)
LEFT JOIN pg_catalog.pg_am am ON (c.relam = am.oid)
WHERE c.oid = '30430';
;SELECT a.attname,
  pg_catalog.format_type(a.atttypid, a.atttypmod),
  (SELECT pg_catalog.pg_get_expr(d.adbin, d.adrelid, true)
   FROM pg_catalog.pg_attrdef d
   WHERE d.adrelid = a.attrelid AND d.adnum = a.attnum AND a.atthasdef),
  a.attnotnull,
  (SELECT c.collname FROM pg_catalog.pg_collation c, pg_catalog.pg_type t
   WHERE c.oid = a.attcollation AND t.oid = a.atttypid AND a.attcollation <> t.typcollation) AS attcollation,
  a.attidentity,
  a.attgenerated
FROM pg_catalog.pg_attribute a
WHERE a.attrelid = '30430' AND a.attnum > 0 AND NOT a.attisdropped
ORDER BY a.attnum;
;SELECT inhparent::pg_catalog.regclass,
  pg_catalog.pg_get_expr(c.relpartbound, c.oid),
  inhdetachpending
FROM pg_catalog.pg_class c JOIN pg_catalog.pg_inherits i ON c.oid = inhrelid
WHERE c.oid = '30430';
;SELECT pg_catalog.pg_get_partkeydef('30430'::pg_catalog.oid);
;SELECT conrelid = '30430'::pg_catalog.regclass AS sametable,
       conname,
       pg_catalog.pg_get_constraintdef(oid, true) AS condef,
       conrelid::pg_catalog.regclass AS ontable
  FROM pg_catalog.pg_constraint,
       pg_catalog.pg_partition_ancestors('30430')
 WHERE conrelid = relid AND contype = 'f' AND conparentid = 0
ORDER BY sametable DESC, conname;
;SELECT conname, conrelid::pg_catalog.regclass AS ontable,
       pg_catalog.pg_get_constraintdef(oid, true) AS condef
  FROM pg_catalog.pg_constraint c
 WHERE confrelid IN (SELECT pg_catalog.pg_partition_ancestors('30430')
                     UNION ALL VALUES ('30430'::pg_catalog.regclass))
       AND contype = 'f' AND conparentid = 0
ORDER BY conname;
;SELECT pol.polname, pol.polpermissive,
  CASE WHEN pol.polroles = '{0}' THEN NULL ELSE pg_catalog.array_to_string(array(select rolname from pg_catalog.pg_roles where oid = any (pol.polroles) order by 1),',') END,
  pg_catalog.pg_get_expr(pol.polqual, pol.polrelid),
  pg_catalog.pg_get_expr(pol.polwithcheck, pol.polrelid),
  CASE pol.polcmd
    WHEN 'r' THEN 'SELECT'
    WHEN 'a' THEN 'INSERT'
    WHEN 'w' THEN 'UPDATE'
    WHEN 'd' THEN 'DELETE'
    END AS cmd
FROM pg_catalog.pg_policy pol
WHERE pol.polrelid = '30430' ORDER BY 1;
;SELECT oid, stxrelid::pg_catalog.regclass, stxnamespace::pg_catalog.regnamespace::pg_catalog.text AS nsp, stxname,
pg_catalog.pg_get_statisticsobjdef_columns(oid) AS columns,
  'd' = any(stxkind) AS ndist_enabled,
  'f' = any(stxkind) AS deps_enabled,
  'm' = any(stxkind) AS mcv_enabled,
stxstattarget
FROM pg_catalog.pg_statistic_ext
WHERE stxrelid = '30430'
ORDER BY nsp, stxname;
;SELECT pubname
FROM pg_catalog.pg_publication p
		JOIN pg_catalog.pg_publication_namespace pn ON p.oid = pn.pnpubid
		JOIN pg_catalog.pg_class pc ON pc.relnamespace = pn.pnnspid
WHERE pc.oid ='30430' and pg_catalog.pg_relation_is_publishable('30430')
UNION
SELECT pubname
FROM pg_catalog.pg_publication p
		JOIN pg_catalog.pg_publication_rel pr ON p.oid = pr.prpubid
WHERE pr.prrelid = '30430'
UNION
SELECT pubname
FROM pg_catalog.pg_publication p
WHERE p.puballtables AND pg_catalog.pg_relation_is_publishable('30430')
ORDER BY 1;
;SELECT t.tgname, pg_catalog.pg_get_triggerdef(t.oid, true), t.tgenabled, t.tgisinternal,
  CASE WHEN t.tgparentid != 0 THEN
    (SELECT u.tgrelid::pg_catalog.regclass
     FROM pg_catalog.pg_trigger AS u,
          pg_catalog.pg_partition_ancestors(t.tgrelid) WITH ORDINALITY AS a(relid, depth)
     WHERE u.tgname = t.tgname AND u.tgrelid = a.relid
           AND u.tgparentid = 0
     ORDER BY a.depth LIMIT 1)
  END AS parent
FROM pg_catalog.pg_trigger t
WHERE t.tgrelid = '30430' AND (NOT t.tgisinternal OR (t.tgisinternal AND t.tgenabled = 'D'))
ORDER BY 1;
;SELECT c.oid::pg_catalog.regclass
FROM pg_catalog.pg_class c, pg_catalog.pg_inherits i
WHERE c.oid = i.inhparent AND i.inhrelid = '30430'
  AND c.relkind != 'p' AND c.relkind != 'I'
ORDER BY inhseqno;
;SELECT c.oid::pg_catalog.regclass, c.relkind, inhdetachpending, pg_catalog.pg_get_expr(c.relpartbound, c.oid)
FROM pg_catalog.pg_class c, pg_catalog.pg_inherits i
WHERE c.oid = i.inhrelid AND i.inhparent = '30430'
ORDER BY pg_catalog.pg_get_expr(c.relpartbound, c.oid) = 'DEFAULT', c.oid::pg_catalog.regclass::pg_catalog.text;
;ALTER TABLE fk_partitioned_fk_5 DETACH PARTITION fk_partitioned_fk_5_1;
;ALTER TABLE fk_partitioned_fk_5 ATTACH PARTITION fk_partitioned_fk_5_1 FOR VALUES FROM (0) TO (10);
;SELECT c.oid,
  n.nspname,
  c.relname
FROM pg_catalog.pg_class c
     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
WHERE c.relname OPERATOR(pg_catalog.~) '^(fk_partitioned_fk_5_1)$' COLLATE pg_catalog.default
  AND pg_catalog.pg_table_is_visible(c.oid)
ORDER BY 2, 3;
;SELECT c.relchecks, c.relkind, c.relhasindex, c.relhasrules, c.relhastriggers, c.relrowsecurity, c.relforcerowsecurity, false AS relhasoids, c.relispartition, '', c.reltablespace, CASE WHEN c.reloftype = 0 THEN '' ELSE c.reloftype::pg_catalog.regtype::pg_catalog.text END, c.relpersistence, c.relreplident, am.amname
FROM pg_catalog.pg_class c
 LEFT JOIN pg_catalog.pg_class tc ON (c.reltoastrelid = tc.oid)
LEFT JOIN pg_catalog.pg_am am ON (c.relam = am.oid)
WHERE c.oid = '30443';
;SELECT a.attname,
  pg_catalog.format_type(a.atttypid, a.atttypmod),
  (SELECT pg_catalog.pg_get_expr(d.adbin, d.adrelid, true)
   FROM pg_catalog.pg_attrdef d
   WHERE d.adrelid = a.attrelid AND d.adnum = a.attnum AND a.atthasdef),
  a.attnotnull,
  (SELECT c.collname FROM pg_catalog.pg_collation c, pg_catalog.pg_type t
   WHERE c.oid = a.attcollation AND t.oid = a.atttypid AND a.attcollation <> t.typcollation) AS attcollation,
  a.attidentity,
  a.attgenerated
FROM pg_catalog.pg_attribute a
WHERE a.attrelid = '30443' AND a.attnum > 0 AND NOT a.attisdropped
ORDER BY a.attnum;
;SELECT inhparent::pg_catalog.regclass,
  pg_catalog.pg_get_expr(c.relpartbound, c.oid),
  inhdetachpending
FROM pg_catalog.pg_class c JOIN pg_catalog.pg_inherits i ON c.oid = inhrelid
WHERE c.oid = '30443';
;SELECT conrelid = '30443'::pg_catalog.regclass AS sametable,
       conname,
       pg_catalog.pg_get_constraintdef(oid, true) AS condef,
       conrelid::pg_catalog.regclass AS ontable
  FROM pg_catalog.pg_constraint,
       pg_catalog.pg_partition_ancestors('30443')
 WHERE conrelid = relid AND contype = 'f' AND conparentid = 0
ORDER BY sametable DESC, conname;
;SELECT conname, conrelid::pg_catalog.regclass AS ontable,
       pg_catalog.pg_get_constraintdef(oid, true) AS condef
  FROM pg_catalog.pg_constraint c
 WHERE confrelid IN (SELECT pg_catalog.pg_partition_ancestors('30443')
                     UNION ALL VALUES ('30443'::pg_catalog.regclass))
       AND contype = 'f' AND conparentid = 0
ORDER BY conname;
;SELECT pol.polname, pol.polpermissive,
  CASE WHEN pol.polroles = '{0}' THEN NULL ELSE pg_catalog.array_to_string(array(select rolname from pg_catalog.pg_roles where oid = any (pol.polroles) order by 1),',') END,
  pg_catalog.pg_get_expr(pol.polqual, pol.polrelid),
  pg_catalog.pg_get_expr(pol.polwithcheck, pol.polrelid),
  CASE pol.polcmd
    WHEN 'r' THEN 'SELECT'
    WHEN 'a' THEN 'INSERT'
    WHEN 'w' THEN 'UPDATE'
    WHEN 'd' THEN 'DELETE'
    END AS cmd
FROM pg_catalog.pg_policy pol
WHERE pol.polrelid = '30443' ORDER BY 1;
;SELECT oid, stxrelid::pg_catalog.regclass, stxnamespace::pg_catalog.regnamespace::pg_catalog.text AS nsp, stxname,
pg_catalog.pg_get_statisticsobjdef_columns(oid) AS columns,
  'd' = any(stxkind) AS ndist_enabled,
  'f' = any(stxkind) AS deps_enabled,
  'm' = any(stxkind) AS mcv_enabled,
stxstattarget
FROM pg_catalog.pg_statistic_ext
WHERE stxrelid = '30443'
ORDER BY nsp, stxname;
;SELECT pubname
FROM pg_catalog.pg_publication p
		JOIN pg_catalog.pg_publication_namespace pn ON p.oid = pn.pnpubid
		JOIN pg_catalog.pg_class pc ON pc.relnamespace = pn.pnnspid
WHERE pc.oid ='30443' and pg_catalog.pg_relation_is_publishable('30443')
UNION
SELECT pubname
FROM pg_catalog.pg_publication p
		JOIN pg_catalog.pg_publication_rel pr ON p.oid = pr.prpubid
WHERE pr.prrelid = '30443'
UNION
SELECT pubname
FROM pg_catalog.pg_publication p
WHERE p.puballtables AND pg_catalog.pg_relation_is_publishable('30443')
ORDER BY 1;
;SELECT t.tgname, pg_catalog.pg_get_triggerdef(t.oid, true), t.tgenabled, t.tgisinternal,
  CASE WHEN t.tgparentid != 0 THEN
    (SELECT u.tgrelid::pg_catalog.regclass
     FROM pg_catalog.pg_trigger AS u,
          pg_catalog.pg_partition_ancestors(t.tgrelid) WITH ORDINALITY AS a(relid, depth)
     WHERE u.tgname = t.tgname AND u.tgrelid = a.relid
           AND u.tgparentid = 0
     ORDER BY a.depth LIMIT 1)
  END AS parent
FROM pg_catalog.pg_trigger t
WHERE t.tgrelid = '30443' AND (NOT t.tgisinternal OR (t.tgisinternal AND t.tgenabled = 'D'))
ORDER BY 1;
;SELECT c.oid::pg_catalog.regclass
FROM pg_catalog.pg_class c, pg_catalog.pg_inherits i
WHERE c.oid = i.inhparent AND i.inhrelid = '30443'
  AND c.relkind != 'p' AND c.relkind != 'I'
ORDER BY inhseqno;
;SELECT c.oid::pg_catalog.regclass, c.relkind, inhdetachpending, pg_catalog.pg_get_expr(c.relpartbound, c.oid)
FROM pg_catalog.pg_class c, pg_catalog.pg_inherits i
WHERE c.oid = i.inhrelid AND i.inhparent = '30443'
ORDER BY pg_catalog.pg_get_expr(c.relpartbound, c.oid) = 'DEFAULT', c.oid::pg_catalog.regclass::pg_catalog.text;
;CREATE TABLE fk_partitioned_fk_2 (a int, b int) PARTITION BY RANGE (b);
;CREATE TABLE fk_partitioned_fk_2_1 PARTITION OF fk_partitioned_fk_2 FOR VALUES FROM (0) TO (1000);
;CREATE TABLE fk_partitioned_fk_2_2 PARTITION OF fk_partitioned_fk_2 FOR VALUES FROM (1000) TO (2000);
;INSERT INTO fk_partitioned_fk_2 VALUES (1600, 601), (1600, 1601);
;ALTER TABLE fk_partitioned_fk ATTACH PARTITION fk_partitioned_fk_2
  FOR VALUES IN (1600);
;INSERT INTO fk_notpartitioned_pk VALUES (1600, 601), (1600, 1601);
;ALTER TABLE fk_partitioned_fk ATTACH PARTITION fk_partitioned_fk_2
  FOR VALUES IN (1600);
;create role regress_other_partitioned_fk_owner;
;grant references on fk_notpartitioned_pk to regress_other_partitioned_fk_owner;
;set role regress_other_partitioned_fk_owner;
;create table other_partitioned_fk(a int, b int) partition by list (a);
;create table other_partitioned_fk_1 partition of other_partitioned_fk
  for values in (2048);
;insert into other_partitioned_fk
  select 2048, x from generate_series(1,10) x;
;alter table other_partitioned_fk add foreign key (a, b)
  references fk_notpartitioned_pk(a, b);
;reset role;
;insert into fk_notpartitioned_pk (a, b)
  select 2048, x from generate_series(1,10) x;
;set role regress_other_partitioned_fk_owner;
;alter table other_partitioned_fk add foreign key (a, b)
  references fk_notpartitioned_pk(a, b);
;drop table other_partitioned_fk;
;reset role;
;revoke all on fk_notpartitioned_pk from regress_other_partitioned_fk_owner;
;drop role regress_other_partitioned_fk_owner;
;create schema fkpart0
  create table pkey (a int primary key)
  create table fk_part (a int) partition by list (a)
  create table fk_part_1 partition of fk_part
      (foreign key (a) references fkpart0.pkey) for values in (1)
  create table fk_part_23 partition of fk_part
      (foreign key (a) references fkpart0.pkey) for values in (2, 3)
      partition by list (a)
  create table fk_part_23_2 partition of fk_part_23 for values in (2);
;alter table fkpart0.fk_part add foreign key (a) references fkpart0.pkey;
;SELECT c.oid,
  n.nspname,
  c.relname
FROM pg_catalog.pg_class c
     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
WHERE c.relname OPERATOR(pg_catalog.~) '^(fk_part_1)$' COLLATE pg_catalog.default
  AND n.nspname OPERATOR(pg_catalog.~) '^(fkpart0)$' COLLATE pg_catalog.default
ORDER BY 2, 3;
;SELECT c.relchecks, c.relkind, c.relhasindex, c.relhasrules, c.relhastriggers, c.relrowsecurity, c.relforcerowsecurity, false AS relhasoids, c.relispartition, '', c.reltablespace, CASE WHEN c.reloftype = 0 THEN '' ELSE c.reloftype::pg_catalog.regtype::pg_catalog.text END, c.relpersistence, c.relreplident, am.amname
FROM pg_catalog.pg_class c
 LEFT JOIN pg_catalog.pg_class tc ON (c.reltoastrelid = tc.oid)
LEFT JOIN pg_catalog.pg_am am ON (c.relam = am.oid)
WHERE c.oid = '30530';
;SELECT a.attname,
  pg_catalog.format_type(a.atttypid, a.atttypmod),
  (SELECT pg_catalog.pg_get_expr(d.adbin, d.adrelid, true)
   FROM pg_catalog.pg_attrdef d
   WHERE d.adrelid = a.attrelid AND d.adnum = a.attnum AND a.atthasdef),
  a.attnotnull,
  (SELECT c.collname FROM pg_catalog.pg_collation c, pg_catalog.pg_type t
   WHERE c.oid = a.attcollation AND t.oid = a.atttypid AND a.attcollation <> t.typcollation) AS attcollation,
  a.attidentity,
  a.attgenerated
FROM pg_catalog.pg_attribute a
WHERE a.attrelid = '30530' AND a.attnum > 0 AND NOT a.attisdropped
ORDER BY a.attnum;
;SELECT inhparent::pg_catalog.regclass,
  pg_catalog.pg_get_expr(c.relpartbound, c.oid),
  inhdetachpending
FROM pg_catalog.pg_class c JOIN pg_catalog.pg_inherits i ON c.oid = inhrelid
WHERE c.oid = '30530';
;SELECT conrelid = '30530'::pg_catalog.regclass AS sametable,
       conname,
       pg_catalog.pg_get_constraintdef(oid, true) AS condef,
       conrelid::pg_catalog.regclass AS ontable
  FROM pg_catalog.pg_constraint,
       pg_catalog.pg_partition_ancestors('30530')
 WHERE conrelid = relid AND contype = 'f' AND conparentid = 0
ORDER BY sametable DESC, conname;
;SELECT conname, conrelid::pg_catalog.regclass AS ontable,
       pg_catalog.pg_get_constraintdef(oid, true) AS condef
  FROM pg_catalog.pg_constraint c
 WHERE confrelid IN (SELECT pg_catalog.pg_partition_ancestors('30530')
                     UNION ALL VALUES ('30530'::pg_catalog.regclass))
       AND contype = 'f' AND conparentid = 0
ORDER BY conname;
;SELECT pol.polname, pol.polpermissive,
  CASE WHEN pol.polroles = '{0}' THEN NULL ELSE pg_catalog.array_to_string(array(select rolname from pg_catalog.pg_roles where oid = any (pol.polroles) order by 1),',') END,
  pg_catalog.pg_get_expr(pol.polqual, pol.polrelid),
  pg_catalog.pg_get_expr(pol.polwithcheck, pol.polrelid),
  CASE pol.polcmd
    WHEN 'r' THEN 'SELECT'
    WHEN 'a' THEN 'INSERT'
    WHEN 'w' THEN 'UPDATE'
    WHEN 'd' THEN 'DELETE'
    END AS cmd
FROM pg_catalog.pg_policy pol
WHERE pol.polrelid = '30530' ORDER BY 1;
;SELECT oid, stxrelid::pg_catalog.regclass, stxnamespace::pg_catalog.regnamespace::pg_catalog.text AS nsp, stxname,
pg_catalog.pg_get_statisticsobjdef_columns(oid) AS columns,
  'd' = any(stxkind) AS ndist_enabled,
  'f' = any(stxkind) AS deps_enabled,
  'm' = any(stxkind) AS mcv_enabled,
stxstattarget
FROM pg_catalog.pg_statistic_ext
WHERE stxrelid = '30530'
ORDER BY nsp, stxname;
;SELECT pubname
FROM pg_catalog.pg_publication p
		JOIN pg_catalog.pg_publication_namespace pn ON p.oid = pn.pnpubid
		JOIN pg_catalog.pg_class pc ON pc.relnamespace = pn.pnnspid
WHERE pc.oid ='30530' and pg_catalog.pg_relation_is_publishable('30530')
UNION
SELECT pubname
FROM pg_catalog.pg_publication p
		JOIN pg_catalog.pg_publication_rel pr ON p.oid = pr.prpubid
WHERE pr.prrelid = '30530'
UNION
SELECT pubname
FROM pg_catalog.pg_publication p
WHERE p.puballtables AND pg_catalog.pg_relation_is_publishable('30530')
ORDER BY 1;
;SELECT t.tgname, pg_catalog.pg_get_triggerdef(t.oid, true), t.tgenabled, t.tgisinternal,
  CASE WHEN t.tgparentid != 0 THEN
    (SELECT u.tgrelid::pg_catalog.regclass
     FROM pg_catalog.pg_trigger AS u,
          pg_catalog.pg_partition_ancestors(t.tgrelid) WITH ORDINALITY AS a(relid, depth)
     WHERE u.tgname = t.tgname AND u.tgrelid = a.relid
           AND u.tgparentid = 0
     ORDER BY a.depth LIMIT 1)
  END AS parent
FROM pg_catalog.pg_trigger t
WHERE t.tgrelid = '30530' AND (NOT t.tgisinternal OR (t.tgisinternal AND t.tgenabled = 'D'))
ORDER BY 1;
;SELECT c.oid::pg_catalog.regclass
FROM pg_catalog.pg_class c, pg_catalog.pg_inherits i
WHERE c.oid = i.inhparent AND i.inhrelid = '30530'
  AND c.relkind != 'p' AND c.relkind != 'I'
ORDER BY inhseqno;
;SELECT c.oid::pg_catalog.regclass, c.relkind, inhdetachpending, pg_catalog.pg_get_expr(c.relpartbound, c.oid)
FROM pg_catalog.pg_class c, pg_catalog.pg_inherits i
WHERE c.oid = i.inhrelid AND i.inhparent = '30530'
ORDER BY pg_catalog.pg_get_expr(c.relpartbound, c.oid) = 'DEFAULT', c.oid::pg_catalog.regclass::pg_catalog.text;
;alter table fkpart0.fk_part_1 drop constraint fk_part_1_a_fkey;
;SELECT c.oid,
  n.nspname,
  c.relname
FROM pg_catalog.pg_class c
     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
WHERE c.relname OPERATOR(pg_catalog.~) '^(fk_part_23)$' COLLATE pg_catalog.default
  AND n.nspname OPERATOR(pg_catalog.~) '^(fkpart0)$' COLLATE pg_catalog.default
ORDER BY 2, 3;
;SELECT c.relchecks, c.relkind, c.relhasindex, c.relhasrules, c.relhastriggers, c.relrowsecurity, c.relforcerowsecurity, false AS relhasoids, c.relispartition, '', c.reltablespace, CASE WHEN c.reloftype = 0 THEN '' ELSE c.reloftype::pg_catalog.regtype::pg_catalog.text END, c.relpersistence, c.relreplident, am.amname
FROM pg_catalog.pg_class c
 LEFT JOIN pg_catalog.pg_class tc ON (c.reltoastrelid = tc.oid)
LEFT JOIN pg_catalog.pg_am am ON (c.relam = am.oid)
WHERE c.oid = '30538';
;SELECT a.attname,
  pg_catalog.format_type(a.atttypid, a.atttypmod),
  (SELECT pg_catalog.pg_get_expr(d.adbin, d.adrelid, true)
   FROM pg_catalog.pg_attrdef d
   WHERE d.adrelid = a.attrelid AND d.adnum = a.attnum AND a.atthasdef),
  a.attnotnull,
  (SELECT c.collname FROM pg_catalog.pg_collation c, pg_catalog.pg_type t
   WHERE c.oid = a.attcollation AND t.oid = a.atttypid AND a.attcollation <> t.typcollation) AS attcollation,
  a.attidentity,
  a.attgenerated
FROM pg_catalog.pg_attribute a
WHERE a.attrelid = '30538' AND a.attnum > 0 AND NOT a.attisdropped
ORDER BY a.attnum;
;SELECT inhparent::pg_catalog.regclass,
  pg_catalog.pg_get_expr(c.relpartbound, c.oid),
  inhdetachpending
FROM pg_catalog.pg_class c JOIN pg_catalog.pg_inherits i ON c.oid = inhrelid
WHERE c.oid = '30538';
;SELECT pg_catalog.pg_get_partkeydef('30538'::pg_catalog.oid);
;SELECT conrelid = '30538'::pg_catalog.regclass AS sametable,
       conname,
       pg_catalog.pg_get_constraintdef(oid, true) AS condef,
       conrelid::pg_catalog.regclass AS ontable
  FROM pg_catalog.pg_constraint,
       pg_catalog.pg_partition_ancestors('30538')
 WHERE conrelid = relid AND contype = 'f' AND conparentid = 0
ORDER BY sametable DESC, conname;
;SELECT conname, conrelid::pg_catalog.regclass AS ontable,
       pg_catalog.pg_get_constraintdef(oid, true) AS condef
  FROM pg_catalog.pg_constraint c
 WHERE confrelid IN (SELECT pg_catalog.pg_partition_ancestors('30538')
                     UNION ALL VALUES ('30538'::pg_catalog.regclass))
       AND contype = 'f' AND conparentid = 0
ORDER BY conname;
;SELECT pol.polname, pol.polpermissive,
  CASE WHEN pol.polroles = '{0}' THEN NULL ELSE pg_catalog.array_to_string(array(select rolname from pg_catalog.pg_roles where oid = any (pol.polroles) order by 1),',') END,
  pg_catalog.pg_get_expr(pol.polqual, pol.polrelid),
  pg_catalog.pg_get_expr(pol.polwithcheck, pol.polrelid),
  CASE pol.polcmd
    WHEN 'r' THEN 'SELECT'
    WHEN 'a' THEN 'INSERT'
    WHEN 'w' THEN 'UPDATE'
    WHEN 'd' THEN 'DELETE'
    END AS cmd
FROM pg_catalog.pg_policy pol
WHERE pol.polrelid = '30538' ORDER BY 1;
;SELECT oid, stxrelid::pg_catalog.regclass, stxnamespace::pg_catalog.regnamespace::pg_catalog.text AS nsp, stxname,
pg_catalog.pg_get_statisticsobjdef_columns(oid) AS columns,
  'd' = any(stxkind) AS ndist_enabled,
  'f' = any(stxkind) AS deps_enabled,
  'm' = any(stxkind) AS mcv_enabled,
stxstattarget
FROM pg_catalog.pg_statistic_ext
WHERE stxrelid = '30538'
ORDER BY nsp, stxname;
;SELECT pubname
FROM pg_catalog.pg_publication p
		JOIN pg_catalog.pg_publication_namespace pn ON p.oid = pn.pnpubid
		JOIN pg_catalog.pg_class pc ON pc.relnamespace = pn.pnnspid
WHERE pc.oid ='30538' and pg_catalog.pg_relation_is_publishable('30538')
UNION
SELECT pubname
FROM pg_catalog.pg_publication p
		JOIN pg_catalog.pg_publication_rel pr ON p.oid = pr.prpubid
WHERE pr.prrelid = '30538'
UNION
SELECT pubname
FROM pg_catalog.pg_publication p
WHERE p.puballtables AND pg_catalog.pg_relation_is_publishable('30538')
ORDER BY 1;
;SELECT t.tgname, pg_catalog.pg_get_triggerdef(t.oid, true), t.tgenabled, t.tgisinternal,
  CASE WHEN t.tgparentid != 0 THEN
    (SELECT u.tgrelid::pg_catalog.regclass
     FROM pg_catalog.pg_trigger AS u,
          pg_catalog.pg_partition_ancestors(t.tgrelid) WITH ORDINALITY AS a(relid, depth)
     WHERE u.tgname = t.tgname AND u.tgrelid = a.relid
           AND u.tgparentid = 0
     ORDER BY a.depth LIMIT 1)
  END AS parent
FROM pg_catalog.pg_trigger t
WHERE t.tgrelid = '30538' AND (NOT t.tgisinternal OR (t.tgisinternal AND t.tgenabled = 'D'))
ORDER BY 1;
;SELECT c.oid::pg_catalog.regclass
FROM pg_catalog.pg_class c, pg_catalog.pg_inherits i
WHERE c.oid = i.inhparent AND i.inhrelid = '30538'
  AND c.relkind != 'p' AND c.relkind != 'I'
ORDER BY inhseqno;
;SELECT c.oid::pg_catalog.regclass, c.relkind, inhdetachpending, pg_catalog.pg_get_expr(c.relpartbound, c.oid)
FROM pg_catalog.pg_class c, pg_catalog.pg_inherits i
WHERE c.oid = i.inhrelid AND i.inhparent = '30538'
ORDER BY pg_catalog.pg_get_expr(c.relpartbound, c.oid) = 'DEFAULT', c.oid::pg_catalog.regclass::pg_catalog.text;
;SELECT c.oid,
  n.nspname,
  c.relname
FROM pg_catalog.pg_class c
     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
WHERE c.relname OPERATOR(pg_catalog.~) '^(fk_part_23_2)$' COLLATE pg_catalog.default
  AND n.nspname OPERATOR(pg_catalog.~) '^(fkpart0)$' COLLATE pg_catalog.default
ORDER BY 2, 3;
;SELECT c.relchecks, c.relkind, c.relhasindex, c.relhasrules, c.relhastriggers, c.relrowsecurity, c.relforcerowsecurity, false AS relhasoids, c.relispartition, '', c.reltablespace, CASE WHEN c.reloftype = 0 THEN '' ELSE c.reloftype::pg_catalog.regtype::pg_catalog.text END, c.relpersistence, c.relreplident, am.amname
FROM pg_catalog.pg_class c
 LEFT JOIN pg_catalog.pg_class tc ON (c.reltoastrelid = tc.oid)
LEFT JOIN pg_catalog.pg_am am ON (c.relam = am.oid)
WHERE c.oid = '30546';
;SELECT a.attname,
  pg_catalog.format_type(a.atttypid, a.atttypmod),
  (SELECT pg_catalog.pg_get_expr(d.adbin, d.adrelid, true)
   FROM pg_catalog.pg_attrdef d
   WHERE d.adrelid = a.attrelid AND d.adnum = a.attnum AND a.atthasdef),
  a.attnotnull,
  (SELECT c.collname FROM pg_catalog.pg_collation c, pg_catalog.pg_type t
   WHERE c.oid = a.attcollation AND t.oid = a.atttypid AND a.attcollation <> t.typcollation) AS attcollation,
  a.attidentity,
  a.attgenerated
FROM pg_catalog.pg_attribute a
WHERE a.attrelid = '30546' AND a.attnum > 0 AND NOT a.attisdropped
ORDER BY a.attnum;
;SELECT inhparent::pg_catalog.regclass,
  pg_catalog.pg_get_expr(c.relpartbound, c.oid),
  inhdetachpending
FROM pg_catalog.pg_class c JOIN pg_catalog.pg_inherits i ON c.oid = inhrelid
WHERE c.oid = '30546';
;SELECT conrelid = '30546'::pg_catalog.regclass AS sametable,
       conname,
       pg_catalog.pg_get_constraintdef(oid, true) AS condef,
       conrelid::pg_catalog.regclass AS ontable
  FROM pg_catalog.pg_constraint,
       pg_catalog.pg_partition_ancestors('30546')
 WHERE conrelid = relid AND contype = 'f' AND conparentid = 0
ORDER BY sametable DESC, conname;
;SELECT conname, conrelid::pg_catalog.regclass AS ontable,
       pg_catalog.pg_get_constraintdef(oid, true) AS condef
  FROM pg_catalog.pg_constraint c
 WHERE confrelid IN (SELECT pg_catalog.pg_partition_ancestors('30546')
                     UNION ALL VALUES ('30546'::pg_catalog.regclass))
       AND contype = 'f' AND conparentid = 0
ORDER BY conname;
;SELECT pol.polname, pol.polpermissive,
  CASE WHEN pol.polroles = '{0}' THEN NULL ELSE pg_catalog.array_to_string(array(select rolname from pg_catalog.pg_roles where oid = any (pol.polroles) order by 1),',') END,
  pg_catalog.pg_get_expr(pol.polqual, pol.polrelid),
  pg_catalog.pg_get_expr(pol.polwithcheck, pol.polrelid),
  CASE pol.polcmd
    WHEN 'r' THEN 'SELECT'
    WHEN 'a' THEN 'INSERT'
    WHEN 'w' THEN 'UPDATE'
    WHEN 'd' THEN 'DELETE'
    END AS cmd
FROM pg_catalog.pg_policy pol
WHERE pol.polrelid = '30546' ORDER BY 1;
;SELECT oid, stxrelid::pg_catalog.regclass, stxnamespace::pg_catalog.regnamespace::pg_catalog.text AS nsp, stxname,
pg_catalog.pg_get_statisticsobjdef_columns(oid) AS columns,
  'd' = any(stxkind) AS ndist_enabled,
  'f' = any(stxkind) AS deps_enabled,
  'm' = any(stxkind) AS mcv_enabled,
stxstattarget
FROM pg_catalog.pg_statistic_ext
WHERE stxrelid = '30546'
ORDER BY nsp, stxname;
;SELECT pubname
FROM pg_catalog.pg_publication p
		JOIN pg_catalog.pg_publication_namespace pn ON p.oid = pn.pnpubid
		JOIN pg_catalog.pg_class pc ON pc.relnamespace = pn.pnnspid
WHERE pc.oid ='30546' and pg_catalog.pg_relation_is_publishable('30546')
UNION
SELECT pubname
FROM pg_catalog.pg_publication p
		JOIN pg_catalog.pg_publication_rel pr ON p.oid = pr.prpubid
WHERE pr.prrelid = '30546'
UNION
SELECT pubname
FROM pg_catalog.pg_publication p
WHERE p.puballtables AND pg_catalog.pg_relation_is_publishable('30546')
ORDER BY 1;
;SELECT t.tgname, pg_catalog.pg_get_triggerdef(t.oid, true), t.tgenabled, t.tgisinternal,
  CASE WHEN t.tgparentid != 0 THEN
    (SELECT u.tgrelid::pg_catalog.regclass
     FROM pg_catalog.pg_trigger AS u,
          pg_catalog.pg_partition_ancestors(t.tgrelid) WITH ORDINALITY AS a(relid, depth)
     WHERE u.tgname = t.tgname AND u.tgrelid = a.relid
           AND u.tgparentid = 0
     ORDER BY a.depth LIMIT 1)
  END AS parent
FROM pg_catalog.pg_trigger t
WHERE t.tgrelid = '30546' AND (NOT t.tgisinternal OR (t.tgisinternal AND t.tgenabled = 'D'))
ORDER BY 1;
;SELECT c.oid::pg_catalog.regclass
FROM pg_catalog.pg_class c, pg_catalog.pg_inherits i
WHERE c.oid = i.inhparent AND i.inhrelid = '30546'
  AND c.relkind != 'p' AND c.relkind != 'I'
ORDER BY inhseqno;
;SELECT c.oid::pg_catalog.regclass, c.relkind, inhdetachpending, pg_catalog.pg_get_expr(c.relpartbound, c.oid)
FROM pg_catalog.pg_class c, pg_catalog.pg_inherits i
WHERE c.oid = i.inhrelid AND i.inhparent = '30546'
ORDER BY pg_catalog.pg_get_expr(c.relpartbound, c.oid) = 'DEFAULT', c.oid::pg_catalog.regclass::pg_catalog.text;
;alter table fkpart0.fk_part_23 drop constraint fk_part_23_a_fkey;
;alter table fkpart0.fk_part_23_2 drop constraint fk_part_23_a_fkey;
;create table fkpart0.fk_part_4 partition of fkpart0.fk_part for values in (4);
;SELECT c.oid,
  n.nspname,
  c.relname
FROM pg_catalog.pg_class c
     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
WHERE c.relname OPERATOR(pg_catalog.~) '^(fk_part_4)$' COLLATE pg_catalog.default
  AND n.nspname OPERATOR(pg_catalog.~) '^(fkpart0)$' COLLATE pg_catalog.default
ORDER BY 2, 3;
;SELECT c.relchecks, c.relkind, c.relhasindex, c.relhasrules, c.relhastriggers, c.relrowsecurity, c.relforcerowsecurity, false AS relhasoids, c.relispartition, '', c.reltablespace, CASE WHEN c.reloftype = 0 THEN '' ELSE c.reloftype::pg_catalog.regtype::pg_catalog.text END, c.relpersistence, c.relreplident, am.amname
FROM pg_catalog.pg_class c
 LEFT JOIN pg_catalog.pg_class tc ON (c.reltoastrelid = tc.oid)
LEFT JOIN pg_catalog.pg_am am ON (c.relam = am.oid)
WHERE c.oid = '30557';
;SELECT a.attname,
  pg_catalog.format_type(a.atttypid, a.atttypmod),
  (SELECT pg_catalog.pg_get_expr(d.adbin, d.adrelid, true)
   FROM pg_catalog.pg_attrdef d
   WHERE d.adrelid = a.attrelid AND d.adnum = a.attnum AND a.atthasdef),
  a.attnotnull,
  (SELECT c.collname FROM pg_catalog.pg_collation c, pg_catalog.pg_type t
   WHERE c.oid = a.attcollation AND t.oid = a.atttypid AND a.attcollation <> t.typcollation) AS attcollation,
  a.attidentity,
  a.attgenerated
FROM pg_catalog.pg_attribute a
WHERE a.attrelid = '30557' AND a.attnum > 0 AND NOT a.attisdropped
ORDER BY a.attnum;
;SELECT inhparent::pg_catalog.regclass,
  pg_catalog.pg_get_expr(c.relpartbound, c.oid),
  inhdetachpending
FROM pg_catalog.pg_class c JOIN pg_catalog.pg_inherits i ON c.oid = inhrelid
WHERE c.oid = '30557';
;SELECT conrelid = '30557'::pg_catalog.regclass AS sametable,
       conname,
       pg_catalog.pg_get_constraintdef(oid, true) AS condef,
       conrelid::pg_catalog.regclass AS ontable
  FROM pg_catalog.pg_constraint,
       pg_catalog.pg_partition_ancestors('30557')
 WHERE conrelid = relid AND contype = 'f' AND conparentid = 0
ORDER BY sametable DESC, conname;
;SELECT conname, conrelid::pg_catalog.regclass AS ontable,
       pg_catalog.pg_get_constraintdef(oid, true) AS condef
  FROM pg_catalog.pg_constraint c
 WHERE confrelid IN (SELECT pg_catalog.pg_partition_ancestors('30557')
                     UNION ALL VALUES ('30557'::pg_catalog.regclass))
       AND contype = 'f' AND conparentid = 0
ORDER BY conname;
;SELECT pol.polname, pol.polpermissive,
  CASE WHEN pol.polroles = '{0}' THEN NULL ELSE pg_catalog.array_to_string(array(select rolname from pg_catalog.pg_roles where oid = any (pol.polroles) order by 1),',') END,
  pg_catalog.pg_get_expr(pol.polqual, pol.polrelid),
  pg_catalog.pg_get_expr(pol.polwithcheck, pol.polrelid),
  CASE pol.polcmd
    WHEN 'r' THEN 'SELECT'
    WHEN 'a' THEN 'INSERT'
    WHEN 'w' THEN 'UPDATE'
    WHEN 'd' THEN 'DELETE'
    END AS cmd
FROM pg_catalog.pg_policy pol
WHERE pol.polrelid = '30557' ORDER BY 1;
;SELECT oid, stxrelid::pg_catalog.regclass, stxnamespace::pg_catalog.regnamespace::pg_catalog.text AS nsp, stxname,
pg_catalog.pg_get_statisticsobjdef_columns(oid) AS columns,
  'd' = any(stxkind) AS ndist_enabled,
  'f' = any(stxkind) AS deps_enabled,
  'm' = any(stxkind) AS mcv_enabled,
stxstattarget
FROM pg_catalog.pg_statistic_ext
WHERE stxrelid = '30557'
ORDER BY nsp, stxname;
;SELECT pubname
FROM pg_catalog.pg_publication p
		JOIN pg_catalog.pg_publication_namespace pn ON p.oid = pn.pnpubid
		JOIN pg_catalog.pg_class pc ON pc.relnamespace = pn.pnnspid
WHERE pc.oid ='30557' and pg_catalog.pg_relation_is_publishable('30557')
UNION
SELECT pubname
FROM pg_catalog.pg_publication p
		JOIN pg_catalog.pg_publication_rel pr ON p.oid = pr.prpubid
WHERE pr.prrelid = '30557'
UNION
SELECT pubname
FROM pg_catalog.pg_publication p
WHERE p.puballtables AND pg_catalog.pg_relation_is_publishable('30557')
ORDER BY 1;
;SELECT t.tgname, pg_catalog.pg_get_triggerdef(t.oid, true), t.tgenabled, t.tgisinternal,
  CASE WHEN t.tgparentid != 0 THEN
    (SELECT u.tgrelid::pg_catalog.regclass
     FROM pg_catalog.pg_trigger AS u,
          pg_catalog.pg_partition_ancestors(t.tgrelid) WITH ORDINALITY AS a(relid, depth)
     WHERE u.tgname = t.tgname AND u.tgrelid = a.relid
           AND u.tgparentid = 0
     ORDER BY a.depth LIMIT 1)
  END AS parent
FROM pg_catalog.pg_trigger t
WHERE t.tgrelid = '30557' AND (NOT t.tgisinternal OR (t.tgisinternal AND t.tgenabled = 'D'))
ORDER BY 1;
;SELECT c.oid::pg_catalog.regclass
FROM pg_catalog.pg_class c, pg_catalog.pg_inherits i
WHERE c.oid = i.inhparent AND i.inhrelid = '30557'
  AND c.relkind != 'p' AND c.relkind != 'I'
ORDER BY inhseqno;
;SELECT c.oid::pg_catalog.regclass, c.relkind, inhdetachpending, pg_catalog.pg_get_expr(c.relpartbound, c.oid)
FROM pg_catalog.pg_class c, pg_catalog.pg_inherits i
WHERE c.oid = i.inhrelid AND i.inhparent = '30557'
ORDER BY pg_catalog.pg_get_expr(c.relpartbound, c.oid) = 'DEFAULT', c.oid::pg_catalog.regclass::pg_catalog.text;
;alter table fkpart0.fk_part_4 drop constraint fk_part_a_fkey;
;create table fkpart0.fk_part_56 partition of fkpart0.fk_part
    for values in (5,6) partition by list (a);
;create table fkpart0.fk_part_56_5 partition of fkpart0.fk_part_56
    for values in (5);
;SELECT c.oid,
  n.nspname,
  c.relname
FROM pg_catalog.pg_class c
     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
WHERE c.relname OPERATOR(pg_catalog.~) '^(fk_part_56)$' COLLATE pg_catalog.default
  AND n.nspname OPERATOR(pg_catalog.~) '^(fkpart0)$' COLLATE pg_catalog.default
ORDER BY 2, 3;
;SELECT c.relchecks, c.relkind, c.relhasindex, c.relhasrules, c.relhastriggers, c.relrowsecurity, c.relforcerowsecurity, false AS relhasoids, c.relispartition, '', c.reltablespace, CASE WHEN c.reloftype = 0 THEN '' ELSE c.reloftype::pg_catalog.regtype::pg_catalog.text END, c.relpersistence, c.relreplident, am.amname
FROM pg_catalog.pg_class c
 LEFT JOIN pg_catalog.pg_class tc ON (c.reltoastrelid = tc.oid)
LEFT JOIN pg_catalog.pg_am am ON (c.relam = am.oid)
WHERE c.oid = '30563';
;SELECT a.attname,
  pg_catalog.format_type(a.atttypid, a.atttypmod),
  (SELECT pg_catalog.pg_get_expr(d.adbin, d.adrelid, true)
   FROM pg_catalog.pg_attrdef d
   WHERE d.adrelid = a.attrelid AND d.adnum = a.attnum AND a.atthasdef),
  a.attnotnull,
  (SELECT c.collname FROM pg_catalog.pg_collation c, pg_catalog.pg_type t
   WHERE c.oid = a.attcollation AND t.oid = a.atttypid AND a.attcollation <> t.typcollation) AS attcollation,
  a.attidentity,
  a.attgenerated
FROM pg_catalog.pg_attribute a
WHERE a.attrelid = '30563' AND a.attnum > 0 AND NOT a.attisdropped
ORDER BY a.attnum;
;SELECT inhparent::pg_catalog.regclass,
  pg_catalog.pg_get_expr(c.relpartbound, c.oid),
  inhdetachpending
FROM pg_catalog.pg_class c JOIN pg_catalog.pg_inherits i ON c.oid = inhrelid
WHERE c.oid = '30563';
;SELECT pg_catalog.pg_get_partkeydef('30563'::pg_catalog.oid);
;SELECT conrelid = '30563'::pg_catalog.regclass AS sametable,
       conname,
       pg_catalog.pg_get_constraintdef(oid, true) AS condef,
       conrelid::pg_catalog.regclass AS ontable
  FROM pg_catalog.pg_constraint,
       pg_catalog.pg_partition_ancestors('30563')
 WHERE conrelid = relid AND contype = 'f' AND conparentid = 0
ORDER BY sametable DESC, conname;
;SELECT conname, conrelid::pg_catalog.regclass AS ontable,
       pg_catalog.pg_get_constraintdef(oid, true) AS condef
  FROM pg_catalog.pg_constraint c
 WHERE confrelid IN (SELECT pg_catalog.pg_partition_ancestors('30563')
                     UNION ALL VALUES ('30563'::pg_catalog.regclass))
       AND contype = 'f' AND conparentid = 0
ORDER BY conname;
;SELECT pol.polname, pol.polpermissive,
  CASE WHEN pol.polroles = '{0}' THEN NULL ELSE pg_catalog.array_to_string(array(select rolname from pg_catalog.pg_roles where oid = any (pol.polroles) order by 1),',') END,
  pg_catalog.pg_get_expr(pol.polqual, pol.polrelid),
  pg_catalog.pg_get_expr(pol.polwithcheck, pol.polrelid),
  CASE pol.polcmd
    WHEN 'r' THEN 'SELECT'
    WHEN 'a' THEN 'INSERT'
    WHEN 'w' THEN 'UPDATE'
    WHEN 'd' THEN 'DELETE'
    END AS cmd
FROM pg_catalog.pg_policy pol
WHERE pol.polrelid = '30563' ORDER BY 1;
;SELECT oid, stxrelid::pg_catalog.regclass, stxnamespace::pg_catalog.regnamespace::pg_catalog.text AS nsp, stxname,
pg_catalog.pg_get_statisticsobjdef_columns(oid) AS columns,
  'd' = any(stxkind) AS ndist_enabled,
  'f' = any(stxkind) AS deps_enabled,
  'm' = any(stxkind) AS mcv_enabled,
stxstattarget
FROM pg_catalog.pg_statistic_ext
WHERE stxrelid = '30563'
ORDER BY nsp, stxname;
;SELECT pubname
FROM pg_catalog.pg_publication p
		JOIN pg_catalog.pg_publication_namespace pn ON p.oid = pn.pnpubid
		JOIN pg_catalog.pg_class pc ON pc.relnamespace = pn.pnnspid
WHERE pc.oid ='30563' and pg_catalog.pg_relation_is_publishable('30563')
UNION
SELECT pubname
FROM pg_catalog.pg_publication p
		JOIN pg_catalog.pg_publication_rel pr ON p.oid = pr.prpubid
WHERE pr.prrelid = '30563'
UNION
SELECT pubname
FROM pg_catalog.pg_publication p
WHERE p.puballtables AND pg_catalog.pg_relation_is_publishable('30563')
ORDER BY 1;
;SELECT t.tgname, pg_catalog.pg_get_triggerdef(t.oid, true), t.tgenabled, t.tgisinternal,
  CASE WHEN t.tgparentid != 0 THEN
    (SELECT u.tgrelid::pg_catalog.regclass
     FROM pg_catalog.pg_trigger AS u,
          pg_catalog.pg_partition_ancestors(t.tgrelid) WITH ORDINALITY AS a(relid, depth)
     WHERE u.tgname = t.tgname AND u.tgrelid = a.relid
           AND u.tgparentid = 0
     ORDER BY a.depth LIMIT 1)
  END AS parent
FROM pg_catalog.pg_trigger t
WHERE t.tgrelid = '30563' AND (NOT t.tgisinternal OR (t.tgisinternal AND t.tgenabled = 'D'))
ORDER BY 1;
;SELECT c.oid::pg_catalog.regclass
FROM pg_catalog.pg_class c, pg_catalog.pg_inherits i
WHERE c.oid = i.inhparent AND i.inhrelid = '30563'
  AND c.relkind != 'p' AND c.relkind != 'I'
ORDER BY inhseqno;
;SELECT c.oid::pg_catalog.regclass, c.relkind, inhdetachpending, pg_catalog.pg_get_expr(c.relpartbound, c.oid)
FROM pg_catalog.pg_class c, pg_catalog.pg_inherits i
WHERE c.oid = i.inhrelid AND i.inhparent = '30563'
ORDER BY pg_catalog.pg_get_expr(c.relpartbound, c.oid) = 'DEFAULT', c.oid::pg_catalog.regclass::pg_catalog.text;
;alter table fkpart0.fk_part_56 drop constraint fk_part_a_fkey;
;alter table fkpart0.fk_part_56_5 drop constraint fk_part_a_fkey;
;create schema fkpart1
  create table pkey (a int primary key)
  create table fk_part (a int) partition by list (a)
  create table fk_part_1 partition of fk_part for values in (1) partition by list (a)
  create table fk_part_1_1 partition of fk_part_1 for values in (1);
;alter table fkpart1.fk_part add foreign key (a) references fkpart1.pkey;
;insert into fkpart1.fk_part values (1);
;insert into fkpart1.pkey values (1);
;insert into fkpart1.fk_part values (1);
;delete from fkpart1.pkey where a = 1;
;alter table fkpart1.fk_part detach partition fkpart1.fk_part_1;
;create table fkpart1.fk_part_1_2 partition of fkpart1.fk_part_1 for values in (2);
;insert into fkpart1.fk_part_1 values (2);
;delete from fkpart1.pkey where a = 1;
;create schema fkpart2
  create table pkey (a int primary key)
  create table fk_part (a int, constraint fkey foreign key (a) references fkpart2.pkey) partition by list (a)
  create table fk_part_1 partition of fkpart2.fk_part for values in (1) partition by list (a)
  create table fk_part_1_1 (a int, constraint my_fkey foreign key (a) references fkpart2.pkey);
;alter table fkpart2.fk_part_1 attach partition fkpart2.fk_part_1_1 for values in (1);
;alter table fkpart2.fk_part_1 drop constraint fkey;
;alter table fkpart2.fk_part_1_1 drop constraint my_fkey;
;alter table fkpart2.fk_part detach partition fkpart2.fk_part_1;
;alter table fkpart2.fk_part_1 drop constraint fkey;
;alter table fkpart2.fk_part_1_1 drop constraint my_fkey;
;create schema fkpart3
  create table pkey (a int primary key)
  create table fk_part (a int, constraint fkey foreign key (a) references fkpart3.pkey deferrable initially immediate) partition by list (a)
  create table fk_part_1 partition of fkpart3.fk_part for values in (1) partition by list (a)
  create table fk_part_1_1 partition of fkpart3.fk_part_1 for values in (1)
  create table fk_part_2 partition of fkpart3.fk_part for values in (2);
;begin;
;set constraints fkpart3.fkey deferred;
;insert into fkpart3.fk_part values (1);
;insert into fkpart3.pkey values (1);
;commit;
;begin;
;set constraints fkpart3.fkey deferred;
;delete from fkpart3.pkey;
;delete from fkpart3.fk_part;
;commit;
;drop schema fkpart0, fkpart1, fkpart2, fkpart3 cascade;
;CREATE SCHEMA fkpart3;
;SET search_path TO fkpart3;
;CREATE TABLE pk (a int PRIMARY KEY) PARTITION BY RANGE (a);
;CREATE TABLE pk1 PARTITION OF pk FOR VALUES FROM (0) TO (1000);
;CREATE TABLE pk2 (b int, a int);
;ALTER TABLE pk2 DROP COLUMN b;
;ALTER TABLE pk2 ALTER a SET NOT NULL;
;ALTER TABLE pk ATTACH PARTITION pk2 FOR VALUES FROM (1000) TO (2000);
;CREATE TABLE fk (a int) PARTITION BY RANGE (a);
;CREATE TABLE fk1 PARTITION OF fk FOR VALUES FROM (0) TO (750);
;ALTER TABLE fk ADD FOREIGN KEY (a) REFERENCES pk;
;CREATE TABLE fk2 (b int, a int) ;
;ALTER TABLE fk2 DROP COLUMN b;
;ALTER TABLE fk ATTACH PARTITION fk2 FOR VALUES FROM (750) TO (3500);
;CREATE TABLE pk3 PARTITION OF pk FOR VALUES FROM (2000) TO (3000);
;CREATE TABLE pk4 (LIKE pk);
;ALTER TABLE pk ATTACH PARTITION pk4 FOR VALUES FROM (3000) TO (4000);
;CREATE TABLE pk5 (c int, b int, a int NOT NULL) PARTITION BY RANGE (a);
;ALTER TABLE pk5 DROP COLUMN b, DROP COLUMN c;
;CREATE TABLE pk51 PARTITION OF pk5 FOR VALUES FROM (4000) TO (4500);
;CREATE TABLE pk52 PARTITION OF pk5 FOR VALUES FROM (4500) TO (5000);
;ALTER TABLE pk ATTACH PARTITION pk5 FOR VALUES FROM (4000) TO (5000);
;CREATE TABLE fk3 PARTITION OF fk FOR VALUES FROM (3500) TO (5000);
;INSERT into fk VALUES (1);
;INSERT into fk VALUES (1000);
;INSERT into fk VALUES (2000);
;INSERT into fk VALUES (3000);
;INSERT into fk VALUES (4000);
;INSERT into fk VALUES (4500);
;INSERT into pk VALUES (1), (1000), (2000), (3000), (4000), (4500);
;INSERT into fk VALUES (1), (1000), (2000), (3000), (4000), (4500);
;DELETE FROM pk WHERE a = 1;
;DELETE FROM pk WHERE a = 1000;
;DELETE FROM pk WHERE a = 2000;
;DELETE FROM pk WHERE a = 3000;
;DELETE FROM pk WHERE a = 4000;
;DELETE FROM pk WHERE a = 4500;
;UPDATE pk SET a = 2 WHERE a = 1;
;UPDATE pk SET a = 1002 WHERE a = 1000;
;UPDATE pk SET a = 2002 WHERE a = 2000;
;UPDATE pk SET a = 3002 WHERE a = 3000;
;UPDATE pk SET a = 4002 WHERE a = 4000;
;UPDATE pk SET a = 4502 WHERE a = 4500;
;DELETE FROM fk;
;UPDATE pk SET a = 2 WHERE a = 1;
;DELETE FROM pk WHERE a = 2;
;UPDATE pk SET a = 1002 WHERE a = 1000;
;DELETE FROM pk WHERE a = 1002;
;UPDATE pk SET a = 2002 WHERE a = 2000;
;DELETE FROM pk WHERE a = 2002;
;UPDATE pk SET a = 3002 WHERE a = 3000;
;DELETE FROM pk WHERE a = 3002;
;UPDATE pk SET a = 4002 WHERE a = 4000;
;DELETE FROM pk WHERE a = 4002;
;UPDATE pk SET a = 4502 WHERE a = 4500;
;DELETE FROM pk WHERE a = 4502;
;CREATE SCHEMA fkpart4;
;SET search_path TO fkpart4;
;CREATE TABLE droppk (a int PRIMARY KEY) PARTITION BY RANGE (a);
;CREATE TABLE droppk1 PARTITION OF droppk FOR VALUES FROM (0) TO (1000);
;CREATE TABLE droppk_d PARTITION OF droppk DEFAULT;
;CREATE TABLE droppk2 PARTITION OF droppk FOR VALUES FROM (1000) TO (2000)
  PARTITION BY RANGE (a);
;CREATE TABLE droppk21 PARTITION OF droppk2 FOR VALUES FROM (1000) TO (1400);
;CREATE TABLE droppk2_d PARTITION OF droppk2 DEFAULT;
;INSERT into droppk VALUES (1), (1000), (1500), (2000);
;CREATE TABLE dropfk (a int REFERENCES droppk);
;INSERT into dropfk VALUES (1), (1000), (1500), (2000);
;ALTER TABLE droppk DETACH PARTITION droppk_d;
;ALTER TABLE droppk2 DETACH PARTITION droppk2_d;
;ALTER TABLE droppk DETACH PARTITION droppk1;
;ALTER TABLE droppk DETACH PARTITION droppk2;
;ALTER TABLE droppk2 DETACH PARTITION droppk21;
;DROP TABLE droppk_d;
;DROP TABLE droppk2_d;
;DROP TABLE droppk1;
;DROP TABLE droppk2;
;DROP TABLE droppk21;
;DELETE FROM dropfk;
;DROP TABLE droppk_d;
;DROP TABLE droppk2_d;
;DROP TABLE droppk1;
;ALTER TABLE droppk2 DETACH PARTITION droppk21;
;DROP TABLE droppk2;
;CREATE SCHEMA fkpart5;
;SET search_path TO fkpart5;
;CREATE TABLE pk (a int PRIMARY KEY) PARTITION BY LIST (a);
;CREATE TABLE pk1 PARTITION OF pk FOR VALUES IN (1) PARTITION BY LIST (a);
;CREATE TABLE pk11 PARTITION OF pk1 FOR VALUES IN (1);
;CREATE TABLE fk (a int) PARTITION BY LIST (a);
;CREATE TABLE fk1 PARTITION OF fk FOR VALUES IN (1) PARTITION BY LIST (a);
;CREATE TABLE fk11 PARTITION OF fk1 FOR VALUES IN (1);
;ALTER TABLE fk ADD FOREIGN KEY (a) REFERENCES pk;
;CREATE TABLE pk2 PARTITION OF pk FOR VALUES IN (2);
;CREATE TABLE pk3 (a int NOT NULL) PARTITION BY LIST (a);
;CREATE TABLE pk31 PARTITION OF pk3 FOR VALUES IN (31);
;CREATE TABLE pk32 (b int, a int NOT NULL);
;ALTER TABLE pk32 DROP COLUMN b;
;ALTER TABLE pk3 ATTACH PARTITION pk32 FOR VALUES IN (32);
;ALTER TABLE pk ATTACH PARTITION pk3 FOR VALUES IN (31, 32);
;CREATE TABLE fk2 PARTITION OF fk FOR VALUES IN (2);
;CREATE TABLE fk3 (b int, a int);
;ALTER TABLE fk3 DROP COLUMN b;
;ALTER TABLE fk ATTACH PARTITION fk3 FOR VALUES IN (3);
;SELECT pg_describe_object('pg_constraint'::regclass, oid, 0), confrelid::regclass,
       CASE WHEN conparentid <> 0 THEN pg_describe_object('pg_constraint'::regclass, conparentid, 0) ELSE 'TOP' END
FROM pg_catalog.pg_constraint
WHERE conrelid IN (SELECT relid FROM pg_partition_tree('fk'))
ORDER BY conrelid::regclass::text, conname;
;CREATE TABLE fk4 (LIKE fk);
;INSERT INTO fk4 VALUES (50);
;ALTER TABLE fk ATTACH PARTITION fk4 FOR VALUES IN (50);
;CREATE SCHEMA fkpart9;
;SET search_path TO fkpart9;
;CREATE TABLE pk (a int PRIMARY KEY) PARTITION BY LIST (a);
;CREATE TABLE pk1 PARTITION OF pk FOR VALUES IN (1, 2) PARTITION BY LIST (a);
;CREATE TABLE pk11 PARTITION OF pk1 FOR VALUES IN (1);
;CREATE TABLE pk3 PARTITION OF pk FOR VALUES IN (3);
;CREATE TABLE fk (a int REFERENCES pk DEFERRABLE INITIALLY IMMEDIATE);
;INSERT INTO fk VALUES (1);
;BEGIN;
;SET CONSTRAINTS fk_a_fkey DEFERRED;
;INSERT INTO fk VALUES (1);
;COMMIT;
;BEGIN;
;SET CONSTRAINTS fk_a_fkey DEFERRED;
;INSERT INTO fk VALUES (1);
;INSERT INTO pk VALUES (1);
;COMMIT;
;BEGIN;
;SET CONSTRAINTS fk_a_fkey DEFERRED;
;DELETE FROM pk WHERE a = 1;
;DELETE FROM fk WHERE a = 1;
;COMMIT;
;CREATE TABLE pt(f1 int, f2 int, f3 int, PRIMARY KEY(f1,f2));
;CREATE TABLE ref(f1 int, f2 int, f3 int)
  PARTITION BY list(f1);
;CREATE TABLE ref1 PARTITION OF ref FOR VALUES IN (1);
;CREATE TABLE ref2 PARTITION OF ref FOR VALUES in (2);
;ALTER TABLE ref ADD FOREIGN KEY(f1,f2) REFERENCES pt;
;ALTER TABLE ref ALTER CONSTRAINT ref_f1_f2_fkey
  DEFERRABLE INITIALLY DEFERRED;
;INSERT INTO pt VALUES(1,2,3);
;INSERT INTO ref VALUES(1,2,3);
;BEGIN;
;DELETE FROM pt;
;DELETE FROM ref;
;ABORT;
;DROP TABLE pt, ref;
;CREATE TABLE pt(f1 int, f2 int, f3 int, PRIMARY KEY(f1,f2));
;CREATE TABLE ref(f1 int, f2 int, f3 int)
  PARTITION BY list(f1);
;CREATE TABLE ref1_2 PARTITION OF ref FOR VALUES IN (1, 2) PARTITION BY list (f2);
;CREATE TABLE ref1 PARTITION OF ref1_2 FOR VALUES IN (1);
;CREATE TABLE ref2 PARTITION OF ref1_2 FOR VALUES IN (2) PARTITION BY list (f2);
;CREATE TABLE ref22 PARTITION OF ref2 FOR VALUES IN (2);
;ALTER TABLE ref ADD FOREIGN KEY(f1,f2) REFERENCES pt;
;INSERT INTO pt VALUES(1,2,3);
;INSERT INTO ref VALUES(1,2,3);
;ALTER TABLE ref22 ALTER CONSTRAINT ref_f1_f2_fkey
  DEFERRABLE INITIALLY IMMEDIATE;
;ALTER TABLE ref ALTER CONSTRAINT ref_f1_f2_fkey
  DEFERRABLE INITIALLY DEFERRED;
;BEGIN;
;DELETE FROM pt;
;DELETE FROM ref;
;ABORT;
;DROP TABLE pt, ref;
;CREATE TABLE pt(f1 int, f2 int, f3 int, PRIMARY KEY(f1,f2))
  PARTITION BY LIST(f1);
;CREATE TABLE pt1 PARTITION OF pt FOR VALUES IN (1);
;CREATE TABLE pt2 PARTITION OF pt FOR VALUES IN (2);
;CREATE TABLE ref(f1 int, f2 int, f3 int);
;ALTER TABLE ref ADD FOREIGN KEY(f1,f2) REFERENCES pt;
;ALTER TABLE ref ALTER CONSTRAINT ref_f1_f2_fkey
  DEFERRABLE INITIALLY DEFERRED;
;INSERT INTO pt VALUES(1,2,3);
;INSERT INTO ref VALUES(1,2,3);
;BEGIN;
;DELETE FROM pt;
;DELETE FROM ref;
;ABORT;
;DROP TABLE pt, ref;
;CREATE TABLE pt(f1 int, f2 int, f3 int, PRIMARY KEY(f1,f2))
  PARTITION BY LIST(f1);
;CREATE TABLE pt1_2 PARTITION OF pt FOR VALUES IN (1, 2) PARTITION BY LIST (f1);
;CREATE TABLE pt1 PARTITION OF pt1_2 FOR VALUES IN (1);
;CREATE TABLE pt2 PARTITION OF pt1_2 FOR VALUES IN (2);
;CREATE TABLE ref(f1 int, f2 int, f3 int);
;ALTER TABLE ref ADD FOREIGN KEY(f1,f2) REFERENCES pt;
;ALTER TABLE ref ALTER CONSTRAINT ref_f1_f2_fkey1
  DEFERRABLE INITIALLY DEFERRED;
;ALTER TABLE ref ALTER CONSTRAINT ref_f1_f2_fkey
  DEFERRABLE INITIALLY DEFERRED;
;INSERT INTO pt VALUES(1,2,3);
;INSERT INTO ref VALUES(1,2,3);
;BEGIN;
;DELETE FROM pt;
;DELETE FROM ref;
;ABORT;
;DROP TABLE pt, ref;
;DROP SCHEMA fkpart9 CASCADE;
;CREATE SCHEMA fkpart6;
;SET search_path TO fkpart6;
;CREATE TABLE pk (a int PRIMARY KEY) PARTITION BY RANGE (a);
;CREATE TABLE pk1 PARTITION OF pk FOR VALUES FROM (1) TO (100) PARTITION BY RANGE (a);
;CREATE TABLE pk11 PARTITION OF pk1 FOR VALUES FROM (1) TO (50);
;CREATE TABLE pk12 PARTITION OF pk1 FOR VALUES FROM (50) TO (100);
;CREATE TABLE fk (a int) PARTITION BY RANGE (a);
;CREATE TABLE fk1 PARTITION OF fk FOR VALUES FROM (1) TO (100) PARTITION BY RANGE (a);
;CREATE TABLE fk11 PARTITION OF fk1 FOR VALUES FROM (1) TO (10);
;CREATE TABLE fk12 PARTITION OF fk1 FOR VALUES FROM (10) TO (100);
;ALTER TABLE fk ADD FOREIGN KEY (a) REFERENCES pk ON UPDATE CASCADE ON DELETE CASCADE;
;CREATE TABLE fk_d PARTITION OF fk DEFAULT;
;INSERT INTO pk VALUES (1);
;INSERT INTO fk VALUES (1);
;UPDATE pk SET a = 20;
;SELECT tableoid::regclass, * FROM fk;
;DELETE FROM pk WHERE a = 20;
;SELECT tableoid::regclass, * FROM fk;
;DROP TABLE fk;
;TRUNCATE TABLE pk;
;INSERT INTO pk VALUES (20), (50);
;CREATE TABLE fk (a int) PARTITION BY RANGE (a);
;CREATE TABLE fk1 PARTITION OF fk FOR VALUES FROM (1) TO (100) PARTITION BY RANGE (a);
;CREATE TABLE fk11 PARTITION OF fk1 FOR VALUES FROM (1) TO (10);
;CREATE TABLE fk12 PARTITION OF fk1 FOR VALUES FROM (10) TO (100);
;ALTER TABLE fk ADD FOREIGN KEY (a) REFERENCES pk ON UPDATE SET NULL ON DELETE SET NULL;
;CREATE TABLE fk_d PARTITION OF fk DEFAULT;
;INSERT INTO fk VALUES (20), (50);
;UPDATE pk SET a = 21 WHERE a = 20;
;DELETE FROM pk WHERE a = 50;
;SELECT tableoid::regclass, * FROM fk;
;DROP TABLE fk;
;TRUNCATE TABLE pk;
;INSERT INTO pk VALUES (20), (30), (50);
;CREATE TABLE fk (id int, a int DEFAULT 50) PARTITION BY RANGE (a);
;CREATE TABLE fk1 PARTITION OF fk FOR VALUES FROM (1) TO (100) PARTITION BY RANGE (a);
;CREATE TABLE fk11 PARTITION OF fk1 FOR VALUES FROM (1) TO (10);
;CREATE TABLE fk12 PARTITION OF fk1 FOR VALUES FROM (10) TO (100);
;ALTER TABLE fk ADD FOREIGN KEY (a) REFERENCES pk ON UPDATE SET DEFAULT ON DELETE SET DEFAULT;
;CREATE TABLE fk_d PARTITION OF fk DEFAULT;
;INSERT INTO fk VALUES (1, 20), (2, 30);
;DELETE FROM pk WHERE a = 20 RETURNING *;
;UPDATE pk SET a = 90 WHERE a = 30 RETURNING *;
;SELECT tableoid::regclass, * FROM fk;
;DROP TABLE fk;
;TRUNCATE TABLE pk;
;INSERT INTO pk VALUES (20), (30);
;CREATE TABLE fk (a int DEFAULT 50) PARTITION BY RANGE (a);
;CREATE TABLE fk1 PARTITION OF fk FOR VALUES FROM (1) TO (100) PARTITION BY RANGE (a);
;CREATE TABLE fk11 PARTITION OF fk1 FOR VALUES FROM (1) TO (10);
;CREATE TABLE fk12 PARTITION OF fk1 FOR VALUES FROM (10) TO (100);
;ALTER TABLE fk ADD FOREIGN KEY (a) REFERENCES pk ON UPDATE RESTRICT ON DELETE RESTRICT;
;CREATE TABLE fk_d PARTITION OF fk DEFAULT;
;INSERT INTO fk VALUES (20), (30);
;DELETE FROM pk WHERE a = 20;
;UPDATE pk SET a = 90 WHERE a = 30;
;SELECT tableoid::regclass, * FROM fk;
;DROP TABLE fk;
;CREATE SCHEMA fkpart7
  CREATE TABLE pkpart (a int) PARTITION BY LIST (a)
  CREATE TABLE pkpart1 PARTITION OF pkpart FOR VALUES IN (1);
;ALTER TABLE fkpart7.pkpart1 ADD PRIMARY KEY (a);
;ALTER TABLE fkpart7.pkpart ADD PRIMARY KEY (a);
;CREATE TABLE fkpart7.fk (a int REFERENCES fkpart7.pkpart);
;DROP SCHEMA fkpart7 CASCADE;
;CREATE SCHEMA fkpart8
  CREATE TABLE tbl1(f1 int PRIMARY KEY)
  CREATE TABLE tbl2(f1 int REFERENCES tbl1 DEFERRABLE INITIALLY DEFERRED) PARTITION BY RANGE(f1)
  CREATE TABLE tbl2_p1 PARTITION OF tbl2 FOR VALUES FROM (minvalue) TO (maxvalue);
;INSERT INTO fkpart8.tbl1 VALUES(1);
;BEGIN;
;INSERT INTO fkpart8.tbl2 VALUES(1);
;ALTER TABLE fkpart8.tbl2 DROP CONSTRAINT tbl2_f1_fkey;
;COMMIT;
;DROP SCHEMA fkpart8 CASCADE;
;CREATE SCHEMA fkpart9
  CREATE TABLE pk (a INT PRIMARY KEY) PARTITION BY RANGE (a)
  CREATE TABLE fk (
    fk_a INT REFERENCES pk(a) ON DELETE CASCADE
  )
  CREATE TABLE pk1 PARTITION OF pk FOR VALUES FROM (30) TO (50) PARTITION BY RANGE (a)
  CREATE TABLE pk11 PARTITION OF pk1 FOR VALUES FROM (30) TO (40);
;INSERT INTO fkpart9.pk VALUES (35);
;INSERT INTO fkpart9.fk VALUES (35);
;DELETE FROM fkpart9.pk WHERE a=35;
;SELECT * FROM fkpart9.pk;
;SELECT * FROM fkpart9.fk;
;DROP SCHEMA fkpart9 CASCADE;
;CREATE SCHEMA fkpart10
  CREATE TABLE tbl1(f1 int PRIMARY KEY) PARTITION BY RANGE(f1)
  CREATE TABLE tbl1_p1 PARTITION OF tbl1 FOR VALUES FROM (minvalue) TO (1)
  CREATE TABLE tbl1_p2 PARTITION OF tbl1 FOR VALUES FROM (1) TO (maxvalue)
  CREATE TABLE tbl2(f1 int REFERENCES tbl1 DEFERRABLE INITIALLY DEFERRED);
;INSERT INTO fkpart10.tbl1 VALUES (0), (1);
;INSERT INTO fkpart10.tbl2 VALUES (0), (1);
;BEGIN;
;DELETE FROM fkpart10.tbl1 WHERE f1 = 0;
;UPDATE fkpart10.tbl1 SET f1 = 2 WHERE f1 = 1;
;INSERT INTO fkpart10.tbl1 VALUES (0), (1);
;COMMIT;
;DROP SCHEMA fkpart10 CASCADE;
;