CREATE TABLE hobbies_r (
	name		text,
	person 		text
);
;CREATE TABLE equipment_r (
	name 		text,
	hobby		text
);
;CREATE TABLE onek (
	unique1		int4,
	unique2		int4,
	two			int4,
	four		int4,
	ten			int4,
	twenty		int4,
	hundred		int4,
	thousand	int4,
	twothousand	int4,
	fivethous	int4,
	tenthous	int4,
	odd			int4,
	even		int4,
	stringu1	name,
	stringu2	name,
	string4		name
);
;CREATE TABLE tenk1 (
	unique1		int4,
	unique2		int4,
	two			int4,
	four		int4,
	ten			int4,
	twenty		int4,
	hundred		int4,
	thousand	int4,
	twothousand	int4,
	fivethous	int4,
	tenthous	int4,
	odd			int4,
	even		int4,
	stringu1	name,
	stringu2	name,
	string4		name
);
;CREATE TABLE tenk2 (
	unique1 	int4,
	unique2 	int4,
	two 	 	int4,
	four 		int4,
	ten			int4,
	twenty 		int4,
	hundred 	int4,
	thousand 	int4,
	twothousand int4,
	fivethous 	int4,
	tenthous	int4,
	odd			int4,
	even		int4,
	stringu1	name,
	stringu2	name,
	string4		name
);
;CREATE TABLE person (
	name 		text,
	age			int4,
	location 	point
);
;CREATE TABLE emp (
	salary 		int4,
	manager 	name
) INHERITS (person);
;CREATE TABLE student (
	gpa 		float8
) INHERITS (person);
;CREATE TABLE stud_emp (
	percent 	int4
) INHERITS (emp, student);
;CREATE TABLE city (
	name		name,
	location 	box,
	budget 		city_budget
);
;CREATE TABLE dept (
	dname		name,
	mgrname 	text
);
;CREATE TABLE slow_emp4000 (
	home_base	 box
);
;CREATE TABLE fast_emp4000 (
	home_base	 box
);
;CREATE TABLE road (
	name		text,
	thepath 	path
);
;CREATE TABLE ihighway () INHERITS (road);
;CREATE TABLE shighway (
	surface		text
) INHERITS (road);
;CREATE TABLE real_city (
	pop			int4,
	cname		text,
	outline 	path
);
;CREATE TABLE a_star (
	class		char,
	a 			int4
);
;CREATE TABLE b_star (
	b 			text
) INHERITS (a_star);
;CREATE TABLE c_star (
	c 			name
) INHERITS (a_star);
;CREATE TABLE d_star (
	d 			float8
) INHERITS (b_star, c_star);
;CREATE TABLE e_star (
	e 			int2
) INHERITS (c_star);
;CREATE TABLE f_star (
	f 			polygon
) INHERITS (e_star);
;CREATE TABLE aggtest (
	a 			int2,
	b			float4
);
;CREATE TABLE hash_i4_heap (
	seqno 		int4,
	random 		int4
);
;CREATE TABLE hash_name_heap (
	seqno 		int4,
	random 		name
);
;CREATE TABLE hash_txt_heap (
	seqno 		int4,
	random 		text
);
;CREATE TABLE hash_f8_heap (
	seqno		int4,
	random 		float8
);
;CREATE TABLE bt_i4_heap (
	seqno 		int4,
	random 		int4
);
;CREATE TABLE bt_name_heap (
	seqno 		name,
	random 		int4
);
;CREATE TABLE bt_txt_heap (
	seqno 		text,
	random 		int4
);
;CREATE TABLE bt_f8_heap (
	seqno 		float8,
	random 		int4
);
;CREATE TABLE array_op_test (
	seqno		int4,
	i			int4[],
	t			text[]
);
;CREATE TABLE array_index_op_test (
	seqno		int4,
	i			int4[],
	t			text[]
);
;CREATE TABLE testjsonb (
       j jsonb
);
;CREATE TABLE unknowntab (
	u unknown    -- fail
);
;CREATE TYPE unknown_comptype AS (
	u unknown    -- fail
);
;CREATE TABLE IF NOT EXISTS test_tsvector(
	t text,
	a tsvector
);
;CREATE TABLE IF NOT EXISTS test_tsvector(
	t text
);
;CREATE TABLE tas_case WITH ("Fillfactor" = 10) AS SELECT 1 a;
;CREATE UNLOGGED TABLE unlogged1 (a int primary key);
;CREATE TEMPORARY TABLE unlogged2 (a int primary key);
;SELECT relname, relkind, relpersistence FROM pg_class WHERE relname ~ '^unlogged\d' ORDER BY relname;
;REINDEX INDEX unlogged1_pkey;
;REINDEX INDEX unlogged2_pkey;
;SELECT relname, relkind, relpersistence FROM pg_class WHERE relname ~ '^unlogged\d' ORDER BY relname;
;DROP TABLE unlogged2;
;INSERT INTO unlogged1 VALUES (42);
;CREATE UNLOGGED TABLE public.unlogged2 (a int primary key);
;CREATE UNLOGGED TABLE pg_temp.unlogged3 (a int primary key);
;CREATE TABLE pg_temp.implicitly_temp (a int primary key);
;CREATE TEMP TABLE explicitly_temp (a int primary key);
;CREATE TEMP TABLE pg_temp.doubly_temp (a int primary key);
;CREATE TEMP TABLE public.temp_to_perm (a int primary key);
;DROP TABLE unlogged1, public.unlogged2;
;CREATE TABLE as_select1 AS SELECT * FROM pg_class WHERE relkind = 'r';
;CREATE TABLE as_select1 AS SELECT * FROM pg_class WHERE relkind = 'r';
;CREATE TABLE IF NOT EXISTS as_select1 AS SELECT * FROM pg_class WHERE relkind = 'r';
;DROP TABLE as_select1;
;PREPARE select1 AS SELECT 1 as a;
;CREATE TABLE as_select1 AS EXECUTE select1;
;CREATE TABLE as_select1 AS EXECUTE select1;
;SELECT * FROM as_select1;
;CREATE TABLE IF NOT EXISTS as_select1 AS EXECUTE select1;
;DROP TABLE as_select1;
;DEALLOCATE select1;
;SELECT 'CREATE TABLE extra_wide_table(firstc text, '|| array_to_string(array_agg('c'||i||' bool'),',')||', lastc text);'
FROM generate_series(1, 1100) g(i)
;CREATE TABLE extra_wide_table(firstc text, c1 bool,c2 bool,c3 bool,c4 bool,c5 bool,c6 bool,c7 bool,c8 bool,c9 bool,c10 bool,c11 bool,c12 bool,c13 bool,c14 bool,c15 bool,c16 bool,c17 bool,c18 bool,c19 bool,c20 bool,c21 bool,c22 bool,c23 bool,c24 bool,c25 bool,c26 bool,c27 bool,c28 bool,c29 bool,c30 bool,c31 bool,c32 bool,c33 bool,c34 bool,c35 bool,c36 bool,c37 bool,c38 bool,c39 bool,c40 bool,c41 bool,c42 bool,c43 bool,c44 bool,c45 bool,c46 bool,c47 bool,c48 bool,c49 bool,c50 bool,c51 bool,c52 bool,c53 bool,c54 bool,c55 bool,c56 bool,c57 bool,c58 bool,c59 bool,c60 bool,c61 bool,c62 bool,c63 bool,c64 bool,c65 bool,c66 bool,c67 bool,c68 bool,c69 bool,c70 bool,c71 bool,c72 bool,c73 bool,c74 bool,c75 bool,c76 bool,c77 bool,c78 bool,c79 bool,c80 bool,c81 bool,c82 bool,c83 bool,c84 bool,c85 bool,c86 bool,c87 bool,c88 bool,c89 bool,c90 bool,c91 bool,c92 bool,c93 bool,c94 bool,c95 bool,c96 bool,c97 bool,c98 bool,c99 bool,c100 bool,c101 bool,c102 bool,c103 bool,c104 bool,c105 bool,c106 bool,c107 bool,c108 bool,c109 bool,c110 bool,c111 bool,c112 bool,c113 bool,c114 bool,c115 bool,c116 bool,c117 bool,c118 bool,c119 bool,c120 bool,c121 bool,c122 bool,c123 bool,c124 bool,c125 bool,c126 bool,c127 bool,c128 bool,c129 bool,c130 bool,c131 bool,c132 bool,c133 bool,c134 bool,c135 bool,c136 bool,c137 bool,c138 bool,c139 bool,c140 bool,c141 bool,c142 bool,c143 bool,c144 bool,c145 bool,c146 bool,c147 bool,c148 bool,c149 bool,c150 bool,c151 bool,c152 bool,c153 bool,c154 bool,c155 bool,c156 bool,c157 bool,c158 bool,c159 bool,c160 bool,c161 bool,c162 bool,c163 bool,c164 bool,c165 bool,c166 bool,c167 bool,c168 bool,c169 bool,c170 bool,c171 bool,c172 bool,c173 bool,c174 bool,c175 bool,c176 bool,c177 bool,c178 bool,c179 bool,c180 bool,c181 bool,c182 bool,c183 bool,c184 bool,c185 bool,c186 bool,c187 bool,c188 bool,c189 bool,c190 bool,c191 bool,c192 bool,c193 bool,c194 bool,c195 bool,c196 bool,c197 bool,c198 bool,c199 bool,c200 bool,c201 bool,c202 bool,c203 bool,c204 bool,c205 bool,c206 bool,c207 bool,c208 bool,c209 bool,c210 bool,c211 bool,c212 bool,c213 bool,c214 bool,c215 bool,c216 bool,c217 bool,c218 bool,c219 bool,c220 bool,c221 bool,c222 bool,c223 bool,c224 bool,c225 bool,c226 bool,c227 bool,c228 bool,c229 bool,c230 bool,c231 bool,c232 bool,c233 bool,c234 bool,c235 bool,c236 bool,c237 bool,c238 bool,c239 bool,c240 bool,c241 bool,c242 bool,c243 bool,c244 bool,c245 bool,c246 bool,c247 bool,c248 bool,c249 bool,c250 bool,c251 bool,c252 bool,c253 bool,c254 bool,c255 bool,c256 bool,c257 bool,c258 bool,c259 bool,c260 bool,c261 bool,c262 bool,c263 bool,c264 bool,c265 bool,c266 bool,c267 bool,c268 bool,c269 bool,c270 bool,c271 bool,c272 bool,c273 bool,c274 bool,c275 bool,c276 bool,c277 bool,c278 bool,c279 bool,c280 bool,c281 bool,c282 bool,c283 bool,c284 bool,c285 bool,c286 bool,c287 bool,c288 bool,c289 bool,c290 bool,c291 bool,c292 bool,c293 bool,c294 bool,c295 bool,c296 bool,c297 bool,c298 bool,c299 bool,c300 bool,c301 bool,c302 bool,c303 bool,c304 bool,c305 bool,c306 bool,c307 bool,c308 bool,c309 bool,c310 bool,c311 bool,c312 bool,c313 bool,c314 bool,c315 bool,c316 bool,c317 bool,c318 bool,c319 bool,c320 bool,c321 bool,c322 bool,c323 bool,c324 bool,c325 bool,c326 bool,c327 bool,c328 bool,c329 bool,c330 bool,c331 bool,c332 bool,c333 bool,c334 bool,c335 bool,c336 bool,c337 bool,c338 bool,c339 bool,c340 bool,c341 bool,c342 bool,c343 bool,c344 bool,c345 bool,c346 bool,c347 bool,c348 bool,c349 bool,c350 bool,c351 bool,c352 bool,c353 bool,c354 bool,c355 bool,c356 bool,c357 bool,c358 bool,c359 bool,c360 bool,c361 bool,c362 bool,c363 bool,c364 bool,c365 bool,c366 bool,c367 bool,c368 bool,c369 bool,c370 bool,c371 bool,c372 bool,c373 bool,c374 bool,c375 bool,c376 bool,c377 bool,c378 bool,c379 bool,c380 bool,c381 bool,c382 bool,c383 bool,c384 bool,c385 bool,c386 bool,c387 bool,c388 bool,c389 bool,c390 bool,c391 bool,c392 bool,c393 bool,c394 bool,c395 bool,c396 bool,c397 bool,c398 bool,c399 bool,c400 bool,c401 bool,c402 bool,c403 bool,c404 bool,c405 bool,c406 bool,c407 bool,c408 bool,c409 bool,c410 bool,c411 bool,c412 bool,c413 bool,c414 bool,c415 bool,c416 bool,c417 bool,c418 bool,c419 bool,c420 bool,c421 bool,c422 bool,c423 bool,c424 bool,c425 bool,c426 bool,c427 bool,c428 bool,c429 bool,c430 bool,c431 bool,c432 bool,c433 bool,c434 bool,c435 bool,c436 bool,c437 bool,c438 bool,c439 bool,c440 bool,c441 bool,c442 bool,c443 bool,c444 bool,c445 bool,c446 bool,c447 bool,c448 bool,c449 bool,c450 bool,c451 bool,c452 bool,c453 bool,c454 bool,c455 bool,c456 bool,c457 bool,c458 bool,c459 bool,c460 bool,c461 bool,c462 bool,c463 bool,c464 bool,c465 bool,c466 bool,c467 bool,c468 bool,c469 bool,c470 bool,c471 bool,c472 bool,c473 bool,c474 bool,c475 bool,c476 bool,c477 bool,c478 bool,c479 bool,c480 bool,c481 bool,c482 bool,c483 bool,c484 bool,c485 bool,c486 bool,c487 bool,c488 bool,c489 bool,c490 bool,c491 bool,c492 bool,c493 bool,c494 bool,c495 bool,c496 bool,c497 bool,c498 bool,c499 bool,c500 bool,c501 bool,c502 bool,c503 bool,c504 bool,c505 bool,c506 bool,c507 bool,c508 bool,c509 bool,c510 bool,c511 bool,c512 bool,c513 bool,c514 bool,c515 bool,c516 bool,c517 bool,c518 bool,c519 bool,c520 bool,c521 bool,c522 bool,c523 bool,c524 bool,c525 bool,c526 bool,c527 bool,c528 bool,c529 bool,c530 bool,c531 bool,c532 bool,c533 bool,c534 bool,c535 bool,c536 bool,c537 bool,c538 bool,c539 bool,c540 bool,c541 bool,c542 bool,c543 bool,c544 bool,c545 bool,c546 bool,c547 bool,c548 bool,c549 bool,c550 bool,c551 bool,c552 bool,c553 bool,c554 bool,c555 bool,c556 bool,c557 bool,c558 bool,c559 bool,c560 bool,c561 bool,c562 bool,c563 bool,c564 bool,c565 bool,c566 bool,c567 bool,c568 bool,c569 bool,c570 bool,c571 bool,c572 bool,c573 bool,c574 bool,c575 bool,c576 bool,c577 bool,c578 bool,c579 bool,c580 bool,c581 bool,c582 bool,c583 bool,c584 bool,c585 bool,c586 bool,c587 bool,c588 bool,c589 bool,c590 bool,c591 bool,c592 bool,c593 bool,c594 bool,c595 bool,c596 bool,c597 bool,c598 bool,c599 bool,c600 bool,c601 bool,c602 bool,c603 bool,c604 bool,c605 bool,c606 bool,c607 bool,c608 bool,c609 bool,c610 bool,c611 bool,c612 bool,c613 bool,c614 bool,c615 bool,c616 bool,c617 bool,c618 bool,c619 bool,c620 bool,c621 bool,c622 bool,c623 bool,c624 bool,c625 bool,c626 bool,c627 bool,c628 bool,c629 bool,c630 bool,c631 bool,c632 bool,c633 bool,c634 bool,c635 bool,c636 bool,c637 bool,c638 bool,c639 bool,c640 bool,c641 bool,c642 bool,c643 bool,c644 bool,c645 bool,c646 bool,c647 bool,c648 bool,c649 bool,c650 bool,c651 bool,c652 bool,c653 bool,c654 bool,c655 bool,c656 bool,c657 bool,c658 bool,c659 bool,c660 bool,c661 bool,c662 bool,c663 bool,c664 bool,c665 bool,c666 bool,c667 bool,c668 bool,c669 bool,c670 bool,c671 bool,c672 bool,c673 bool,c674 bool,c675 bool,c676 bool,c677 bool,c678 bool,c679 bool,c680 bool,c681 bool,c682 bool,c683 bool,c684 bool,c685 bool,c686 bool,c687 bool,c688 bool,c689 bool,c690 bool,c691 bool,c692 bool,c693 bool,c694 bool,c695 bool,c696 bool,c697 bool,c698 bool,c699 bool,c700 bool,c701 bool,c702 bool,c703 bool,c704 bool,c705 bool,c706 bool,c707 bool,c708 bool,c709 bool,c710 bool,c711 bool,c712 bool,c713 bool,c714 bool,c715 bool,c716 bool,c717 bool,c718 bool,c719 bool,c720 bool,c721 bool,c722 bool,c723 bool,c724 bool,c725 bool,c726 bool,c727 bool,c728 bool,c729 bool,c730 bool,c731 bool,c732 bool,c733 bool,c734 bool,c735 bool,c736 bool,c737 bool,c738 bool,c739 bool,c740 bool,c741 bool,c742 bool,c743 bool,c744 bool,c745 bool,c746 bool,c747 bool,c748 bool,c749 bool,c750 bool,c751 bool,c752 bool,c753 bool,c754 bool,c755 bool,c756 bool,c757 bool,c758 bool,c759 bool,c760 bool,c761 bool,c762 bool,c763 bool,c764 bool,c765 bool,c766 bool,c767 bool,c768 bool,c769 bool,c770 bool,c771 bool,c772 bool,c773 bool,c774 bool,c775 bool,c776 bool,c777 bool,c778 bool,c779 bool,c780 bool,c781 bool,c782 bool,c783 bool,c784 bool,c785 bool,c786 bool,c787 bool,c788 bool,c789 bool,c790 bool,c791 bool,c792 bool,c793 bool,c794 bool,c795 bool,c796 bool,c797 bool,c798 bool,c799 bool,c800 bool,c801 bool,c802 bool,c803 bool,c804 bool,c805 bool,c806 bool,c807 bool,c808 bool,c809 bool,c810 bool,c811 bool,c812 bool,c813 bool,c814 bool,c815 bool,c816 bool,c817 bool,c818 bool,c819 bool,c820 bool,c821 bool,c822 bool,c823 bool,c824 bool,c825 bool,c826 bool,c827 bool,c828 bool,c829 bool,c830 bool,c831 bool,c832 bool,c833 bool,c834 bool,c835 bool,c836 bool,c837 bool,c838 bool,c839 bool,c840 bool,c841 bool,c842 bool,c843 bool,c844 bool,c845 bool,c846 bool,c847 bool,c848 bool,c849 bool,c850 bool,c851 bool,c852 bool,c853 bool,c854 bool,c855 bool,c856 bool,c857 bool,c858 bool,c859 bool,c860 bool,c861 bool,c862 bool,c863 bool,c864 bool,c865 bool,c866 bool,c867 bool,c868 bool,c869 bool,c870 bool,c871 bool,c872 bool,c873 bool,c874 bool,c875 bool,c876 bool,c877 bool,c878 bool,c879 bool,c880 bool,c881 bool,c882 bool,c883 bool,c884 bool,c885 bool,c886 bool,c887 bool,c888 bool,c889 bool,c890 bool,c891 bool,c892 bool,c893 bool,c894 bool,c895 bool,c896 bool,c897 bool,c898 bool,c899 bool,c900 bool,c901 bool,c902 bool,c903 bool,c904 bool,c905 bool,c906 bool,c907 bool,c908 bool,c909 bool,c910 bool,c911 bool,c912 bool,c913 bool,c914 bool,c915 bool,c916 bool,c917 bool,c918 bool,c919 bool,c920 bool,c921 bool,c922 bool,c923 bool,c924 bool,c925 bool,c926 bool,c927 bool,c928 bool,c929 bool,c930 bool,c931 bool,c932 bool,c933 bool,c934 bool,c935 bool,c936 bool,c937 bool,c938 bool,c939 bool,c940 bool,c941 bool,c942 bool,c943 bool,c944 bool,c945 bool,c946 bool,c947 bool,c948 bool,c949 bool,c950 bool,c951 bool,c952 bool,c953 bool,c954 bool,c955 bool,c956 bool,c957 bool,c958 bool,c959 bool,c960 bool,c961 bool,c962 bool,c963 bool,c964 bool,c965 bool,c966 bool,c967 bool,c968 bool,c969 bool,c970 bool,c971 bool,c972 bool,c973 bool,c974 bool,c975 bool,c976 bool,c977 bool,c978 bool,c979 bool,c980 bool,c981 bool,c982 bool,c983 bool,c984 bool,c985 bool,c986 bool,c987 bool,c988 bool,c989 bool,c990 bool,c991 bool,c992 bool,c993 bool,c994 bool,c995 bool,c996 bool,c997 bool,c998 bool,c999 bool,c1000 bool,c1001 bool,c1002 bool,c1003 bool,c1004 bool,c1005 bool,c1006 bool,c1007 bool,c1008 bool,c1009 bool,c1010 bool,c1011 bool,c1012 bool,c1013 bool,c1014 bool,c1015 bool,c1016 bool,c1017 bool,c1018 bool,c1019 bool,c1020 bool,c1021 bool,c1022 bool,c1023 bool,c1024 bool,c1025 bool,c1026 bool,c1027 bool,c1028 bool,c1029 bool,c1030 bool,c1031 bool,c1032 bool,c1033 bool,c1034 bool,c1035 bool,c1036 bool,c1037 bool,c1038 bool,c1039 bool,c1040 bool,c1041 bool,c1042 bool,c1043 bool,c1044 bool,c1045 bool,c1046 bool,c1047 bool,c1048 bool,c1049 bool,c1050 bool,c1051 bool,c1052 bool,c1053 bool,c1054 bool,c1055 bool,c1056 bool,c1057 bool,c1058 bool,c1059 bool,c1060 bool,c1061 bool,c1062 bool,c1063 bool,c1064 bool,c1065 bool,c1066 bool,c1067 bool,c1068 bool,c1069 bool,c1070 bool,c1071 bool,c1072 bool,c1073 bool,c1074 bool,c1075 bool,c1076 bool,c1077 bool,c1078 bool,c1079 bool,c1080 bool,c1081 bool,c1082 bool,c1083 bool,c1084 bool,c1085 bool,c1086 bool,c1087 bool,c1088 bool,c1089 bool,c1090 bool,c1091 bool,c1092 bool,c1093 bool,c1094 bool,c1095 bool,c1096 bool,c1097 bool,c1098 bool,c1099 bool,c1100 bool, lastc text);
;INSERT INTO extra_wide_table(firstc, lastc) VALUES('first col', 'last col');
;SELECT firstc, lastc FROM extra_wide_table;
;CREATE TABLE withoid() WITH OIDS;
;CREATE TABLE withoid() WITH (oids);
;CREATE TABLE withoid() WITH (oids = true);
;CREATE TEMP TABLE withoutoid() WITHOUT OIDS;
;DROP TABLE withoutoid;
;CREATE TEMP TABLE withoutoid() WITH (oids = false);
;DROP TABLE withoutoid;
;CREATE TABLE default_expr_column (id int DEFAULT (id));
;CREATE TABLE default_expr_column (id int DEFAULT (bar.id));
;CREATE TABLE default_expr_agg_column (id int DEFAULT (avg(id)));
;CREATE TABLE default_expr_non_column (a int DEFAULT (avg(non_existent)));
;CREATE TABLE default_expr_agg (a int DEFAULT (avg(1)));
;CREATE TABLE default_expr_agg (a int DEFAULT (select 1));
;CREATE TABLE default_expr_agg (a int DEFAULT (generate_series(1,3)));
;BEGIN;
;CREATE TABLE remember_create_subid (c int);
;SAVEPOINT q;
;DROP TABLE remember_create_subid;
;ROLLBACK TO q;
;COMMIT;
;DROP TABLE remember_create_subid;
;CREATE TABLE remember_node_subid (c int);
;BEGIN;
;ALTER TABLE remember_node_subid ALTER c TYPE bigint;
;SAVEPOINT q;
;DROP TABLE remember_node_subid;
;ROLLBACK TO q;
;COMMIT;
;DROP TABLE remember_node_subid;
;CREATE TABLE partitioned (
	a int
) INHERITS (some_table) PARTITION BY LIST (a);
;CREATE TABLE partitioned (
	a1 int,
	a2 int
) PARTITION BY LIST (a1, a2);
;CREATE TABLE partitioned (
	a int,
	EXCLUDE USING gist (a WITH &&)
) PARTITION BY RANGE (a);
;CREATE FUNCTION retset (a int) RETURNS SETOF int AS $$ SELECT 1; $$ LANGUAGE SQL IMMUTABLE;
;CREATE TABLE partitioned (
	a int
) PARTITION BY RANGE (retset(a));
;DROP FUNCTION retset(int);
;CREATE TABLE partitioned (
	a int
) PARTITION BY RANGE ((avg(a)));
;CREATE TABLE partitioned (
	a int,
	b int
) PARTITION BY RANGE ((avg(a) OVER (PARTITION BY b)));
;CREATE TABLE partitioned (
	a int
) PARTITION BY LIST ((a LIKE (SELECT 1)));
;CREATE TABLE partitioned (
	a int
) PARTITION BY RANGE ((42));
;CREATE FUNCTION const_func () RETURNS int AS $$ SELECT 1; $$ LANGUAGE SQL IMMUTABLE;
;CREATE TABLE partitioned (
	a int
) PARTITION BY RANGE (const_func());
;DROP FUNCTION const_func();
;CREATE TABLE partitioned (
    a int
) PARTITION BY MAGIC (a);
;CREATE TABLE partitioned (
	a int
) PARTITION BY RANGE (b);
;CREATE TABLE partitioned (
	a int
) PARTITION BY RANGE (xmin);
;CREATE TABLE partitioned (
	a int,
	b int
) PARTITION BY RANGE (((a, b)));
;CREATE TABLE partitioned (
	a int,
	b int
) PARTITION BY RANGE (a, ('unknown'));
;CREATE FUNCTION immut_func (a int) RETURNS int AS $$ SELECT a + random()::int; $$ LANGUAGE SQL;
;CREATE TABLE partitioned (
	a int
) PARTITION BY RANGE (immut_func(a));
;DROP FUNCTION immut_func(int);
;CREATE TABLE partitioned (
	a point
) PARTITION BY LIST (a);
;CREATE TABLE partitioned (
	a point
) PARTITION BY LIST (a point_ops);
;CREATE TABLE partitioned (
	a point
) PARTITION BY RANGE (a);
;CREATE TABLE partitioned (
	a point
) PARTITION BY RANGE (a point_ops);
;CREATE TABLE partitioned (
	a int,
	CONSTRAINT check_a CHECK (a > 0) NO INHERIT
) PARTITION BY RANGE (a);
;CREATE FUNCTION plusone(a int) RETURNS INT AS $$ SELECT a+1; $$ LANGUAGE SQL;
;CREATE TABLE partitioned (
	a int,
	b int,
	c text,
	d text
) PARTITION BY RANGE (a oid_ops, plusone(b), c collate "default", d collate "C");
;SELECT relkind FROM pg_class WHERE relname = 'partitioned';
;DROP FUNCTION plusone(int);
;CREATE TABLE partitioned2 (
	a int,
	b text
) PARTITION BY RANGE ((a+1), substr(b, 1, 5));
;CREATE TABLE fail () INHERITS (partitioned2);
;SELECT c.oid,
  n.nspname,
  c.relname
FROM pg_catalog.pg_class c
     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
WHERE c.relname OPERATOR(pg_catalog.~) '^(partitioned)$' COLLATE pg_catalog.default
  AND pg_catalog.pg_table_is_visible(c.oid)
ORDER BY 2, 3;
;SELECT c.relchecks, c.relkind, c.relhasindex, c.relhasrules, c.relhastriggers, c.relrowsecurity, c.relforcerowsecurity, false AS relhasoids, c.relispartition, '', c.reltablespace, CASE WHEN c.reloftype = 0 THEN '' ELSE c.reloftype::pg_catalog.regtype::pg_catalog.text END, c.relpersistence, c.relreplident, am.amname
FROM pg_catalog.pg_class c
 LEFT JOIN pg_catalog.pg_class tc ON (c.reltoastrelid = tc.oid)
LEFT JOIN pg_catalog.pg_am am ON (c.relam = am.oid)
WHERE c.oid = '17854';
;SELECT a.attname,
  pg_catalog.format_type(a.atttypid, a.atttypmod),
  (SELECT pg_catalog.pg_get_expr(d.adbin, d.adrelid, true)
   FROM pg_catalog.pg_attrdef d
   WHERE d.adrelid = a.attrelid AND d.adnum = a.attnum AND a.atthasdef),
  a.attnotnull,
  (SELECT c.collname FROM pg_catalog.pg_collation c, pg_catalog.pg_type t
   WHERE c.oid = a.attcollation AND t.oid = a.atttypid AND a.attcollation <> t.typcollation) AS attcollation,
  a.attidentity,
  a.attgenerated
FROM pg_catalog.pg_attribute a
WHERE a.attrelid = '17854' AND a.attnum > 0 AND NOT a.attisdropped
ORDER BY a.attnum;
;SELECT pg_catalog.pg_get_partkeydef('17854'::pg_catalog.oid);
;SELECT conrelid = '17854'::pg_catalog.regclass AS sametable,
       conname,
       pg_catalog.pg_get_constraintdef(oid, true) AS condef,
       conrelid::pg_catalog.regclass AS ontable
  FROM pg_catalog.pg_constraint,
       pg_catalog.pg_partition_ancestors('17854')
 WHERE conrelid = relid AND contype = 'f' AND conparentid = 0
ORDER BY sametable DESC, conname;
;SELECT conname, conrelid::pg_catalog.regclass AS ontable,
       pg_catalog.pg_get_constraintdef(oid, true) AS condef
  FROM pg_catalog.pg_constraint c
 WHERE confrelid IN (SELECT pg_catalog.pg_partition_ancestors('17854')
                     UNION ALL VALUES ('17854'::pg_catalog.regclass))
       AND contype = 'f' AND conparentid = 0
ORDER BY conname;
;SELECT pol.polname, pol.polpermissive,
  CASE WHEN pol.polroles = '{0}' THEN NULL ELSE pg_catalog.array_to_string(array(select rolname from pg_catalog.pg_roles where oid = any (pol.polroles) order by 1),',') END,
  pg_catalog.pg_get_expr(pol.polqual, pol.polrelid),
  pg_catalog.pg_get_expr(pol.polwithcheck, pol.polrelid),
  CASE pol.polcmd
    WHEN 'r' THEN 'SELECT'
    WHEN 'a' THEN 'INSERT'
    WHEN 'w' THEN 'UPDATE'
    WHEN 'd' THEN 'DELETE'
    END AS cmd
FROM pg_catalog.pg_policy pol
WHERE pol.polrelid = '17854' ORDER BY 1;
;SELECT oid, stxrelid::pg_catalog.regclass, stxnamespace::pg_catalog.regnamespace::pg_catalog.text AS nsp, stxname,
pg_catalog.pg_get_statisticsobjdef_columns(oid) AS columns,
  'd' = any(stxkind) AS ndist_enabled,
  'f' = any(stxkind) AS deps_enabled,
  'm' = any(stxkind) AS mcv_enabled,
stxstattarget
FROM pg_catalog.pg_statistic_ext
WHERE stxrelid = '17854'
ORDER BY nsp, stxname;
;SELECT pubname
FROM pg_catalog.pg_publication p
		JOIN pg_catalog.pg_publication_namespace pn ON p.oid = pn.pnpubid
		JOIN pg_catalog.pg_class pc ON pc.relnamespace = pn.pnnspid
WHERE pc.oid ='17854' and pg_catalog.pg_relation_is_publishable('17854')
UNION
SELECT pubname
FROM pg_catalog.pg_publication p
		JOIN pg_catalog.pg_publication_rel pr ON p.oid = pr.prpubid
WHERE pr.prrelid = '17854'
UNION
SELECT pubname
FROM pg_catalog.pg_publication p
WHERE p.puballtables AND pg_catalog.pg_relation_is_publishable('17854')
ORDER BY 1;
;SELECT c.oid::pg_catalog.regclass
FROM pg_catalog.pg_class c, pg_catalog.pg_inherits i
WHERE c.oid = i.inhparent AND i.inhrelid = '17854'
  AND c.relkind != 'p' AND c.relkind != 'I'
ORDER BY inhseqno;
;SELECT c.oid::pg_catalog.regclass, c.relkind, inhdetachpending, pg_catalog.pg_get_expr(c.relpartbound, c.oid)
FROM pg_catalog.pg_class c, pg_catalog.pg_inherits i
WHERE c.oid = i.inhrelid AND i.inhparent = '17854'
ORDER BY pg_catalog.pg_get_expr(c.relpartbound, c.oid) = 'DEFAULT', c.oid::pg_catalog.regclass::pg_catalog.text;
;SELECT c.oid,
  n.nspname,
  c.relname
FROM pg_catalog.pg_class c
     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
WHERE c.relname OPERATOR(pg_catalog.~) '^(partitioned2)$' COLLATE pg_catalog.default
  AND pg_catalog.pg_table_is_visible(c.oid)
ORDER BY 2, 3;
;SELECT c.relchecks, c.relkind, c.relhasindex, c.relhasrules, c.relhastriggers, c.relrowsecurity, c.relforcerowsecurity, false AS relhasoids, c.relispartition, pg_catalog.array_to_string(c.reloptions || array(select 'toast.' || x from pg_catalog.unnest(tc.reloptions) x), ', ')
, c.reltablespace, CASE WHEN c.reloftype = 0 THEN '' ELSE c.reloftype::pg_catalog.regtype::pg_catalog.text END, c.relpersistence, c.relreplident, am.amname
FROM pg_catalog.pg_class c
 LEFT JOIN pg_catalog.pg_class tc ON (c.reltoastrelid = tc.oid)
LEFT JOIN pg_catalog.pg_am am ON (c.relam = am.oid)
WHERE c.oid = '17857';
;SELECT a.attname,
  pg_catalog.format_type(a.atttypid, a.atttypmod),
  (SELECT pg_catalog.pg_get_expr(d.adbin, d.adrelid, true)
   FROM pg_catalog.pg_attrdef d
   WHERE d.adrelid = a.attrelid AND d.adnum = a.attnum AND a.atthasdef),
  a.attnotnull,
  (SELECT c.collname FROM pg_catalog.pg_collation c, pg_catalog.pg_type t
   WHERE c.oid = a.attcollation AND t.oid = a.atttypid AND a.attcollation <> t.typcollation) AS attcollation,
  a.attidentity,
  a.attgenerated,
  a.attstorage,
  CASE WHEN a.attstattarget=-1 THEN NULL ELSE a.attstattarget END AS attstattarget,
  pg_catalog.col_description(a.attrelid, a.attnum)
FROM pg_catalog.pg_attribute a
WHERE a.attrelid = '17857' AND a.attnum > 0 AND NOT a.attisdropped
ORDER BY a.attnum;
;SELECT pg_catalog.pg_get_partkeydef('17857'::pg_catalog.oid);
;SELECT conrelid = '17857'::pg_catalog.regclass AS sametable,
       conname,
       pg_catalog.pg_get_constraintdef(oid, true) AS condef,
       conrelid::pg_catalog.regclass AS ontable
  FROM pg_catalog.pg_constraint,
       pg_catalog.pg_partition_ancestors('17857')
 WHERE conrelid = relid AND contype = 'f' AND conparentid = 0
ORDER BY sametable DESC, conname;
;SELECT conname, conrelid::pg_catalog.regclass AS ontable,
       pg_catalog.pg_get_constraintdef(oid, true) AS condef
  FROM pg_catalog.pg_constraint c
 WHERE confrelid IN (SELECT pg_catalog.pg_partition_ancestors('17857')
                     UNION ALL VALUES ('17857'::pg_catalog.regclass))
       AND contype = 'f' AND conparentid = 0
ORDER BY conname;
;SELECT pol.polname, pol.polpermissive,
  CASE WHEN pol.polroles = '{0}' THEN NULL ELSE pg_catalog.array_to_string(array(select rolname from pg_catalog.pg_roles where oid = any (pol.polroles) order by 1),',') END,
  pg_catalog.pg_get_expr(pol.polqual, pol.polrelid),
  pg_catalog.pg_get_expr(pol.polwithcheck, pol.polrelid),
  CASE pol.polcmd
    WHEN 'r' THEN 'SELECT'
    WHEN 'a' THEN 'INSERT'
    WHEN 'w' THEN 'UPDATE'
    WHEN 'd' THEN 'DELETE'
    END AS cmd
FROM pg_catalog.pg_policy pol
WHERE pol.polrelid = '17857' ORDER BY 1;
;SELECT oid, stxrelid::pg_catalog.regclass, stxnamespace::pg_catalog.regnamespace::pg_catalog.text AS nsp, stxname,
pg_catalog.pg_get_statisticsobjdef_columns(oid) AS columns,
  'd' = any(stxkind) AS ndist_enabled,
  'f' = any(stxkind) AS deps_enabled,
  'm' = any(stxkind) AS mcv_enabled,
stxstattarget
FROM pg_catalog.pg_statistic_ext
WHERE stxrelid = '17857'
ORDER BY nsp, stxname;
;SELECT pubname
FROM pg_catalog.pg_publication p
		JOIN pg_catalog.pg_publication_namespace pn ON p.oid = pn.pnpubid
		JOIN pg_catalog.pg_class pc ON pc.relnamespace = pn.pnnspid
WHERE pc.oid ='17857' and pg_catalog.pg_relation_is_publishable('17857')
UNION
SELECT pubname
FROM pg_catalog.pg_publication p
		JOIN pg_catalog.pg_publication_rel pr ON p.oid = pr.prpubid
WHERE pr.prrelid = '17857'
UNION
SELECT pubname
FROM pg_catalog.pg_publication p
WHERE p.puballtables AND pg_catalog.pg_relation_is_publishable('17857')
ORDER BY 1;
;SELECT c.oid::pg_catalog.regclass
FROM pg_catalog.pg_class c, pg_catalog.pg_inherits i
WHERE c.oid = i.inhparent AND i.inhrelid = '17857'
  AND c.relkind != 'p' AND c.relkind != 'I'
ORDER BY inhseqno;
;SELECT c.oid::pg_catalog.regclass, c.relkind, inhdetachpending, pg_catalog.pg_get_expr(c.relpartbound, c.oid)
FROM pg_catalog.pg_class c, pg_catalog.pg_inherits i
WHERE c.oid = i.inhrelid AND i.inhparent = '17857'
ORDER BY pg_catalog.pg_get_expr(c.relpartbound, c.oid) = 'DEFAULT', c.oid::pg_catalog.regclass::pg_catalog.text;
;INSERT INTO partitioned2 VALUES (1, 'hello');
;CREATE TABLE part2_1 PARTITION OF partitioned2 FOR VALUES FROM (-1, 'aaaaa') TO (100, 'ccccc');
;SELECT c.oid,
  n.nspname,
  c.relname
FROM pg_catalog.pg_class c
     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
WHERE c.relname OPERATOR(pg_catalog.~) '^(part2_1)$' COLLATE pg_catalog.default
  AND pg_catalog.pg_table_is_visible(c.oid)
ORDER BY 2, 3;
;SELECT c.relchecks, c.relkind, c.relhasindex, c.relhasrules, c.relhastriggers, c.relrowsecurity, c.relforcerowsecurity, false AS relhasoids, c.relispartition, pg_catalog.array_to_string(c.reloptions || array(select 'toast.' || x from pg_catalog.unnest(tc.reloptions) x), ', ')
, c.reltablespace, CASE WHEN c.reloftype = 0 THEN '' ELSE c.reloftype::pg_catalog.regtype::pg_catalog.text END, c.relpersistence, c.relreplident, am.amname
FROM pg_catalog.pg_class c
 LEFT JOIN pg_catalog.pg_class tc ON (c.reltoastrelid = tc.oid)
LEFT JOIN pg_catalog.pg_am am ON (c.relam = am.oid)
WHERE c.oid = '17860';
;SELECT a.attname,
  pg_catalog.format_type(a.atttypid, a.atttypmod),
  (SELECT pg_catalog.pg_get_expr(d.adbin, d.adrelid, true)
   FROM pg_catalog.pg_attrdef d
   WHERE d.adrelid = a.attrelid AND d.adnum = a.attnum AND a.atthasdef),
  a.attnotnull,
  (SELECT c.collname FROM pg_catalog.pg_collation c, pg_catalog.pg_type t
   WHERE c.oid = a.attcollation AND t.oid = a.atttypid AND a.attcollation <> t.typcollation) AS attcollation,
  a.attidentity,
  a.attgenerated,
  a.attstorage,
  CASE WHEN a.attstattarget=-1 THEN NULL ELSE a.attstattarget END AS attstattarget,
  pg_catalog.col_description(a.attrelid, a.attnum)
FROM pg_catalog.pg_attribute a
WHERE a.attrelid = '17860' AND a.attnum > 0 AND NOT a.attisdropped
ORDER BY a.attnum;
;SELECT inhparent::pg_catalog.regclass,
  pg_catalog.pg_get_expr(c.relpartbound, c.oid),
  inhdetachpending,
  pg_catalog.pg_get_partition_constraintdef(c.oid)
FROM pg_catalog.pg_class c JOIN pg_catalog.pg_inherits i ON c.oid = inhrelid
WHERE c.oid = '17860';
;SELECT pol.polname, pol.polpermissive,
  CASE WHEN pol.polroles = '{0}' THEN NULL ELSE pg_catalog.array_to_string(array(select rolname from pg_catalog.pg_roles where oid = any (pol.polroles) order by 1),',') END,
  pg_catalog.pg_get_expr(pol.polqual, pol.polrelid),
  pg_catalog.pg_get_expr(pol.polwithcheck, pol.polrelid),
  CASE pol.polcmd
    WHEN 'r' THEN 'SELECT'
    WHEN 'a' THEN 'INSERT'
    WHEN 'w' THEN 'UPDATE'
    WHEN 'd' THEN 'DELETE'
    END AS cmd
FROM pg_catalog.pg_policy pol
WHERE pol.polrelid = '17860' ORDER BY 1;
;SELECT oid, stxrelid::pg_catalog.regclass, stxnamespace::pg_catalog.regnamespace::pg_catalog.text AS nsp, stxname,
pg_catalog.pg_get_statisticsobjdef_columns(oid) AS columns,
  'd' = any(stxkind) AS ndist_enabled,
  'f' = any(stxkind) AS deps_enabled,
  'm' = any(stxkind) AS mcv_enabled,
stxstattarget
FROM pg_catalog.pg_statistic_ext
WHERE stxrelid = '17860'
ORDER BY nsp, stxname;
;SELECT pubname
FROM pg_catalog.pg_publication p
		JOIN pg_catalog.pg_publication_namespace pn ON p.oid = pn.pnpubid
		JOIN pg_catalog.pg_class pc ON pc.relnamespace = pn.pnnspid
WHERE pc.oid ='17860' and pg_catalog.pg_relation_is_publishable('17860')
UNION
SELECT pubname
FROM pg_catalog.pg_publication p
		JOIN pg_catalog.pg_publication_rel pr ON p.oid = pr.prpubid
WHERE pr.prrelid = '17860'
UNION
SELECT pubname
FROM pg_catalog.pg_publication p
WHERE p.puballtables AND pg_catalog.pg_relation_is_publishable('17860')
ORDER BY 1;
;SELECT c.oid::pg_catalog.regclass
FROM pg_catalog.pg_class c, pg_catalog.pg_inherits i
WHERE c.oid = i.inhparent AND i.inhrelid = '17860'
  AND c.relkind != 'p' AND c.relkind != 'I'
ORDER BY inhseqno;
;SELECT c.oid::pg_catalog.regclass, c.relkind, inhdetachpending, pg_catalog.pg_get_expr(c.relpartbound, c.oid)
FROM pg_catalog.pg_class c, pg_catalog.pg_inherits i
WHERE c.oid = i.inhrelid AND i.inhparent = '17860'
ORDER BY pg_catalog.pg_get_expr(c.relpartbound, c.oid) = 'DEFAULT', c.oid::pg_catalog.regclass::pg_catalog.text;
;DROP TABLE partitioned, partitioned2;
;create table partitioned (a int, b int)
  partition by list ((row(a, b)::partitioned));
;create table partitioned1
  partition of partitioned for values in ('(1,2)'::partitioned);
;create table partitioned2
  partition of partitioned for values in ('(2,4)'::partitioned);
;explain (costs off)
select * from partitioned where row(a,b)::partitioned = '(1,2)'::partitioned;
;drop table partitioned;
;create table partitioned (a int, b int)
  partition by list ((partitioned));
;create table partitioned1
  partition of partitioned for values in ('(1,2)');
;create table partitioned2
  partition of partitioned for values in ('(2,4)');
;explain (costs off)
select * from partitioned where partitioned = '(1,2)'::partitioned;
;SELECT c.oid,
  n.nspname,
  c.relname
FROM pg_catalog.pg_class c
     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
WHERE c.relname OPERATOR(pg_catalog.~) '^(partitioned1)$' COLLATE pg_catalog.default
  AND pg_catalog.pg_table_is_visible(c.oid)
ORDER BY 2, 3;
;SELECT c.relchecks, c.relkind, c.relhasindex, c.relhasrules, c.relhastriggers, c.relrowsecurity, c.relforcerowsecurity, false AS relhasoids, c.relispartition, pg_catalog.array_to_string(c.reloptions || array(select 'toast.' || x from pg_catalog.unnest(tc.reloptions) x), ', ')
, c.reltablespace, CASE WHEN c.reloftype = 0 THEN '' ELSE c.reloftype::pg_catalog.regtype::pg_catalog.text END, c.relpersistence, c.relreplident, am.amname
FROM pg_catalog.pg_class c
 LEFT JOIN pg_catalog.pg_class tc ON (c.reltoastrelid = tc.oid)
LEFT JOIN pg_catalog.pg_am am ON (c.relam = am.oid)
WHERE c.oid = '17877';
;SELECT a.attname,
  pg_catalog.format_type(a.atttypid, a.atttypmod),
  (SELECT pg_catalog.pg_get_expr(d.adbin, d.adrelid, true)
   FROM pg_catalog.pg_attrdef d
   WHERE d.adrelid = a.attrelid AND d.adnum = a.attnum AND a.atthasdef),
  a.attnotnull,
  (SELECT c.collname FROM pg_catalog.pg_collation c, pg_catalog.pg_type t
   WHERE c.oid = a.attcollation AND t.oid = a.atttypid AND a.attcollation <> t.typcollation) AS attcollation,
  a.attidentity,
  a.attgenerated,
  a.attstorage,
  CASE WHEN a.attstattarget=-1 THEN NULL ELSE a.attstattarget END AS attstattarget,
  pg_catalog.col_description(a.attrelid, a.attnum)
FROM pg_catalog.pg_attribute a
WHERE a.attrelid = '17877' AND a.attnum > 0 AND NOT a.attisdropped
ORDER BY a.attnum;
;SELECT inhparent::pg_catalog.regclass,
  pg_catalog.pg_get_expr(c.relpartbound, c.oid),
  inhdetachpending,
  pg_catalog.pg_get_partition_constraintdef(c.oid)
FROM pg_catalog.pg_class c JOIN pg_catalog.pg_inherits i ON c.oid = inhrelid
WHERE c.oid = '17877';
;SELECT pol.polname, pol.polpermissive,
  CASE WHEN pol.polroles = '{0}' THEN NULL ELSE pg_catalog.array_to_string(array(select rolname from pg_catalog.pg_roles where oid = any (pol.polroles) order by 1),',') END,
  pg_catalog.pg_get_expr(pol.polqual, pol.polrelid),
  pg_catalog.pg_get_expr(pol.polwithcheck, pol.polrelid),
  CASE pol.polcmd
    WHEN 'r' THEN 'SELECT'
    WHEN 'a' THEN 'INSERT'
    WHEN 'w' THEN 'UPDATE'
    WHEN 'd' THEN 'DELETE'
    END AS cmd
FROM pg_catalog.pg_policy pol
WHERE pol.polrelid = '17877' ORDER BY 1;
;SELECT oid, stxrelid::pg_catalog.regclass, stxnamespace::pg_catalog.regnamespace::pg_catalog.text AS nsp, stxname,
pg_catalog.pg_get_statisticsobjdef_columns(oid) AS columns,
  'd' = any(stxkind) AS ndist_enabled,
  'f' = any(stxkind) AS deps_enabled,
  'm' = any(stxkind) AS mcv_enabled,
stxstattarget
FROM pg_catalog.pg_statistic_ext
WHERE stxrelid = '17877'
ORDER BY nsp, stxname;
;SELECT pubname
FROM pg_catalog.pg_publication p
		JOIN pg_catalog.pg_publication_namespace pn ON p.oid = pn.pnpubid
		JOIN pg_catalog.pg_class pc ON pc.relnamespace = pn.pnnspid
WHERE pc.oid ='17877' and pg_catalog.pg_relation_is_publishable('17877')
UNION
SELECT pubname
FROM pg_catalog.pg_publication p
		JOIN pg_catalog.pg_publication_rel pr ON p.oid = pr.prpubid
WHERE pr.prrelid = '17877'
UNION
SELECT pubname
FROM pg_catalog.pg_publication p
WHERE p.puballtables AND pg_catalog.pg_relation_is_publishable('17877')
ORDER BY 1;
;SELECT c.oid::pg_catalog.regclass
FROM pg_catalog.pg_class c, pg_catalog.pg_inherits i
WHERE c.oid = i.inhparent AND i.inhrelid = '17877'
  AND c.relkind != 'p' AND c.relkind != 'I'
ORDER BY inhseqno;
;SELECT c.oid::pg_catalog.regclass, c.relkind, inhdetachpending, pg_catalog.pg_get_expr(c.relpartbound, c.oid)
FROM pg_catalog.pg_class c, pg_catalog.pg_inherits i
WHERE c.oid = i.inhrelid AND i.inhparent = '17877'
ORDER BY pg_catalog.pg_get_expr(c.relpartbound, c.oid) = 'DEFAULT', c.oid::pg_catalog.regclass::pg_catalog.text;
;drop table partitioned;
;create domain intdom1 as int;
;create table partitioned (
	a intdom1,
	b text
) partition by range (a);
;alter table partitioned drop column a;
;drop domain intdom1;
;drop domain intdom1 cascade;
;table partitioned;
;create domain intdom1 as int;
;create table partitioned (
	a intdom1,
	b text
) partition by range (plusone(a));
;alter table partitioned drop column a;
;drop domain intdom1;
;drop domain intdom1 cascade;
;table partitioned;
;CREATE TABLE list_parted (
	a int
) PARTITION BY LIST (a);
;CREATE TABLE part_p1 PARTITION OF list_parted FOR VALUES IN ('1');
;CREATE TABLE part_p2 PARTITION OF list_parted FOR VALUES IN (2);
;CREATE TABLE part_p3 PARTITION OF list_parted FOR VALUES IN ((2+1));
;CREATE TABLE part_null PARTITION OF list_parted FOR VALUES IN (null);
;SELECT c.oid,
  n.nspname,
  c.relname
FROM pg_catalog.pg_class c
     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
WHERE c.relname OPERATOR(pg_catalog.~) '^(list_parted)$' COLLATE pg_catalog.default
  AND pg_catalog.pg_table_is_visible(c.oid)
ORDER BY 2, 3;
;SELECT c.relchecks, c.relkind, c.relhasindex, c.relhasrules, c.relhastriggers, c.relrowsecurity, c.relforcerowsecurity, false AS relhasoids, c.relispartition, pg_catalog.array_to_string(c.reloptions || array(select 'toast.' || x from pg_catalog.unnest(tc.reloptions) x), ', ')
, c.reltablespace, CASE WHEN c.reloftype = 0 THEN '' ELSE c.reloftype::pg_catalog.regtype::pg_catalog.text END, c.relpersistence, c.relreplident, am.amname
FROM pg_catalog.pg_class c
 LEFT JOIN pg_catalog.pg_class tc ON (c.reltoastrelid = tc.oid)
LEFT JOIN pg_catalog.pg_am am ON (c.relam = am.oid)
WHERE c.oid = '17893';
;SELECT a.attname,
  pg_catalog.format_type(a.atttypid, a.atttypmod),
  (SELECT pg_catalog.pg_get_expr(d.adbin, d.adrelid, true)
   FROM pg_catalog.pg_attrdef d
   WHERE d.adrelid = a.attrelid AND d.adnum = a.attnum AND a.atthasdef),
  a.attnotnull,
  (SELECT c.collname FROM pg_catalog.pg_collation c, pg_catalog.pg_type t
   WHERE c.oid = a.attcollation AND t.oid = a.atttypid AND a.attcollation <> t.typcollation) AS attcollation,
  a.attidentity,
  a.attgenerated,
  a.attstorage,
  CASE WHEN a.attstattarget=-1 THEN NULL ELSE a.attstattarget END AS attstattarget,
  pg_catalog.col_description(a.attrelid, a.attnum)
FROM pg_catalog.pg_attribute a
WHERE a.attrelid = '17893' AND a.attnum > 0 AND NOT a.attisdropped
ORDER BY a.attnum;
;SELECT pg_catalog.pg_get_partkeydef('17893'::pg_catalog.oid);
;SELECT conrelid = '17893'::pg_catalog.regclass AS sametable,
       conname,
       pg_catalog.pg_get_constraintdef(oid, true) AS condef,
       conrelid::pg_catalog.regclass AS ontable
  FROM pg_catalog.pg_constraint,
       pg_catalog.pg_partition_ancestors('17893')
 WHERE conrelid = relid AND contype = 'f' AND conparentid = 0
ORDER BY sametable DESC, conname;
;SELECT conname, conrelid::pg_catalog.regclass AS ontable,
       pg_catalog.pg_get_constraintdef(oid, true) AS condef
  FROM pg_catalog.pg_constraint c
 WHERE confrelid IN (SELECT pg_catalog.pg_partition_ancestors('17893')
                     UNION ALL VALUES ('17893'::pg_catalog.regclass))
       AND contype = 'f' AND conparentid = 0
ORDER BY conname;
;SELECT pol.polname, pol.polpermissive,
  CASE WHEN pol.polroles = '{0}' THEN NULL ELSE pg_catalog.array_to_string(array(select rolname from pg_catalog.pg_roles where oid = any (pol.polroles) order by 1),',') END,
  pg_catalog.pg_get_expr(pol.polqual, pol.polrelid),
  pg_catalog.pg_get_expr(pol.polwithcheck, pol.polrelid),
  CASE pol.polcmd
    WHEN 'r' THEN 'SELECT'
    WHEN 'a' THEN 'INSERT'
    WHEN 'w' THEN 'UPDATE'
    WHEN 'd' THEN 'DELETE'
    END AS cmd
FROM pg_catalog.pg_policy pol
WHERE pol.polrelid = '17893' ORDER BY 1;
;SELECT oid, stxrelid::pg_catalog.regclass, stxnamespace::pg_catalog.regnamespace::pg_catalog.text AS nsp, stxname,
pg_catalog.pg_get_statisticsobjdef_columns(oid) AS columns,
  'd' = any(stxkind) AS ndist_enabled,
  'f' = any(stxkind) AS deps_enabled,
  'm' = any(stxkind) AS mcv_enabled,
stxstattarget
FROM pg_catalog.pg_statistic_ext
WHERE stxrelid = '17893'
ORDER BY nsp, stxname;
;SELECT pubname
FROM pg_catalog.pg_publication p
		JOIN pg_catalog.pg_publication_namespace pn ON p.oid = pn.pnpubid
		JOIN pg_catalog.pg_class pc ON pc.relnamespace = pn.pnnspid
WHERE pc.oid ='17893' and pg_catalog.pg_relation_is_publishable('17893')
UNION
SELECT pubname
FROM pg_catalog.pg_publication p
		JOIN pg_catalog.pg_publication_rel pr ON p.oid = pr.prpubid
WHERE pr.prrelid = '17893'
UNION
SELECT pubname
FROM pg_catalog.pg_publication p
WHERE p.puballtables AND pg_catalog.pg_relation_is_publishable('17893')
ORDER BY 1;
;SELECT c.oid::pg_catalog.regclass
FROM pg_catalog.pg_class c, pg_catalog.pg_inherits i
WHERE c.oid = i.inhparent AND i.inhrelid = '17893'
  AND c.relkind != 'p' AND c.relkind != 'I'
ORDER BY inhseqno;
;SELECT c.oid::pg_catalog.regclass, c.relkind, inhdetachpending, pg_catalog.pg_get_expr(c.relpartbound, c.oid)
FROM pg_catalog.pg_class c, pg_catalog.pg_inherits i
WHERE c.oid = i.inhrelid AND i.inhparent = '17893'
ORDER BY pg_catalog.pg_get_expr(c.relpartbound, c.oid) = 'DEFAULT', c.oid::pg_catalog.regclass::pg_catalog.text;
;CREATE TABLE part_bogus_expr_fail PARTITION OF list_parted FOR VALUES IN (somename);
;CREATE TABLE part_bogus_expr_fail PARTITION OF list_parted FOR VALUES IN (somename.somename);
;CREATE TABLE part_bogus_expr_fail PARTITION OF list_parted FOR VALUES IN (a);
;CREATE TABLE part_bogus_expr_fail PARTITION OF list_parted FOR VALUES IN (sum(a));
;CREATE TABLE part_bogus_expr_fail PARTITION OF list_parted FOR VALUES IN (sum(somename));
;CREATE TABLE part_bogus_expr_fail PARTITION OF list_parted FOR VALUES IN (sum(1));
;CREATE TABLE part_bogus_expr_fail PARTITION OF list_parted FOR VALUES IN ((select 1));
;CREATE TABLE part_bogus_expr_fail PARTITION OF list_parted FOR VALUES IN (generate_series(4, 6));
;CREATE TABLE part_bogus_expr_fail PARTITION OF list_parted FOR VALUES IN ((1+1) collate "POSIX");
;CREATE TABLE fail_part PARTITION OF list_parted FOR VALUES IN ();
;CREATE TABLE fail_part PARTITION OF list_parted FOR VALUES FROM (1) TO (2);
;CREATE TABLE fail_part PARTITION OF list_parted FOR VALUES WITH (MODULUS 10, REMAINDER 1);
;CREATE TABLE part_default PARTITION OF list_parted DEFAULT;
;CREATE TABLE fail_default_part PARTITION OF list_parted DEFAULT;
;CREATE TABLE bools (
	a bool
) PARTITION BY LIST (a);
;CREATE TABLE bools_true PARTITION OF bools FOR VALUES IN (1);
;DROP TABLE bools;
;CREATE TABLE moneyp (
	a money
) PARTITION BY LIST (a);
;CREATE TABLE moneyp_10 PARTITION OF moneyp FOR VALUES IN (10);
;CREATE TABLE moneyp_11 PARTITION OF moneyp FOR VALUES IN ('11');
;CREATE TABLE moneyp_12 PARTITION OF moneyp FOR VALUES IN (to_char(12, '99')::int);
;DROP TABLE moneyp;
;CREATE TABLE bigintp (
	a bigint
) PARTITION BY LIST (a);
;CREATE TABLE bigintp_10 PARTITION OF bigintp FOR VALUES IN (10);
;CREATE TABLE bigintp_10_2 PARTITION OF bigintp FOR VALUES IN ('10');
;DROP TABLE bigintp;
;CREATE TABLE range_parted (
	a date
) PARTITION BY RANGE (a);
;CREATE TABLE part_bogus_expr_fail PARTITION OF range_parted
  FOR VALUES FROM (somename) TO ('2019-01-01');
;CREATE TABLE part_bogus_expr_fail PARTITION OF range_parted
  FOR VALUES FROM (somename.somename) TO ('2019-01-01');
;CREATE TABLE part_bogus_expr_fail PARTITION OF range_parted
  FOR VALUES FROM (a) TO ('2019-01-01');
;CREATE TABLE part_bogus_expr_fail PARTITION OF range_parted
  FOR VALUES FROM (max(a)) TO ('2019-01-01');
;CREATE TABLE part_bogus_expr_fail PARTITION OF range_parted
  FOR VALUES FROM (max(somename)) TO ('2019-01-01');
;CREATE TABLE part_bogus_expr_fail PARTITION OF range_parted
  FOR VALUES FROM (max('2019-02-01'::date)) TO ('2019-01-01');
;CREATE TABLE part_bogus_expr_fail PARTITION OF range_parted
  FOR VALUES FROM ((select 1)) TO ('2019-01-01');
;CREATE TABLE part_bogus_expr_fail PARTITION OF range_parted
  FOR VALUES FROM (generate_series(1, 3)) TO ('2019-01-01');
;CREATE TABLE fail_part PARTITION OF range_parted FOR VALUES IN ('a');
;CREATE TABLE fail_part PARTITION OF range_parted FOR VALUES WITH (MODULUS 10, REMAINDER 1);
;CREATE TABLE fail_part PARTITION OF range_parted FOR VALUES FROM ('a', 1) TO ('z');
;CREATE TABLE fail_part PARTITION OF range_parted FOR VALUES FROM ('a') TO ('z', 1);
;CREATE TABLE fail_part PARTITION OF range_parted FOR VALUES FROM (null) TO (maxvalue);
;CREATE TABLE fail_part PARTITION OF range_parted FOR VALUES WITH (MODULUS 10, REMAINDER 1);
;CREATE TABLE hash_parted (
	a int
) PARTITION BY HASH (a);
;CREATE TABLE hpart_1 PARTITION OF hash_parted FOR VALUES WITH (MODULUS 10, REMAINDER 0);
;CREATE TABLE hpart_2 PARTITION OF hash_parted FOR VALUES WITH (MODULUS 50, REMAINDER 1);
;CREATE TABLE hpart_3 PARTITION OF hash_parted FOR VALUES WITH (MODULUS 200, REMAINDER 2);
;CREATE TABLE hpart_4 PARTITION OF hash_parted FOR VALUES WITH (MODULUS 10, REMAINDER 3);
;CREATE TABLE fail_part PARTITION OF hash_parted FOR VALUES WITH (MODULUS 25, REMAINDER 3);
;CREATE TABLE fail_part PARTITION OF hash_parted FOR VALUES WITH (MODULUS 150, REMAINDER 3);
;CREATE TABLE fail_part PARTITION OF hash_parted FOR VALUES WITH (MODULUS 100, REMAINDER 3);
;CREATE TABLE fail_part PARTITION OF hash_parted FOR VALUES FROM ('a', 1) TO ('z');
;CREATE TABLE fail_part PARTITION OF hash_parted FOR VALUES IN (1000);
;CREATE TABLE fail_default_part PARTITION OF hash_parted DEFAULT;
;CREATE TABLE unparted (
	a int
);
;CREATE TABLE fail_part PARTITION OF unparted FOR VALUES IN ('a');
;CREATE TABLE fail_part PARTITION OF unparted FOR VALUES WITH (MODULUS 2, REMAINDER 1);
;DROP TABLE unparted;
;CREATE TEMP TABLE temp_parted (
	a int
) PARTITION BY LIST (a);
;CREATE TABLE fail_part PARTITION OF temp_parted FOR VALUES IN ('a');
;DROP TABLE temp_parted;
;CREATE TABLE list_parted2 (
	a varchar
) PARTITION BY LIST (a);
;CREATE TABLE part_null_z PARTITION OF list_parted2 FOR VALUES IN (null, 'z');
;CREATE TABLE part_ab PARTITION OF list_parted2 FOR VALUES IN ('a', 'b');
;CREATE TABLE list_parted2_def PARTITION OF list_parted2 DEFAULT;
;CREATE TABLE fail_part PARTITION OF list_parted2 FOR VALUES IN (null);
;CREATE TABLE fail_part PARTITION OF list_parted2 FOR VALUES IN ('b', 'c');
;INSERT INTO list_parted2 VALUES('X');
;CREATE TABLE fail_part PARTITION OF list_parted2 FOR VALUES IN ('W', 'X', 'Y');
;CREATE TABLE range_parted2 (
	a int
) PARTITION BY RANGE (a);
;CREATE TABLE fail_part PARTITION OF range_parted2 FOR VALUES FROM (1) TO (0);
;CREATE TABLE fail_part PARTITION OF range_parted2 FOR VALUES FROM (1) TO (1);
;CREATE TABLE part0 PARTITION OF range_parted2 FOR VALUES FROM (minvalue) TO (1);
;CREATE TABLE fail_part PARTITION OF range_parted2 FOR VALUES FROM (minvalue) TO (2);
;CREATE TABLE part1 PARTITION OF range_parted2 FOR VALUES FROM (1) TO (10);
;CREATE TABLE fail_part PARTITION OF range_parted2 FOR VALUES FROM (-1) TO (1);
;CREATE TABLE fail_part PARTITION OF range_parted2 FOR VALUES FROM (9) TO (maxvalue);
;CREATE TABLE part2 PARTITION OF range_parted2 FOR VALUES FROM (20) TO (30);
;CREATE TABLE part3 PARTITION OF range_parted2 FOR VALUES FROM (30) TO (40);
;CREATE TABLE fail_part PARTITION OF range_parted2 FOR VALUES FROM (10) TO (30);
;CREATE TABLE fail_part PARTITION OF range_parted2 FOR VALUES FROM (10) TO (50);
;CREATE TABLE range2_default PARTITION OF range_parted2 DEFAULT;
;CREATE TABLE fail_default_part PARTITION OF range_parted2 DEFAULT;
;INSERT INTO range_parted2 VALUES (85);
;CREATE TABLE fail_part PARTITION OF range_parted2 FOR VALUES FROM (80) TO (90);
;CREATE TABLE part4 PARTITION OF range_parted2 FOR VALUES FROM (90) TO (100);
;CREATE TABLE range_parted3 (
	a int,
	b int
) PARTITION BY RANGE (a, (b+1));
;CREATE TABLE part00 PARTITION OF range_parted3 FOR VALUES FROM (0, minvalue) TO (0, maxvalue);
;CREATE TABLE fail_part PARTITION OF range_parted3 FOR VALUES FROM (0, minvalue) TO (0, 1);
;CREATE TABLE part10 PARTITION OF range_parted3 FOR VALUES FROM (1, minvalue) TO (1, 1);
;CREATE TABLE part11 PARTITION OF range_parted3 FOR VALUES FROM (1, 1) TO (1, 10);
;CREATE TABLE part12 PARTITION OF range_parted3 FOR VALUES FROM (1, 10) TO (1, maxvalue);
;CREATE TABLE fail_part PARTITION OF range_parted3 FOR VALUES FROM (1, 10) TO (1, 20);
;CREATE TABLE range3_default PARTITION OF range_parted3 DEFAULT;
;CREATE TABLE fail_part PARTITION OF range_parted3 FOR VALUES FROM (1, minvalue) TO (1, maxvalue);
;CREATE TABLE hash_parted2 (
	a varchar
) PARTITION BY HASH (a);
;CREATE TABLE h2part_1 PARTITION OF hash_parted2 FOR VALUES WITH (MODULUS 4, REMAINDER 2);
;CREATE TABLE h2part_2 PARTITION OF hash_parted2 FOR VALUES WITH (MODULUS 8, REMAINDER 0);
;CREATE TABLE h2part_3 PARTITION OF hash_parted2 FOR VALUES WITH (MODULUS 8, REMAINDER 4);
;CREATE TABLE h2part_4 PARTITION OF hash_parted2 FOR VALUES WITH (MODULUS 8, REMAINDER 5);
;CREATE TABLE fail_part PARTITION OF hash_parted2 FOR VALUES WITH (MODULUS 2, REMAINDER 1);
;CREATE TABLE fail_part PARTITION OF hash_parted2 FOR VALUES WITH (MODULUS 0, REMAINDER 1);
;CREATE TABLE fail_part PARTITION OF hash_parted2 FOR VALUES WITH (MODULUS 8, REMAINDER 8);
;CREATE TABLE parted (
	a text,
	b int NOT NULL DEFAULT 0,
	CONSTRAINT check_a CHECK (length(a) > 0)
) PARTITION BY LIST (a);
;CREATE TABLE part_a PARTITION OF parted FOR VALUES IN ('a');
;SELECT attname, attislocal, attinhcount FROM pg_attribute
  WHERE attrelid = 'part_a'::regclass and attnum > 0
  ORDER BY attnum;
;CREATE TABLE part_b PARTITION OF parted (
	b NOT NULL,
	b DEFAULT 1,
	b CHECK (b >= 0),
	CONSTRAINT check_a CHECK (length(a) > 0)
) FOR VALUES IN ('b');
;CREATE TABLE part_b PARTITION OF parted (
	b NOT NULL DEFAULT 1,
	CONSTRAINT check_a CHECK (length(a) > 0),
	CONSTRAINT check_b CHECK (b >= 0)
) FOR VALUES IN ('b');
;SELECT conislocal, coninhcount FROM pg_constraint WHERE conrelid = 'part_b'::regclass ORDER BY conislocal, coninhcount;
;ALTER TABLE parted ADD CONSTRAINT check_b CHECK (b >= 0);
;SELECT conislocal, coninhcount FROM pg_constraint WHERE conrelid = 'part_b'::regclass;
;ALTER TABLE part_b DROP CONSTRAINT check_a;
;ALTER TABLE part_b DROP CONSTRAINT check_b;
;ALTER TABLE parted DROP CONSTRAINT check_a, DROP CONSTRAINT check_b;
;SELECT conislocal, coninhcount FROM pg_constraint WHERE conrelid = 'part_b'::regclass;
;CREATE TABLE fail_part_col_not_found PARTITION OF parted FOR VALUES IN ('c') PARTITION BY RANGE (c);
;CREATE TABLE part_c PARTITION OF parted (b WITH OPTIONS NOT NULL DEFAULT 0) FOR VALUES IN ('c') PARTITION BY RANGE ((b));
;CREATE TABLE part_c_1_10 PARTITION OF part_c FOR VALUES FROM (1) TO (10);
;create table parted_notnull_inh_test (a int default 1, b int not null default 0) partition by list (a);
;create table parted_notnull_inh_test1 partition of parted_notnull_inh_test (a not null, b default 1) for values in (1);
;insert into parted_notnull_inh_test (b) values (null);
;SELECT c.oid,
  n.nspname,
  c.relname
FROM pg_catalog.pg_class c
     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
WHERE c.relname OPERATOR(pg_catalog.~) '^(parted_notnull_inh_test1)$' COLLATE pg_catalog.default
  AND pg_catalog.pg_table_is_visible(c.oid)
ORDER BY 2, 3;
;SELECT c.relchecks, c.relkind, c.relhasindex, c.relhasrules, c.relhastriggers, c.relrowsecurity, c.relforcerowsecurity, false AS relhasoids, c.relispartition, '', c.reltablespace, CASE WHEN c.reloftype = 0 THEN '' ELSE c.reloftype::pg_catalog.regtype::pg_catalog.text END, c.relpersistence, c.relreplident, am.amname
FROM pg_catalog.pg_class c
 LEFT JOIN pg_catalog.pg_class tc ON (c.reltoastrelid = tc.oid)
LEFT JOIN pg_catalog.pg_am am ON (c.relam = am.oid)
WHERE c.oid = '18239';
;SELECT a.attname,
  pg_catalog.format_type(a.atttypid, a.atttypmod),
  (SELECT pg_catalog.pg_get_expr(d.adbin, d.adrelid, true)
   FROM pg_catalog.pg_attrdef d
   WHERE d.adrelid = a.attrelid AND d.adnum = a.attnum AND a.atthasdef),
  a.attnotnull,
  (SELECT c.collname FROM pg_catalog.pg_collation c, pg_catalog.pg_type t
   WHERE c.oid = a.attcollation AND t.oid = a.atttypid AND a.attcollation <> t.typcollation) AS attcollation,
  a.attidentity,
  a.attgenerated
FROM pg_catalog.pg_attribute a
WHERE a.attrelid = '18239' AND a.attnum > 0 AND NOT a.attisdropped
ORDER BY a.attnum;
;SELECT inhparent::pg_catalog.regclass,
  pg_catalog.pg_get_expr(c.relpartbound, c.oid),
  inhdetachpending
FROM pg_catalog.pg_class c JOIN pg_catalog.pg_inherits i ON c.oid = inhrelid
WHERE c.oid = '18239';
;SELECT pol.polname, pol.polpermissive,
  CASE WHEN pol.polroles = '{0}' THEN NULL ELSE pg_catalog.array_to_string(array(select rolname from pg_catalog.pg_roles where oid = any (pol.polroles) order by 1),',') END,
  pg_catalog.pg_get_expr(pol.polqual, pol.polrelid),
  pg_catalog.pg_get_expr(pol.polwithcheck, pol.polrelid),
  CASE pol.polcmd
    WHEN 'r' THEN 'SELECT'
    WHEN 'a' THEN 'INSERT'
    WHEN 'w' THEN 'UPDATE'
    WHEN 'd' THEN 'DELETE'
    END AS cmd
FROM pg_catalog.pg_policy pol
WHERE pol.polrelid = '18239' ORDER BY 1;
;SELECT oid, stxrelid::pg_catalog.regclass, stxnamespace::pg_catalog.regnamespace::pg_catalog.text AS nsp, stxname,
pg_catalog.pg_get_statisticsobjdef_columns(oid) AS columns,
  'd' = any(stxkind) AS ndist_enabled,
  'f' = any(stxkind) AS deps_enabled,
  'm' = any(stxkind) AS mcv_enabled,
stxstattarget
FROM pg_catalog.pg_statistic_ext
WHERE stxrelid = '18239'
ORDER BY nsp, stxname;
;SELECT pubname
FROM pg_catalog.pg_publication p
		JOIN pg_catalog.pg_publication_namespace pn ON p.oid = pn.pnpubid
		JOIN pg_catalog.pg_class pc ON pc.relnamespace = pn.pnnspid
WHERE pc.oid ='18239' and pg_catalog.pg_relation_is_publishable('18239')
UNION
SELECT pubname
FROM pg_catalog.pg_publication p
		JOIN pg_catalog.pg_publication_rel pr ON p.oid = pr.prpubid
WHERE pr.prrelid = '18239'
UNION
SELECT pubname
FROM pg_catalog.pg_publication p
WHERE p.puballtables AND pg_catalog.pg_relation_is_publishable('18239')
ORDER BY 1;
;SELECT c.oid::pg_catalog.regclass
FROM pg_catalog.pg_class c, pg_catalog.pg_inherits i
WHERE c.oid = i.inhparent AND i.inhrelid = '18239'
  AND c.relkind != 'p' AND c.relkind != 'I'
ORDER BY inhseqno;
;SELECT c.oid::pg_catalog.regclass, c.relkind, inhdetachpending, pg_catalog.pg_get_expr(c.relpartbound, c.oid)
FROM pg_catalog.pg_class c, pg_catalog.pg_inherits i
WHERE c.oid = i.inhrelid AND i.inhparent = '18239'
ORDER BY pg_catalog.pg_get_expr(c.relpartbound, c.oid) = 'DEFAULT', c.oid::pg_catalog.regclass::pg_catalog.text;
;drop table parted_notnull_inh_test;
;create table parted_boolean_col (a bool, b text) partition by list(a);
;create table parted_boolean_less partition of parted_boolean_col
  for values in ('foo' < 'bar');
;create table parted_boolean_greater partition of parted_boolean_col
  for values in ('foo' > 'bar');
;drop table parted_boolean_col;
;create table parted_collate_must_match (a text collate "C", b text collate "C")
  partition by range (a);
;create table parted_collate_must_match1 partition of parted_collate_must_match
  (a collate "POSIX") for values from ('a') to ('m');
;create table parted_collate_must_match2 partition of parted_collate_must_match
  (b collate "POSIX") for values from ('m') to ('z');
;drop table parted_collate_must_match;
;create table test_part_coll_posix (a text) partition by range (a collate "POSIX");
;create table test_part_coll partition of test_part_coll_posix for values from ('a' collate "C") to ('g');
;create table test_part_coll2 partition of test_part_coll_posix for values from ('g') to ('m');
;create table test_part_coll_cast partition of test_part_coll_posix for values from (name 'm' collate "C") to ('s');
;create table test_part_coll_cast2 partition of test_part_coll_posix for values from (name 's') to ('z');
;drop table test_part_coll_posix;
;SELECT c.oid,
  n.nspname,
  c.relname
FROM pg_catalog.pg_class c
     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
WHERE c.relname OPERATOR(pg_catalog.~) '^(part_b)$' COLLATE pg_catalog.default
  AND pg_catalog.pg_table_is_visible(c.oid)
ORDER BY 2, 3;
;SELECT c.relchecks, c.relkind, c.relhasindex, c.relhasrules, c.relhastriggers, c.relrowsecurity, c.relforcerowsecurity, false AS relhasoids, c.relispartition, pg_catalog.array_to_string(c.reloptions || array(select 'toast.' || x from pg_catalog.unnest(tc.reloptions) x), ', ')
, c.reltablespace, CASE WHEN c.reloftype = 0 THEN '' ELSE c.reloftype::pg_catalog.regtype::pg_catalog.text END, c.relpersistence, c.relreplident, am.amname
FROM pg_catalog.pg_class c
 LEFT JOIN pg_catalog.pg_class tc ON (c.reltoastrelid = tc.oid)
LEFT JOIN pg_catalog.pg_am am ON (c.relam = am.oid)
WHERE c.oid = '18210';
;SELECT a.attname,
  pg_catalog.format_type(a.atttypid, a.atttypmod),
  (SELECT pg_catalog.pg_get_expr(d.adbin, d.adrelid, true)
   FROM pg_catalog.pg_attrdef d
   WHERE d.adrelid = a.attrelid AND d.adnum = a.attnum AND a.atthasdef),
  a.attnotnull,
  (SELECT c.collname FROM pg_catalog.pg_collation c, pg_catalog.pg_type t
   WHERE c.oid = a.attcollation AND t.oid = a.atttypid AND a.attcollation <> t.typcollation) AS attcollation,
  a.attidentity,
  a.attgenerated,
  a.attstorage,
  CASE WHEN a.attstattarget=-1 THEN NULL ELSE a.attstattarget END AS attstattarget,
  pg_catalog.col_description(a.attrelid, a.attnum)
FROM pg_catalog.pg_attribute a
WHERE a.attrelid = '18210' AND a.attnum > 0 AND NOT a.attisdropped
ORDER BY a.attnum;
;SELECT inhparent::pg_catalog.regclass,
  pg_catalog.pg_get_expr(c.relpartbound, c.oid),
  inhdetachpending,
  pg_catalog.pg_get_partition_constraintdef(c.oid)
FROM pg_catalog.pg_class c JOIN pg_catalog.pg_inherits i ON c.oid = inhrelid
WHERE c.oid = '18210';
;SELECT pol.polname, pol.polpermissive,
  CASE WHEN pol.polroles = '{0}' THEN NULL ELSE pg_catalog.array_to_string(array(select rolname from pg_catalog.pg_roles where oid = any (pol.polroles) order by 1),',') END,
  pg_catalog.pg_get_expr(pol.polqual, pol.polrelid),
  pg_catalog.pg_get_expr(pol.polwithcheck, pol.polrelid),
  CASE pol.polcmd
    WHEN 'r' THEN 'SELECT'
    WHEN 'a' THEN 'INSERT'
    WHEN 'w' THEN 'UPDATE'
    WHEN 'd' THEN 'DELETE'
    END AS cmd
FROM pg_catalog.pg_policy pol
WHERE pol.polrelid = '18210' ORDER BY 1;
;SELECT oid, stxrelid::pg_catalog.regclass, stxnamespace::pg_catalog.regnamespace::pg_catalog.text AS nsp, stxname,
pg_catalog.pg_get_statisticsobjdef_columns(oid) AS columns,
  'd' = any(stxkind) AS ndist_enabled,
  'f' = any(stxkind) AS deps_enabled,
  'm' = any(stxkind) AS mcv_enabled,
stxstattarget
FROM pg_catalog.pg_statistic_ext
WHERE stxrelid = '18210'
ORDER BY nsp, stxname;
;SELECT pubname
FROM pg_catalog.pg_publication p
		JOIN pg_catalog.pg_publication_namespace pn ON p.oid = pn.pnpubid
		JOIN pg_catalog.pg_class pc ON pc.relnamespace = pn.pnnspid
WHERE pc.oid ='18210' and pg_catalog.pg_relation_is_publishable('18210')
UNION
SELECT pubname
FROM pg_catalog.pg_publication p
		JOIN pg_catalog.pg_publication_rel pr ON p.oid = pr.prpubid
WHERE pr.prrelid = '18210'
UNION
SELECT pubname
FROM pg_catalog.pg_publication p
WHERE p.puballtables AND pg_catalog.pg_relation_is_publishable('18210')
ORDER BY 1;
;SELECT c.oid::pg_catalog.regclass
FROM pg_catalog.pg_class c, pg_catalog.pg_inherits i
WHERE c.oid = i.inhparent AND i.inhrelid = '18210'
  AND c.relkind != 'p' AND c.relkind != 'I'
ORDER BY inhseqno;
;SELECT c.oid::pg_catalog.regclass, c.relkind, inhdetachpending, pg_catalog.pg_get_expr(c.relpartbound, c.oid)
FROM pg_catalog.pg_class c, pg_catalog.pg_inherits i
WHERE c.oid = i.inhrelid AND i.inhparent = '18210'
ORDER BY pg_catalog.pg_get_expr(c.relpartbound, c.oid) = 'DEFAULT', c.oid::pg_catalog.regclass::pg_catalog.text;
;SELECT c.oid,
  n.nspname,
  c.relname
FROM pg_catalog.pg_class c
     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
WHERE c.relname OPERATOR(pg_catalog.~) '^(part_c)$' COLLATE pg_catalog.default
  AND pg_catalog.pg_table_is_visible(c.oid)
ORDER BY 2, 3;
;SELECT c.relchecks, c.relkind, c.relhasindex, c.relhasrules, c.relhastriggers, c.relrowsecurity, c.relforcerowsecurity, false AS relhasoids, c.relispartition, pg_catalog.array_to_string(c.reloptions || array(select 'toast.' || x from pg_catalog.unnest(tc.reloptions) x), ', ')
, c.reltablespace, CASE WHEN c.reloftype = 0 THEN '' ELSE c.reloftype::pg_catalog.regtype::pg_catalog.text END, c.relpersistence, c.relreplident, am.amname
FROM pg_catalog.pg_class c
 LEFT JOIN pg_catalog.pg_class tc ON (c.reltoastrelid = tc.oid)
LEFT JOIN pg_catalog.pg_am am ON (c.relam = am.oid)
WHERE c.oid = '18224';
;SELECT a.attname,
  pg_catalog.format_type(a.atttypid, a.atttypmod),
  (SELECT pg_catalog.pg_get_expr(d.adbin, d.adrelid, true)
   FROM pg_catalog.pg_attrdef d
   WHERE d.adrelid = a.attrelid AND d.adnum = a.attnum AND a.atthasdef),
  a.attnotnull,
  (SELECT c.collname FROM pg_catalog.pg_collation c, pg_catalog.pg_type t
   WHERE c.oid = a.attcollation AND t.oid = a.atttypid AND a.attcollation <> t.typcollation) AS attcollation,
  a.attidentity,
  a.attgenerated,
  a.attstorage,
  CASE WHEN a.attstattarget=-1 THEN NULL ELSE a.attstattarget END AS attstattarget,
  pg_catalog.col_description(a.attrelid, a.attnum)
FROM pg_catalog.pg_attribute a
WHERE a.attrelid = '18224' AND a.attnum > 0 AND NOT a.attisdropped
ORDER BY a.attnum;
;SELECT inhparent::pg_catalog.regclass,
  pg_catalog.pg_get_expr(c.relpartbound, c.oid),
  inhdetachpending,
  pg_catalog.pg_get_partition_constraintdef(c.oid)
FROM pg_catalog.pg_class c JOIN pg_catalog.pg_inherits i ON c.oid = inhrelid
WHERE c.oid = '18224';
;SELECT pg_catalog.pg_get_partkeydef('18224'::pg_catalog.oid);
;SELECT conrelid = '18224'::pg_catalog.regclass AS sametable,
       conname,
       pg_catalog.pg_get_constraintdef(oid, true) AS condef,
       conrelid::pg_catalog.regclass AS ontable
  FROM pg_catalog.pg_constraint,
       pg_catalog.pg_partition_ancestors('18224')
 WHERE conrelid = relid AND contype = 'f' AND conparentid = 0
ORDER BY sametable DESC, conname;
;SELECT conname, conrelid::pg_catalog.regclass AS ontable,
       pg_catalog.pg_get_constraintdef(oid, true) AS condef
  FROM pg_catalog.pg_constraint c
 WHERE confrelid IN (SELECT pg_catalog.pg_partition_ancestors('18224')
                     UNION ALL VALUES ('18224'::pg_catalog.regclass))
       AND contype = 'f' AND conparentid = 0
ORDER BY conname;
;SELECT pol.polname, pol.polpermissive,
  CASE WHEN pol.polroles = '{0}' THEN NULL ELSE pg_catalog.array_to_string(array(select rolname from pg_catalog.pg_roles where oid = any (pol.polroles) order by 1),',') END,
  pg_catalog.pg_get_expr(pol.polqual, pol.polrelid),
  pg_catalog.pg_get_expr(pol.polwithcheck, pol.polrelid),
  CASE pol.polcmd
    WHEN 'r' THEN 'SELECT'
    WHEN 'a' THEN 'INSERT'
    WHEN 'w' THEN 'UPDATE'
    WHEN 'd' THEN 'DELETE'
    END AS cmd
FROM pg_catalog.pg_policy pol
WHERE pol.polrelid = '18224' ORDER BY 1;
;SELECT oid, stxrelid::pg_catalog.regclass, stxnamespace::pg_catalog.regnamespace::pg_catalog.text AS nsp, stxname,
pg_catalog.pg_get_statisticsobjdef_columns(oid) AS columns,
  'd' = any(stxkind) AS ndist_enabled,
  'f' = any(stxkind) AS deps_enabled,
  'm' = any(stxkind) AS mcv_enabled,
stxstattarget
FROM pg_catalog.pg_statistic_ext
WHERE stxrelid = '18224'
ORDER BY nsp, stxname;
;SELECT pubname
FROM pg_catalog.pg_publication p
		JOIN pg_catalog.pg_publication_namespace pn ON p.oid = pn.pnpubid
		JOIN pg_catalog.pg_class pc ON pc.relnamespace = pn.pnnspid
WHERE pc.oid ='18224' and pg_catalog.pg_relation_is_publishable('18224')
UNION
SELECT pubname
FROM pg_catalog.pg_publication p
		JOIN pg_catalog.pg_publication_rel pr ON p.oid = pr.prpubid
WHERE pr.prrelid = '18224'
UNION
SELECT pubname
FROM pg_catalog.pg_publication p
WHERE p.puballtables AND pg_catalog.pg_relation_is_publishable('18224')
ORDER BY 1;
;SELECT c.oid::pg_catalog.regclass
FROM pg_catalog.pg_class c, pg_catalog.pg_inherits i
WHERE c.oid = i.inhparent AND i.inhrelid = '18224'
  AND c.relkind != 'p' AND c.relkind != 'I'
ORDER BY inhseqno;
;SELECT c.oid::pg_catalog.regclass, c.relkind, inhdetachpending, pg_catalog.pg_get_expr(c.relpartbound, c.oid)
FROM pg_catalog.pg_class c, pg_catalog.pg_inherits i
WHERE c.oid = i.inhrelid AND i.inhparent = '18224'
ORDER BY pg_catalog.pg_get_expr(c.relpartbound, c.oid) = 'DEFAULT', c.oid::pg_catalog.regclass::pg_catalog.text;
;SELECT c.oid,
  n.nspname,
  c.relname
FROM pg_catalog.pg_class c
     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
WHERE c.relname OPERATOR(pg_catalog.~) '^(part_c_1_10)$' COLLATE pg_catalog.default
  AND pg_catalog.pg_table_is_visible(c.oid)
ORDER BY 2, 3;
;SELECT c.relchecks, c.relkind, c.relhasindex, c.relhasrules, c.relhastriggers, c.relrowsecurity, c.relforcerowsecurity, false AS relhasoids, c.relispartition, pg_catalog.array_to_string(c.reloptions || array(select 'toast.' || x from pg_catalog.unnest(tc.reloptions) x), ', ')
, c.reltablespace, CASE WHEN c.reloftype = 0 THEN '' ELSE c.reloftype::pg_catalog.regtype::pg_catalog.text END, c.relpersistence, c.relreplident, am.amname
FROM pg_catalog.pg_class c
 LEFT JOIN pg_catalog.pg_class tc ON (c.reltoastrelid = tc.oid)
LEFT JOIN pg_catalog.pg_am am ON (c.relam = am.oid)
WHERE c.oid = '18228';
;SELECT a.attname,
  pg_catalog.format_type(a.atttypid, a.atttypmod),
  (SELECT pg_catalog.pg_get_expr(d.adbin, d.adrelid, true)
   FROM pg_catalog.pg_attrdef d
   WHERE d.adrelid = a.attrelid AND d.adnum = a.attnum AND a.atthasdef),
  a.attnotnull,
  (SELECT c.collname FROM pg_catalog.pg_collation c, pg_catalog.pg_type t
   WHERE c.oid = a.attcollation AND t.oid = a.atttypid AND a.attcollation <> t.typcollation) AS attcollation,
  a.attidentity,
  a.attgenerated,
  a.attstorage,
  CASE WHEN a.attstattarget=-1 THEN NULL ELSE a.attstattarget END AS attstattarget,
  pg_catalog.col_description(a.attrelid, a.attnum)
FROM pg_catalog.pg_attribute a
WHERE a.attrelid = '18228' AND a.attnum > 0 AND NOT a.attisdropped
ORDER BY a.attnum;
;SELECT inhparent::pg_catalog.regclass,
  pg_catalog.pg_get_expr(c.relpartbound, c.oid),
  inhdetachpending,
  pg_catalog.pg_get_partition_constraintdef(c.oid)
FROM pg_catalog.pg_class c JOIN pg_catalog.pg_inherits i ON c.oid = inhrelid
WHERE c.oid = '18228';
;SELECT pol.polname, pol.polpermissive,
  CASE WHEN pol.polroles = '{0}' THEN NULL ELSE pg_catalog.array_to_string(array(select rolname from pg_catalog.pg_roles where oid = any (pol.polroles) order by 1),',') END,
  pg_catalog.pg_get_expr(pol.polqual, pol.polrelid),
  pg_catalog.pg_get_expr(pol.polwithcheck, pol.polrelid),
  CASE pol.polcmd
    WHEN 'r' THEN 'SELECT'
    WHEN 'a' THEN 'INSERT'
    WHEN 'w' THEN 'UPDATE'
    WHEN 'd' THEN 'DELETE'
    END AS cmd
FROM pg_catalog.pg_policy pol
WHERE pol.polrelid = '18228' ORDER BY 1;
;SELECT oid, stxrelid::pg_catalog.regclass, stxnamespace::pg_catalog.regnamespace::pg_catalog.text AS nsp, stxname,
pg_catalog.pg_get_statisticsobjdef_columns(oid) AS columns,
  'd' = any(stxkind) AS ndist_enabled,
  'f' = any(stxkind) AS deps_enabled,
  'm' = any(stxkind) AS mcv_enabled,
stxstattarget
FROM pg_catalog.pg_statistic_ext
WHERE stxrelid = '18228'
ORDER BY nsp, stxname;
;SELECT pubname
FROM pg_catalog.pg_publication p
		JOIN pg_catalog.pg_publication_namespace pn ON p.oid = pn.pnpubid
		JOIN pg_catalog.pg_class pc ON pc.relnamespace = pn.pnnspid
WHERE pc.oid ='18228' and pg_catalog.pg_relation_is_publishable('18228')
UNION
SELECT pubname
FROM pg_catalog.pg_publication p
		JOIN pg_catalog.pg_publication_rel pr ON p.oid = pr.prpubid
WHERE pr.prrelid = '18228'
UNION
SELECT pubname
FROM pg_catalog.pg_publication p
WHERE p.puballtables AND pg_catalog.pg_relation_is_publishable('18228')
ORDER BY 1;
;SELECT c.oid::pg_catalog.regclass
FROM pg_catalog.pg_class c, pg_catalog.pg_inherits i
WHERE c.oid = i.inhparent AND i.inhrelid = '18228'
  AND c.relkind != 'p' AND c.relkind != 'I'
ORDER BY inhseqno;
;SELECT c.oid::pg_catalog.regclass, c.relkind, inhdetachpending, pg_catalog.pg_get_expr(c.relpartbound, c.oid)
FROM pg_catalog.pg_class c, pg_catalog.pg_inherits i
WHERE c.oid = i.inhrelid AND i.inhparent = '18228'
ORDER BY pg_catalog.pg_get_expr(c.relpartbound, c.oid) = 'DEFAULT', c.oid::pg_catalog.regclass::pg_catalog.text;
;SELECT c.oid,
  n.nspname,
  c.relname
FROM pg_catalog.pg_class c
     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
WHERE c.relname OPERATOR(pg_catalog.~) '^(parted)$' COLLATE pg_catalog.default
  AND pg_catalog.pg_table_is_visible(c.oid)
ORDER BY 2, 3;
;SELECT c.relchecks, c.relkind, c.relhasindex, c.relhasrules, c.relhastriggers, c.relrowsecurity, c.relforcerowsecurity, false AS relhasoids, c.relispartition, '', c.reltablespace, CASE WHEN c.reloftype = 0 THEN '' ELSE c.reloftype::pg_catalog.regtype::pg_catalog.text END, c.relpersistence, c.relreplident, am.amname
FROM pg_catalog.pg_class c
 LEFT JOIN pg_catalog.pg_class tc ON (c.reltoastrelid = tc.oid)
LEFT JOIN pg_catalog.pg_am am ON (c.relam = am.oid)
WHERE c.oid = '18198';
;SELECT a.attname,
  pg_catalog.format_type(a.atttypid, a.atttypmod),
  (SELECT pg_catalog.pg_get_expr(d.adbin, d.adrelid, true)
   FROM pg_catalog.pg_attrdef d
   WHERE d.adrelid = a.attrelid AND d.adnum = a.attnum AND a.atthasdef),
  a.attnotnull,
  (SELECT c.collname FROM pg_catalog.pg_collation c, pg_catalog.pg_type t
   WHERE c.oid = a.attcollation AND t.oid = a.atttypid AND a.attcollation <> t.typcollation) AS attcollation,
  a.attidentity,
  a.attgenerated
FROM pg_catalog.pg_attribute a
WHERE a.attrelid = '18198' AND a.attnum > 0 AND NOT a.attisdropped
ORDER BY a.attnum;
;SELECT pg_catalog.pg_get_partkeydef('18198'::pg_catalog.oid);
;SELECT conrelid = '18198'::pg_catalog.regclass AS sametable,
       conname,
       pg_catalog.pg_get_constraintdef(oid, true) AS condef,
       conrelid::pg_catalog.regclass AS ontable
  FROM pg_catalog.pg_constraint,
       pg_catalog.pg_partition_ancestors('18198')
 WHERE conrelid = relid AND contype = 'f' AND conparentid = 0
ORDER BY sametable DESC, conname;
;SELECT conname, conrelid::pg_catalog.regclass AS ontable,
       pg_catalog.pg_get_constraintdef(oid, true) AS condef
  FROM pg_catalog.pg_constraint c
 WHERE confrelid IN (SELECT pg_catalog.pg_partition_ancestors('18198')
                     UNION ALL VALUES ('18198'::pg_catalog.regclass))
       AND contype = 'f' AND conparentid = 0
ORDER BY conname;
;SELECT pol.polname, pol.polpermissive,
  CASE WHEN pol.polroles = '{0}' THEN NULL ELSE pg_catalog.array_to_string(array(select rolname from pg_catalog.pg_roles where oid = any (pol.polroles) order by 1),',') END,
  pg_catalog.pg_get_expr(pol.polqual, pol.polrelid),
  pg_catalog.pg_get_expr(pol.polwithcheck, pol.polrelid),
  CASE pol.polcmd
    WHEN 'r' THEN 'SELECT'
    WHEN 'a' THEN 'INSERT'
    WHEN 'w' THEN 'UPDATE'
    WHEN 'd' THEN 'DELETE'
    END AS cmd
FROM pg_catalog.pg_policy pol
WHERE pol.polrelid = '18198' ORDER BY 1;
;SELECT oid, stxrelid::pg_catalog.regclass, stxnamespace::pg_catalog.regnamespace::pg_catalog.text AS nsp, stxname,
pg_catalog.pg_get_statisticsobjdef_columns(oid) AS columns,
  'd' = any(stxkind) AS ndist_enabled,
  'f' = any(stxkind) AS deps_enabled,
  'm' = any(stxkind) AS mcv_enabled,
stxstattarget
FROM pg_catalog.pg_statistic_ext
WHERE stxrelid = '18198'
ORDER BY nsp, stxname;
;SELECT pubname
FROM pg_catalog.pg_publication p
		JOIN pg_catalog.pg_publication_namespace pn ON p.oid = pn.pnpubid
		JOIN pg_catalog.pg_class pc ON pc.relnamespace = pn.pnnspid
WHERE pc.oid ='18198' and pg_catalog.pg_relation_is_publishable('18198')
UNION
SELECT pubname
FROM pg_catalog.pg_publication p
		JOIN pg_catalog.pg_publication_rel pr ON p.oid = pr.prpubid
WHERE pr.prrelid = '18198'
UNION
SELECT pubname
FROM pg_catalog.pg_publication p
WHERE p.puballtables AND pg_catalog.pg_relation_is_publishable('18198')
ORDER BY 1;
;SELECT c.oid::pg_catalog.regclass
FROM pg_catalog.pg_class c, pg_catalog.pg_inherits i
WHERE c.oid = i.inhparent AND i.inhrelid = '18198'
  AND c.relkind != 'p' AND c.relkind != 'I'
ORDER BY inhseqno;
;SELECT c.oid::pg_catalog.regclass, c.relkind, inhdetachpending, pg_catalog.pg_get_expr(c.relpartbound, c.oid)
FROM pg_catalog.pg_class c, pg_catalog.pg_inherits i
WHERE c.oid = i.inhrelid AND i.inhparent = '18198'
ORDER BY pg_catalog.pg_get_expr(c.relpartbound, c.oid) = 'DEFAULT', c.oid::pg_catalog.regclass::pg_catalog.text;
;SELECT c.oid,
  n.nspname,
  c.relname
FROM pg_catalog.pg_class c
     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
WHERE c.relname OPERATOR(pg_catalog.~) '^(hash_parted)$' COLLATE pg_catalog.default
  AND pg_catalog.pg_table_is_visible(c.oid)
ORDER BY 2, 3;
;SELECT c.relchecks, c.relkind, c.relhasindex, c.relhasrules, c.relhastriggers, c.relrowsecurity, c.relforcerowsecurity, false AS relhasoids, c.relispartition, '', c.reltablespace, CASE WHEN c.reloftype = 0 THEN '' ELSE c.reloftype::pg_catalog.regtype::pg_catalog.text END, c.relpersistence, c.relreplident, am.amname
FROM pg_catalog.pg_class c
 LEFT JOIN pg_catalog.pg_class tc ON (c.reltoastrelid = tc.oid)
LEFT JOIN pg_catalog.pg_am am ON (c.relam = am.oid)
WHERE c.oid = '18019';
;SELECT a.attname,
  pg_catalog.format_type(a.atttypid, a.atttypmod),
  (SELECT pg_catalog.pg_get_expr(d.adbin, d.adrelid, true)
   FROM pg_catalog.pg_attrdef d
   WHERE d.adrelid = a.attrelid AND d.adnum = a.attnum AND a.atthasdef),
  a.attnotnull,
  (SELECT c.collname FROM pg_catalog.pg_collation c, pg_catalog.pg_type t
   WHERE c.oid = a.attcollation AND t.oid = a.atttypid AND a.attcollation <> t.typcollation) AS attcollation,
  a.attidentity,
  a.attgenerated
FROM pg_catalog.pg_attribute a
WHERE a.attrelid = '18019' AND a.attnum > 0 AND NOT a.attisdropped
ORDER BY a.attnum;
;SELECT pg_catalog.pg_get_partkeydef('18019'::pg_catalog.oid);
;SELECT conrelid = '18019'::pg_catalog.regclass AS sametable,
       conname,
       pg_catalog.pg_get_constraintdef(oid, true) AS condef,
       conrelid::pg_catalog.regclass AS ontable
  FROM pg_catalog.pg_constraint,
       pg_catalog.pg_partition_ancestors('18019')
 WHERE conrelid = relid AND contype = 'f' AND conparentid = 0
ORDER BY sametable DESC, conname;
;SELECT conname, conrelid::pg_catalog.regclass AS ontable,
       pg_catalog.pg_get_constraintdef(oid, true) AS condef
  FROM pg_catalog.pg_constraint c
 WHERE confrelid IN (SELECT pg_catalog.pg_partition_ancestors('18019')
                     UNION ALL VALUES ('18019'::pg_catalog.regclass))
       AND contype = 'f' AND conparentid = 0
ORDER BY conname;
;SELECT pol.polname, pol.polpermissive,
  CASE WHEN pol.polroles = '{0}' THEN NULL ELSE pg_catalog.array_to_string(array(select rolname from pg_catalog.pg_roles where oid = any (pol.polroles) order by 1),',') END,
  pg_catalog.pg_get_expr(pol.polqual, pol.polrelid),
  pg_catalog.pg_get_expr(pol.polwithcheck, pol.polrelid),
  CASE pol.polcmd
    WHEN 'r' THEN 'SELECT'
    WHEN 'a' THEN 'INSERT'
    WHEN 'w' THEN 'UPDATE'
    WHEN 'd' THEN 'DELETE'
    END AS cmd
FROM pg_catalog.pg_policy pol
WHERE pol.polrelid = '18019' ORDER BY 1;
;SELECT oid, stxrelid::pg_catalog.regclass, stxnamespace::pg_catalog.regnamespace::pg_catalog.text AS nsp, stxname,
pg_catalog.pg_get_statisticsobjdef_columns(oid) AS columns,
  'd' = any(stxkind) AS ndist_enabled,
  'f' = any(stxkind) AS deps_enabled,
  'm' = any(stxkind) AS mcv_enabled,
stxstattarget
FROM pg_catalog.pg_statistic_ext
WHERE stxrelid = '18019'
ORDER BY nsp, stxname;
;SELECT pubname
FROM pg_catalog.pg_publication p
		JOIN pg_catalog.pg_publication_namespace pn ON p.oid = pn.pnpubid
		JOIN pg_catalog.pg_class pc ON pc.relnamespace = pn.pnnspid
WHERE pc.oid ='18019' and pg_catalog.pg_relation_is_publishable('18019')
UNION
SELECT pubname
FROM pg_catalog.pg_publication p
		JOIN pg_catalog.pg_publication_rel pr ON p.oid = pr.prpubid
WHERE pr.prrelid = '18019'
UNION
SELECT pubname
FROM pg_catalog.pg_publication p
WHERE p.puballtables AND pg_catalog.pg_relation_is_publishable('18019')
ORDER BY 1;
;SELECT c.oid::pg_catalog.regclass
FROM pg_catalog.pg_class c, pg_catalog.pg_inherits i
WHERE c.oid = i.inhparent AND i.inhrelid = '18019'
  AND c.relkind != 'p' AND c.relkind != 'I'
ORDER BY inhseqno;
;SELECT c.oid::pg_catalog.regclass, c.relkind, inhdetachpending, pg_catalog.pg_get_expr(c.relpartbound, c.oid)
FROM pg_catalog.pg_class c, pg_catalog.pg_inherits i
WHERE c.oid = i.inhrelid AND i.inhparent = '18019'
ORDER BY pg_catalog.pg_get_expr(c.relpartbound, c.oid) = 'DEFAULT', c.oid::pg_catalog.regclass::pg_catalog.text;
;CREATE TABLE range_parted4 (a int, b int, c int) PARTITION BY RANGE (abs(a), abs(b), c);
;CREATE TABLE unbounded_range_part PARTITION OF range_parted4 FOR VALUES FROM (MINVALUE, MINVALUE, MINVALUE) TO (MAXVALUE, MAXVALUE, MAXVALUE);
;SELECT c.oid,
  n.nspname,
  c.relname
FROM pg_catalog.pg_class c
     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
WHERE c.relname OPERATOR(pg_catalog.~) '^(unbounded_range_part)$' COLLATE pg_catalog.default
  AND pg_catalog.pg_table_is_visible(c.oid)
ORDER BY 2, 3;
;SELECT c.relchecks, c.relkind, c.relhasindex, c.relhasrules, c.relhastriggers, c.relrowsecurity, c.relforcerowsecurity, false AS relhasoids, c.relispartition, pg_catalog.array_to_string(c.reloptions || array(select 'toast.' || x from pg_catalog.unnest(tc.reloptions) x), ', ')
, c.reltablespace, CASE WHEN c.reloftype = 0 THEN '' ELSE c.reloftype::pg_catalog.regtype::pg_catalog.text END, c.relpersistence, c.relreplident, am.amname
FROM pg_catalog.pg_class c
 LEFT JOIN pg_catalog.pg_class tc ON (c.reltoastrelid = tc.oid)
LEFT JOIN pg_catalog.pg_am am ON (c.relam = am.oid)
WHERE c.oid = '18296';
;SELECT a.attname,
  pg_catalog.format_type(a.atttypid, a.atttypmod),
  (SELECT pg_catalog.pg_get_expr(d.adbin, d.adrelid, true)
   FROM pg_catalog.pg_attrdef d
   WHERE d.adrelid = a.attrelid AND d.adnum = a.attnum AND a.atthasdef),
  a.attnotnull,
  (SELECT c.collname FROM pg_catalog.pg_collation c, pg_catalog.pg_type t
   WHERE c.oid = a.attcollation AND t.oid = a.atttypid AND a.attcollation <> t.typcollation) AS attcollation,
  a.attidentity,
  a.attgenerated,
  a.attstorage,
  CASE WHEN a.attstattarget=-1 THEN NULL ELSE a.attstattarget END AS attstattarget,
  pg_catalog.col_description(a.attrelid, a.attnum)
FROM pg_catalog.pg_attribute a
WHERE a.attrelid = '18296' AND a.attnum > 0 AND NOT a.attisdropped
ORDER BY a.attnum;
;SELECT inhparent::pg_catalog.regclass,
  pg_catalog.pg_get_expr(c.relpartbound, c.oid),
  inhdetachpending,
  pg_catalog.pg_get_partition_constraintdef(c.oid)
FROM pg_catalog.pg_class c JOIN pg_catalog.pg_inherits i ON c.oid = inhrelid
WHERE c.oid = '18296';
;SELECT pol.polname, pol.polpermissive,
  CASE WHEN pol.polroles = '{0}' THEN NULL ELSE pg_catalog.array_to_string(array(select rolname from pg_catalog.pg_roles where oid = any (pol.polroles) order by 1),',') END,
  pg_catalog.pg_get_expr(pol.polqual, pol.polrelid),
  pg_catalog.pg_get_expr(pol.polwithcheck, pol.polrelid),
  CASE pol.polcmd
    WHEN 'r' THEN 'SELECT'
    WHEN 'a' THEN 'INSERT'
    WHEN 'w' THEN 'UPDATE'
    WHEN 'd' THEN 'DELETE'
    END AS cmd
FROM pg_catalog.pg_policy pol
WHERE pol.polrelid = '18296' ORDER BY 1;
;SELECT oid, stxrelid::pg_catalog.regclass, stxnamespace::pg_catalog.regnamespace::pg_catalog.text AS nsp, stxname,
pg_catalog.pg_get_statisticsobjdef_columns(oid) AS columns,
  'd' = any(stxkind) AS ndist_enabled,
  'f' = any(stxkind) AS deps_enabled,
  'm' = any(stxkind) AS mcv_enabled,
stxstattarget
FROM pg_catalog.pg_statistic_ext
WHERE stxrelid = '18296'
ORDER BY nsp, stxname;
;SELECT pubname
FROM pg_catalog.pg_publication p
		JOIN pg_catalog.pg_publication_namespace pn ON p.oid = pn.pnpubid
		JOIN pg_catalog.pg_class pc ON pc.relnamespace = pn.pnnspid
WHERE pc.oid ='18296' and pg_catalog.pg_relation_is_publishable('18296')
UNION
SELECT pubname
FROM pg_catalog.pg_publication p
		JOIN pg_catalog.pg_publication_rel pr ON p.oid = pr.prpubid
WHERE pr.prrelid = '18296'
UNION
SELECT pubname
FROM pg_catalog.pg_publication p
WHERE p.puballtables AND pg_catalog.pg_relation_is_publishable('18296')
ORDER BY 1;
;SELECT c.oid::pg_catalog.regclass
FROM pg_catalog.pg_class c, pg_catalog.pg_inherits i
WHERE c.oid = i.inhparent AND i.inhrelid = '18296'
  AND c.relkind != 'p' AND c.relkind != 'I'
ORDER BY inhseqno;
;SELECT c.oid::pg_catalog.regclass, c.relkind, inhdetachpending, pg_catalog.pg_get_expr(c.relpartbound, c.oid)
FROM pg_catalog.pg_class c, pg_catalog.pg_inherits i
WHERE c.oid = i.inhrelid AND i.inhparent = '18296'
ORDER BY pg_catalog.pg_get_expr(c.relpartbound, c.oid) = 'DEFAULT', c.oid::pg_catalog.regclass::pg_catalog.text;
;DROP TABLE unbounded_range_part;
;CREATE TABLE range_parted4_1 PARTITION OF range_parted4 FOR VALUES FROM (MINVALUE, MINVALUE, MINVALUE) TO (1, MAXVALUE, MAXVALUE);
;SELECT c.oid,
  n.nspname,
  c.relname
FROM pg_catalog.pg_class c
     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
WHERE c.relname OPERATOR(pg_catalog.~) '^(range_parted4_1)$' COLLATE pg_catalog.default
  AND pg_catalog.pg_table_is_visible(c.oid)
ORDER BY 2, 3;
;SELECT c.relchecks, c.relkind, c.relhasindex, c.relhasrules, c.relhastriggers, c.relrowsecurity, c.relforcerowsecurity, false AS relhasoids, c.relispartition, pg_catalog.array_to_string(c.reloptions || array(select 'toast.' || x from pg_catalog.unnest(tc.reloptions) x), ', ')
, c.reltablespace, CASE WHEN c.reloftype = 0 THEN '' ELSE c.reloftype::pg_catalog.regtype::pg_catalog.text END, c.relpersistence, c.relreplident, am.amname
FROM pg_catalog.pg_class c
 LEFT JOIN pg_catalog.pg_class tc ON (c.reltoastrelid = tc.oid)
LEFT JOIN pg_catalog.pg_am am ON (c.relam = am.oid)
WHERE c.oid = '18299';
;SELECT a.attname,
  pg_catalog.format_type(a.atttypid, a.atttypmod),
  (SELECT pg_catalog.pg_get_expr(d.adbin, d.adrelid, true)
   FROM pg_catalog.pg_attrdef d
   WHERE d.adrelid = a.attrelid AND d.adnum = a.attnum AND a.atthasdef),
  a.attnotnull,
  (SELECT c.collname FROM pg_catalog.pg_collation c, pg_catalog.pg_type t
   WHERE c.oid = a.attcollation AND t.oid = a.atttypid AND a.attcollation <> t.typcollation) AS attcollation,
  a.attidentity,
  a.attgenerated,
  a.attstorage,
  CASE WHEN a.attstattarget=-1 THEN NULL ELSE a.attstattarget END AS attstattarget,
  pg_catalog.col_description(a.attrelid, a.attnum)
FROM pg_catalog.pg_attribute a
WHERE a.attrelid = '18299' AND a.attnum > 0 AND NOT a.attisdropped
ORDER BY a.attnum;
;SELECT inhparent::pg_catalog.regclass,
  pg_catalog.pg_get_expr(c.relpartbound, c.oid),
  inhdetachpending,
  pg_catalog.pg_get_partition_constraintdef(c.oid)
FROM pg_catalog.pg_class c JOIN pg_catalog.pg_inherits i ON c.oid = inhrelid
WHERE c.oid = '18299';
;SELECT pol.polname, pol.polpermissive,
  CASE WHEN pol.polroles = '{0}' THEN NULL ELSE pg_catalog.array_to_string(array(select rolname from pg_catalog.pg_roles where oid = any (pol.polroles) order by 1),',') END,
  pg_catalog.pg_get_expr(pol.polqual, pol.polrelid),
  pg_catalog.pg_get_expr(pol.polwithcheck, pol.polrelid),
  CASE pol.polcmd
    WHEN 'r' THEN 'SELECT'
    WHEN 'a' THEN 'INSERT'
    WHEN 'w' THEN 'UPDATE'
    WHEN 'd' THEN 'DELETE'
    END AS cmd
FROM pg_catalog.pg_policy pol
WHERE pol.polrelid = '18299' ORDER BY 1;
;SELECT oid, stxrelid::pg_catalog.regclass, stxnamespace::pg_catalog.regnamespace::pg_catalog.text AS nsp, stxname,
pg_catalog.pg_get_statisticsobjdef_columns(oid) AS columns,
  'd' = any(stxkind) AS ndist_enabled,
  'f' = any(stxkind) AS deps_enabled,
  'm' = any(stxkind) AS mcv_enabled,
stxstattarget
FROM pg_catalog.pg_statistic_ext
WHERE stxrelid = '18299'
ORDER BY nsp, stxname;
;SELECT pubname
FROM pg_catalog.pg_publication p
		JOIN pg_catalog.pg_publication_namespace pn ON p.oid = pn.pnpubid
		JOIN pg_catalog.pg_class pc ON pc.relnamespace = pn.pnnspid
WHERE pc.oid ='18299' and pg_catalog.pg_relation_is_publishable('18299')
UNION
SELECT pubname
FROM pg_catalog.pg_publication p
		JOIN pg_catalog.pg_publication_rel pr ON p.oid = pr.prpubid
WHERE pr.prrelid = '18299'
UNION
SELECT pubname
FROM pg_catalog.pg_publication p
WHERE p.puballtables AND pg_catalog.pg_relation_is_publishable('18299')
ORDER BY 1;
;SELECT c.oid::pg_catalog.regclass
FROM pg_catalog.pg_class c, pg_catalog.pg_inherits i
WHERE c.oid = i.inhparent AND i.inhrelid = '18299'
  AND c.relkind != 'p' AND c.relkind != 'I'
ORDER BY inhseqno;
;SELECT c.oid::pg_catalog.regclass, c.relkind, inhdetachpending, pg_catalog.pg_get_expr(c.relpartbound, c.oid)
FROM pg_catalog.pg_class c, pg_catalog.pg_inherits i
WHERE c.oid = i.inhrelid AND i.inhparent = '18299'
ORDER BY pg_catalog.pg_get_expr(c.relpartbound, c.oid) = 'DEFAULT', c.oid::pg_catalog.regclass::pg_catalog.text;
;CREATE TABLE range_parted4_2 PARTITION OF range_parted4 FOR VALUES FROM (3, 4, 5) TO (6, 7, MAXVALUE);
;SELECT c.oid,
  n.nspname,
  c.relname
FROM pg_catalog.pg_class c
     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
WHERE c.relname OPERATOR(pg_catalog.~) '^(range_parted4_2)$' COLLATE pg_catalog.default
  AND pg_catalog.pg_table_is_visible(c.oid)
ORDER BY 2, 3;
;SELECT c.relchecks, c.relkind, c.relhasindex, c.relhasrules, c.relhastriggers, c.relrowsecurity, c.relforcerowsecurity, false AS relhasoids, c.relispartition, pg_catalog.array_to_string(c.reloptions || array(select 'toast.' || x from pg_catalog.unnest(tc.reloptions) x), ', ')
, c.reltablespace, CASE WHEN c.reloftype = 0 THEN '' ELSE c.reloftype::pg_catalog.regtype::pg_catalog.text END, c.relpersistence, c.relreplident, am.amname
FROM pg_catalog.pg_class c
 LEFT JOIN pg_catalog.pg_class tc ON (c.reltoastrelid = tc.oid)
LEFT JOIN pg_catalog.pg_am am ON (c.relam = am.oid)
WHERE c.oid = '18302';
;SELECT a.attname,
  pg_catalog.format_type(a.atttypid, a.atttypmod),
  (SELECT pg_catalog.pg_get_expr(d.adbin, d.adrelid, true)
   FROM pg_catalog.pg_attrdef d
   WHERE d.adrelid = a.attrelid AND d.adnum = a.attnum AND a.atthasdef),
  a.attnotnull,
  (SELECT c.collname FROM pg_catalog.pg_collation c, pg_catalog.pg_type t
   WHERE c.oid = a.attcollation AND t.oid = a.atttypid AND a.attcollation <> t.typcollation) AS attcollation,
  a.attidentity,
  a.attgenerated,
  a.attstorage,
  CASE WHEN a.attstattarget=-1 THEN NULL ELSE a.attstattarget END AS attstattarget,
  pg_catalog.col_description(a.attrelid, a.attnum)
FROM pg_catalog.pg_attribute a
WHERE a.attrelid = '18302' AND a.attnum > 0 AND NOT a.attisdropped
ORDER BY a.attnum;
;SELECT inhparent::pg_catalog.regclass,
  pg_catalog.pg_get_expr(c.relpartbound, c.oid),
  inhdetachpending,
  pg_catalog.pg_get_partition_constraintdef(c.oid)
FROM pg_catalog.pg_class c JOIN pg_catalog.pg_inherits i ON c.oid = inhrelid
WHERE c.oid = '18302';
;SELECT pol.polname, pol.polpermissive,
  CASE WHEN pol.polroles = '{0}' THEN NULL ELSE pg_catalog.array_to_string(array(select rolname from pg_catalog.pg_roles where oid = any (pol.polroles) order by 1),',') END,
  pg_catalog.pg_get_expr(pol.polqual, pol.polrelid),
  pg_catalog.pg_get_expr(pol.polwithcheck, pol.polrelid),
  CASE pol.polcmd
    WHEN 'r' THEN 'SELECT'
    WHEN 'a' THEN 'INSERT'
    WHEN 'w' THEN 'UPDATE'
    WHEN 'd' THEN 'DELETE'
    END AS cmd
FROM pg_catalog.pg_policy pol
WHERE pol.polrelid = '18302' ORDER BY 1;
;SELECT oid, stxrelid::pg_catalog.regclass, stxnamespace::pg_catalog.regnamespace::pg_catalog.text AS nsp, stxname,
pg_catalog.pg_get_statisticsobjdef_columns(oid) AS columns,
  'd' = any(stxkind) AS ndist_enabled,
  'f' = any(stxkind) AS deps_enabled,
  'm' = any(stxkind) AS mcv_enabled,
stxstattarget
FROM pg_catalog.pg_statistic_ext
WHERE stxrelid = '18302'
ORDER BY nsp, stxname;
;SELECT pubname
FROM pg_catalog.pg_publication p
		JOIN pg_catalog.pg_publication_namespace pn ON p.oid = pn.pnpubid
		JOIN pg_catalog.pg_class pc ON pc.relnamespace = pn.pnnspid
WHERE pc.oid ='18302' and pg_catalog.pg_relation_is_publishable('18302')
UNION
SELECT pubname
FROM pg_catalog.pg_publication p
		JOIN pg_catalog.pg_publication_rel pr ON p.oid = pr.prpubid
WHERE pr.prrelid = '18302'
UNION
SELECT pubname
FROM pg_catalog.pg_publication p
WHERE p.puballtables AND pg_catalog.pg_relation_is_publishable('18302')
ORDER BY 1;
;SELECT c.oid::pg_catalog.regclass
FROM pg_catalog.pg_class c, pg_catalog.pg_inherits i
WHERE c.oid = i.inhparent AND i.inhrelid = '18302'
  AND c.relkind != 'p' AND c.relkind != 'I'
ORDER BY inhseqno;
;SELECT c.oid::pg_catalog.regclass, c.relkind, inhdetachpending, pg_catalog.pg_get_expr(c.relpartbound, c.oid)
FROM pg_catalog.pg_class c, pg_catalog.pg_inherits i
WHERE c.oid = i.inhrelid AND i.inhparent = '18302'
ORDER BY pg_catalog.pg_get_expr(c.relpartbound, c.oid) = 'DEFAULT', c.oid::pg_catalog.regclass::pg_catalog.text;
;CREATE TABLE range_parted4_3 PARTITION OF range_parted4 FOR VALUES FROM (6, 8, MINVALUE) TO (9, MAXVALUE, MAXVALUE);
;SELECT c.oid,
  n.nspname,
  c.relname
FROM pg_catalog.pg_class c
     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
WHERE c.relname OPERATOR(pg_catalog.~) '^(range_parted4_3)$' COLLATE pg_catalog.default
  AND pg_catalog.pg_table_is_visible(c.oid)
ORDER BY 2, 3;
;SELECT c.relchecks, c.relkind, c.relhasindex, c.relhasrules, c.relhastriggers, c.relrowsecurity, c.relforcerowsecurity, false AS relhasoids, c.relispartition, pg_catalog.array_to_string(c.reloptions || array(select 'toast.' || x from pg_catalog.unnest(tc.reloptions) x), ', ')
, c.reltablespace, CASE WHEN c.reloftype = 0 THEN '' ELSE c.reloftype::pg_catalog.regtype::pg_catalog.text END, c.relpersistence, c.relreplident, am.amname
FROM pg_catalog.pg_class c
 LEFT JOIN pg_catalog.pg_class tc ON (c.reltoastrelid = tc.oid)
LEFT JOIN pg_catalog.pg_am am ON (c.relam = am.oid)
WHERE c.oid = '18305';
;SELECT a.attname,
  pg_catalog.format_type(a.atttypid, a.atttypmod),
  (SELECT pg_catalog.pg_get_expr(d.adbin, d.adrelid, true)
   FROM pg_catalog.pg_attrdef d
   WHERE d.adrelid = a.attrelid AND d.adnum = a.attnum AND a.atthasdef),
  a.attnotnull,
  (SELECT c.collname FROM pg_catalog.pg_collation c, pg_catalog.pg_type t
   WHERE c.oid = a.attcollation AND t.oid = a.atttypid AND a.attcollation <> t.typcollation) AS attcollation,
  a.attidentity,
  a.attgenerated,
  a.attstorage,
  CASE WHEN a.attstattarget=-1 THEN NULL ELSE a.attstattarget END AS attstattarget,
  pg_catalog.col_description(a.attrelid, a.attnum)
FROM pg_catalog.pg_attribute a
WHERE a.attrelid = '18305' AND a.attnum > 0 AND NOT a.attisdropped
ORDER BY a.attnum;
;SELECT inhparent::pg_catalog.regclass,
  pg_catalog.pg_get_expr(c.relpartbound, c.oid),
  inhdetachpending,
  pg_catalog.pg_get_partition_constraintdef(c.oid)
FROM pg_catalog.pg_class c JOIN pg_catalog.pg_inherits i ON c.oid = inhrelid
WHERE c.oid = '18305';
;SELECT pol.polname, pol.polpermissive,
  CASE WHEN pol.polroles = '{0}' THEN NULL ELSE pg_catalog.array_to_string(array(select rolname from pg_catalog.pg_roles where oid = any (pol.polroles) order by 1),',') END,
  pg_catalog.pg_get_expr(pol.polqual, pol.polrelid),
  pg_catalog.pg_get_expr(pol.polwithcheck, pol.polrelid),
  CASE pol.polcmd
    WHEN 'r' THEN 'SELECT'
    WHEN 'a' THEN 'INSERT'
    WHEN 'w' THEN 'UPDATE'
    WHEN 'd' THEN 'DELETE'
    END AS cmd
FROM pg_catalog.pg_policy pol
WHERE pol.polrelid = '18305' ORDER BY 1;
;SELECT oid, stxrelid::pg_catalog.regclass, stxnamespace::pg_catalog.regnamespace::pg_catalog.text AS nsp, stxname,
pg_catalog.pg_get_statisticsobjdef_columns(oid) AS columns,
  'd' = any(stxkind) AS ndist_enabled,
  'f' = any(stxkind) AS deps_enabled,
  'm' = any(stxkind) AS mcv_enabled,
stxstattarget
FROM pg_catalog.pg_statistic_ext
WHERE stxrelid = '18305'
ORDER BY nsp, stxname;
;SELECT pubname
FROM pg_catalog.pg_publication p
		JOIN pg_catalog.pg_publication_namespace pn ON p.oid = pn.pnpubid
		JOIN pg_catalog.pg_class pc ON pc.relnamespace = pn.pnnspid
WHERE pc.oid ='18305' and pg_catalog.pg_relation_is_publishable('18305')
UNION
SELECT pubname
FROM pg_catalog.pg_publication p
		JOIN pg_catalog.pg_publication_rel pr ON p.oid = pr.prpubid
WHERE pr.prrelid = '18305'
UNION
SELECT pubname
FROM pg_catalog.pg_publication p
WHERE p.puballtables AND pg_catalog.pg_relation_is_publishable('18305')
ORDER BY 1;
;SELECT c.oid::pg_catalog.regclass
FROM pg_catalog.pg_class c, pg_catalog.pg_inherits i
WHERE c.oid = i.inhparent AND i.inhrelid = '18305'
  AND c.relkind != 'p' AND c.relkind != 'I'
ORDER BY inhseqno;
;SELECT c.oid::pg_catalog.regclass, c.relkind, inhdetachpending, pg_catalog.pg_get_expr(c.relpartbound, c.oid)
FROM pg_catalog.pg_class c, pg_catalog.pg_inherits i
WHERE c.oid = i.inhrelid AND i.inhparent = '18305'
ORDER BY pg_catalog.pg_get_expr(c.relpartbound, c.oid) = 'DEFAULT', c.oid::pg_catalog.regclass::pg_catalog.text;
;DROP TABLE range_parted4;
;CREATE FUNCTION my_int4_sort(int4,int4) RETURNS int LANGUAGE sql
  AS $$ SELECT CASE WHEN $1 = $2 THEN 0 WHEN $1 > $2 THEN 1 ELSE -1 END; $$;
;CREATE OPERATOR CLASS test_int4_ops FOR TYPE int4 USING btree AS
  OPERATOR 1 < (int4,int4), OPERATOR 2 <= (int4,int4),
  OPERATOR 3 = (int4,int4), OPERATOR 4 >= (int4,int4),
  OPERATOR 5 > (int4,int4), FUNCTION 1 my_int4_sort(int4,int4);
;CREATE TABLE partkey_t (a int4) PARTITION BY RANGE (a test_int4_ops);
;CREATE TABLE partkey_t_1 PARTITION OF partkey_t FOR VALUES FROM (0) TO (1000);
;INSERT INTO partkey_t VALUES (100);
;INSERT INTO partkey_t VALUES (200);
;DROP TABLE parted, list_parted, range_parted, list_parted2, range_parted2, range_parted3;
;DROP TABLE partkey_t, hash_parted, hash_parted2;
;DROP OPERATOR CLASS test_int4_ops USING btree;
;DROP FUNCTION my_int4_sort(int4,int4);
;CREATE TABLE parted_col_comment (a int, b text) PARTITION BY LIST (a);
;COMMENT ON TABLE parted_col_comment IS 'Am partitioned table';
;COMMENT ON COLUMN parted_col_comment.a IS 'Partition key';
;SELECT obj_description('parted_col_comment'::regclass);
;SELECT c.oid,
  n.nspname,
  c.relname
FROM pg_catalog.pg_class c
     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
WHERE c.relname OPERATOR(pg_catalog.~) '^(parted_col_comment)$' COLLATE pg_catalog.default
  AND pg_catalog.pg_table_is_visible(c.oid)
ORDER BY 2, 3;
;SELECT c.relchecks, c.relkind, c.relhasindex, c.relhasrules, c.relhastriggers, c.relrowsecurity, c.relforcerowsecurity, false AS relhasoids, c.relispartition, pg_catalog.array_to_string(c.reloptions || array(select 'toast.' || x from pg_catalog.unnest(tc.reloptions) x), ', ')
, c.reltablespace, CASE WHEN c.reloftype = 0 THEN '' ELSE c.reloftype::pg_catalog.regtype::pg_catalog.text END, c.relpersistence, c.relreplident, am.amname
FROM pg_catalog.pg_class c
 LEFT JOIN pg_catalog.pg_class tc ON (c.reltoastrelid = tc.oid)
LEFT JOIN pg_catalog.pg_am am ON (c.relam = am.oid)
WHERE c.oid = '18323';
;SELECT a.attname,
  pg_catalog.format_type(a.atttypid, a.atttypmod),
  (SELECT pg_catalog.pg_get_expr(d.adbin, d.adrelid, true)
   FROM pg_catalog.pg_attrdef d
   WHERE d.adrelid = a.attrelid AND d.adnum = a.attnum AND a.atthasdef),
  a.attnotnull,
  (SELECT c.collname FROM pg_catalog.pg_collation c, pg_catalog.pg_type t
   WHERE c.oid = a.attcollation AND t.oid = a.atttypid AND a.attcollation <> t.typcollation) AS attcollation,
  a.attidentity,
  a.attgenerated,
  a.attstorage,
  CASE WHEN a.attstattarget=-1 THEN NULL ELSE a.attstattarget END AS attstattarget,
  pg_catalog.col_description(a.attrelid, a.attnum)
FROM pg_catalog.pg_attribute a
WHERE a.attrelid = '18323' AND a.attnum > 0 AND NOT a.attisdropped
ORDER BY a.attnum;
;SELECT pg_catalog.pg_get_partkeydef('18323'::pg_catalog.oid);
;SELECT conrelid = '18323'::pg_catalog.regclass AS sametable,
       conname,
       pg_catalog.pg_get_constraintdef(oid, true) AS condef,
       conrelid::pg_catalog.regclass AS ontable
  FROM pg_catalog.pg_constraint,
       pg_catalog.pg_partition_ancestors('18323')
 WHERE conrelid = relid AND contype = 'f' AND conparentid = 0
ORDER BY sametable DESC, conname;
;SELECT conname, conrelid::pg_catalog.regclass AS ontable,
       pg_catalog.pg_get_constraintdef(oid, true) AS condef
  FROM pg_catalog.pg_constraint c
 WHERE confrelid IN (SELECT pg_catalog.pg_partition_ancestors('18323')
                     UNION ALL VALUES ('18323'::pg_catalog.regclass))
       AND contype = 'f' AND conparentid = 0
ORDER BY conname;
;SELECT pol.polname, pol.polpermissive,
  CASE WHEN pol.polroles = '{0}' THEN NULL ELSE pg_catalog.array_to_string(array(select rolname from pg_catalog.pg_roles where oid = any (pol.polroles) order by 1),',') END,
  pg_catalog.pg_get_expr(pol.polqual, pol.polrelid),
  pg_catalog.pg_get_expr(pol.polwithcheck, pol.polrelid),
  CASE pol.polcmd
    WHEN 'r' THEN 'SELECT'
    WHEN 'a' THEN 'INSERT'
    WHEN 'w' THEN 'UPDATE'
    WHEN 'd' THEN 'DELETE'
    END AS cmd
FROM pg_catalog.pg_policy pol
WHERE pol.polrelid = '18323' ORDER BY 1;
;SELECT oid, stxrelid::pg_catalog.regclass, stxnamespace::pg_catalog.regnamespace::pg_catalog.text AS nsp, stxname,
pg_catalog.pg_get_statisticsobjdef_columns(oid) AS columns,
  'd' = any(stxkind) AS ndist_enabled,
  'f' = any(stxkind) AS deps_enabled,
  'm' = any(stxkind) AS mcv_enabled,
stxstattarget
FROM pg_catalog.pg_statistic_ext
WHERE stxrelid = '18323'
ORDER BY nsp, stxname;
;SELECT pubname
FROM pg_catalog.pg_publication p
		JOIN pg_catalog.pg_publication_namespace pn ON p.oid = pn.pnpubid
		JOIN pg_catalog.pg_class pc ON pc.relnamespace = pn.pnnspid
WHERE pc.oid ='18323' and pg_catalog.pg_relation_is_publishable('18323')
UNION
SELECT pubname
FROM pg_catalog.pg_publication p
		JOIN pg_catalog.pg_publication_rel pr ON p.oid = pr.prpubid
WHERE pr.prrelid = '18323'
UNION
SELECT pubname
FROM pg_catalog.pg_publication p
WHERE p.puballtables AND pg_catalog.pg_relation_is_publishable('18323')
ORDER BY 1;
;SELECT c.oid::pg_catalog.regclass
FROM pg_catalog.pg_class c, pg_catalog.pg_inherits i
WHERE c.oid = i.inhparent AND i.inhrelid = '18323'
  AND c.relkind != 'p' AND c.relkind != 'I'
ORDER BY inhseqno;
;SELECT c.oid::pg_catalog.regclass, c.relkind, inhdetachpending, pg_catalog.pg_get_expr(c.relpartbound, c.oid)
FROM pg_catalog.pg_class c, pg_catalog.pg_inherits i
WHERE c.oid = i.inhrelid AND i.inhparent = '18323'
ORDER BY pg_catalog.pg_get_expr(c.relpartbound, c.oid) = 'DEFAULT', c.oid::pg_catalog.regclass::pg_catalog.text;
;DROP TABLE parted_col_comment;
;CREATE TABLE arrlp (a int[]) PARTITION BY LIST (a);
;CREATE TABLE arrlp12 PARTITION OF arrlp FOR VALUES IN ('{1}', '{2}');
;SELECT c.oid,
  n.nspname,
  c.relname
FROM pg_catalog.pg_class c
     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
WHERE c.relname OPERATOR(pg_catalog.~) '^(arrlp12)$' COLLATE pg_catalog.default
  AND pg_catalog.pg_table_is_visible(c.oid)
ORDER BY 2, 3;
;SELECT c.relchecks, c.relkind, c.relhasindex, c.relhasrules, c.relhastriggers, c.relrowsecurity, c.relforcerowsecurity, false AS relhasoids, c.relispartition, pg_catalog.array_to_string(c.reloptions || array(select 'toast.' || x from pg_catalog.unnest(tc.reloptions) x), ', ')
, c.reltablespace, CASE WHEN c.reloftype = 0 THEN '' ELSE c.reloftype::pg_catalog.regtype::pg_catalog.text END, c.relpersistence, c.relreplident, am.amname
FROM pg_catalog.pg_class c
 LEFT JOIN pg_catalog.pg_class tc ON (c.reltoastrelid = tc.oid)
LEFT JOIN pg_catalog.pg_am am ON (c.relam = am.oid)
WHERE c.oid = '18329';
;SELECT a.attname,
  pg_catalog.format_type(a.atttypid, a.atttypmod),
  (SELECT pg_catalog.pg_get_expr(d.adbin, d.adrelid, true)
   FROM pg_catalog.pg_attrdef d
   WHERE d.adrelid = a.attrelid AND d.adnum = a.attnum AND a.atthasdef),
  a.attnotnull,
  (SELECT c.collname FROM pg_catalog.pg_collation c, pg_catalog.pg_type t
   WHERE c.oid = a.attcollation AND t.oid = a.atttypid AND a.attcollation <> t.typcollation) AS attcollation,
  a.attidentity,
  a.attgenerated,
  a.attstorage,
  CASE WHEN a.attstattarget=-1 THEN NULL ELSE a.attstattarget END AS attstattarget,
  pg_catalog.col_description(a.attrelid, a.attnum)
FROM pg_catalog.pg_attribute a
WHERE a.attrelid = '18329' AND a.attnum > 0 AND NOT a.attisdropped
ORDER BY a.attnum;
;SELECT inhparent::pg_catalog.regclass,
  pg_catalog.pg_get_expr(c.relpartbound, c.oid),
  inhdetachpending,
  pg_catalog.pg_get_partition_constraintdef(c.oid)
FROM pg_catalog.pg_class c JOIN pg_catalog.pg_inherits i ON c.oid = inhrelid
WHERE c.oid = '18329';
;SELECT pol.polname, pol.polpermissive,
  CASE WHEN pol.polroles = '{0}' THEN NULL ELSE pg_catalog.array_to_string(array(select rolname from pg_catalog.pg_roles where oid = any (pol.polroles) order by 1),',') END,
  pg_catalog.pg_get_expr(pol.polqual, pol.polrelid),
  pg_catalog.pg_get_expr(pol.polwithcheck, pol.polrelid),
  CASE pol.polcmd
    WHEN 'r' THEN 'SELECT'
    WHEN 'a' THEN 'INSERT'
    WHEN 'w' THEN 'UPDATE'
    WHEN 'd' THEN 'DELETE'
    END AS cmd
FROM pg_catalog.pg_policy pol
WHERE pol.polrelid = '18329' ORDER BY 1;
;SELECT oid, stxrelid::pg_catalog.regclass, stxnamespace::pg_catalog.regnamespace::pg_catalog.text AS nsp, stxname,
pg_catalog.pg_get_statisticsobjdef_columns(oid) AS columns,
  'd' = any(stxkind) AS ndist_enabled,
  'f' = any(stxkind) AS deps_enabled,
  'm' = any(stxkind) AS mcv_enabled,
stxstattarget
FROM pg_catalog.pg_statistic_ext
WHERE stxrelid = '18329'
ORDER BY nsp, stxname;
;SELECT pubname
FROM pg_catalog.pg_publication p
		JOIN pg_catalog.pg_publication_namespace pn ON p.oid = pn.pnpubid
		JOIN pg_catalog.pg_class pc ON pc.relnamespace = pn.pnnspid
WHERE pc.oid ='18329' and pg_catalog.pg_relation_is_publishable('18329')
UNION
SELECT pubname
FROM pg_catalog.pg_publication p
		JOIN pg_catalog.pg_publication_rel pr ON p.oid = pr.prpubid
WHERE pr.prrelid = '18329'
UNION
SELECT pubname
FROM pg_catalog.pg_publication p
WHERE p.puballtables AND pg_catalog.pg_relation_is_publishable('18329')
ORDER BY 1;
;SELECT c.oid::pg_catalog.regclass
FROM pg_catalog.pg_class c, pg_catalog.pg_inherits i
WHERE c.oid = i.inhparent AND i.inhrelid = '18329'
  AND c.relkind != 'p' AND c.relkind != 'I'
ORDER BY inhseqno;
;SELECT c.oid::pg_catalog.regclass, c.relkind, inhdetachpending, pg_catalog.pg_get_expr(c.relpartbound, c.oid)
FROM pg_catalog.pg_class c, pg_catalog.pg_inherits i
WHERE c.oid = i.inhrelid AND i.inhparent = '18329'
ORDER BY pg_catalog.pg_get_expr(c.relpartbound, c.oid) = 'DEFAULT', c.oid::pg_catalog.regclass::pg_catalog.text;
;DROP TABLE arrlp;
;create table boolspart (a bool) partition by list (a);
;create table boolspart_t partition of boolspart for values in (true);
;create table boolspart_f partition of boolspart for values in (false);
;SELECT c.oid,
  n.nspname,
  c.relname
FROM pg_catalog.pg_class c
     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
WHERE c.relname OPERATOR(pg_catalog.~) '^(boolspart)$' COLLATE pg_catalog.default
  AND pg_catalog.pg_table_is_visible(c.oid)
ORDER BY 2, 3;
;SELECT c.relchecks, c.relkind, c.relhasindex, c.relhasrules, c.relhastriggers, c.relrowsecurity, c.relforcerowsecurity, false AS relhasoids, c.relispartition, pg_catalog.array_to_string(c.reloptions || array(select 'toast.' || x from pg_catalog.unnest(tc.reloptions) x), ', ')
, c.reltablespace, CASE WHEN c.reloftype = 0 THEN '' ELSE c.reloftype::pg_catalog.regtype::pg_catalog.text END, c.relpersistence, c.relreplident, am.amname
FROM pg_catalog.pg_class c
 LEFT JOIN pg_catalog.pg_class tc ON (c.reltoastrelid = tc.oid)
LEFT JOIN pg_catalog.pg_am am ON (c.relam = am.oid)
WHERE c.oid = '18334';
;SELECT a.attname,
  pg_catalog.format_type(a.atttypid, a.atttypmod),
  (SELECT pg_catalog.pg_get_expr(d.adbin, d.adrelid, true)
   FROM pg_catalog.pg_attrdef d
   WHERE d.adrelid = a.attrelid AND d.adnum = a.attnum AND a.atthasdef),
  a.attnotnull,
  (SELECT c.collname FROM pg_catalog.pg_collation c, pg_catalog.pg_type t
   WHERE c.oid = a.attcollation AND t.oid = a.atttypid AND a.attcollation <> t.typcollation) AS attcollation,
  a.attidentity,
  a.attgenerated,
  a.attstorage,
  CASE WHEN a.attstattarget=-1 THEN NULL ELSE a.attstattarget END AS attstattarget,
  pg_catalog.col_description(a.attrelid, a.attnum)
FROM pg_catalog.pg_attribute a
WHERE a.attrelid = '18334' AND a.attnum > 0 AND NOT a.attisdropped
ORDER BY a.attnum;
;SELECT pg_catalog.pg_get_partkeydef('18334'::pg_catalog.oid);
;SELECT conrelid = '18334'::pg_catalog.regclass AS sametable,
       conname,
       pg_catalog.pg_get_constraintdef(oid, true) AS condef,
       conrelid::pg_catalog.regclass AS ontable
  FROM pg_catalog.pg_constraint,
       pg_catalog.pg_partition_ancestors('18334')
 WHERE conrelid = relid AND contype = 'f' AND conparentid = 0
ORDER BY sametable DESC, conname;
;SELECT conname, conrelid::pg_catalog.regclass AS ontable,
       pg_catalog.pg_get_constraintdef(oid, true) AS condef
  FROM pg_catalog.pg_constraint c
 WHERE confrelid IN (SELECT pg_catalog.pg_partition_ancestors('18334')
                     UNION ALL VALUES ('18334'::pg_catalog.regclass))
       AND contype = 'f' AND conparentid = 0
ORDER BY conname;
;SELECT pol.polname, pol.polpermissive,
  CASE WHEN pol.polroles = '{0}' THEN NULL ELSE pg_catalog.array_to_string(array(select rolname from pg_catalog.pg_roles where oid = any (pol.polroles) order by 1),',') END,
  pg_catalog.pg_get_expr(pol.polqual, pol.polrelid),
  pg_catalog.pg_get_expr(pol.polwithcheck, pol.polrelid),
  CASE pol.polcmd
    WHEN 'r' THEN 'SELECT'
    WHEN 'a' THEN 'INSERT'
    WHEN 'w' THEN 'UPDATE'
    WHEN 'd' THEN 'DELETE'
    END AS cmd
FROM pg_catalog.pg_policy pol
WHERE pol.polrelid = '18334' ORDER BY 1;
;SELECT oid, stxrelid::pg_catalog.regclass, stxnamespace::pg_catalog.regnamespace::pg_catalog.text AS nsp, stxname,
pg_catalog.pg_get_statisticsobjdef_columns(oid) AS columns,
  'd' = any(stxkind) AS ndist_enabled,
  'f' = any(stxkind) AS deps_enabled,
  'm' = any(stxkind) AS mcv_enabled,
stxstattarget
FROM pg_catalog.pg_statistic_ext
WHERE stxrelid = '18334'
ORDER BY nsp, stxname;
;SELECT pubname
FROM pg_catalog.pg_publication p
		JOIN pg_catalog.pg_publication_namespace pn ON p.oid = pn.pnpubid
		JOIN pg_catalog.pg_class pc ON pc.relnamespace = pn.pnnspid
WHERE pc.oid ='18334' and pg_catalog.pg_relation_is_publishable('18334')
UNION
SELECT pubname
FROM pg_catalog.pg_publication p
		JOIN pg_catalog.pg_publication_rel pr ON p.oid = pr.prpubid
WHERE pr.prrelid = '18334'
UNION
SELECT pubname
FROM pg_catalog.pg_publication p
WHERE p.puballtables AND pg_catalog.pg_relation_is_publishable('18334')
ORDER BY 1;
;SELECT c.oid::pg_catalog.regclass
FROM pg_catalog.pg_class c, pg_catalog.pg_inherits i
WHERE c.oid = i.inhparent AND i.inhrelid = '18334'
  AND c.relkind != 'p' AND c.relkind != 'I'
ORDER BY inhseqno;
;SELECT c.oid::pg_catalog.regclass, c.relkind, inhdetachpending, pg_catalog.pg_get_expr(c.relpartbound, c.oid)
FROM pg_catalog.pg_class c, pg_catalog.pg_inherits i
WHERE c.oid = i.inhrelid AND i.inhparent = '18334'
ORDER BY pg_catalog.pg_get_expr(c.relpartbound, c.oid) = 'DEFAULT', c.oid::pg_catalog.regclass::pg_catalog.text;
;drop table boolspart;
;create table perm_parted (a int) partition by list (a);
;create temporary table temp_parted (a int) partition by list (a);
;create table perm_part partition of temp_parted default;
;create temp table temp_part partition of perm_parted default;
;create temp table temp_part partition of temp_parted default;
;drop table perm_parted cascade;
;drop table temp_parted cascade;
;create table tab_part_create (a int) partition by list (a);
;create or replace function func_part_create() returns trigger
  language plpgsql as $$
  begin
    execute 'create table tab_part_create_1 partition of tab_part_create for values in (1)';
    return null;
  end $$;
;create trigger trig_part_create before insert on tab_part_create
  for each statement execute procedure func_part_create();
;insert into tab_part_create values (1);
;drop table tab_part_create;
;drop function func_part_create();
;create table volatile_partbound_test (partkey timestamp) partition by range (partkey);
;create table volatile_partbound_test1 partition of volatile_partbound_test for values from (minvalue) to (current_timestamp);
;create table volatile_partbound_test2 partition of volatile_partbound_test for values from (current_timestamp) to (maxvalue);
;insert into volatile_partbound_test values (current_timestamp);
;select tableoid::regclass from volatile_partbound_test;
;drop table volatile_partbound_test;
;create table defcheck (a int, b int) partition by list (b);
;create table defcheck_def (a int, c int, b int);
;alter table defcheck_def drop c;
;alter table defcheck attach partition defcheck_def default;
;alter table defcheck_def add check (b <= 0 and b is not null);
;create table defcheck_1 partition of defcheck for values in (1, null);
;insert into defcheck_def values (0, 0);
;create table defcheck_0 partition of defcheck for values in (0);
;drop table defcheck;
;create table part_column_drop (
  useless_1 int,
  id int,
  useless_2 int,
  d int,
  b int,
  useless_3 int
) partition by range (id);
;alter table part_column_drop drop column useless_1;
;alter table part_column_drop drop column useless_2;
;alter table part_column_drop drop column useless_3;
;create index part_column_drop_b_pred on part_column_drop(b) where b = 1;
;create index part_column_drop_b_expr on part_column_drop((b = 1));
;create index part_column_drop_d_pred on part_column_drop(d) where d = 2;
;create index part_column_drop_d_expr on part_column_drop((d = 2));
;create table part_column_drop_1_10 partition of
  part_column_drop for values from (1) to (10);
;SELECT c.oid,
  n.nspname,
  c.relname
FROM pg_catalog.pg_class c
     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
WHERE c.relname OPERATOR(pg_catalog.~) '^(part_column_drop)$' COLLATE pg_catalog.default
  AND pg_catalog.pg_table_is_visible(c.oid)
ORDER BY 2, 3;
;SELECT c.relchecks, c.relkind, c.relhasindex, c.relhasrules, c.relhastriggers, c.relrowsecurity, c.relforcerowsecurity, false AS relhasoids, c.relispartition, '', c.reltablespace, CASE WHEN c.reloftype = 0 THEN '' ELSE c.reloftype::pg_catalog.regtype::pg_catalog.text END, c.relpersistence, c.relreplident, am.amname
FROM pg_catalog.pg_class c
 LEFT JOIN pg_catalog.pg_class tc ON (c.reltoastrelid = tc.oid)
LEFT JOIN pg_catalog.pg_am am ON (c.relam = am.oid)
WHERE c.oid = '18379';
;SELECT a.attname,
  pg_catalog.format_type(a.atttypid, a.atttypmod),
  (SELECT pg_catalog.pg_get_expr(d.adbin, d.adrelid, true)
   FROM pg_catalog.pg_attrdef d
   WHERE d.adrelid = a.attrelid AND d.adnum = a.attnum AND a.atthasdef),
  a.attnotnull,
  (SELECT c.collname FROM pg_catalog.pg_collation c, pg_catalog.pg_type t
   WHERE c.oid = a.attcollation AND t.oid = a.atttypid AND a.attcollation <> t.typcollation) AS attcollation,
  a.attidentity,
  a.attgenerated
FROM pg_catalog.pg_attribute a
WHERE a.attrelid = '18379' AND a.attnum > 0 AND NOT a.attisdropped
ORDER BY a.attnum;
;SELECT pg_catalog.pg_get_partkeydef('18379'::pg_catalog.oid);
;SELECT c2.relname, i.indisprimary, i.indisunique, i.indisclustered, i.indisvalid, pg_catalog.pg_get_indexdef(i.indexrelid, 0, true),
  pg_catalog.pg_get_constraintdef(con.oid, true), contype, condeferrable, condeferred, i.indisreplident, c2.reltablespace
FROM pg_catalog.pg_class c, pg_catalog.pg_class c2, pg_catalog.pg_index i
  LEFT JOIN pg_catalog.pg_constraint con ON (conrelid = i.indrelid AND conindid = i.indexrelid AND contype IN ('p','u','x'))
WHERE c.oid = '18379' AND c.oid = i.indrelid AND i.indexrelid = c2.oid
ORDER BY i.indisprimary DESC, c2.relname;
;SELECT conrelid = '18379'::pg_catalog.regclass AS sametable,
       conname,
       pg_catalog.pg_get_constraintdef(oid, true) AS condef,
       conrelid::pg_catalog.regclass AS ontable
  FROM pg_catalog.pg_constraint,
       pg_catalog.pg_partition_ancestors('18379')
 WHERE conrelid = relid AND contype = 'f' AND conparentid = 0
ORDER BY sametable DESC, conname;
;SELECT conname, conrelid::pg_catalog.regclass AS ontable,
       pg_catalog.pg_get_constraintdef(oid, true) AS condef
  FROM pg_catalog.pg_constraint c
 WHERE confrelid IN (SELECT pg_catalog.pg_partition_ancestors('18379')
                     UNION ALL VALUES ('18379'::pg_catalog.regclass))
       AND contype = 'f' AND conparentid = 0
ORDER BY conname;
;SELECT pol.polname, pol.polpermissive,
  CASE WHEN pol.polroles = '{0}' THEN NULL ELSE pg_catalog.array_to_string(array(select rolname from pg_catalog.pg_roles where oid = any (pol.polroles) order by 1),',') END,
  pg_catalog.pg_get_expr(pol.polqual, pol.polrelid),
  pg_catalog.pg_get_expr(pol.polwithcheck, pol.polrelid),
  CASE pol.polcmd
    WHEN 'r' THEN 'SELECT'
    WHEN 'a' THEN 'INSERT'
    WHEN 'w' THEN 'UPDATE'
    WHEN 'd' THEN 'DELETE'
    END AS cmd
FROM pg_catalog.pg_policy pol
WHERE pol.polrelid = '18379' ORDER BY 1;
;SELECT oid, stxrelid::pg_catalog.regclass, stxnamespace::pg_catalog.regnamespace::pg_catalog.text AS nsp, stxname,
pg_catalog.pg_get_statisticsobjdef_columns(oid) AS columns,
  'd' = any(stxkind) AS ndist_enabled,
  'f' = any(stxkind) AS deps_enabled,
  'm' = any(stxkind) AS mcv_enabled,
stxstattarget
FROM pg_catalog.pg_statistic_ext
WHERE stxrelid = '18379'
ORDER BY nsp, stxname;
;SELECT pubname
FROM pg_catalog.pg_publication p
		JOIN pg_catalog.pg_publication_namespace pn ON p.oid = pn.pnpubid
		JOIN pg_catalog.pg_class pc ON pc.relnamespace = pn.pnnspid
WHERE pc.oid ='18379' and pg_catalog.pg_relation_is_publishable('18379')
UNION
SELECT pubname
FROM pg_catalog.pg_publication p
		JOIN pg_catalog.pg_publication_rel pr ON p.oid = pr.prpubid
WHERE pr.prrelid = '18379'
UNION
SELECT pubname
FROM pg_catalog.pg_publication p
WHERE p.puballtables AND pg_catalog.pg_relation_is_publishable('18379')
ORDER BY 1;
;SELECT c.oid::pg_catalog.regclass
FROM pg_catalog.pg_class c, pg_catalog.pg_inherits i
WHERE c.oid = i.inhparent AND i.inhrelid = '18379'
  AND c.relkind != 'p' AND c.relkind != 'I'
ORDER BY inhseqno;
;SELECT c.oid::pg_catalog.regclass, c.relkind, inhdetachpending, pg_catalog.pg_get_expr(c.relpartbound, c.oid)
FROM pg_catalog.pg_class c, pg_catalog.pg_inherits i
WHERE c.oid = i.inhrelid AND i.inhparent = '18379'
ORDER BY pg_catalog.pg_get_expr(c.relpartbound, c.oid) = 'DEFAULT', c.oid::pg_catalog.regclass::pg_catalog.text;
;SELECT c.oid,
  n.nspname,
  c.relname
FROM pg_catalog.pg_class c
     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
WHERE c.relname OPERATOR(pg_catalog.~) '^(part_column_drop_1_10)$' COLLATE pg_catalog.default
  AND pg_catalog.pg_table_is_visible(c.oid)
ORDER BY 2, 3;
;SELECT c.relchecks, c.relkind, c.relhasindex, c.relhasrules, c.relhastriggers, c.relrowsecurity, c.relforcerowsecurity, false AS relhasoids, c.relispartition, '', c.reltablespace, CASE WHEN c.reloftype = 0 THEN '' ELSE c.reloftype::pg_catalog.regtype::pg_catalog.text END, c.relpersistence, c.relreplident, am.amname
FROM pg_catalog.pg_class c
 LEFT JOIN pg_catalog.pg_class tc ON (c.reltoastrelid = tc.oid)
LEFT JOIN pg_catalog.pg_am am ON (c.relam = am.oid)
WHERE c.oid = '18386';
;SELECT a.attname,
  pg_catalog.format_type(a.atttypid, a.atttypmod),
  (SELECT pg_catalog.pg_get_expr(d.adbin, d.adrelid, true)
   FROM pg_catalog.pg_attrdef d
   WHERE d.adrelid = a.attrelid AND d.adnum = a.attnum AND a.atthasdef),
  a.attnotnull,
  (SELECT c.collname FROM pg_catalog.pg_collation c, pg_catalog.pg_type t
   WHERE c.oid = a.attcollation AND t.oid = a.atttypid AND a.attcollation <> t.typcollation) AS attcollation,
  a.attidentity,
  a.attgenerated
FROM pg_catalog.pg_attribute a
WHERE a.attrelid = '18386' AND a.attnum > 0 AND NOT a.attisdropped
ORDER BY a.attnum;
;SELECT inhparent::pg_catalog.regclass,
  pg_catalog.pg_get_expr(c.relpartbound, c.oid),
  inhdetachpending
FROM pg_catalog.pg_class c JOIN pg_catalog.pg_inherits i ON c.oid = inhrelid
WHERE c.oid = '18386';
;SELECT c2.relname, i.indisprimary, i.indisunique, i.indisclustered, i.indisvalid, pg_catalog.pg_get_indexdef(i.indexrelid, 0, true),
  pg_catalog.pg_get_constraintdef(con.oid, true), contype, condeferrable, condeferred, i.indisreplident, c2.reltablespace
FROM pg_catalog.pg_class c, pg_catalog.pg_class c2, pg_catalog.pg_index i
  LEFT JOIN pg_catalog.pg_constraint con ON (conrelid = i.indrelid AND conindid = i.indexrelid AND contype IN ('p','u','x'))
WHERE c.oid = '18386' AND c.oid = i.indrelid AND i.indexrelid = c2.oid
ORDER BY i.indisprimary DESC, c2.relname;
;SELECT pol.polname, pol.polpermissive,
  CASE WHEN pol.polroles = '{0}' THEN NULL ELSE pg_catalog.array_to_string(array(select rolname from pg_catalog.pg_roles where oid = any (pol.polroles) order by 1),',') END,
  pg_catalog.pg_get_expr(pol.polqual, pol.polrelid),
  pg_catalog.pg_get_expr(pol.polwithcheck, pol.polrelid),
  CASE pol.polcmd
    WHEN 'r' THEN 'SELECT'
    WHEN 'a' THEN 'INSERT'
    WHEN 'w' THEN 'UPDATE'
    WHEN 'd' THEN 'DELETE'
    END AS cmd
FROM pg_catalog.pg_policy pol
WHERE pol.polrelid = '18386' ORDER BY 1;
;SELECT oid, stxrelid::pg_catalog.regclass, stxnamespace::pg_catalog.regnamespace::pg_catalog.text AS nsp, stxname,
pg_catalog.pg_get_statisticsobjdef_columns(oid) AS columns,
  'd' = any(stxkind) AS ndist_enabled,
  'f' = any(stxkind) AS deps_enabled,
  'm' = any(stxkind) AS mcv_enabled,
stxstattarget
FROM pg_catalog.pg_statistic_ext
WHERE stxrelid = '18386'
ORDER BY nsp, stxname;
;SELECT pubname
FROM pg_catalog.pg_publication p
		JOIN pg_catalog.pg_publication_namespace pn ON p.oid = pn.pnpubid
		JOIN pg_catalog.pg_class pc ON pc.relnamespace = pn.pnnspid
WHERE pc.oid ='18386' and pg_catalog.pg_relation_is_publishable('18386')
UNION
SELECT pubname
FROM pg_catalog.pg_publication p
		JOIN pg_catalog.pg_publication_rel pr ON p.oid = pr.prpubid
WHERE pr.prrelid = '18386'
UNION
SELECT pubname
FROM pg_catalog.pg_publication p
WHERE p.puballtables AND pg_catalog.pg_relation_is_publishable('18386')
ORDER BY 1;
;SELECT c.oid::pg_catalog.regclass
FROM pg_catalog.pg_class c, pg_catalog.pg_inherits i
WHERE c.oid = i.inhparent AND i.inhrelid = '18386'
  AND c.relkind != 'p' AND c.relkind != 'I'
ORDER BY inhseqno;
;SELECT c.oid::pg_catalog.regclass, c.relkind, inhdetachpending, pg_catalog.pg_get_expr(c.relpartbound, c.oid)
FROM pg_catalog.pg_class c, pg_catalog.pg_inherits i
WHERE c.oid = i.inhrelid AND i.inhparent = '18386'
ORDER BY pg_catalog.pg_get_expr(c.relpartbound, c.oid) = 'DEFAULT', c.oid::pg_catalog.regclass::pg_catalog.text;
;drop table part_column_drop;
;