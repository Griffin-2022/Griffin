SHOW track_counts;
;SET enable_seqscan TO on;
;SET enable_indexscan TO on;
;SET enable_indexonlyscan TO off;
;CREATE TABLE prevstats AS
SELECT t.seq_scan, t.seq_tup_read, t.idx_scan, t.idx_tup_fetch,
       (b.heap_blks_read + b.heap_blks_hit) AS heap_blks,
       (b.idx_blks_read + b.idx_blks_hit) AS idx_blks,
       pg_stat_get_snapshot_timestamp() as snap_ts
  FROM pg_catalog.pg_stat_user_tables AS t,
       pg_catalog.pg_statio_user_tables AS b
 WHERE t.relname='tenk2' AND b.relname='tenk2';
;create function wait_for_stats() returns void as $$
declare
  start_time timestamptz := clock_timestamp();
  updated1 bool;
  updated2 bool;
  updated3 bool;
  updated4 bool;
begin
  -- we don't want to wait forever; loop will exit after 30 seconds
  for i in 1 .. 300 loop

    -- With parallel query, the seqscan and indexscan on tenk2 might be done
    -- in parallel worker processes, which will send their stats counters
    -- asynchronously to what our own session does.  So we must check for
    -- those counts to be registered separately from the update counts.

    -- check to see if seqscan has been sensed
    SELECT (st.seq_scan >= pr.seq_scan + 1) INTO updated1
      FROM pg_stat_user_tables AS st, pg_class AS cl, prevstats AS pr
     WHERE st.relname='tenk2' AND cl.relname='tenk2';

    -- check to see if indexscan has been sensed
    SELECT (st.idx_scan >= pr.idx_scan + 1) INTO updated2
      FROM pg_stat_user_tables AS st, pg_class AS cl, prevstats AS pr
     WHERE st.relname='tenk2' AND cl.relname='tenk2';

    -- check to see if all updates have been sensed
    SELECT (n_tup_ins > 0) INTO updated3
      FROM pg_stat_user_tables WHERE relname='trunc_stats_test4';

    -- We must also check explicitly that pg_stat_get_snapshot_timestamp has
    -- advanced, because that comes from the global stats file which might
    -- be older than the per-DB stats file we got the other values from.
    SELECT (pr.snap_ts < pg_stat_get_snapshot_timestamp()) INTO updated4
      FROM prevstats AS pr;

    exit when updated1 and updated2 and updated3 and updated4;

    -- wait a little
    perform pg_sleep_for('100 milliseconds');

    -- reset stats snapshot so we can test again
    perform pg_stat_clear_snapshot();

  end loop;

  -- report time waited in postmaster log (where it won't change test output)
  raise log 'wait_for_stats delayed % seconds',
    extract(epoch from clock_timestamp() - start_time);
end
$$ language plpgsql;
;CREATE TABLE trunc_stats_test(id serial);
;CREATE TABLE trunc_stats_test1(id serial, stuff text);
;CREATE TABLE trunc_stats_test2(id serial);
;CREATE TABLE trunc_stats_test3(id serial, stuff text);
;CREATE TABLE trunc_stats_test4(id serial);
;INSERT INTO trunc_stats_test DEFAULT VALUES;
;INSERT INTO trunc_stats_test DEFAULT VALUES;
;INSERT INTO trunc_stats_test DEFAULT VALUES;
;TRUNCATE trunc_stats_test;
;INSERT INTO trunc_stats_test1 DEFAULT VALUES;
;INSERT INTO trunc_stats_test1 DEFAULT VALUES;
;INSERT INTO trunc_stats_test1 DEFAULT VALUES;
;UPDATE trunc_stats_test1 SET id = id + 10 WHERE id IN (1, 2);
;DELETE FROM trunc_stats_test1 WHERE id = 3;
;BEGIN;
;UPDATE trunc_stats_test1 SET id = id + 100;
;TRUNCATE trunc_stats_test1;
;INSERT INTO trunc_stats_test1 DEFAULT VALUES;
;COMMIT;
;BEGIN;
;INSERT INTO trunc_stats_test2 DEFAULT VALUES;
;INSERT INTO trunc_stats_test2 DEFAULT VALUES;
;SAVEPOINT p1;
;INSERT INTO trunc_stats_test2 DEFAULT VALUES;
;TRUNCATE trunc_stats_test2;
;INSERT INTO trunc_stats_test2 DEFAULT VALUES;
;RELEASE SAVEPOINT p1;
;COMMIT;
;BEGIN;
;INSERT INTO trunc_stats_test3 DEFAULT VALUES;
;INSERT INTO trunc_stats_test3 DEFAULT VALUES;
;SAVEPOINT p1;
;INSERT INTO trunc_stats_test3 DEFAULT VALUES;
;INSERT INTO trunc_stats_test3 DEFAULT VALUES;
;TRUNCATE trunc_stats_test3;
;INSERT INTO trunc_stats_test3 DEFAULT VALUES;
;ROLLBACK TO SAVEPOINT p1;
;COMMIT;
;BEGIN;
;INSERT INTO trunc_stats_test4 DEFAULT VALUES;
;INSERT INTO trunc_stats_test4 DEFAULT VALUES;
;TRUNCATE trunc_stats_test4;
;INSERT INTO trunc_stats_test4 DEFAULT VALUES;
;ROLLBACK;
;SELECT count(*) FROM tenk2;
;SET enable_bitmapscan TO off;
;SELECT count(*) FROM tenk2 WHERE unique1 = 1;
;RESET enable_bitmapscan;
;