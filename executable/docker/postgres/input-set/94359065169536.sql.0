
  --
  -- Setup to test an error from ExecUpdate and ExecDelete.
  --
  CREATE TABLE foo (a int, b text) PARTITION BY LIST(a);
  CREATE TABLE foo1 PARTITION OF foo FOR VALUES IN (1);
  CREATE TABLE foo2 PARTITION OF foo FOR VALUES IN (2);
  INSERT INTO foo VALUES (1, 'ABC');

  --
  -- Setup to test an error from GetTupleForTrigger
  --
  CREATE TABLE footrg (a int, b text) PARTITION BY LIST(a);
  CREATE TABLE footrg1 PARTITION OF footrg FOR VALUES IN (1);
  CREATE TABLE footrg2 PARTITION OF footrg FOR VALUES IN (2);
  INSERT INTO footrg VALUES (1, 'ABC');
  CREATE FUNCTION func_footrg_mod_a() RETURNS TRIGGER AS $$
    BEGIN
	  NEW.a = 2; -- This is changing partition key column.
   RETURN NEW;
  END $$ LANGUAGE PLPGSQL;
  CREATE TRIGGER footrg_mod_a BEFORE UPDATE ON footrg1
   FOR EACH ROW EXECUTE PROCEDURE func_footrg_mod_a();

  --
  -- Setup to test an error from ExecLockRows
  --
  CREATE TABLE foo_range_parted (a int, b text) PARTITION BY RANGE(a);
  CREATE TABLE foo_range_parted1 PARTITION OF foo_range_parted FOR VALUES FROM (1) TO (10);
  CREATE TABLE foo_range_parted2 PARTITION OF foo_range_parted FOR VALUES FROM (10) TO (20);
  INSERT INTO foo_range_parted VALUES(7, 'ABC');
  CREATE UNIQUE INDEX foo_range_parted1_a_unique ON foo_range_parted1 (a);
  CREATE TABLE bar (a int REFERENCES foo_range_parted1(a));

;
  DROP TABLE foo;
  DROP TRIGGER footrg_mod_a ON footrg1;
  DROP FUNCTION func_footrg_mod_a();
  DROP TABLE footrg;
  DROP TABLE bar, foo_range_parted;

;
  --
  -- Setup to test an error from ExecUpdate and ExecDelete.
  --
  CREATE TABLE foo (a int, b text) PARTITION BY LIST(a);
  CREATE TABLE foo1 PARTITION OF foo FOR VALUES IN (1);
  CREATE TABLE foo2 PARTITION OF foo FOR VALUES IN (2);
  INSERT INTO foo VALUES (1, 'ABC');

  --
  -- Setup to test an error from GetTupleForTrigger
  --
  CREATE TABLE footrg (a int, b text) PARTITION BY LIST(a);
  CREATE TABLE footrg1 PARTITION OF footrg FOR VALUES IN (1);
  CREATE TABLE footrg2 PARTITION OF footrg FOR VALUES IN (2);
  INSERT INTO footrg VALUES (1, 'ABC');
  CREATE FUNCTION func_footrg_mod_a() RETURNS TRIGGER AS $$
    BEGIN
	  NEW.a = 2; -- This is changing partition key column.
   RETURN NEW;
  END $$ LANGUAGE PLPGSQL;
  CREATE TRIGGER footrg_mod_a BEFORE UPDATE ON footrg1
   FOR EACH ROW EXECUTE PROCEDURE func_footrg_mod_a();

  --
  -- Setup to test an error from ExecLockRows
  --
  CREATE TABLE foo_range_parted (a int, b text) PARTITION BY RANGE(a);
  CREATE TABLE foo_range_parted1 PARTITION OF foo_range_parted FOR VALUES FROM (1) TO (10);
  CREATE TABLE foo_range_parted2 PARTITION OF foo_range_parted FOR VALUES FROM (10) TO (20);
  INSERT INTO foo_range_parted VALUES(7, 'ABC');
  CREATE UNIQUE INDEX foo_range_parted1_a_unique ON foo_range_parted1 (a);
  CREATE TABLE bar (a int REFERENCES foo_range_parted1(a));

;
  DROP TABLE foo;
  DROP TRIGGER footrg_mod_a ON footrg1;
  DROP FUNCTION func_footrg_mod_a();
  DROP TABLE footrg;
  DROP TABLE bar, foo_range_parted;

;
  --
  -- Setup to test an error from ExecUpdate and ExecDelete.
  --
  CREATE TABLE foo (a int, b text) PARTITION BY LIST(a);
  CREATE TABLE foo1 PARTITION OF foo FOR VALUES IN (1);
  CREATE TABLE foo2 PARTITION OF foo FOR VALUES IN (2);
  INSERT INTO foo VALUES (1, 'ABC');

  --
  -- Setup to test an error from GetTupleForTrigger
  --
  CREATE TABLE footrg (a int, b text) PARTITION BY LIST(a);
  CREATE TABLE footrg1 PARTITION OF footrg FOR VALUES IN (1);
  CREATE TABLE footrg2 PARTITION OF footrg FOR VALUES IN (2);
  INSERT INTO footrg VALUES (1, 'ABC');
  CREATE FUNCTION func_footrg_mod_a() RETURNS TRIGGER AS $$
    BEGIN
	  NEW.a = 2; -- This is changing partition key column.
   RETURN NEW;
  END $$ LANGUAGE PLPGSQL;
  CREATE TRIGGER footrg_mod_a BEFORE UPDATE ON footrg1
   FOR EACH ROW EXECUTE PROCEDURE func_footrg_mod_a();

  --
  -- Setup to test an error from ExecLockRows
  --
  CREATE TABLE foo_range_parted (a int, b text) PARTITION BY RANGE(a);
  CREATE TABLE foo_range_parted1 PARTITION OF foo_range_parted FOR VALUES FROM (1) TO (10);
  CREATE TABLE foo_range_parted2 PARTITION OF foo_range_parted FOR VALUES FROM (10) TO (20);
  INSERT INTO foo_range_parted VALUES(7, 'ABC');
  CREATE UNIQUE INDEX foo_range_parted1_a_unique ON foo_range_parted1 (a);
  CREATE TABLE bar (a int REFERENCES foo_range_parted1(a));

;
  DROP TABLE foo;
  DROP TRIGGER footrg_mod_a ON footrg1;
  DROP FUNCTION func_footrg_mod_a();
  DROP TABLE footrg;
  DROP TABLE bar, foo_range_parted;

;
  --
  -- Setup to test an error from ExecUpdate and ExecDelete.
  --
  CREATE TABLE foo (a int, b text) PARTITION BY LIST(a);
  CREATE TABLE foo1 PARTITION OF foo FOR VALUES IN (1);
  CREATE TABLE foo2 PARTITION OF foo FOR VALUES IN (2);
  INSERT INTO foo VALUES (1, 'ABC');

  --
  -- Setup to test an error from GetTupleForTrigger
  --
  CREATE TABLE footrg (a int, b text) PARTITION BY LIST(a);
  CREATE TABLE footrg1 PARTITION OF footrg FOR VALUES IN (1);
  CREATE TABLE footrg2 PARTITION OF footrg FOR VALUES IN (2);
  INSERT INTO footrg VALUES (1, 'ABC');
  CREATE FUNCTION func_footrg_mod_a() RETURNS TRIGGER AS $$
    BEGIN
	  NEW.a = 2; -- This is changing partition key column.
   RETURN NEW;
  END $$ LANGUAGE PLPGSQL;
  CREATE TRIGGER footrg_mod_a BEFORE UPDATE ON footrg1
   FOR EACH ROW EXECUTE PROCEDURE func_footrg_mod_a();

  --
  -- Setup to test an error from ExecLockRows
  --
  CREATE TABLE foo_range_parted (a int, b text) PARTITION BY RANGE(a);
  CREATE TABLE foo_range_parted1 PARTITION OF foo_range_parted FOR VALUES FROM (1) TO (10);
  CREATE TABLE foo_range_parted2 PARTITION OF foo_range_parted FOR VALUES FROM (10) TO (20);
  INSERT INTO foo_range_parted VALUES(7, 'ABC');
  CREATE UNIQUE INDEX foo_range_parted1_a_unique ON foo_range_parted1 (a);
  CREATE TABLE bar (a int REFERENCES foo_range_parted1(a));

;
  DROP TABLE foo;
  DROP TRIGGER footrg_mod_a ON footrg1;
  DROP FUNCTION func_footrg_mod_a();
  DROP TABLE footrg;
  DROP TABLE bar, foo_range_parted;

;
  --
  -- Setup to test an error from ExecUpdate and ExecDelete.
  --
  CREATE TABLE foo (a int, b text) PARTITION BY LIST(a);
  CREATE TABLE foo1 PARTITION OF foo FOR VALUES IN (1);
  CREATE TABLE foo2 PARTITION OF foo FOR VALUES IN (2);
  INSERT INTO foo VALUES (1, 'ABC');

  --
  -- Setup to test an error from GetTupleForTrigger
  --
  CREATE TABLE footrg (a int, b text) PARTITION BY LIST(a);
  CREATE TABLE footrg1 PARTITION OF footrg FOR VALUES IN (1);
  CREATE TABLE footrg2 PARTITION OF footrg FOR VALUES IN (2);
  INSERT INTO footrg VALUES (1, 'ABC');
  CREATE FUNCTION func_footrg_mod_a() RETURNS TRIGGER AS $$
    BEGIN
	  NEW.a = 2; -- This is changing partition key column.
   RETURN NEW;
  END $$ LANGUAGE PLPGSQL;
  CREATE TRIGGER footrg_mod_a BEFORE UPDATE ON footrg1
   FOR EACH ROW EXECUTE PROCEDURE func_footrg_mod_a();

  --
  -- Setup to test an error from ExecLockRows
  --
  CREATE TABLE foo_range_parted (a int, b text) PARTITION BY RANGE(a);
  CREATE TABLE foo_range_parted1 PARTITION OF foo_range_parted FOR VALUES FROM (1) TO (10);
  CREATE TABLE foo_range_parted2 PARTITION OF foo_range_parted FOR VALUES FROM (10) TO (20);
  INSERT INTO foo_range_parted VALUES(7, 'ABC');
  CREATE UNIQUE INDEX foo_range_parted1_a_unique ON foo_range_parted1 (a);
  CREATE TABLE bar (a int REFERENCES foo_range_parted1(a));

;
  DROP TABLE foo;
  DROP TRIGGER footrg_mod_a ON footrg1;
  DROP FUNCTION func_footrg_mod_a();
  DROP TABLE footrg;
  DROP TABLE bar, foo_range_parted;

;
  --
  -- Setup to test an error from ExecUpdate and ExecDelete.
  --
  CREATE TABLE foo (a int, b text) PARTITION BY LIST(a);
  CREATE TABLE foo1 PARTITION OF foo FOR VALUES IN (1);
  CREATE TABLE foo2 PARTITION OF foo FOR VALUES IN (2);
  INSERT INTO foo VALUES (1, 'ABC');

  --
  -- Setup to test an error from GetTupleForTrigger
  --
  CREATE TABLE footrg (a int, b text) PARTITION BY LIST(a);
  CREATE TABLE footrg1 PARTITION OF footrg FOR VALUES IN (1);
  CREATE TABLE footrg2 PARTITION OF footrg FOR VALUES IN (2);
  INSERT INTO footrg VALUES (1, 'ABC');
  CREATE FUNCTION func_footrg_mod_a() RETURNS TRIGGER AS $$
    BEGIN
	  NEW.a = 2; -- This is changing partition key column.
   RETURN NEW;
  END $$ LANGUAGE PLPGSQL;
  CREATE TRIGGER footrg_mod_a BEFORE UPDATE ON footrg1
   FOR EACH ROW EXECUTE PROCEDURE func_footrg_mod_a();

  --
  -- Setup to test an error from ExecLockRows
  --
  CREATE TABLE foo_range_parted (a int, b text) PARTITION BY RANGE(a);
  CREATE TABLE foo_range_parted1 PARTITION OF foo_range_parted FOR VALUES FROM (1) TO (10);
  CREATE TABLE foo_range_parted2 PARTITION OF foo_range_parted FOR VALUES FROM (10) TO (20);
  INSERT INTO foo_range_parted VALUES(7, 'ABC');
  CREATE UNIQUE INDEX foo_range_parted1_a_unique ON foo_range_parted1 (a);
  CREATE TABLE bar (a int REFERENCES foo_range_parted1(a));

;
  DROP TABLE foo;
  DROP TRIGGER footrg_mod_a ON footrg1;
  DROP FUNCTION func_footrg_mod_a();
  DROP TABLE footrg;
  DROP TABLE bar, foo_range_parted;

;
  --
  -- Setup to test an error from ExecUpdate and ExecDelete.
  --
  CREATE TABLE foo (a int, b text) PARTITION BY LIST(a);
  CREATE TABLE foo1 PARTITION OF foo FOR VALUES IN (1);
  CREATE TABLE foo2 PARTITION OF foo FOR VALUES IN (2);
  INSERT INTO foo VALUES (1, 'ABC');

  --
  -- Setup to test an error from GetTupleForTrigger
  --
  CREATE TABLE footrg (a int, b text) PARTITION BY LIST(a);
  CREATE TABLE footrg1 PARTITION OF footrg FOR VALUES IN (1);
  CREATE TABLE footrg2 PARTITION OF footrg FOR VALUES IN (2);
  INSERT INTO footrg VALUES (1, 'ABC');
  CREATE FUNCTION func_footrg_mod_a() RETURNS TRIGGER AS $$
    BEGIN
	  NEW.a = 2; -- This is changing partition key column.
   RETURN NEW;
  END $$ LANGUAGE PLPGSQL;
  CREATE TRIGGER footrg_mod_a BEFORE UPDATE ON footrg1
   FOR EACH ROW EXECUTE PROCEDURE func_footrg_mod_a();

  --
  -- Setup to test an error from ExecLockRows
  --
  CREATE TABLE foo_range_parted (a int, b text) PARTITION BY RANGE(a);
  CREATE TABLE foo_range_parted1 PARTITION OF foo_range_parted FOR VALUES FROM (1) TO (10);
  CREATE TABLE foo_range_parted2 PARTITION OF foo_range_parted FOR VALUES FROM (10) TO (20);
  INSERT INTO foo_range_parted VALUES(7, 'ABC');
  CREATE UNIQUE INDEX foo_range_parted1_a_unique ON foo_range_parted1 (a);
  CREATE TABLE bar (a int REFERENCES foo_range_parted1(a));

;
  DROP TABLE foo;
  DROP TRIGGER footrg_mod_a ON footrg1;
  DROP FUNCTION func_footrg_mod_a();
  DROP TABLE footrg;
  DROP TABLE bar, foo_range_parted;

;
  --
  -- Setup to test an error from ExecUpdate and ExecDelete.
  --
  CREATE TABLE foo (a int, b text) PARTITION BY LIST(a);
  CREATE TABLE foo1 PARTITION OF foo FOR VALUES IN (1);
  CREATE TABLE foo2 PARTITION OF foo FOR VALUES IN (2);
  INSERT INTO foo VALUES (1, 'ABC');

  --
  -- Setup to test an error from GetTupleForTrigger
  --
  CREATE TABLE footrg (a int, b text) PARTITION BY LIST(a);
  CREATE TABLE footrg1 PARTITION OF footrg FOR VALUES IN (1);
  CREATE TABLE footrg2 PARTITION OF footrg FOR VALUES IN (2);
  INSERT INTO footrg VALUES (1, 'ABC');
  CREATE FUNCTION func_footrg_mod_a() RETURNS TRIGGER AS $$
    BEGIN
	  NEW.a = 2; -- This is changing partition key column.
   RETURN NEW;
  END $$ LANGUAGE PLPGSQL;
  CREATE TRIGGER footrg_mod_a BEFORE UPDATE ON footrg1
   FOR EACH ROW EXECUTE PROCEDURE func_footrg_mod_a();

  --
  -- Setup to test an error from ExecLockRows
  --
  CREATE TABLE foo_range_parted (a int, b text) PARTITION BY RANGE(a);
  CREATE TABLE foo_range_parted1 PARTITION OF foo_range_parted FOR VALUES FROM (1) TO (10);
  CREATE TABLE foo_range_parted2 PARTITION OF foo_range_parted FOR VALUES FROM (10) TO (20);
  INSERT INTO foo_range_parted VALUES(7, 'ABC');
  CREATE UNIQUE INDEX foo_range_parted1_a_unique ON foo_range_parted1 (a);
  CREATE TABLE bar (a int REFERENCES foo_range_parted1(a));

;
  DROP TABLE foo;
  DROP TRIGGER footrg_mod_a ON footrg1;
  DROP FUNCTION func_footrg_mod_a();
  DROP TABLE footrg;
  DROP TABLE bar, foo_range_parted;

;
  --
  -- Setup to test an error from ExecUpdate and ExecDelete.
  --
  CREATE TABLE foo (a int, b text) PARTITION BY LIST(a);
  CREATE TABLE foo1 PARTITION OF foo FOR VALUES IN (1);
  CREATE TABLE foo2 PARTITION OF foo FOR VALUES IN (2);
  INSERT INTO foo VALUES (1, 'ABC');

  --
  -- Setup to test an error from GetTupleForTrigger
  --
  CREATE TABLE footrg (a int, b text) PARTITION BY LIST(a);
  CREATE TABLE footrg1 PARTITION OF footrg FOR VALUES IN (1);
  CREATE TABLE footrg2 PARTITION OF footrg FOR VALUES IN (2);
  INSERT INTO footrg VALUES (1, 'ABC');
  CREATE FUNCTION func_footrg_mod_a() RETURNS TRIGGER AS $$
    BEGIN
	  NEW.a = 2; -- This is changing partition key column.
   RETURN NEW;
  END $$ LANGUAGE PLPGSQL;
  CREATE TRIGGER footrg_mod_a BEFORE UPDATE ON footrg1
   FOR EACH ROW EXECUTE PROCEDURE func_footrg_mod_a();

  --
  -- Setup to test an error from ExecLockRows
  --
  CREATE TABLE foo_range_parted (a int, b text) PARTITION BY RANGE(a);
  CREATE TABLE foo_range_parted1 PARTITION OF foo_range_parted FOR VALUES FROM (1) TO (10);
  CREATE TABLE foo_range_parted2 PARTITION OF foo_range_parted FOR VALUES FROM (10) TO (20);
  INSERT INTO foo_range_parted VALUES(7, 'ABC');
  CREATE UNIQUE INDEX foo_range_parted1_a_unique ON foo_range_parted1 (a);
  CREATE TABLE bar (a int REFERENCES foo_range_parted1(a));

;
  DROP TABLE foo;
  DROP TRIGGER footrg_mod_a ON footrg1;
  DROP FUNCTION func_footrg_mod_a();
  DROP TABLE footrg;
  DROP TABLE bar, foo_range_parted;

;
  --
  -- Setup to test an error from ExecUpdate and ExecDelete.
  --
  CREATE TABLE foo (a int, b text) PARTITION BY LIST(a);
  CREATE TABLE foo1 PARTITION OF foo FOR VALUES IN (1);
  CREATE TABLE foo2 PARTITION OF foo FOR VALUES IN (2);
  INSERT INTO foo VALUES (1, 'ABC');

  --
  -- Setup to test an error from GetTupleForTrigger
  --
  CREATE TABLE footrg (a int, b text) PARTITION BY LIST(a);
  CREATE TABLE footrg1 PARTITION OF footrg FOR VALUES IN (1);
  CREATE TABLE footrg2 PARTITION OF footrg FOR VALUES IN (2);
  INSERT INTO footrg VALUES (1, 'ABC');
  CREATE FUNCTION func_footrg_mod_a() RETURNS TRIGGER AS $$
    BEGIN
	  NEW.a = 2; -- This is changing partition key column.
   RETURN NEW;
  END $$ LANGUAGE PLPGSQL;
  CREATE TRIGGER footrg_mod_a BEFORE UPDATE ON footrg1
   FOR EACH ROW EXECUTE PROCEDURE func_footrg_mod_a();

  --
  -- Setup to test an error from ExecLockRows
  --
  CREATE TABLE foo_range_parted (a int, b text) PARTITION BY RANGE(a);
  CREATE TABLE foo_range_parted1 PARTITION OF foo_range_parted FOR VALUES FROM (1) TO (10);
  CREATE TABLE foo_range_parted2 PARTITION OF foo_range_parted FOR VALUES FROM (10) TO (20);
  INSERT INTO foo_range_parted VALUES(7, 'ABC');
  CREATE UNIQUE INDEX foo_range_parted1_a_unique ON foo_range_parted1 (a);
  CREATE TABLE bar (a int REFERENCES foo_range_parted1(a));

;
  DROP TABLE foo;
  DROP TRIGGER footrg_mod_a ON footrg1;
  DROP FUNCTION func_footrg_mod_a();
  DROP TABLE footrg;
  DROP TABLE bar, foo_range_parted;

;
  --
  -- Setup to test an error from ExecUpdate and ExecDelete.
  --
  CREATE TABLE foo (a int, b text) PARTITION BY LIST(a);
  CREATE TABLE foo1 PARTITION OF foo FOR VALUES IN (1);
  CREATE TABLE foo2 PARTITION OF foo FOR VALUES IN (2);
  INSERT INTO foo VALUES (1, 'ABC');

  --
  -- Setup to test an error from GetTupleForTrigger
  --
  CREATE TABLE footrg (a int, b text) PARTITION BY LIST(a);
  CREATE TABLE footrg1 PARTITION OF footrg FOR VALUES IN (1);
  CREATE TABLE footrg2 PARTITION OF footrg FOR VALUES IN (2);
  INSERT INTO footrg VALUES (1, 'ABC');
  CREATE FUNCTION func_footrg_mod_a() RETURNS TRIGGER AS $$
    BEGIN
	  NEW.a = 2; -- This is changing partition key column.
   RETURN NEW;
  END $$ LANGUAGE PLPGSQL;
  CREATE TRIGGER footrg_mod_a BEFORE UPDATE ON footrg1
   FOR EACH ROW EXECUTE PROCEDURE func_footrg_mod_a();

  --
  -- Setup to test an error from ExecLockRows
  --
  CREATE TABLE foo_range_parted (a int, b text) PARTITION BY RANGE(a);
  CREATE TABLE foo_range_parted1 PARTITION OF foo_range_parted FOR VALUES FROM (1) TO (10);
  CREATE TABLE foo_range_parted2 PARTITION OF foo_range_parted FOR VALUES FROM (10) TO (20);
  INSERT INTO foo_range_parted VALUES(7, 'ABC');
  CREATE UNIQUE INDEX foo_range_parted1_a_unique ON foo_range_parted1 (a);
  CREATE TABLE bar (a int REFERENCES foo_range_parted1(a));

;
  DROP TABLE foo;
  DROP TRIGGER footrg_mod_a ON footrg1;
  DROP FUNCTION func_footrg_mod_a();
  DROP TABLE footrg;
  DROP TABLE bar, foo_range_parted;

;
  --
  -- Setup to test an error from ExecUpdate and ExecDelete.
  --
  CREATE TABLE foo (a int, b text) PARTITION BY LIST(a);
  CREATE TABLE foo1 PARTITION OF foo FOR VALUES IN (1);
  CREATE TABLE foo2 PARTITION OF foo FOR VALUES IN (2);
  INSERT INTO foo VALUES (1, 'ABC');

  --
  -- Setup to test an error from GetTupleForTrigger
  --
  CREATE TABLE footrg (a int, b text) PARTITION BY LIST(a);
  CREATE TABLE footrg1 PARTITION OF footrg FOR VALUES IN (1);
  CREATE TABLE footrg2 PARTITION OF footrg FOR VALUES IN (2);
  INSERT INTO footrg VALUES (1, 'ABC');
  CREATE FUNCTION func_footrg_mod_a() RETURNS TRIGGER AS $$
    BEGIN
	  NEW.a = 2; -- This is changing partition key column.
   RETURN NEW;
  END $$ LANGUAGE PLPGSQL;
  CREATE TRIGGER footrg_mod_a BEFORE UPDATE ON footrg1
   FOR EACH ROW EXECUTE PROCEDURE func_footrg_mod_a();

  --
  -- Setup to test an error from ExecLockRows
  --
  CREATE TABLE foo_range_parted (a int, b text) PARTITION BY RANGE(a);
  CREATE TABLE foo_range_parted1 PARTITION OF foo_range_parted FOR VALUES FROM (1) TO (10);
  CREATE TABLE foo_range_parted2 PARTITION OF foo_range_parted FOR VALUES FROM (10) TO (20);
  INSERT INTO foo_range_parted VALUES(7, 'ABC');
  CREATE UNIQUE INDEX foo_range_parted1_a_unique ON foo_range_parted1 (a);
  CREATE TABLE bar (a int REFERENCES foo_range_parted1(a));

;
  DROP TABLE foo;
  DROP TRIGGER footrg_mod_a ON footrg1;
  DROP FUNCTION func_footrg_mod_a();
  DROP TABLE footrg;
  DROP TABLE bar, foo_range_parted;

;
  --
  -- Setup to test an error from ExecUpdate and ExecDelete.
  --
  CREATE TABLE foo (a int, b text) PARTITION BY LIST(a);
  CREATE TABLE foo1 PARTITION OF foo FOR VALUES IN (1);
  CREATE TABLE foo2 PARTITION OF foo FOR VALUES IN (2);
  INSERT INTO foo VALUES (1, 'ABC');

  --
  -- Setup to test an error from GetTupleForTrigger
  --
  CREATE TABLE footrg (a int, b text) PARTITION BY LIST(a);
  CREATE TABLE footrg1 PARTITION OF footrg FOR VALUES IN (1);
  CREATE TABLE footrg2 PARTITION OF footrg FOR VALUES IN (2);
  INSERT INTO footrg VALUES (1, 'ABC');
  CREATE FUNCTION func_footrg_mod_a() RETURNS TRIGGER AS $$
    BEGIN
	  NEW.a = 2; -- This is changing partition key column.
   RETURN NEW;
  END $$ LANGUAGE PLPGSQL;
  CREATE TRIGGER footrg_mod_a BEFORE UPDATE ON footrg1
   FOR EACH ROW EXECUTE PROCEDURE func_footrg_mod_a();

  --
  -- Setup to test an error from ExecLockRows
  --
  CREATE TABLE foo_range_parted (a int, b text) PARTITION BY RANGE(a);
  CREATE TABLE foo_range_parted1 PARTITION OF foo_range_parted FOR VALUES FROM (1) TO (10);
  CREATE TABLE foo_range_parted2 PARTITION OF foo_range_parted FOR VALUES FROM (10) TO (20);
  INSERT INTO foo_range_parted VALUES(7, 'ABC');
  CREATE UNIQUE INDEX foo_range_parted1_a_unique ON foo_range_parted1 (a);
  CREATE TABLE bar (a int REFERENCES foo_range_parted1(a));

;
  DROP TABLE foo;
  DROP TRIGGER footrg_mod_a ON footrg1;
  DROP FUNCTION func_footrg_mod_a();
  DROP TABLE footrg;
  DROP TABLE bar, foo_range_parted;

;